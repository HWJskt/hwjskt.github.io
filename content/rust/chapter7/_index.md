+++
title = "Managing Growing Projects with Packages, Crates, and Modules"
weight = 7
sort_by = "weight"
template ="book_section_rust.html"

+++

## 요약

<!-- more -->

# [패키지, 크레이트 및 모듈로 성장하는 프로젝트 관리](https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html#managing-growing-projects-with-packages-crates-and-modules)

대규모 프로그램을 작성할 때 코드 구성이 점점 더 중요해집니다. 관련 기능을 그룹화하고 고유한 기능으로 코드를 분리하면 특정 기능을 구현하는 코드를 찾을 위치와 기능 작동 방식을 변경하기 위해 이동해야 하는 위치를 명확히 할 수 있습니다.

지금까지 우리가 작성한 프로그램은 하나의 파일에 하나의 모듈에 있었습니다. 프로젝트가 커짐에 따라 코드를 여러 모듈로 분할한 다음 여러 파일로 분할하여 구성해야 합니다. 패키지는 여러 바이너리 크레이트와 선택적으로 하나의 라이브러리 크레이트를 포함할 수 있습니다. 패키지가 커짐에 따라 외부 종속성이 되는 별도의 크레이트로 부품을 추출할 수 있습니다. 이 장에서는 이러한 모든 기술을 다룹니다. 함께 발전하는 상호 관련된 일련의 패키지로 구성된 대규모 프로젝트의 경우 Cargo는 *작업 공간을* 제공하며 이에 대해서는 14장의 [Cargo workspace](https://doc.rust-lang.org/book/ch14-03-cargo-workspaces.html) 섹션 에서 다룰 것입니다.


또한 더 높은 수준에서 코드를 재사용할 수 있게 해주는 구현 세부 사항 캡슐화에 대해서도 논의할 것입니다. 당신이 작업을 구현하면, 다른 사람의 코드가 구현 작동 방식을 알 필요 없이 공용 인터페이스를 통해 당신의 코드를 호출할 수 있습니다. 코드를 작성하는 방식에 따라, 다른 사람 코드에서 사용할 수 있도록 공개(public)되는 부분과 당신만 변경 권한이 있는 개인(privat)e 구현 부분으로 나뉩니다.  이것은 머리 속에 간직해야 하는 세부 사항의 양을 제한하는 또 다른 방법입니다.


관련 개념은 범위(scope)입니다. 코드가 작성되는 중첩 컨텍스트에는 `in scope`로 정의되는 일련의 이름이 있습니다. 코드를 읽고 쓰고 컴파일할 때 프로그래머와 컴파일러는 특정 지점의 특정 이름이 변수, 함수, 구조체, 열거형, 모듈, 상수 또는 기타 항목을 참조하는지 여부와 해당 항목이 무엇을 의미하는지 알아야 합니다. 범위를 생성하고 범위에 포함되거나 포함되지 않는 이름을 변경할 수 있습니다. 동일한 범위에 동일한 이름을 가진 두 개의 항목이 있을 수 없습니다. 이름 충돌을 해결하기 위한 도구를 사용할 수 있습니다.

Rust에는 어떤 세부 정보가 노출되고 어떤 세부 정보가 비공개인지, 프로그램의 각 범위에 어떤 이름이 있는지 등 코드 구성을 관리할 수 있는 여러 기능이 있습니다. *모듈 시스템* 이라고도 통칭하는 이러한 기능에는 다음이 포함됩니다.

- **패키지(packages)** : crates 를 만들고 테스트하고 공유할 수 있는 Cargo 기능
- **크레이트(crates):** 라이브러리 또는 실행 파일을 생성하는 모듈 트리
- **모듈** 및 **사용:** 경로의 구성, 범위 및 개인정보 보호를 제어할 수 있습니다.
- **경로(paths):** 구조체, 함수 또는 모듈과 같은 항목의 이름을 지정하는 방법

이 장에서는 이러한 모든 기능을 다루고, 상호 작용하는 방법에 대해 설명하고, 범위를 관리하는 데 사용하는 방법을 설명합니다. 마지막에는 모듈 시스템에 대한 확실한 이해가 있어야 하며, 프로처럼 범위(scopes)를 다룰 수 있어야 합니다!
