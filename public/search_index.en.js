window.searchIndex = {"fields":["title","body"],"pipeline":["trimmer","stopWordFilter","stemmer"],"ref":"id","version":"0.9.5","index":{"body":{"root":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":16.186414056238647},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":16.3707055437449},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":6.928203230275509},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":7.3484692283495345},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.69041575982343},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":4.795831523312719}},"df":9,".":{"docs":{},"df":0,".":{"docs":{},"df":0,"1":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772}},"df":2}}},"2":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2},"5":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2},"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"z":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.449489742783178}},"df":2}}}}},"0":{"docs":{"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":5,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":7.14142842854285},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":7.14142842854285}},"df":2},"1":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0}},"df":1},"2":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0}},"df":1}},"1":{"docs":{},"df":0,".":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0}},"df":4}},"9":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}},"2":{"docs":{},"df":0,"4":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2},"5":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2},"7":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4},"8":{"docs":{"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.0}},"df":1},"9":{"docs":{"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.0}},"df":1}},"3":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.0}},"df":3},"1":{"docs":{"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.7320508075688772}},"df":3},"2":{"docs":{"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.0}},"df":2},"3":{"docs":{"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":1.0}},"df":1},"8":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2},"9":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}},"4":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2},"2":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4},"3":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":5},"5":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2},"6":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2},"7":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2},"8":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":6}},"5":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2},"2":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2},"3":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2},"4":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2},"7":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2},"8":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.0}},"df":3},"9":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0}},"df":5}},"6":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2},"1":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4},"2":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2},"3":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2},"4":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2},"6":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0}},"df":2},"8":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2},"9":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}},"7":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2},"2":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2},"3":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4},"5":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}},"8":{"docs":{},"df":0,".":{"docs":{},"df":0,"5":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter2/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":5},"6":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.7320508075688772}},"df":1}},"8":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2},"9":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}},"9":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2,".":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":2.6457513110645907}},"df":1},"x":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0}},"df":1}},"1":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2},"3":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2},"7":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}},"0":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2},"1":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2},"2":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4},"3":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2},"4":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1},"6":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1,",":{"docs":{},"df":0,"2":{"docs":{},"df":0,"0":{"docs":{},"df":0,"1":{"docs":{},"df":0,"4":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}}}}},"8":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1},"9":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1},"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"o":{"docs":{},"df":0,"k":{"docs":{},"df":0,"(":{"docs":{},"df":0,"(":{"docs":{},"df":0,")":{"docs":{},"df":0,")":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"0":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"u":{"docs":{},"df":0,"3":{"docs":{},"df":0,"2":{"docs":{},"df":0,".":{"docs":{},"df":0,".":{"docs":{},"df":0,"2":{"docs":{},"df":0,"0":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{},"df":0,"(":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"x":{"docs":{},"df":0,"0":{"docs":{},"df":0,"1":{"docs":{},"df":0,"2":{"docs":{},"df":0,"3":{"docs":{},"df":0,"4":{"docs":{},"df":0,"5":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"z":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}},"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"z":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}},"1":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":5.477225575051661},"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.0},"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/posts/post-2/":{"tf":1.0},"http://127.0.0.1:1111/rust/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":13.527749258468683},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":13.638181696985855},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":7.416198487095663},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":7.483314773547883},"http://127.0.0.1:1111/rust/chapter2/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":4.69041575982343},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":8.888194417315589},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":8.94427190999916}},"df":19,"\"":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"/":{"docs":{},"df":0,"a":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}}}}}}}}},"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"/":{"docs":{},"df":0,"p":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0}},"df":1}}}},"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"y":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}},")":{"docs":{},"df":0,".":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}},",":{"docs":{},"df":0,"0":{"docs":{},"df":0,"0":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}},".":{"docs":{},"df":0,".":{"docs":{},"df":0,"1":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2}},"4":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"v":{"docs":{"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.0}},"df":1}}}}}},"5":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2},"=":{"docs":{},"df":0,"1":{"docs":{},"df":0,"0":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0}},"df":1}}},"5":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}},"0":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":6,".":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2}}},"1":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}},"2":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.0}},"df":1},"2":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2},"8":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0}},"df":1}},"3":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":4},"3":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}},"4":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}},"5":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.4142135623730951}},"df":1},"7":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}},"6":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}},"0":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":7.483314773547883},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":7.54983443527075},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.47213595499958},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":4.358898943540674},"http://127.0.0.1:1111/rust/chapter2/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":11.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":11.045361017187261}},"df":12,",":{"docs":{},"df":0,"0":{"docs":{},"df":0,"0":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}},"8":{"docs":{},"df":0,"0":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":1.0}},"df":1}}}},".":{"docs":{},"df":0,".":{"docs":{},"df":0,"=":{"docs":{},"df":0,"1":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}},"1":{"docs":{},"df":0,"5":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2},"8":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}},"4":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}},"0":{"docs":{"http://127.0.0.1:1111/":{"tf":1.0},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.358898943540674},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":4.358898943540674},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter2/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.358898943540674},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":4.47213595499958}},"df":9,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":3,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}},"t":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}},"2":{"docs":{},"df":0,"3":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2},"4":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}},"4":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2},"8":{"docs":{},"df":0,"2":{"docs":{},"df":0,"c":{"docs":{},"df":0,"4":{"docs":{},"df":0,"b":{"docs":{},"df":0,"0":{"docs":{},"df":0,"6":{"docs":{},"df":0,"3":{"docs":{},"df":0,"a":{"docs":{},"df":0,"8":{"docs":{},"df":0,"f":{"docs":{},"df":0,"b":{"docs":{},"df":0,"e":{"docs":{},"df":0,"6":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}}}}}},"_":{"docs":{},"df":0,"1":{"docs":{},"df":0,"_":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}}},"2":{"docs":{},"df":0,"_":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}}},"3":{"docs":{},"df":0,"_":{"docs":{},"df":0,"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}}},"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}}},"1":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":6.928203230275509},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":6.928203230275509},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.242640687119285},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":4.242640687119285}},"df":10,":":{"docs":{},"df":0,"4":{"docs":{},"df":0,"3":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}},"_":{"docs":{},"df":0,"1":{"docs":{},"df":0,"_":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}},"2":{"docs":{},"df":0,"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}}}}},"3":{"docs":{},"df":0,"_":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}},"w":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}}},"2":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":9.695359714832659},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":9.695359714832659},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.123105625617661},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":4.242640687119285},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.123105625617661},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":4.123105625617661}},"df":11,".":{"docs":{},"df":0,".":{"docs":{},"df":0,"b":{"docs":{},"df":0,"u":{"docs":{},"df":0,"f":{"docs":{},"df":0,"f":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,".":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}},"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}},"2":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1},"7":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1,".":{"docs":{},"df":0,"0":{"docs":{},"df":0,".":{"docs":{},"df":0,"0":{"docs":{},"df":0,".":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2,":":{"docs":{},"df":0,"7":{"docs":{},"df":0,"8":{"docs":{},"df":0,"7":{"docs":{},"df":0,"8":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.8284271247461903}},"df":2,"/":{"docs":{},"df":0,"f":{"docs":{},"df":0,"o":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}},"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}}},"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}},"8":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1,"비":{"docs":{},"df":0,"트":{"docs":{},"df":0,"i":{"docs":{},"df":0,"1":{"docs":{},"df":0,"2":{"docs":{},"df":0,"8":{"docs":{},"df":0,"u":{"docs":{},"df":0,"1":{"docs":{},"df":0,"2":{"docs":{},"df":0,"8":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1}}}}}}}}}}},"_":{"docs":{},"df":0,"1":{"docs":{},"df":0,"_":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"p":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}}}},"2":{"docs":{},"df":0,"_":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}},"3":{"docs":{},"df":0,"_":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"f":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}}}}}},"4":{"docs":{},"df":0,"_":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}}}}},"5":{"docs":{},"df":0,"_":{"docs":{},"df":0,"w":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}},"6":{"docs":{},"df":0,"_":{"docs":{},"df":0,"w":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}}},"a":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}},"3":{"docs":{"http://127.0.0.1:1111/rust/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":8.717797887081348},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":8.717797887081348},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.358898943540674},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":4.358898943540674}},"df":7,"5":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2},"_":{"docs":{},"df":0,"1":{"docs":{},"df":0,"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}}}},"2":{"docs":{},"df":0,"_":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}}}}},"3":{"docs":{},"df":0,"_":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"v":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}}}},"4":{"docs":{},"df":0,"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}}}},"f":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}}}}}},"4":{"docs":{"http://127.0.0.1:1111/rust/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":6.708203932499369},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":6.708203932499369},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/4-comments/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.605551275463989}},"df":9,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2},"_":{"docs":{},"df":0,"1":{"docs":{},"df":0,"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}}}},"2":{"docs":{},"df":0,"_":{"docs":{},"df":0,"p":{"docs":{},"df":0,"u":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}}}}},"3":{"docs":{},"df":0,"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"g":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}}},"4":{"docs":{},"df":0,"_":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}}}},"5":{"docs":{},"df":0,"_":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}}}},"m":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}},"5":{"docs":{"http://127.0.0.1:1111/rust/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":11.045361017187261},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":11.045361017187261},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":4.0}},"df":7,"0":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1,"0":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":3}},"1":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2},"_":{"docs":{},"df":0,"1":{"docs":{},"df":0,"_":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}},"2":{"docs":{},"df":0,"_":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}}},"3":{"docs":{},"df":0,"_":{"docs":{},"df":0,"r":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}},"4":{"docs":{},"df":0,"_":{"docs":{},"df":0,"r":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}},"5":{"docs":{},"df":0,"_":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"f":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}}}},"6":{"docs":{},"df":0,"_":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"f":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}}},"s":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}}},"6":{"docs":{"http://127.0.0.1:1111/rust/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":8.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":8.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.242640687119285},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":4.358898943540674},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.4641016151377544}},"df":7,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772}},"df":2,"8":{"docs":{},"df":0,"6":{"docs":{},"df":0,"9":{"docs":{},"df":0,"f":{"docs":{},"df":0,"3":{"docs":{},"df":0,"8":{"docs":{},"df":0,"c":{"docs":{},"df":0,"f":{"docs":{},"df":0,"f":{"docs":{},"df":0,"9":{"docs":{},"df":0,"1":{"docs":{},"df":0,"6":{"docs":{},"df":0,"6":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}}}}}},"4":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.23606797749979}},"df":2},"5":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2},"8":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2},"_":{"docs":{},"df":0,"1":{"docs":{},"df":0,"_":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}},"2":{"docs":{},"df":0,"_":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}},"3":{"docs":{},"df":0,"_":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}}},"4":{"docs":{},"df":0,"_":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}}}},"f":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}}}}},"x":{"docs":{},"df":0,"1":{"docs":{},"df":0,"6":{"docs":{},"df":0,".":{"docs":{},"df":0,"p":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0}},"df":1}}}}}}},"—":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}},"비":{"docs":{},"df":0,"트":{"docs":{},"df":0,"i":{"docs":{},"df":0,"1":{"docs":{},"df":0,"6":{"docs":{},"df":0,"u":{"docs":{},"df":0,"1":{"docs":{},"df":0,"6":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1}}}}}}}}},"7":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":4.0}},"df":8,"0":{"docs":{},"df":0,"b":{"docs":{},"df":0,"9":{"docs":{},"df":0,"4":{"docs":{},"df":0,"2":{"docs":{},"df":0,"e":{"docs":{},"df":0,"b":{"docs":{},"df":0,"5":{"docs":{},"df":0,"b":{"docs":{},"df":0,"f":{"docs":{},"df":0,"5":{"docs":{},"df":0,"e":{"docs":{},"df":0,"3":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}}}}}},"4":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2},"_":{"docs":{},"df":0,"1":{"docs":{},"df":0,"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}}}}}}}}}},"2":{"docs":{},"df":0,"_":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}},"3":{"docs":{},"df":0,"_":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}}}}}}},"o":{"docs":{},"df":0,"b":{"docs":{},"df":0,"j":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}}},"장":{"docs":{},"df":0,"]":{"docs":{},"df":0,"(":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{},"df":0,"t":{"docs":{},"df":0,"p":{"docs":{},"df":0,"s":{"docs":{},"df":0,":":{"docs":{},"df":0,"/":{"docs":{},"df":0,"/":{"docs":{},"df":0,"d":{"docs":{},"df":0,"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,".":{"docs":{},"df":0,"r":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}},"8":{"docs":{"http://127.0.0.1:1111/rust/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":8.831760866327848},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":8.888194417315589},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.605551275463989}},"df":8,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2},"4":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2},"_":{"docs":{},"df":0,"1":{"docs":{},"df":0,"_":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}},"2":{"docs":{},"df":0,"_":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"f":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}}},"3":{"docs":{},"df":0,"_":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}}}}},"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}}}}},"9":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":9.695359714832659},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":9.695359714832659},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.1622776601683795}},"df":9,",":{"docs":{},"df":0,"2":{"docs":{},"df":0,"3":{"docs":{},"df":0,"4":{"docs":{},"df":0,",":{"docs":{},"df":0,"9":{"docs":{},"df":0,"0":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}},"6":{"docs":{},"df":0,"2":{"docs":{},"df":0,"0":{"docs":{},"df":0,",":{"docs":{},"df":0,"3":{"docs":{},"df":0,"0":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}},"7":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}},"9":{"docs":{},"df":0,"9":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}},"_":{"docs":{},"df":0,"1":{"docs":{},"df":0,"_":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"a":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}}},"2":{"docs":{},"df":0,"_":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}}}},"3":{"docs":{},"df":0,"_":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}}}},"4":{"docs":{},"df":0,"_":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}}}},"5":{"docs":{},"df":0,"_":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}}},"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}}}},":":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}},"]":{"docs":{},"df":0,"(":{"docs":{},"df":0,"#":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}}}}},"_":{"docs":{},"df":0,"0":{"docs":{},"df":0,"0":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1}}}},"—":{"docs":{},"df":0,"f":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}}}}}}},"2":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":4.0},"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":2.449489742783178},"http://127.0.0.1:1111/posts/post-1/":{"tf":1.0},"http://127.0.0.1:1111/posts/post-2/":{"tf":1.0},"http://127.0.0.1:1111/rust/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":10.04987562112089},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":10.198039027185569},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":7.615773105863909},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":7.810249675906654},"http://127.0.0.1:1111/rust/chapter2/":{"tf":4.0},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":4.123105625617661},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":4.123105625617661},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":7.615773105863909},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":7.745966692414834}},"df":18,"\"":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"/":{"docs":{},"df":0,"a":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}}}}}}}}},"(":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1}},".":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":3},"5":{"docs":{},"df":0,"3":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.4142135623730951}},"df":1}},"8":{"docs":{},"df":0,"5":{"docs":{"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":1.0}},"df":1}}},"0":{"docs":{"http://127.0.0.1:1111/rust/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":8.831760866327848},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":8.831760866327848},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.0}},"df":8,"0":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.3166247903554}},"df":5,"8":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2},"9":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}},"1":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1},"3":{"docs":{"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":1.0}},"df":1},"4":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.449489742783178}},"df":1},"5":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.8284271247461903}},"df":2},"8":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.23606797749979}},"df":2},"9":{"docs":{"http://127.0.0.1:1111/about/":{"tf":1.0}},"df":1}},"2":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0}},"df":6},"2":{"docs":{"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":1.0}},"df":1}},"8":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.449489742783178}},"df":2},"_":{"docs":{},"df":0,"1":{"docs":{},"df":0,"_":{"docs":{},"df":0,"b":{"docs":{},"df":0,"u":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}}},"2":{"docs":{},"df":0,"_":{"docs":{},"df":0,"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}},"3":{"docs":{},"df":0,"_":{"docs":{},"df":0,"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}}},"f":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}}},"1":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.6457513110645907}},"df":6,"_":{"docs":{},"df":0,"1":{"docs":{},"df":0,"_":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}},"2":{"docs":{},"df":0,"_":{"docs":{},"df":0,"b":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}},"3":{"docs":{},"df":0,"_":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}},"4":{"docs":{},"df":0,"_":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}},"5":{"docs":{},"df":0,"_":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}},"6":{"docs":{},"df":0,"_":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}},"7":{"docs":{},"df":0,"_":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}},"a":{"docs":{},"df":0,"p":{"docs":{},"df":0,"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"x":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}}}}}},"2":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.6457513110645907}},"df":7,"4":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.449489742783178}},"df":2}},"3":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.449489742783178}},"df":6},"4":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.6457513110645907}},"df":6,"3":{"docs":{},"df":0,".":{"docs":{},"df":0,"3":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}},"5":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.872983346207417}},"df":6,"5":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":5},"6":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.4142135623730951}},"df":1},"7":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1}},"6":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.6457513110645907}},"df":4},"7":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0}},"df":4,".":{"docs":{},"df":0,"1":{"docs":{},"df":0,"8":{"docs":{},"df":0,"3":{"docs":{},"df":0,"3":{"docs":{},"df":0,"3":{"docs":{},"df":0,"3":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}}}}}}},"8":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.23606797749979}},"df":4,".":{"docs":{},"df":0,"6":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}},"0":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}},"9":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0}},"df":5,"0":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}},":":{"docs":{},"df":0,"8":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}},"]":{"docs":{},"df":0,"(":{"docs":{},"df":0,"#":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}}}}},"^":{"docs":{},"df":0,"(":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1}},"7":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.4142135623730951}},"df":1},"8":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1},"n":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1}},"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"e":{"docs":{},"df":0,"h":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"2":{"docs":{},"df":0,"5":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}}}}}}}}},"—":{"docs":{},"df":0,"w":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}}},"3":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.449489742783178},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":4.0},"http://127.0.0.1:1111/posts/post-2/":{"tf":1.0},"http://127.0.0.1:1111/rust/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":9.16515138991168},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":9.327379053088816},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":7.681145747868608},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":7.874007874011811},"http://127.0.0.1:1111/rust/chapter2/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":4.123105625617661},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":5.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":7.937253933193772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":8.0}},"df":16,"\"":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"/":{"docs":{},"df":0,"a":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}}}}}}}}},".":{"docs":{},"df":0,".":{"docs":{},"df":0,"=":{"docs":{},"df":0,"7":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772}},"df":2}}},"0":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1},"1":{"docs":{},"df":0,"4":{"docs":{},"df":0,"1":{"docs":{},"df":0,"5":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}},"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"_":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}},"0":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.7416573867739413}},"df":7,"0":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}},"1":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2},"2":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":6,".":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1}},"x":{"docs":{},"df":0,"3":{"docs":{},"df":0,"2":{"docs":{},"df":0,".":{"docs":{},"df":0,"p":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0}},"df":1}}}}}}},"비":{"docs":{},"df":0,"트":{"docs":{},"df":0,"i":{"docs":{},"df":0,"3":{"docs":{},"df":0,"2":{"docs":{},"df":0,"u":{"docs":{},"df":0,"3":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1}}}}}}}}},"3":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772}},"df":2},"4":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2,"\"":{"docs":{},"df":0,".":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}},"`":{"docs":{},"df":0,".":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1}}}}}}},"8":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.7320508075688772}},"df":1},"]":{"docs":{},"df":0,"(":{"docs":{},"df":0,"#":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}}}}},"d":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1},"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}},"4":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":7.14142842854285},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":7.14142842854285},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":6.48074069840786},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":6.6332495807108},"http://127.0.0.1:1111/rust/chapter2/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":9.695359714832659},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":10.198039027185569}},"df":15,".":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.449489742783178}},"df":2},"3":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1},"4":{"docs":{},"df":0,"5":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0}},"df":1}}},"0":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":6,"4":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.0}},"df":2,".":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{},"df":0,"m":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.6457513110645907}},"df":2}}}}}}},"2":{"docs":{},"df":0,"\"":{"docs":{},"df":0,".":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}},".":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1}}}}},"`":{"docs":{},"df":0,".":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"(":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"(":{"docs":{},"df":0,"`":{"docs":{},"df":0,"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.7320508075688772}},"df":1}}}}}}}}}}}}}}}}}}}}}},"3":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":3},"5":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4},"8":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2},"9":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2,"9":{"docs":{},"df":0,"7":{"docs":{},"df":0,"9":{"docs":{},"df":0,"f":{"docs":{},"df":0,"f":{"docs":{},"df":0,"4":{"docs":{},"df":0,"0":{"docs":{},"df":0,"6":{"docs":{},"df":0,"8":{"docs":{},"df":0,"6":{"docs":{},"df":0,"f":{"docs":{},"df":0,"a":{"docs":{},"df":0,"8":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}},"_":{"docs":{},"df":0,"1":{"docs":{},"df":0,"_":{"docs":{},"df":0,"w":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}},"2":{"docs":{},"df":0,"_":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"f":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}}},"3":{"docs":{},"df":0,"_":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}},"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}}}}}}}},"5":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":4.0},"http://127.0.0.1:1111/rust/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":8.426149773176359},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":8.426149773176359},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":7.416198487095663},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":7.615773105863909},"http://127.0.0.1:1111/rust/chapter2/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":10.770329614269007},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":10.816653826391969}},"df":14,"0":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.477225575051661},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":5.477225575051661}},"df":9,"0":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.7320508075688772}},"df":2,"0":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}},"2":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772}},"df":2},"3":{"docs":{},"df":0,"6":{"docs":{},"df":0,"6":{"docs":{},"df":0,"7":{"docs":{"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.0}},"df":1}}}},"4":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2},"6":{"docs":{},"df":0,".":{"docs":{},"df":0,"7":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1}}},"7":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2,"d":{"docs":{},"df":0,"7":{"docs":{},"df":0,"0":{"docs":{},"df":0,"c":{"docs":{},"df":0,"3":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"b":{"docs":{},"df":0,"7":{"docs":{},"df":0,"3":{"docs":{},"df":0,"8":{"docs":{},"df":0,"f":{"docs":{},"df":0,"4":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2}}}}}}}}}}}}}},"u":{"docs":{},"df":0,"8":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1}}},"8":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0}},"df":3},"9":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.7320508075688772}},"df":1},"\\":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0}},"df":1}},"_":{"docs":{},"df":0,"1":{"docs":{},"df":0,"_":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"f":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}}},"2":{"docs":{},"df":0,"_":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}},"3":{"docs":{},"df":0,"_":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}}}},"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}},"d":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.0}},"df":1},"h":{"docs":{"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.0}},"df":1}},"6":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.5677643628300215},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":5.5677643628300215},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.477225575051661},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":6.244997998398398},"http://127.0.0.1:1111/rust/chapter2/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":4.123105625617661},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":8.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":8.246211251235321}},"df":13,".":{"docs":{},"df":0,"4":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":2.0}},"df":1,"4":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0}},"df":1}}},"0":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":4,"(":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":1.4142135623730951}},"df":1}},"0":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}}},"1":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.7320508075688772}},"df":1},"4":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.7320508075688772}},"df":2,"}":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"s":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"p":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}},"비":{"docs":{},"df":0,"트":{"docs":{},"df":0,"i":{"docs":{},"df":0,"6":{"docs":{},"df":0,"4":{"docs":{},"df":0,"u":{"docs":{},"df":0,"6":{"docs":{},"df":0,"4":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1}}}}}}}}},"5":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.23606797749979}},"df":2,"7":{"docs":{},"df":0,",":{"docs":{},"df":0,"2":{"docs":{},"df":0,"0":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}},"8":{"docs":{},"df":0,"4":{"docs":{},"df":0,"c":{"docs":{},"df":0,"4":{"docs":{},"df":0,"5":{"docs":{},"df":0,"6":{"docs":{},"df":0,"1":{"docs":{},"df":0,"e":{"docs":{},"df":0,"4":{"docs":{},"df":0,"8":{"docs":{},"df":0,"9":{"docs":{},"df":0,"4":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2}}}}}}}}}}}}}},"_":{"docs":{},"df":0,"1":{"docs":{},"df":0,"_":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"f":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}}},"2":{"docs":{},"df":0,"_":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}},"3":{"docs":{},"df":0,"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}}}},"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}},"7":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.916079783099616},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":6.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/4-comments/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":10.44030650891055},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":10.44030650891055}},"df":13,"0":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.0}},"df":1},"2":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2},"5":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2,"4":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1}},"6":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.7320508075688772}},"df":1},"7":{"docs":{},"df":0,".":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}},"8":{"docs":{},"df":0,".":{"docs":{},"df":0,"0":{"docs":{},"df":0,"1":{"docs":{},"df":0,"6":{"docs":{},"df":0,"6":{"docs":{},"df":0,"6":{"docs":{},"df":0,"7":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}}}}}},"7":{"docs":{},"df":0,"8":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}},"_":{"docs":{},"df":0,"1":{"docs":{},"df":0,"_":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}}}},"2":{"docs":{},"df":0,"_":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"f":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}}},"3":{"docs":{},"df":0,"_":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}},"4":{"docs":{},"df":0,"_":{"docs":{},"df":0,"b":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}}},"5":{"docs":{},"df":0,"_":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}}},"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}},"a":{"docs":{},"df":0,"z":{"docs":{},"df":0,"t":{"docs":{},"df":0,"p":{"docs":{},"df":0,"s":{"docs":{},"df":0,"y":{"docs":{},"df":0,"a":{"docs":{},"df":0,"w":{"docs":{},"df":0,"v":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}}}}}}}}}},"8":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.0},"http://127.0.0.1:1111/rust/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.744562646538029},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":5.656854249492381},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.242640687119285},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":4.242640687119285},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":10.099504938362077},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":10.099504938362077}},"df":13,"\"":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1}}}},".":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}},"0":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":5,"0":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1,"0":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}},"2":{"docs":{},"df":0,"e":{"docs":{},"df":0,"7":{"docs":{},"df":0,"7":{"docs":{},"df":0,"9":{"docs":{},"df":0,"9":{"docs":{},"df":0,"c":{"docs":{},"df":0,"1":{"docs":{},"df":0,"b":{"docs":{},"df":0,"c":{"docs":{},"df":0,"6":{"docs":{},"df":0,"2":{"docs":{},"df":0,"2":{"docs":{},"df":0,"9":{"docs":{},"df":0,"8":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}},"3":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0}},"df":1},"7":{"docs":{},"df":0,"1":{"docs":{},"df":0,".":{"docs":{},"df":0,"8":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0}},"df":1}}}},"9":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2},"_":{"docs":{},"df":0,"1":{"docs":{},"df":0,"_":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}}},"2":{"docs":{},"df":0,"_":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}}},"3":{"docs":{},"df":0,"_":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}}},"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"m":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}}},"`":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":1}}}},"비":{"docs":{},"df":0,"트":{"docs":{},"df":0,"i":{"docs":{},"df":0,"8":{"docs":{},"df":0,"u":{"docs":{},"df":0,"8":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1}}}}}},"은":{"docs":{},"df":0,"m":{"docs":{},"df":0,"y":{"docs":{},"df":0,"b":{"docs":{},"df":0,"o":{"docs":{},"df":0,"x":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1}}}}}}},"9":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.5677643628300215},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":5.656854249492381},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":8.366600265340756},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":8.306623862918075}},"df":11,"0":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":3},"1":{"docs":{},"df":0,"5":{"docs":{},"df":0,",":{"docs":{},"df":0,"7":{"docs":{},"df":0,"0":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}},"2":{"docs":{},"df":0,"9":{"docs":{},"df":0,"4":{"docs":{},"df":0,"8":{"docs":{},"df":0,"b":{"docs":{},"df":0,"6":{"docs":{},"df":0,"5":{"docs":{},"df":0,"e":{"docs":{},"df":0,"8":{"docs":{},"df":0,"8":{"docs":{},"df":0,"9":{"docs":{},"df":0,"6":{"docs":{},"df":0,"0":{"docs":{},"df":0,"b":{"docs":{},"df":0,"4":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.605551275463989}},"df":2}}}}}}}}}}}}}}},"5":{"docs":{},"df":0,".":{"docs":{},"df":0,"5":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1}}},"9":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":3},"_":{"docs":{},"df":0,"1":{"docs":{},"df":0,"_":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}}}}}}},"2":{"docs":{},"df":0,"_":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}}}}},"3":{"docs":{},"df":0,"_":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}},"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}}},"c":{"docs":{},"df":0,"d":{"docs":{},"df":0,"2":{"docs":{},"df":0,"0":{"docs":{},"df":0,"0":{"docs":{},"df":0,"e":{"docs":{},"df":0,"5":{"docs":{},"df":0,"f":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"0":{"docs":{},"df":0,"f":{"docs":{},"df":0,"c":{"docs":{},"df":0,"9":{"docs":{},"df":0,"4":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.23606797749979}},"df":2}}}}}}}}}}}}}}},"—":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}}}}},"_":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.0},"http://127.0.0.1:1111/posts/post-1/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.0990195135927845},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":5.196152422706632},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.3166247903554}},"df":12,"\"":{"docs":{},"df":0,"“":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}},"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}},"_":{"docs":{},"df":0,"_":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1,"_":{"docs":{},"df":0,"_":{"docs":{},"df":0,"_":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2,"_":{"docs":{},"df":0,"_":{"docs":{},"df":0,"_":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2,"_":{"docs":{},"df":0,"_":{"docs":{},"df":0,"_":{"docs":{},"df":0,"_":{"docs":{},"df":0,"_":{"docs":{},"df":0,"_":{"docs":{},"df":0,"_":{"docs":{},"df":0,"_":{"docs":{},"df":0,"_":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2,"_":{"docs":{},"df":0,"_":{"docs":{},"df":0,"_":{"docs":{},"df":0,"_":{"docs":{},"df":0,"|":{"docs":{},"df":0,"_":{"docs":{},"df":0,"_":{"docs":{},"df":0,"_":{"docs":{},"df":0,"_":{"docs":{},"df":0,"_":{"docs":{},"df":0,"_":{"docs":{},"df":0,"_":{"docs":{},"df":0,"_":{"docs":{},"df":0,"_":{"docs":{},"df":0,"_":{"docs":{},"df":0,"_":{"docs":{},"df":0,"_":{"docs":{},"df":0,"_":{"docs":{},"df":0,"w":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}},"b":{"docs":{},"df":0,"o":{"docs":{},"df":0,"o":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/posts/post-1/":{"tf":1.0}},"df":1}}}},"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0}},"df":2,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,".":{"docs":{},"df":0,"m":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0},"http://127.0.0.1:1111/posts/post-1/":{"tf":1.0}},"df":2}}}}}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}},"x":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}},"a":{"docs":{},"df":0,"\"":{"docs":{},"df":0,".":{"docs":{},"df":0,".":{"docs":{},"df":0,"=":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"j":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}},"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1}}}}}},".":{"docs":{},"df":0,"c":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}},"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2}}}}},"[":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1},"1":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.0}},"df":2}}}}}},"_":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2}}},"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}},"`":{"docs":{},"df":0,".":{"docs":{},"df":0,".":{"docs":{},"df":0,"=":{"docs":{},"df":0,"`":{"docs":{},"df":0,"j":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1}}}}}},"b":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2,"b":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"v":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":2}}}}},"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":1.0}},"df":1}}}}}},"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2,"e":{"docs":{},"df":0,"f":{"docs":{},"df":0,"g":{"docs":{},"df":0,"h":{"docs":{},"df":0,"i":{"docs":{},"df":0,"j":{"docs":{},"df":0,"k":{"docs":{},"df":0,"l":{"docs":{},"df":0,"m":{"docs":{},"df":0,"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"p":{"docs":{},"df":0,"q":{"docs":{},"df":0,"r":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"v":{"docs":{},"df":0,"w":{"docs":{},"df":0,"x":{"docs":{},"df":0,"y":{"docs":{},"df":0,"z":{"docs":{},"df":0,"0":{"docs":{},"df":0,"1":{"docs":{},"df":0,"2":{"docs":{},"df":0,"3":{"docs":{},"df":0,"4":{"docs":{},"df":0,"5":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.23606797749979}},"df":2,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":3}},"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}},"v":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}},"s":{"docs":{},"df":0,"(":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"p":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}},"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":2,"_":{"docs":{},"df":0,"n":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{},"df":0,"b":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2}}}}}}}},"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.58257569495584},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":3}}}},"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903}},"df":3,"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}}}}}},"c":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.449489742783178}},"df":1,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"p":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.58257569495584},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":5}},"s":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0},"http://127.0.0.1:1111/posts/post-2/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":6.082762530298219},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.0990195135927845},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":6.6332495807108}},"df":5,"_":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"k":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0}},"df":1}}}}}}}}},"i":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3}}}}},"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}}},"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":3}}}}}},"r":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":4}},"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":3}}}},"u":{"docs":{},"df":0,"m":{"docs":{},"df":0,"s":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1}}},"u":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0}},"df":1}}},"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772}},"df":1}}},"h":{"docs":{},"df":0,"i":{"docs":{},"df":0,"e":{"docs":{},"df":0,"v":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":2}}}},"k":{"docs":{},"df":0,"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"d":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}}}}},"q":{"docs":{},"df":0,"u":{"docs":{},"df":0,"i":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":2},"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}}},"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"y":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/posts/post-2/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.4641016151377544}},"df":4,"@":{"docs":{},"df":0,"v":{"docs":{},"df":0,"0":{"docs":{},"df":0,".":{"docs":{},"df":0,"1":{"docs":{},"df":0,"7":{"docs":{},"df":0,".":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/posts/post-2/":{"tf":1.0}},"df":1}}}}}}}},"s":{"docs":{},"df":0,"/":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{},"df":0,"@":{"docs":{},"df":0,"v":{"docs":{},"df":0,"3":{"docs":{},"df":0,".":{"docs":{},"df":0,"0":{"docs":{},"df":0,".":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/posts/post-2/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}},"v":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.4641016151377544}},"df":5}},"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1}},"u":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.242640687119285}},"df":3}}}}},"d":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.449489742783178},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":6.782329983125268},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.242640687119285},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.916079783099616},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":6,".":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"/":{"docs":{},"df":0,"p":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}}}}},"a":{"docs":{},"df":0,"p":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.7416573867739413}},"df":1}}}}},"d":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/docs/config-options/":{"tf":2.0},"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0},"http://127.0.0.1:1111/posts/post-2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":9.539392014169456},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":7.874007874011811},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":7.483314773547883},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.0}},"df":10,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}},"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"i":{"docs":{},"df":0,"8":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}}}}}},"i":{"docs":{},"df":0,"8":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}},"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"s":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}},"o":{"docs":{},"df":0,"p":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"i":{"docs":{},"df":0,"8":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}},"r":{"docs":{},"df":0,"h":{"docs":{},"df":0,"s":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}},"=":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"f":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}},"(":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4}}}}},"/":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"/":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}},"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}}}},"_":{"docs":{},"df":0,"f":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"y":{"docs":{},"df":0,"_":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.449489742783178}},"df":2}}}}}}}}},"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":6.48074069840786},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":6.48074069840786},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772}},"df":4,"e":{"docs":{},"df":0,"(":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2},"x":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":4}},"/":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"g":{"docs":{},"df":0,"o":{"docs":{},"df":0,".":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2}}}}}}}}}},"s":{"docs":{},"df":0,"r":{"docs":{},"df":0,"c":{"docs":{},"df":0,"/":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"b":{"docs":{},"df":0,".":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0}},"df":2,"s":{"docs":{},"df":0,":":{"docs":{},"df":0,"1":{"docs":{},"df":0,":":{"docs":{},"df":0,"5":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}},":":{"docs":{},"df":0,":":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"d":{"docs":{},"df":0,"_":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2,"e":{"docs":{},"df":0,"(":{"docs":{},"df":0,"n":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}},"_":{"docs":{},"df":0,"v":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2},"2":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2},"3":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2},"4":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}}}},"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"e":{"docs":{},"df":0,"_":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"_":{"docs":{},"df":0,"t":{"docs":{},"df":0,"w":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}},"o":{"docs":{},"df":0,"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"(":{"docs":{},"df":0,"3":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}},"w":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":6.6332495807108},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":6.6332495807108}},"df":2}}}}}}}}}},"w":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.8284271247461903}},"df":2,"(":{"docs":{},"df":0,"1":{"docs":{},"df":0,"0":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}},"2":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0}},"df":2},"3":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2},"a":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0}},"df":2}},"_":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"_":{"docs":{},"df":0,"t":{"docs":{},"df":0,"w":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}},"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":7.615773105863909},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":7.483314773547883}},"df":2,"/":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"g":{"docs":{},"df":0,"o":{"docs":{},"df":0,".":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2}}}}}}}}}},"s":{"docs":{},"df":0,"r":{"docs":{},"df":0,"c":{"docs":{},"df":0,"/":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,".":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0}},"df":2,"s":{"docs":{},"df":0,":":{"docs":{},"df":0,"2":{"docs":{},"df":0,":":{"docs":{},"df":0,"5":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}},":":{"docs":{},"df":0,":":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"d":{"docs":{},"df":0,"_":{"docs":{},"df":0,"t":{"docs":{},"df":0,"w":{"docs":{},"df":0,"o":{"docs":{},"df":0,"(":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}}}}},"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.3166247903554}},"df":4,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":2,"\"":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":6.082762530298219},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.23606797749979}},"df":6}}}}},"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}}},"i":{"docs":{},"df":0,"p":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.8284271247461903}},"df":1}}}}},"m":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3}}}}},"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0}},"df":2}}},"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3},"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979}},"df":3}}}}},"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}},"i":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1},"s":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}},"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.0}},"df":1}}}}},"f":{"docs":{},"df":0,"f":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903}},"df":3}}}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}},"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"w":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}},"g":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.6457513110645907}},"df":2,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.830951894845301},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":5,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979}},"df":4}}}}},"e":{"docs":{},"df":0,"=":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}},"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}},"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":3,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"{":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}},"o":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2},"r":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.449489742783178}},"df":1},"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1}}},"i":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}},"k":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}},"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}},"s":{"docs":{},"df":0,"k":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}},"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":3}},"x":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.7320508075688772}},"df":1}}}}}},"g":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":2}}}}}}},"i":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}},"c":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.0}},"df":1},"g":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}},"q":{"docs":{},"df":0,"u":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":3.1622776601683795}},"df":1}},"e":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.0}},"df":1,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"/":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1}}}}}}}}}}}}}},"v":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}},"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"v":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}},"o":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.58257569495584}},"df":3},"w":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":8.12403840463596},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":7.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":7.211102550927978},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":8}}},"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979}},"df":2}}},"p":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.69041575982343},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.449489742783178}},"df":5}}}}},"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979}},"df":4}}},"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"g":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903}},"df":3}}}}}},"w":{"docs":{},"df":0,"a":{"docs":{},"df":0,"y":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.0}},"df":4,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"q":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.449489742783178}},"df":2}}}}}}}},"m":{"docs":{},"df":0,"b":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":3}},"t":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}},"e":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":3.4641016151377544}},"df":1,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"/":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1}}}}}}}}}}}},"i":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}},"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.4641016151377544}},"df":4}}}},"p":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.4641016151377544}},"df":8,";":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.3166247903554}},"df":4,"\"":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}},"t":{"docs":{},"df":0,"y":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}}},"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}},"a":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":2},"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"[":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}}}}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907}},"df":1}}}}},"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":6,";":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}},"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":1}}}},"t":{"docs":{},"df":0,"y":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1}}}}}}}},"'":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.196152422706632},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":5.196152422706632}},"df":2},"b":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}}}}},"(":{"docs":{},"df":0,"3":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2},"i":{"docs":{},"df":0,"3":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}},"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}},"x":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}},"=":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}},"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1}}}},"[":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2},"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}},"i":{"docs":{},"df":0,"3":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":4}}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.0}},"df":2}}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2},"u":{"docs":{},"df":0,"8":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.23606797749979}},"df":2}}},"`":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.3166247903554}},"df":1},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.449489742783178}},"df":1}}}}},"a":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1,"[":{"docs":{},"df":0,"1":{"docs":{},"df":0,".":{"docs":{},"df":0,".":{"docs":{},"df":0,"3":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}},"r":{"docs":{},"df":0,"g":{"docs":{},"df":0,"s":{"docs":{},"df":0,"[":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2},"2":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,".":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}},"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}},"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2}}}},"d":{"docs":{},"df":0,"y":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}},"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1}}}},"g":{"docs":{},"df":0,"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0}},"df":1}}}}},"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"[":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2,".":{"docs":{},"df":0,".":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2},"4":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}},"i":{"docs":{},"df":0,"3":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":2}},"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2}}},"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.23606797749979}},"df":2}}}},"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"[":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":2}}}}}},"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.196152422706632},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":5.291502622129181},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.358898943540674},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":4.358898943540674}},"df":7}},"y":{"docs":{},"df":0,"b":{"docs":{},"df":0,"o":{"docs":{},"df":0,"x":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}}},"n":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2,"b":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"_":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2,"[":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2}}}}}}}}}}}}},"p":{"docs":{},"df":0,"1":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"p":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2},"2":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2},"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.449489742783178}},"df":4}}}}}},"q":{"docs":{},"df":0,"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"_":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}},"s":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2},"2":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.6457513110645907}},"df":2},"3":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2},"[":{"docs":{},"df":0,".":{"docs":{},"df":0,".":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}},"0":{"docs":{},"df":0,".":{"docs":{},"df":0,".":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2},"5":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2},"i":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2},"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}},"3":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2,".":{"docs":{},"df":0,".":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}},"6":{"docs":{},"df":0,".":{"docs":{},"df":0,".":{"docs":{},"df":0,"1":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}}}}}},"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}},"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.0}},"df":4,".":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2},"s":{"docs":{},"df":0,"h":{"docs":{},"df":0,"i":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}},"x":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}},":":{"docs":{},"df":0,":":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}},"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1}},"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.0990195135927845},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":5.0990195135927845},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":8.12403840463596},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":8.12403840463596}},"df":9}},"y":{"docs":{},"df":0,"n":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"p":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.605551275463989}},"df":6,"\"":{"docs":{},"df":0,"(":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1}}}}},"u":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":4},"v":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2,"[":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2},"1":{"docs":{},"df":0,"0":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}},"2":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}},"x":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":4},"{":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.4142135623730951}},"df":3}}}}}}},"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"s":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}}}}}}}},"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}},"y":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979}},"df":3}},"t":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.4142135623730951}},"df":2},"z":{"docs":{"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":5}}},"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}},"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":2}}}}},"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.7320508075688772}},"df":1}}}},"d":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"b":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}},"/":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772}},"df":1}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"w":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}},"—":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}},"g":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903}},"df":2}},"i":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.123105625617661},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.605551275463989}},"df":3,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"b":{"docs":{},"df":0,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"y":{"docs":{},"df":0,"_":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}}}}}},":":{"docs":{},"df":0,":":{"docs":{},"df":0,"b":{"docs":{},"df":0,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"y":{"docs":{},"df":0,"_":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.23606797749979}},"df":2}}}}}}}}}}}}}},"n":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2,"o":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.477225575051661},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.898979485566356},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":7.937253933193772}},"df":4},"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2,"e":{"docs":{},"df":0,"_":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"_":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{},"df":0,"n":{"docs":{},"df":0,"_":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"y":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979}},"df":2}}},"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"y":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":2}}},"t":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":7.681145747868608},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.385164807134504},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":7.0710678118654755},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":8,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"_":{"docs":{},"df":0,"f":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":3.0}},"df":1,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"(":{"docs":{},"df":0,"5":{"docs":{"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.0}},"df":1},"x":{"docs":{"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}},"s":{"docs":{},"df":0,"w":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":6}}}},"y":{"docs":{},"df":0,"m":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}}},"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3}},"t":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.1622776601683795}},"df":4}},"w":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":4}}}}}},"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}},"r":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0}},"df":2}}},"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.477225575051661},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":5.477225575051661},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.69041575982343},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":4.69041575982343}},"df":7,"(":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":1.0}},"df":2}}}}}},"o":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"p":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}}}},"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":5}},"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2,"i":{"docs":{},"df":0,"x":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.123105625617661},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":3}}}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}},"l":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":3,"e":{"docs":{},"df":0,"_":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"_":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0}},"df":1}}}}}}}}}}}},"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4,"c":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":7}}},"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}}},"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.123105625617661}},"df":3}}},"v":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1},"x":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}},"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":2}}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"b":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}},"b":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":3}}}}}}},"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.449489742783178}},"df":4,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"m":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}},"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,"s":{"docs":{},"df":0,"c":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"i":{"docs":{},"df":0,"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"j":{"docs":{},"df":0,"o":{"docs":{},"df":0,"b":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.449489742783178}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},":":{"docs":{},"df":0,":":{"docs":{},"df":0,"c":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"i":{"docs":{},"df":0,"v":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}}}}}}}}},"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"w":{"docs":{},"df":0,"(":{"docs":{},"df":0,"m":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"w":{"docs":{},"df":0,"(":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"i":{"docs":{},"df":0,"v":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}}}}}}}}}}}}}}},"h":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"z":{"docs":{},"df":0,"e":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1}}}}}},"v":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}},"e":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.385164807134504},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":4.358898943540674}},"df":5,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}},"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2}}}}}}}}},"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2},"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}},"w":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}},"n":{"docs":{},"df":0,"’":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.0}},"df":3}}}},"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.830951894845301},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":5.656854249492381},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0}},"df":5,"s":{"docs":{},"df":0,".":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0}},"df":2}}},"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2}}}}},"[":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2},"1":{"docs":{},"df":0,"]":{"docs":{},"df":0,".":{"docs":{},"df":0,"c":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.23606797749979}},"df":2}}}}}}},"2":{"docs":{},"df":0,"]":{"docs":{},"df":0,".":{"docs":{},"df":0,"c":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.23606797749979}},"df":2}}}}}}}}},"u":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":11.661903789690601},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":4.123105625617661},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.0990195135927845},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.4641016151377544}},"df":7}}}}}},"m":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":8.426149773176359},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter2/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":6.48074069840786},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":6,"’":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772}},"df":1}},"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907}},"df":4}}}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"y":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903}},"df":4}},"i":{"docs":{},"df":0,"v":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2}},"o":{"docs":{},"df":0,"w":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2}}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.242640687119285},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":4.0}},"df":2,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"k":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"s":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"y":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}},"m":{"docs":{},"df":0,"i":{"docs":{},"df":0,"x":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}},"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"y":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}},"u":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"s":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"m":{"docs":{},"df":0,"i":{"docs":{},"df":0,"x":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}},"h":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}},"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":3,"e":{"docs":{},"df":0,".":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}},"f":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0}},"df":1}}}},"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}}},"s":{"docs":{},"df":0,"_":{"docs":{},"df":0,"b":{"docs":{},"df":0,"y":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4}}},"m":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{},"df":0,"_":{"docs":{},"df":0,"p":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}},"c":{"docs":{},"df":0,"i":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":5}}},"i":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}},"k":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907}},"df":4},"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":2}}}}},"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":3}}}},"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":3,"e":{"docs":{},"df":0,"]":{"docs":{},"df":0,"(":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{},"df":0,"t":{"docs":{},"df":0,"p":{"docs":{},"df":0,"s":{"docs":{},"df":0,":":{"docs":{},"df":0,"/":{"docs":{},"df":0,"/":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,".":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}},"r":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":7.211102550927978},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":4.123105625617661},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":4,"!":{"docs":{},"df":0,"(":{"docs":{},"df":0,"!":{"docs":{},"df":0,"s":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,".":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"_":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"d":{"docs":{},"df":0,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}}}},"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,".":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"_":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"d":{"docs":{},"df":0,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"s":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}},"m":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}},"r":{"docs":{},"df":0,"#":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"(":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"f":{"docs":{},"df":0,"o":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}},"`":{"docs":{},"df":0,"f":{"docs":{},"df":0,"o":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1}}}}}}}}}}},"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,".":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"(":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}}},"`":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}},"s":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.6457513110645907}},"df":2},"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,".":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"_":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}},"_":{"docs":{},"df":0,"e":{"docs":{},"df":0,"q":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772}},"df":4,"!":{"docs":{},"df":0,"(":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2},"1":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}},"2":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2},"3":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2},"4":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.23606797749979}},"df":2},"5":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.3166247903554}},"df":2},"6":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2},"7":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2},"a":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2,"d":{"docs":{},"df":0,"d":{"docs":{},"df":0,"_":{"docs":{},"df":0,"t":{"docs":{},"df":0,"w":{"docs":{},"df":0,"o":{"docs":{},"df":0,"(":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}},"b":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2},"m":{"docs":{},"df":0,"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{},"df":0,"_":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,".":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"_":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,".":{"docs":{},"df":0,"b":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{},"df":0,"(":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}},"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}}}},"s":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}},"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}},"v":{"docs":{},"df":0,"1":{"docs":{},"df":0,"_":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,".":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0}},"df":2}}}}}}}}}}},"2":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2},"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"!":{"docs":{},"df":0,"[":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"s":{"docs":{},"df":0,"a":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1}}}},"`":{"docs":{},"df":0,"s":{"docs":{},"df":0,"a":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":1}}}}}}}}}}}}},"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.23606797749979}},"df":2,"e":{"docs":{},"df":0,"!":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"—":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}}}}}}}},"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.242640687119285}},"df":5,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"d":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}}}},"b":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}}}},"x":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}}}}}}},"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}}}},"m":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}}}},"s":{"docs":{},"df":0,"h":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}}},"u":{"docs":{},"df":0,"b":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}},"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}},"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":7.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":6.082762530298219}},"df":6}}},"u":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903}},"df":3,"p":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":3}}},"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2,".":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}},"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3}}}}}},"y":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2,"h":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772}},"df":1}}}}}}}},"t":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"/":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}}}}},"o":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}},"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2},"k":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":2}}},"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.358898943540674},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.0}},"df":3}}}},"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"b":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.291502622129181},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178}},"df":3,"e":{"docs":{},"df":0,"’":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}}}}}},"u":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1}}}},"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}},"g":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.8284271247461903}},"df":1,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1}}}},"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/about/":{"tf":1.0},"http://127.0.0.1:1111/docs/config-options/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":6}}},"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}},"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":2,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.47213595499958},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.7416573867739413}},"df":4}}}}}},"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.795831523312719},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":5}},"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.4142135623730951}},"df":1}}}},"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"y":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"c":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}}}}}}}}}}},"o":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":4}}}},"w":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}},"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1},"y":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4}},"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}},"x":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0}},"df":1,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772}},"df":2}},"y":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}},"b":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.0},"http://127.0.0.1:1111/rust/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":6.782329983125268},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":6.708203932499369},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.830951894845301},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":5.744562646538029},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.242640687119285},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.7416573867739413}},"df":10,"\"":{"docs":{},"df":0,".":{"docs":{},"df":0,".":{"docs":{},"df":0,".":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"c":{"docs":{},"df":0,"i":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}},"b":{"docs":{},"df":0,"y":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}}}},"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1}}}},"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"(":{"docs":{},"df":0,"x":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}}}}}},"'":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1}},".":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}},"3":{"docs":{},"df":0,"2":{"docs":{},"df":0,"3":{"docs":{},"df":0,"5":{"docs":{},"df":0,"f":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"9":{"docs":{},"df":0,"a":{"docs":{},"df":0,"1":{"docs":{},"df":0,"5":{"docs":{},"df":0,"6":{"docs":{},"df":0,"f":{"docs":{},"df":0,"7":{"docs":{},"df":0,"4":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}},"`":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":1}}}},"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.8284271247461903}},"df":2},"y":{"docs":{},"df":0,"_":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.3166247903554}},"df":2}}}}}},"c":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":5,"_":{"docs":{},"df":0,"o":{"docs":{},"df":0,"f":{"docs":{},"df":0,"_":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.6457513110645907}},"df":2,"e":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{},"df":0,"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"z":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"s":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}},"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}},"b":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"k":{"docs":{},"df":0,"f":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"(":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"r":{"docs":{},"df":0,"y":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}},"`":{"docs":{},"df":0,"r":{"docs":{},"df":0,"y":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"d":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}}},"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0}},"df":3}}}}}},"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}},"s":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}},"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.242640687119285},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.6457513110645907}},"df":6}}}},"w":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}},"y":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2}}}}}},"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178}},"df":3},"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0}},"df":1}}},"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2}}}},"r":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/posts/post-1/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":8,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}},"s":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903}},"df":4,".":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{},"df":0,"m":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/posts/post-1/":{"tf":1.4142135623730951}},"df":1,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"y":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"s":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"v":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}},"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"v":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.0}},"df":1}}}}}}}}}}},"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"c":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.0}},"df":1}}}}}}}}}}}}},"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"c":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.0}},"df":1}}}}}}}}}}}},"o":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"_":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"_":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"_":{"docs":{},"df":0,"j":{"docs":{},"df":0,"s":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"v":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}},"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}},"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"v":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.0}},"df":1}}}}}}}}}}}},"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.0}},"df":1}}}}}}}}}}},"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"_":{"docs":{},"df":0,"j":{"docs":{},"df":0,"s":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"v":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.0}},"df":1}}}}}}}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"y":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"c":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"h":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2},"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3,"c":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":4}}}},"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.58257569495584},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.196152422706632},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4,"a":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1},"u":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0}},"df":1}}}},"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.1622776601683795}},"df":3}}},"f":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":6.324555320336759},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":6.324555320336759},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.5677643628300215}},"df":6,"e":{"docs":{},"df":0,"_":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/posts/post-1/":{"tf":1.4142135623730951}},"df":1}}}}},"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}}}}},"g":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178}},"df":3}}},"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}},"n":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0}},"df":1}},"v":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178}},"df":3,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.898979485566356},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.123105625617661},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":6.855654600401044}},"df":6,"—":{"docs":{},"df":0,"w":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":6}}}},"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"e":{"docs":{},"df":0,"v":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}},"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":2}},"w":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/docs/config-options/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":4}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}},"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2,"_":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"_":{"docs":{},"df":0,"f":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}},"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}},"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907}},"df":1}}}}}},"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}},"f":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":4}}}}},"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":4}},"t":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.795831523312719},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.8284271247461903}},"df":2},"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907}},"df":4}}},"w":{"docs":{},"df":0,"e":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":6.48074069840786},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.795831523312719},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.0990195135927845},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":7}}}}},"y":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178}},"df":3}}}}},"i":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter2/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":4,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}}}},"j":{"docs":{},"df":0,"4":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"b":{"docs":{},"df":0,"c":{"docs":{},"df":0,"6":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}}}}}},"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}},"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.0}},"df":6,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":6.244997998398398},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.916079783099616},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":8},"y":{"docs":{},"df":0,"0":{"docs":{},"df":0,"b":{"docs":{},"df":0,"1":{"docs":{},"df":0,"1":{"docs":{},"df":0,"1":{"docs":{},"df":0,"1":{"docs":{},"df":0,"_":{"docs":{},"df":0,"0":{"docs":{},"df":0,"0":{"docs":{},"df":0,"0":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1}}}}}}}}}}}}}},"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.830951894845301},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.605551275463989}},"df":5}},"r":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.872983346207417}},"df":4,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1}}}}}}}}},"x":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1}}}}}}}}}}},"j":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}},"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}},"n":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3,"e":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":1}}}}},"e":{"docs":{},"df":0,"e":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}},"o":{"docs":{},"df":0,"b":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2},"c":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/posts/post-1/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":7.280109889280518},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.916079783099616}},"df":8,"q":{"docs":{},"df":0,"u":{"docs":{},"df":0,"o":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1}}}}}},"g":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0},"http://127.0.0.1:1111/posts/post-2/":{"tf":1.0}},"df":2}},"u":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.8284271247461903}},"df":7}}},"o":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}},"b":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.0}},"df":1},"d":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.0},"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":6.244997998398398},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.795831523312719},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":6.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":9}},"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0}},"df":2},"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":2}}}}}},"l":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.23606797749979},"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0}},"df":2}},"n":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}},"o":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/posts/post-1/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.358898943540674},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":6,".":{"docs":{},"df":0,"s":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/posts/post-1/":{"tf":1.7320508075688772}},"df":1}}}}},"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/posts/post-1/":{"tf":1.7320508075688772}},"df":1}}}},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,".":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{},"df":0,"m":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/posts/post-1/":{"tf":2.0}},"df":1}}}}}}}}}},"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,".":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{},"df":0,"m":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/posts/post-1/":{"tf":1.4142135623730951}},"df":1}}}}}}}}},"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"n":{"docs":{},"df":0,".":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{},"df":0,"m":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/posts/post-1/":{"tf":1.0}},"df":1}}}}}}},"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,".":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{},"df":0,"m":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/posts/post-1/":{"tf":1.0}},"df":1}}}}}}}}}}}}},"k":{"docs":{},"df":0,"e":{"docs":{},"df":0,"e":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}},"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.3166247903554}},"df":8,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":4}}}}},"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":9.1104335791443},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":4.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":9.055385138137417},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":5.916079783099616},"http://127.0.0.1:1111/rust/to do/chapter4/2-references-and-borrowing/":{"tf":1.0}},"df":8,"_":{"docs":{},"df":0,"m":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.449489742783178}},"df":2}}}},"m":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}},"s":{"docs":{},"df":0,"_":{"docs":{},"df":0,"m":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0}},"df":2}}}}},"및":{"docs":{},"df":0,"b":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{},"df":0,"_":{"docs":{},"df":0,"m":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}},"t":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.58257569495584},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.123105625617661},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":7.0}},"df":4,"_":{"docs":{},"df":0,"f":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}},"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3}}}},"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.5677643628300215},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":7,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}},"x":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":8.306623862918075},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":5.291502622129181},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":7,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}},"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"d":{"docs":{},"df":0,"y":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":6}}},"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0}},"df":2}}}}}}}}}}},":":{"docs":{},"df":0,":":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"w":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2,"(":{"docs":{},"df":0,"5":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2},"a":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0}},"df":2},"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"(":{"docs":{},"df":0,"1":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}},"2":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2},"3":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}},"f":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772}},"df":2},"n":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2}}},"x":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2},"|":{"docs":{},"df":0,"x":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}},"’":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1}}},"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.23606797749979}},"df":2,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1},"k":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.5677643628300215}},"df":4}}}},"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/posts/post-2/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.477225575051661},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":4.47213595499958},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":3.0}},"df":5,".":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"d":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}},"d":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.7320508075688772}},"df":1}}}},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2},"k":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter2/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":8,"a":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}},"f":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.8284271247461903}},"df":2}}}}}},"v":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}},"i":{"docs":{},"df":0,"e":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2,"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}}}},"n":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.242640687119285},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":6.0}},"df":3}},"t":{"docs":{},"df":0,"t":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}},"o":{"docs":{},"df":0,"k":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}}},"u":{"docs":{},"df":0,"g":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903}},"df":3}}}},"w":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.916079783099616}},"df":2}}}}}},"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}},"u":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0}},"df":2,"_":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.6457513110645907}},"df":2,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,".":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"(":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"t":{"docs":{},"df":0,"(":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"w":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{},"df":0,"(":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"w":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"f":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":5,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"w":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}},".":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"s":{"docs":{},"df":0,"_":{"docs":{},"df":0,"w":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"(":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}},"s":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"e":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}},"[":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.449489742783178}},"df":2,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"w":{"docs":{},"df":0,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"m":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0}},"df":2}}}}}}}}}}}}}}}}}}}}},"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.242640687119285},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.0}},"df":3},"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/posts/post-1/":{"tf":1.0},"http://127.0.0.1:1111/posts/post-2/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":4.123105625617661},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":6.928203230275509},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":4.898979485566356},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.69041575982343},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter2/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.23606797749979}},"df":14,"(":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0}},"df":2}}},"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"z":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}},"_":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.23606797749979}},"df":2,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"(":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}}},"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}},"t":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":4}}},"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.0}},"df":1}}}},"m":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}},"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":1}}},"r":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}},"n":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}},"s":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}},"y":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":6.557438524302},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.8284271247461903}},"df":3,"(":{"docs":{},"df":0,"u":{"docs":{},"df":0,"8":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1}}},"s":{"docs":{},"df":0,"(":{"docs":{},"df":0,"9":{"docs":{},"df":0,"5":{"docs":{},"df":0,".":{"docs":{},"df":0,".":{"docs":{},"df":0,"1":{"docs":{},"df":0,"0":{"docs":{},"df":0,"3":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}},".":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"(":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":2}}}}}}}}}}}}}}}}}}},"c":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.0},"http://127.0.0.1:1111/rust/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.916079783099616},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":5.830951894845301},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.795831523312719},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":4.795831523312719},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.3166247903554}},"df":14,"+":{"docs":{},"df":0,"+":{"docs":{},"df":0,"(":{"docs":{},"df":0,"2":{"docs":{},"df":0,"0":{"docs":{},"df":0,"1":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1}}}}}}},".":{"docs":{},"df":0,"d":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}}},"2":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":3},"3":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1},"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}},"g":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.0}},"df":1}}}},"l":{"docs":{},"df":0,"c":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.0}},"df":3,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"_":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2,"(":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"s":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}},"s":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}},"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":16.06237840420901},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":11.958260743101398},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":16.186414056238647},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.449489742783178}},"df":6,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}},"_":{"docs":{},"df":0,"f":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"_":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}},"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":2}}}},"m":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178}},"df":3}},"n":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2}},"'":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0}},"df":1}},"_":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.23606797749979}},"df":4,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":4}}}}}}}}}},"방":{"docs":{},"df":0,"법":{"docs":{},"df":0,".":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"_":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}},"`":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1}},"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}},"y":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}},"’":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":6.164414002968976},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":6.082762530298219},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.69041575982343}},"df":4}}},"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":3}},"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907}},"df":3}},"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3}},"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}},"u":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":6.928203230275509},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":5}}}},"r":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":3,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1}},"g":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter1/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":9.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":13.96424004376894},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":13.784048752090222},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":7.416198487095663},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":7.3484692283495345},"http://127.0.0.1:1111/rust/chapter2/":{"tf":7.14142842854285},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":7.14142842854285},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":7.14142842854285}},"df":16,".":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter2/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":6}}}},"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.0990195135927845},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":5.0990195135927845},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter2/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.3166247903554}},"df":8}}}}},"/":{"docs":{},"df":0,"b":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"/":{"docs":{},"df":0,"r":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}},"c":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}},"’":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772}},"df":1}}},"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1}}}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1,"o":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0}},"df":1}}}}}},"s":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":9.219544457292887},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":7.14142842854285},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":9.055385138137417},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":5,"_":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}},"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1}},"t":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"p":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}}}},"c":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":4,"a":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1}}}},"e":{"docs":{},"df":0,"g":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}}}}}},"u":{"docs":{},"df":0,"g":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772}},"df":1}}},"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.898979485566356},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.242640687119285}},"df":4},"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}}}}}},"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}}}}}},"d":{"docs":{"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0}},"df":7},"e":{"docs":{},"df":0,"b":{"docs":{},"df":0,"u":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}},"l":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":4,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.4142135623730951}},"df":1}}}}}},"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}},"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979}},"df":5}}}}}},"f":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.7320508075688772}},"df":3,"(":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.0990195135927845},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":5.0}},"df":2}}}}}}},"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":2}},"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":2}}}}},"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{},"df":0,"i":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}},"n":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":2},"d":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.7320508075688772}},"df":1}}}},"g":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":9.38083151964686},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":7.681145747868608},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":7.745966692414834},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":6,"e":{"docs":{},"df":0,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2,"m":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}},"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"_":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2}}}}}}}}},"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4,"(":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}},"i":{"docs":{},"df":0,"3":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":6}}}},"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"(":{"docs":{},"df":0,"i":{"docs":{},"df":0,"3":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}},"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.477225575051661},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.0}},"df":2}}}},"p":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":10.14889156509222},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":7.745966692414834},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":9.9498743710662}},"df":4,"1":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.4641016151377544}},"df":2}}}}}},"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.123105625617661},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.7416573867739413}},"df":6,"_":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}}}}},"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.898979485566356}},"df":5,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":2}}},"’":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}}},"i":{"docs":{},"df":0,"z":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}}}},"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"=":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1}}}},"`":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":1}}}}}}}},"t":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":4.69041575982343}},"df":2,".":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0}},"df":1}},"x":{"docs":{},"df":0,"k":{"docs":{},"df":0,"c":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0}},"df":1}}}}}}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772}},"df":1}},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}},"c":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":7.681145747868608},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":6.782329983125268},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":4.123105625617661},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":6.0}},"df":5,"b":{"docs":{},"df":0,"o":{"docs":{},"df":0,"x":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1}}},"e":{"docs":{},"df":0,"d":{"docs":{},"df":0,"_":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1}},"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.605551275463989}},"df":3,"'":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}},"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}},"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/posts/post-2/":{"tf":1.0}},"df":1}}}}},"f":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":1}},"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}}}},"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.3166247903554}},"df":2,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.58257569495584},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.1622776601683795}},"df":2}}}},"l":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.0}},"df":1}},"m":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}},"o":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.0}},"df":2}},"o":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.358898943540674}},"df":3}},"s":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979}},"df":3,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":4}}}},"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.0}},"df":1}}}}}}},"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2,"r":{"docs":{},"df":0,"c":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3},"u":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}},"m":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3}}}}}},"s":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}},"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":1.0}},"df":2}},"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"f":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3}},"t":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":2}}}},"s":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3,"0":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.8284271247461903}},"df":1},"3":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1},"4":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1},"5":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1},"6":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1},"7":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.8284271247461903}},"df":1},"8":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.0}},"df":1},"9":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.449489742783178}},"df":1}},"=":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"b":{"docs":{},"df":0,"o":{"docs":{},"df":0,"o":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/posts/post-1/":{"tf":1.0}},"df":1}}}},"c":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}}}}},"'":{"docs":{},"df":0,"f":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"'":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0}},"df":1}}}}}}}}}}}}}},"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}}}}}},"i":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1}}}},"u":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":2}}},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.123105625617661},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.0}},"df":3,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":1}},"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1}},"u":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":4}}},"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":4,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":3}},"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2}}}}},"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":3}},"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}}},"p":{"docs":{},"df":0,"p":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.0}},"df":2},"y":{"docs":{},"df":0,"/":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"/":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,".":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{},"df":0,"m":{"docs":{},"df":0,"l":{"docs":{},"df":0,"#":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"x":{"docs":{},"df":0,"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"’":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}},"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{},"df":0,"w":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}},"n":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.656854249492381},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.47213595499958},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.449489742783178}},"df":7}},"s":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178}},"df":3,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":2},"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}},"u":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":14.317821063276353},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":5.385164807134504},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":8.12403840463596},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":7,"e":{"docs":{},"df":0,"@":{"docs":{},"df":0,"s":{"docs":{},"df":0,"r":{"docs":{},"df":0,"c":{"docs":{},"df":0,"/":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"b":{"docs":{},"df":0,".":{"docs":{},"df":0,"r":{"docs":{},"df":0,"s":{"docs":{},"df":0,":":{"docs":{},"df":0,"2":{"docs":{},"df":0,":":{"docs":{},"df":0,"5":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}},"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,".":{"docs":{},"df":0,"r":{"docs":{},"df":0,"s":{"docs":{},"df":0,":":{"docs":{},"df":0,"1":{"docs":{},"df":0,"1":{"docs":{},"df":0,":":{"docs":{},"df":0,"3":{"docs":{},"df":0,"6":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}}}}}}}}}},"s":{"docs":{},"df":0,".":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{},"df":0,"m":{"docs":{},"df":0,"l":{"docs":{},"df":0,"#":{"docs":{},"df":0,"m":{"docs":{},"df":0,"o":{"docs":{},"df":0,"v":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1}}}}}}}}}},"’":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0}},"df":1}}}}},"u":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}},"u":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979}},"df":1}}}},"t":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}}}}}},"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/":{"tf":1.0}},"df":1}}},"d":{"docs":{"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":1.7320508075688772}},"df":2,".":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":1.0}},"df":1}}},"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}},"p":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter2/":{"tf":2.23606797749979}},"df":3,"_":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"y":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}},"o":{"docs":{"http://127.0.0.1:1111/about/":{"tf":1.0}},"df":1,"d":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":4.123105625617661},"http://127.0.0.1:1111/docs/config-options/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":3.872983346207417},"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":17.26267650163207},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":18.411952639521967},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":20.12461179749811},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":11,"—":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}},"’":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":1}}},"e":{"docs":{},"df":0,"f":{"docs":{},"df":0,"f":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"s":{"docs":{},"df":0,".":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}},"r":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.242640687119285},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":2}}}}}},"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}},"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.385164807134504},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":4.242640687119285}},"df":3,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2}}},"n":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2}}}}}},"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"n":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.23606797749979}},"df":2}}}}},"q":{"docs":{},"df":0,"u":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":2,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"(":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":2}},"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"k":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}}}},"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}},"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.0990195135927845},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.656854249492381},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.449489742783178}},"df":7,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":1}}}}}},"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979}},"df":3},"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.123105625617661},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.358898943540674},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":6,"(":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2},"i":{"docs":{},"df":0,"3":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}},":":{"docs":{},"df":0,":":{"docs":{},"df":0,"h":{"docs":{},"df":0,"s":{"docs":{},"df":0,"v":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}},"r":{"docs":{},"df":0,"g":{"docs":{},"df":0,"b":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}},"u":{"docs":{},"df":0,"m":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}},"m":{"docs":{},"df":0,"b":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.449489742783178},"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.0}},"df":6}}},"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.0990195135927845},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.0}},"df":5},"f":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}},"m":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":2,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":7.280109889280518},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979}},"df":7}}},"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/docs/config-options/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.385164807134504},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/4-comments/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":7}}},"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}},"o":{"docs":{},"df":0,"d":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1}},"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.47213595499958},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter3/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.795831523312719}},"df":5,".":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}},":":{"docs":{},"df":0,":":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}},"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3}},"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/":{"tf":1.4142135623730951}},"df":1}}}},"p":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}}},"u":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":3}}},"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":3},"y":{"docs":{},"df":0,"’":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}},"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.47213595499958},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.605551275463989}},"df":5,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":4,"\"":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"q":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1}},"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0}},"df":1}}}}}}}}}}}}}}}},"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":4}},"e":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}},"i":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":14.866068747318506},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":9.433981132056603},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":11.704699910719626},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":5.656854249492381},"http://127.0.0.1:1111/rust/chapter2/":{"tf":4.898979485566356},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":14.560219778561036},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":7.211102550927978}},"df":13,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"’":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":2}}}}},"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}}},"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1}}}}}},"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}}},"t":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":4},"x":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.1622776601683795}},"df":4}},"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1,"c":{"docs":{"http://127.0.0.1:1111/about/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/4-comments/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178}},"df":5}}},"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":4},"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3}}}}},"i":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}}},"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979}},"df":4,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"’":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}}}},"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":7.211102550927978},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":7.0}},"df":2,"a":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}},"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":2}}}},"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":2}}},"p":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.58257569495584},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter3/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.58257569495584}},"df":5,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772}},"df":1}}},"r":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772}},"df":2}}},"i":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.0}},"df":3}},"l":{"docs":{},"df":0,"u":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{},"df":0,"q":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1}}}}}}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.385164807134504}},"df":3}}},"u":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":7.416198487095663},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.7320508075688772}},"df":5}}}},"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.795831523312719},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907}},"df":4,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":2}}}}}},"f":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}},"i":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":2},"g":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":7.937253933193772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":7.615773105863909}},"df":5,".":{"docs":{},"df":0,"f":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"_":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2}}}}}}}}},"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}},"q":{"docs":{},"df":0,"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0}},"df":2}}}}},"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":2.8284271247461903}},"df":1}}}}},":":{"docs":{},"df":0,":":{"docs":{},"df":0,"b":{"docs":{},"df":0,"u":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":5.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":4,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"g":{"docs":{},"df":0,"s":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"w":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{},"df":0,"_":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"_":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"(":{"docs":{},"df":0,"|":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"v":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"g":{"docs":{},"df":0,"s":{"docs":{},"df":0,"(":{"docs":{},"df":0,")":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"w":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{},"df":0,"_":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"_":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"(":{"docs":{},"df":0,"|":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"w":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}},"_":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"x":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.23606797749979}},"df":2}}}},"u":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.358898943540674},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":5}}},"r":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}},"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":2}}}},"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2}}},"u":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":3}}},"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1,"u":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}}},"j":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2}}}}},"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":6.782329983125268},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":4}}}},"s":{"docs":{},"df":0,"(":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2},"2":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2},"3":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.23606797749979}},"df":2},"4":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0}},"df":2},"5":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2},"_":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2},"i":{"docs":{},"df":0,"3":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.8284271247461903}},"df":2}}},"r":{"docs":{},"df":0,"c":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"f":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"i":{"docs":{},"df":0,"3":{"docs":{},"df":0,"2":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}},":":{"docs":{},"df":0,":":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"w":{"docs":{},"df":0,"(":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"f":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"w":{"docs":{},"df":0,"(":{"docs":{},"df":0,"3":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2},"4":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}},"e":{"docs":{},"df":0,"f":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.23606797749979}},"df":2}}}}}}},"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.449489742783178}},"df":1}}}}},"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":2}}},"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}},"q":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}},"r":{"docs":{},"df":0,"v":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2}}},"i":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.0990195135927845},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.6457513110645907}},"df":8,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":2}}},"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":3}}},"o":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":1,"i":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}},"n":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":1.7320508075688772}},"df":3,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":3,"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":2,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":3}}}},"u":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.1622776601683795}},"df":7,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":2}}}}}}},"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":4}},"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.358898943540674},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":4,"p":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}},"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1,"@":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"v":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,".":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}},"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":9.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.916079783099616},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":7.937253933193772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":8}}},"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}}}},"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0},"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.0},"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":4.0},"http://127.0.0.1:1111/posts/post-1/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":7.211102550927978},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":5.656854249492381},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.69041575982343},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.916079783099616},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.1622776601683795}},"df":11,"\"":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/posts/post-1/":{"tf":1.0}},"df":1}}}},"s":{"docs":{},"df":0,"\"":{"docs":{},"df":0,".":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"_":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}}}}},".":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.23606797749979}},"df":2}},"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.23606797749979}},"df":2}}}},"`":{"docs":{},"df":0,".":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"_":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}}}},"x":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.872983346207417}},"df":3,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1}}}}}}}}},"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}},"n":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.358898943540674},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.47213595499958},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":7}}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.0}},"df":2}},"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}}}},"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":3}}},"i":{"docs":{},"df":0,"b":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}},"v":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}},"o":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.605551275463989}},"df":7}}}},"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.242640687119285},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.1622776601683795}},"df":4},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907}},"df":3}},"r":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":4},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907}},"df":3}},"y":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":2}},"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}}},"o":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1,"_":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}}}}},"l":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":3},"r":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":4}}}}},"p":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.242640687119285},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.58257569495584},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":6.928203230275509},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":6}},"r":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":3,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"o":{"docs":{},"df":0,"p":{"docs":{},"df":0,"s":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"f":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"f":{"docs":{},"df":0,"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"_":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}}},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"i":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2,";":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"_":{"docs":{},"df":0,"b":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"s":{"docs":{},"df":0,"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}},"f":{"docs":{},"df":0,"m":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}},"s":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}},"s":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"[":{"docs":{},"df":0,"t":{"docs":{},"df":0,"]":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907}},"df":3,"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":3}}}},"l":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2},"s":{"docs":{},"df":0,"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907}},"df":4}}}}}},"u":{"docs":{},"df":0,"p":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}},"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":3}},"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"d":{"docs":{},"df":0,"n":{"docs":{},"df":0,"’":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178}},"df":3}}}}},"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":8.774964387392123},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.8284271247461903}},"df":8,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.358898943540674},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":2.449489742783178}},"df":5,".":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{},"df":0,"(":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"w":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.8284271247461903}},"df":2}}}}}}}}}}}}}}}},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"_":{"docs":{},"df":0,"u":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":2.0}},"df":1}}}}}},"s":{"docs":{},"df":0,"—":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"b":{"docs":{},"df":0,"t":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}}}}}},"p":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}},"r":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.23606797749979}},"df":3}}},"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.898979485566356},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.69041575982343},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":6.082762530298219},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":5,"a":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1}}}}}},"p":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":5}},"t":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":11.874342087037917},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":7.874007874011811},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":11.489125293076057},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.449489742783178}},"df":9,"\"":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1},":":{"docs":{},"df":0,":":{"docs":{},"df":0,"f":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"_":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"g":{"docs":{},"df":0,"s":{"docs":{},"df":0,"_":{"docs":{},"df":0,"n":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4}}}}}}}}}}}}},"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"_":{"docs":{},"df":0,"o":{"docs":{},"df":0,"f":{"docs":{},"df":0,"_":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.1622776601683795}},"df":2,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"d":{"docs":{},"df":0,"_":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"_":{"docs":{},"df":0,"w":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.449489742783178}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"g":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}}}}},"k":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}},"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"{":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.449489742783178}},"df":2}}}}}}}}}}}},"s":{"docs":{},"df":0,".":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.196152422706632},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":5.196152422706632},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter2/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter3/4-comments/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":8}}},"_":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.7320508075688772}},"df":1}}}},"’":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907}},"df":3}}}},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":13.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":4.123105625617661},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":11.135528725660043},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":11.090536506409418},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":8,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":4}}}}},"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}},"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}},"l":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.3166247903554}},"df":2}},"o":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1},"s":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}},"u":{"docs":{},"df":0,"c":{"docs":{},"df":0,"i":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}},"t":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.7320508075688772}},"df":1}}}}}}}}},"s":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.0},"http://127.0.0.1:1111/posts/post-1/":{"tf":3.605551275463989}},"df":2}},"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.4142135623730951}},"df":4}}},"u":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1,"m":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1},"p":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2},"r":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":1.0}},"df":1,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.69041575982343}},"df":2}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.291502622129181},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.898979485566356},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.242640687119285},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":6}}}}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.0},"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.69041575982343},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.47213595499958},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":8,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"_":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}},"i":{"docs":{},"df":0,"z":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}},"s":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.795831523312719},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":4.795831523312719}},"df":2}}}}}}}}}}}}}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2}},"y":{"docs":{},"df":0,"c":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.744562646538029},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":5,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,".":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{},"df":0,"m":{"docs":{},"df":0,"l":{"docs":{},"df":0,"#":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"v":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}},"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}},"d":{"docs":{"http://127.0.0.1:1111/rust/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0}},"df":7,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}},"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4}},"l":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.69041575982343},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.0}},"df":3}},"i":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}},"s":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}},"s":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.7320508075688772}},"df":1}},"t":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":6.48074069840786},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":11.445523142259598},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":7.483314773547883},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter22/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":13.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/to do/chapter5/":{"tf":1.0}},"df":11,".":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"_":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}},"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}}}},"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}},"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":3.4641016151377544}},"df":1}},"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"u":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}},"’":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}},"e":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1,"f":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}}}}}}},"y":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.0}},"df":6}},"b":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.0}},"df":2,"!":{"docs":{},"df":0,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}},"3":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}},"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}},"d":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":1.0}},"df":2},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}},"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979}},"df":1}}}}},"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":3,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979}},"df":2}}}}},"b":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1}},"u":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.58257569495584},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.449489742783178}},"df":6,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"(":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"f":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":7.54983443527075},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":7.54983443527075},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter2/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.8284271247461903}},"df":11}}}}}}},"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"b":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":2}}},"i":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.605551275463989}},"df":3},"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"9":{"docs":{},"df":0,"8":{"docs":{},"df":0,"_":{"docs":{},"df":0,"2":{"docs":{},"df":0,"2":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1}}}}}}}}},"s":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":2}},"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.196152422706632},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":7.3484692283495345},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":6}}},"o":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772}},"df":1},"u":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979}},"df":1}}}}},"e":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/posts/post-1/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":4,"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}},"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"g":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/":{"tf":1.0},"http://127.0.0.1:1111/docs/config-options/":{"tf":2.0},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0},"http://127.0.0.1:1111/docs/theme-extension/":{"tf":2.23606797749979},"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.4142135623730951}},"df":5,"/":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"/":{"docs":{},"df":0,"b":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,".":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{},"df":0,"m":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/posts/post-1/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"f":{"docs":{},"df":0,"a":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0},"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.385164807134504},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":6.855654600401044},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":6.244997998398398},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":11,".":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"/":{"docs":{},"df":0,"t":{"docs":{},"df":0,"d":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}}}}}},":":{"docs":{},"df":0,":":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"f":{"docs":{},"df":0,"a":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772}},"df":2}}}}}}}}}}}}},"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":9.219544457292887},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":9.055385138137417},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":13.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/to do/chapter5/1-defining-and-instantiating-structs/":{"tf":1.0}},"df":10,"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":7.3484692283495345},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":6.557438524302},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":8.602325267042627}},"df":5}}}},"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}},"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2}}},"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"y":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":2}},"e":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979}},"df":1}},"h":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.449489742783178}},"df":1}},"i":{"docs":{},"df":0,"b":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":2}}},"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"_":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.23606797749979}},"df":2}}}},"i":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}}}},"t":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}},"m":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.123105625617661},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903}},"df":3}}}}}},"n":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2,"i":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}},"q":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1}}},"o":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":4}},"t":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.7320508075688772}},"df":1},"y":{"docs":{},"df":0,"(":{"docs":{},"df":0,"c":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"p":{"docs":{},"df":0,"p":{"docs":{},"df":0,"y":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"x":{"docs":{},"df":0,"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}},"p":{"docs":{"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":1.0}},"df":1,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":1}}},"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.916079783099616},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.47213595499958},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter2/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.242640687119285}},"df":7}}},"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}},"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"y":{"docs":{"http://127.0.0.1:1111/posts/post-2/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}},"t":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979}},"df":2}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":8.12403840463596},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":7.211102550927978},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":6,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"=":{"docs":{},"df":0,"u":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}}}}}}},"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}},":":{"docs":{},"df":0,":":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}},"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.898979485566356},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907}},"df":3,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":4}}}}},"m":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"=":{"docs":{},"df":0,"u":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}},"i":{"docs":{},"df":0,"v":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":6.782329983125268},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":7,"e":{"docs":{},"df":0,"(":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"b":{"docs":{},"df":0,"u":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.6457513110645907}},"df":6}}}}},"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0}},"df":2}}}}}}}}}},"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"q":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"p":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.449489742783178}},"df":2}}}}}}}}},"s":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1},"2":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.0}},"df":1},"3":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.0}},"df":1},"4":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1},"c":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"b":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178}},"df":3},"p":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/docs/config-options/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":4.47213595499958},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":7}}}}},"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.4641016151377544}},"df":4}},"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":3}},"k":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":1.0}},"df":1}}}},"p":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}},"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":3,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}},"r":{"docs":{},"df":0,"u":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}},"u":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.5677643628300215},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":5}}}}}}}},"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.47213595499958},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.291502622129181},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":6}}},"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1}},"r":{"docs":{},"df":0,"m":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903}},"df":3,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":1}}}}}}}}},"u":{"docs":{},"df":0,"t":{"docs":{},"df":0,"s":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}},"v":{"docs":{"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.744562646538029},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":5.744562646538029},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter2/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.8284271247461903}},"df":11,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}},"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0},"http://127.0.0.1:1111/posts/post-2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.123105625617661},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903}},"df":8}}}},"i":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0}},"df":1}},"o":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/":{"tf":1.0}},"df":1},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1}}}},"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}},"g":{"docs":{},"df":0,"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":3}}}},"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}},"m":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1}},"c":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":1,"_":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.449489742783178}},"df":2}}}}},"k":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2}}}}}},"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}},"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}}}}},"d":{"docs":{},"df":0,"n":{"docs":{},"df":0,"’":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903}},"df":3}}}},"f":{"docs":{},"df":0,"f":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":8.660254037844387},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":7.874007874011811},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":10.246950765959598}},"df":7}},"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":3,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}}}}},"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2,"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.0}},"df":1}}},"j":{"docs":{},"df":0,"k":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}},"m":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2,"n":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":1,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2,"s":{"docs":{},"df":0,".":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2},"1":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}},"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.7320508075688772}},"df":1}}},"e":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}},"r":{"docs":{"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":1.0}},"df":1,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":4,"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.58257569495584},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":5}},"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":6.855654600401044},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.242640687119285},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":5}}}}}}},"s":{"docs":{},"df":0,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":2}},"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":2}}}},"m":{"docs":{},"df":0,"b":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0}},"df":1}}}}}},"c":{"docs":{},"df":0,"i":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}},"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.449489742783178}},"df":2}}}}},"v":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":3}},"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.916079783099616},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":6.324555320336759},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":7.280109889280518}},"df":3}}}},"h":{"docs":{},"df":0,"w":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}},"k":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1},"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}},"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"y":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.58257569495584},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.291502622129181},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.7416573867739413}},"df":11,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2,";":{"docs":{},"df":0,"(":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}},"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"w":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"{":{"docs":{},"df":0,"}":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"y":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"'":{"docs":{},"df":0,"a":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}},"특":{"docs":{},"df":0,"성":{"docs":{},"df":0,"과":{"docs":{},"df":0,"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1}}}}}}}}}},"q":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":2.0}},"df":1}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"g":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":2}}}}}},"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}},"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"_":{"docs":{},"df":0,"f":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"_":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}}},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3}},"g":{"docs":{},"df":0,"u":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":3}}}}}}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}},"i":{"docs":{},"df":0,"b":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772}},"df":1}}},"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}}}}},"v":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3,"r":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1}}},"i":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":3},"s":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":2.23606797749979}},"df":3,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"v":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}}}}}},"j":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/":{"tf":1.4142135623730951}},"df":1}}}}},"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}},"o":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/4-comments/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":6,"_":{"docs":{},"df":0,"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.23606797749979}},"df":2}}}}}},"t":{"docs":{},"df":0,"w":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.449489742783178}},"df":2,"e":{"docs":{},"df":0,"(":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"d":{"docs":{},"df":0,"_":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}},"f":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}},"c":{"docs":{"http://127.0.0.1:1111/docs/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.477225575051661},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":4.898979485566356},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.4142135623730951}},"df":7,"u":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.0},"http://127.0.0.1:1111/posts/post-2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":7.810249675906654},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.358898943540674},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.123105625617661}},"df":7}}}}}},"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"_":{"docs":{},"df":0,"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"t":{"docs":{},"df":0,"_":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}},"n":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979}},"df":1}},"'":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}},"`":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":1}},"’":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":7.54983443527075},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":7.874007874011811},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":7.874007874011811}},"df":3}}}}},"g":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.795831523312719},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":4.47213595499958}},"df":2,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"b":{"docs":{},"df":0,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"y":{"docs":{},"df":0,"_":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}},"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}},"j":{"docs":{},"df":0,"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}},"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4}}},"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":3.1622776601683795}},"df":1}}},"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979}},"df":1}}}},"n":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2}},"'":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.0}},"df":1}},"`":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}},"e":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907}},"df":5,"c":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.0}},"df":1}},"’":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":8.18535277187245},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":6.082762530298219},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":7.745966692414834}},"df":4}}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":1,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"z":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}}},"u":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":3}}},"w":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.830951894845301},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":4.123105625617661},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907}},"df":5,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter2/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":4}}}},"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":2}},"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1}}}}}}}},"y":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1},"w":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1,"n":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0}},"df":1}}},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.6457513110645907}},"df":2}}}},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}},"v":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":3,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"/":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}}}}}}}}},"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":3}}}},"o":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":10.14889156509222},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":7.416198487095663},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.196152422706632},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.3166247903554}},"df":8,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"m":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0}},"df":4}}}}}}}},"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2},"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"f":{"docs":{},"df":0,".":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,".":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}}}}}}},"v":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}},"u":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/":{"tf":1.0}},"df":1}}}}},"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772}},"df":2}},"u":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}},"c":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979}},"df":1},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.6457513110645907}},"df":2}},"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.358898943540674},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":4.123105625617661},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.242640687119285},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":4.58257569495584}},"df":11},"o":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1},"p":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.58257569495584}},"df":2}}}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":4}},"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":3}}},"y":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772}},"df":3,"a":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3}},"키":{"docs":{},"df":0,"워":{"docs":{},"df":0,"드":{"docs":{},"df":0,"는":{"docs":{},"df":0,"d":{"docs":{},"df":0,"y":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}},"e":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.449489742783178}},"df":9,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.872983346207417}},"df":6,";":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}},"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}}}}}}},".":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0}},"df":3}},"0":{"docs":{},"df":0,"0":{"docs":{},"df":0,"0":{"docs":{},"df":0,"4":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2},"5":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}},"4":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}},"7":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}},"1":{"docs":{},"df":0,"0":{"docs":{},"df":0,"6":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":4}},"3":{"docs":{},"df":0,"3":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}},"2":{"docs":{},"df":0,"7":{"docs":{},"df":0,"7":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":6}},"8":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1}}},"3":{"docs":{},"df":0,"0":{"docs":{},"df":0,"8":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":10}},"6":{"docs":{},"df":0,"9":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}},"7":{"docs":{},"df":0,"3":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}},"8":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":6},"4":{"docs":{"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":1.0}},"df":1}}},"4":{"docs":{},"df":0,"3":{"docs":{},"df":0,"3":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4}},"9":{"docs":{},"df":0,"9":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4}}},"5":{"docs":{},"df":0,"0":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2},"7":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":4}},"1":{"docs":{},"df":0,"5":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}},"9":{"docs":{},"df":0,"6":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4},"7":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2},"9":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772}},"df":2}}},"6":{"docs":{},"df":0,"0":{"docs":{},"df":0,"3":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}},"1":{"docs":{},"df":0,"4":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}},"5":{"docs":{},"df":0,"8":{"docs":{"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.0}},"df":1}}},"7":{"docs":{},"df":0,"4":{"docs":{},"df":0,"6":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}},"9":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}},"5":{"docs":{},"df":0,"9":{"docs":{},"df":0,"9":{"docs":{},"df":0,"8":{"docs":{},"df":0,"1":{"docs":{},"df":0,"1":{"docs":{},"df":0,"f":{"docs":{},"df":0,"a":{"docs":{},"df":0,"2":{"docs":{},"df":0,"4":{"docs":{},"df":0,"6":{"docs":{},"df":0,"d":{"docs":{},"df":0,"b":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}},"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.0},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":10.099504938362077},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":8.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":9.797958971132712}},"df":5}},"r":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.1622776601683795}},"df":3,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178}},"df":3}}}},"n":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}},"s":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907}},"df":3,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.7416573867739413}},"df":3},"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}},"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":3}}}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1,"_":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"_":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":6.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":6.0}},"df":2}}}}}}}}}}}}},"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":1.7320508075688772}},"df":1}},"o":{"docs":{},"df":0,"s":{"docs":{},"df":0,"y":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}}}}},"d":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":2},"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":6.082762530298219},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":7,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":2}}}},"s":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}},"u":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/about/":{"tf":1.0}},"df":1}}},"f":{"docs":{},"df":0,"f":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":3}}},"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979}},"df":3,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1}}}}}}}}},"g":{"docs":{"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.0}},"df":1,"e":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.0}},"df":1}},"o":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}},"i":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.0}},"df":1},"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2},"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.358898943540674},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":8.12403840463596},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.23606797749979}},"df":8,"d":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}}}}}}}},"i":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":3},"m":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178}},"df":2}}},"s":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903}},"df":1},"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.449489742783178}},"df":1,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"/":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1}}}}}}}}}}}},"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"w":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":2}}}},"—":{"docs":{},"df":0,"b":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}},"’":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":1}}}},"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.656854249492381},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":5.0990195135927845}},"df":4}}},"b":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1,"e":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}}},"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":1}}},"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4}},"p":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1,"i":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}},"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"y":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}},"t":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.123105625617661},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":5}}}},"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/docs/config-options/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.0}},"df":6}}},"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}}}}},"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}},"o":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.358898943540674}},"df":4},"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}}}}},"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979}},"df":3}}}}},"d":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":4.123105625617661},"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":6.928203230275509},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.830951894845301},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":6.6332495807108}},"df":9,"b":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/posts/post-1/":{"tf":2.23606797749979}},"df":1}}}}},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"_":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}},"f":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":3}}}},"g":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2,"e":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}}},"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2}}}},"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}}},"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3}}}},"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"g":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.47213595499958},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter3/4-comments/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":6}}}},"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.196152422706632},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.196152422706632},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4}}},"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.1622776601683795}},"df":5}},"h":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1}}}}}}},"i":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.872983346207417}},"df":3,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}},"t":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0}},"df":1}}},"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.0}},"df":2}}},"u":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":6.324555320336759},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":12.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":5.830951894845301}},"df":9,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":4}}}},"v":{"docs":{"http://127.0.0.1:1111/posts/post-2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":3,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.6457513110645907}},"df":2,"s":{"docs":{},"df":0,"(":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.8284271247461903}},"df":2}}}}}}}}}}}}}},"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2,"(":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"\"":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"_":{"docs":{},"df":0,"o":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772}},"df":1}}}}}}}}}}}}}}}}}}}},"`":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"`":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"_":{"docs":{},"df":0,"o":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}},"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2,"e":{"docs":{},"df":0,"=":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}},"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":1.0}},"df":1}}}}},"i":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/posts/post-2/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":8.18535277187245},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":8,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"—":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}},"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"l":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0}},"df":2,"!":{"docs":{},"df":0,"(":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}},"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772}},"df":1}}}}}}}},"`":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1}}}},"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":1}}}}}}}}}}}}}}}}},"q":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.6457513110645907}},"df":2,"u":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.291502622129181},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.0990195135927845},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":7}},"i":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1},"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4}}}}}},"r":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0}},"df":1,"a":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.449489742783178}},"df":1}},"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}}}}}},"g":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":2}}}}},"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}},"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.58257569495584},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":4.58257569495584},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter2/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.69041575982343},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.872983346207417}},"df":7,"(":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.8284271247461903}},"df":5,"\"":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{},"df":0,"n":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1}}}}}},"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772}},"df":1}}}},"_":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":5},"`":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{},"df":0,"n":{"docs":{},"df":0,"`":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":1}}}}}},"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":1}}}},"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}}}}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"f":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"(":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"t":{"docs":{},"df":0,"w":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}},"`":{"docs":{},"df":0,"t":{"docs":{},"df":0,"w":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}},"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2},"r":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":14.933184523068078},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":7.874007874011811},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":11.224972160321824},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":6.708203932499369},"http://127.0.0.1:1111/rust/chapter2/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":15.427248620541512},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":8.602325267042627}},"df":13,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4,";":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":4}}},"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"?":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"b":{"docs":{},"df":0,"o":{"docs":{},"df":0,"x":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"d":{"docs":{},"df":0,"y":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}},"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"d":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"b":{"docs":{},"df":0,"o":{"docs":{},"df":0,"x":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"d":{"docs":{},"df":0,"y":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}}},".":{"docs":{},"df":0,"k":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":2}}}}},"[":{"docs":{},"df":0,"e":{"docs":{},"df":0,"0":{"docs":{},"df":0,"0":{"docs":{},"df":0,"0":{"docs":{},"df":0,"4":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2},"5":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}},"4":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}},"7":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}},"1":{"docs":{},"df":0,"0":{"docs":{},"df":0,"6":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":4}},"3":{"docs":{},"df":0,"3":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}},"2":{"docs":{},"df":0,"7":{"docs":{},"df":0,"7":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.23606797749979}},"df":6}},"8":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1}}},"3":{"docs":{},"df":0,"0":{"docs":{},"df":0,"8":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":10}},"6":{"docs":{},"df":0,"9":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}},"7":{"docs":{},"df":0,"3":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}},"8":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":6},"4":{"docs":{"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":1.0}},"df":1}}},"4":{"docs":{},"df":0,"3":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2},"3":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4}},"9":{"docs":{},"df":0,"9":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4}}},"5":{"docs":{},"df":0,"0":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2},"7":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":4}},"1":{"docs":{},"df":0,"5":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}},"9":{"docs":{},"df":0,"6":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4},"7":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2},"9":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772}},"df":2}}},"6":{"docs":{},"df":0,"0":{"docs":{},"df":0,"3":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":2}},"1":{"docs":{},"df":0,"4":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}},"5":{"docs":{},"df":0,"8":{"docs":{"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.0}},"df":1}}},"7":{"docs":{},"df":0,"4":{"docs":{},"df":0,"6":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}},"9":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}},"k":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"t":{"docs":{},"df":0,"f":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2}}}}}}}}}}}}}}}}}},"s":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}},"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"ñ":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}},"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":3}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}},"s":{"docs":{},"df":0,"a":{"docs":{},"df":0,"y":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}},"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":2}}}}},"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0}},"df":2}}}}}},"i":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}},"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1,"c":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0},"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":3,".":{"docs":{},"df":0,"n":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"w":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1}}},"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}},"u":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1,"m":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1}},"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":3}}},"e":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.795831523312719},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.58257569495584},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":6.082762530298219}},"df":6,"t":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3}}},"r":{"docs":{},"df":0,"y":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3}},"t":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":4}},"w":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":3}}}}}}},"i":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}},"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"v":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}}}},"x":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":2,"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.242640687119285}},"df":3}}}},"m":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":3}},"p":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.23606797749979},"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":11.224972160321824},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":5.291502622129181},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":10.816653826391969},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":4.898979485566356},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":11.224972160321824},"http://127.0.0.1:1111/rust/to do/chapter5/2-an-example-program-using-structs/":{"tf":1.0}},"df":10,"e":{"docs":{},"df":0,".":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"g":{"docs":{},"df":0,"/":{"docs":{},"df":0,"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"j":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}},"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.23606797749979}},"df":2,"e":{"docs":{},"df":0,"(":{"docs":{},"df":0,"5":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"f":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"(":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}}},"`":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}},"’":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}}},"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1},"p":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178}},"df":4}}},"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2,"e":{"docs":{},"df":0,"(":{"docs":{},"df":0,"s":{"docs":{},"df":0,"p":{"docs":{},"df":0,"d":{"docs":{},"df":0,"x":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1}}}}}}}}}},"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2}},"u":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3},"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772}},"df":2}}}},"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":7.3484692283495345},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":5.196152422706632},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.0}},"df":5,"e":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"f":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}},"r":{"docs":{},"df":0,"c":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":2}}}}},"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":3}}}}},"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.123105625617661}},"df":4}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178}},"df":3,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}},"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3},"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":5}}},"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":6.4031242374328485},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter2/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.477225575051661},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.7416573867739413}},"df":10,"(":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"f":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":2.449489742783178}},"df":1}}}},"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}}},"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,".":{"docs":{},"df":0,"t":{"docs":{},"df":0,"x":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}}}}}},"s":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772}},"df":1}}}}}}},"`":{"docs":{},"df":0,"f":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1}}}},"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}},"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,".":{"docs":{},"df":0,"t":{"docs":{},"df":0,"x":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1}}}}},"s":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":1}}}}}}}},"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"o":{"docs":{},"df":0,"k":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"w":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"n":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":1,"i":{"docs":{},"df":0,"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}},"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.23606797749979}},"df":2}}}}}}}}}},"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/about/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":4,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":2}}},"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2}}}}}}},"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.58257569495584},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/4-comments/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.385164807134504},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":4.58257569495584}},"df":13}},"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":4,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}}}},"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":6,"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.0}},"df":4}}}}}},"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.47213595499958},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.1622776601683795}},"df":4}}},"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979}},"df":3}},"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.1622776601683795}},"df":3}},"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.358898943540674},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":6.48074069840786}},"df":2,"\"":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"g":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}},"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.3166247903554}},"df":1}}}}}}}},"b":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"w":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979}},"df":1}}}}},"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}},"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"f":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}},"e":{"docs":{},"df":0,"q":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}},"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1}}}}},"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"f":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1}},"s":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1}}}},"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"q":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}},"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}},"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1}}}}},"s":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}},"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"u":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1}}}}}}},"(":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}},")":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}}}}}},",":{"docs":{},"df":0,")":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}}},".":{"docs":{},"df":0,".":{"docs":{},"df":0,".":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1,"\"":{"docs":{},"df":0,"(":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}}}}}}}},"=":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1,"\"":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}}}}}},"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1,"\"":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}}}}}},"0":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2},"1":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2},"i":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"b":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}}}}}},";":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}},"?":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}},"[":{"docs":{},"df":0,".":{"docs":{},"df":0,".":{"docs":{},"df":0,"b":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}},"a":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2,".":{"docs":{},"df":0,".":{"docs":{},"df":0,"b":{"docs":{},"df":0,"]":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1}}}}}}}}},"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"]":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}}}}}}}}},"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":8.94427190999916},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":7.874007874011811}},"df":7,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"’":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}}},"x":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}},"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0},"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/posts/post-1/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":6},"s":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":6},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}},"r":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0},"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.898979485566356},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.605551275463989}},"df":7}},"x":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}},"r":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/docs/config-options/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.0}},"df":5,".":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"y":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.4142135623730951}},"df":1}}}}},"u":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.4142135623730951}},"df":1}}}}}},"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.4142135623730951}},"df":1}}},"f":{"docs":{},"df":0,"a":{"docs":{},"df":0,"v":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.4142135623730951}},"df":1}}}}}}},"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{},"df":0,"b":{"docs":{},"df":0,"o":{"docs":{},"df":0,"x":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.4142135623730951}},"df":1}}}}}},"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.4142135623730951}},"df":1}}}}},"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.0}},"df":2}},"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}},"e":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979}},"df":2}}}}}},"f":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.5677643628300215},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":5.5677643628300215},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":7,"(":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}},"0":{"docs":{},"df":0,"2":{"docs":{},"df":0,"5":{"docs":{},"df":0,"3":{"docs":{},"df":0,"1":{"docs":{},"df":0,"5":{"docs":{},"df":0,"9":{"docs":{},"df":0,"1":{"docs":{},"df":0,"9":{"docs":{},"df":0,"7":{"docs":{},"df":0,"f":{"docs":{},"df":0,"7":{"docs":{},"df":0,"8":{"docs":{},"df":0,"4":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}},"3":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":5}},"6":{"docs":{},"df":0,"4":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":7}},"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":2,"b":{"docs":{},"df":0,"o":{"docs":{},"df":0,"o":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0}},"df":1}}}}},"i":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.449489742783178}},"df":1}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903}},"df":2,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}}}},"i":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":12.529964086141668},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":9.899494936611665},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.291502622129181},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":7,"u":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.830951894845301},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":4.69041575982343},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":5}}},"r":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}}}},"l":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":2,"b":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}},"i":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}},"s":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.4641016151377544}},"df":9}},"m":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2,"a":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":3}}}}},"o":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":2}}},"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":1}}},"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.0}},"df":3,"m":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1},"s":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}},"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}},"s":{"docs":{},"df":0,"h":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3}}}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":4,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":3},"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}},"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"h":{"docs":{},"df":0,"p":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}}}}},"u":{"docs":{},"df":0,"c":{"docs":{},"df":0,"i":{"docs":{},"df":0,"b":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.0}},"df":1}}}},"l":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}},"v":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":2.0}},"df":1,".":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}},"_":{"docs":{},"df":0,"1":{"docs":{},"df":0,"6":{"docs":{},"df":0,"x":{"docs":{},"df":0,"1":{"docs":{},"df":0,"6":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0}},"df":1}}}}},"3":{"docs":{},"df":0,"2":{"docs":{},"df":0,"x":{"docs":{},"df":0,"3":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0}},"df":1}}}}}}}}}},"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1,"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":4,"e":{"docs":{},"df":0,"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}}}},"y":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}},"c":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2,"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}}}},"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.830951894845301},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":6.928203230275509},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.291502622129181}},"df":6,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}}}}}}}}}}},"b":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1,"r":{"docs":{},"df":0,"u":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1}}}}}},"e":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1,"b":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}},"l":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter3/4-comments/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":5},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}},"r":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1}}}}}},"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/":{"tf":2.0}},"df":1}}},"t":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0}},"df":2}}},"w":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.1622776601683795}},"df":3,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":3}}}},"f":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}},"i":{"docs":{},"df":0,"d":{"docs":{},"df":0,"d":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}},"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.795831523312719},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":7.615773105863909},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":9.433981132056603}},"df":5,"_":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2}}},"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":2}}}}},"’":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3}}}},"f":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3}}},"g":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}},"u":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.795831523312719},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.0}},"df":3}}},"l":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.449489742783178},"http://127.0.0.1:1111/docs/config-options/":{"tf":2.449489742783178},"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":12.041594578792296},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.58257569495584},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":10.723805294763608},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.7416573867739413}},"df":10,":":{"docs":{},"df":0,"/":{"docs":{},"df":0,"/":{"docs":{},"df":0,"/":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"j":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"s":{"docs":{},"df":0,"/":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.605551275463989}},"df":2,"/":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0}},"df":2,"_":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2}}}}}}}}}},"b":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":2.449489742783178}},"df":1}}}}}},"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"1":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.449489742783178}},"df":2}}}}}}}},"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2}}}}},"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2}}}}},"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.23606797749979}},"df":2}}},"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}},"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2}}}},"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}}},"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}}}}},"f":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":2.449489742783178}},"df":3}}}}},"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}},"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"_":{"docs":{},"df":0,"g":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter2/":{"tf":3.0}},"df":3,"e":{"docs":{},"df":0,"/":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"/":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"/":{"docs":{},"df":0,"g":{"docs":{},"df":0,"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"_":{"docs":{},"df":0,"g":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.1622776601683795}},"df":2,"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"g":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":1.7320508075688772}},"df":1}}}}}}}}}}},"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}},"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}},"o":{"docs":{},"df":0,"o":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.7320508075688772}},"df":1}}}},"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":4.0}},"df":2}}}}}}},"y":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}},"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"_":{"docs":{},"df":0,"t":{"docs":{},"df":0,"y":{"docs":{},"df":0,"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"_":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1}}}}}}}}}}}}},"o":{"docs":{},"df":0,"w":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{},"df":0,"i":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.449489742783178}},"df":2}}}}}}}}},"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2},"t":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.23606797749979}},"df":2}}}}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":4}}}}}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2}}}}}}},"s":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}},"i":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}},"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}},"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"u":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}},"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.23606797749979}},"df":2}}}}},"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"a":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}},"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":2.0}},"df":1}}}}}}}}}}}}}}}},":":{"docs":{},"df":0,"c":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"(":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,".":{"docs":{},"df":0,"t":{"docs":{},"df":0,"x":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1,"\"":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"w":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{},"df":0,"_":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"_":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"(":{"docs":{},"df":0,"|":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"`":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,".":{"docs":{},"df":0,"t":{"docs":{},"df":0,"x":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1,"`":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"w":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{},"df":0,"_":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"_":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"(":{"docs":{},"df":0,"|":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"o":{"docs":{},"df":0,"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.47213595499958},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":4.242640687119285}},"df":2,"(":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,".":{"docs":{},"df":0,"t":{"docs":{},"df":0,"x":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.1622776601683795}},"df":1,"\"":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"w":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1,"_":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"_":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"(":{"docs":{},"df":0,"|":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}},"?":{"docs":{},"df":0,".":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"_":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"_":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"m":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"`":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,".":{"docs":{},"df":0,"t":{"docs":{},"df":0,"x":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.0}},"df":1,"`":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"w":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1,"_":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"_":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"(":{"docs":{},"df":0,"|":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}},"?":{"docs":{},"df":0,".":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"_":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"_":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"m":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,".":{"docs":{},"df":0,"t":{"docs":{},"df":0,"x":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}},"_":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.830951894845301},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":5.830951894845301}},"df":2}}}}},"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":11.445523142259598},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":9.16515138991168},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":9.848857801796104}},"df":5,"e":{"docs":{},"df":0,".":{"docs":{},"df":0,"t":{"docs":{},"df":0,"x":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}},"s":{"docs":{},"df":0,".":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"/":{"docs":{},"df":0,"t":{"docs":{},"df":0,"d":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}}}}}},"y":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907}},"df":2,"’":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}}}},"—":{"docs":{},"df":0,"w":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}},"’":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3}},"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.0}},"df":3},"m":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}},"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":8.12403840463596},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":7.416198487095663}},"df":2,"(":{"docs":{},"df":0,"|":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}},"s":{"docs":{},"df":0,"_":{"docs":{},"df":0,"b":{"docs":{},"df":0,"y":{"docs":{},"df":0,"_":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}},"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907}},"df":3}},"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":6.082762530298219},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4},"e":{"docs":{"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":4},"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":11.40175425099138},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":10.488088481701515},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.795831523312719},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter2/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.8284271247461903}},"df":11}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"f":{"docs":{},"df":0,"o":{"docs":{},"df":0,"x":{"docs":{"http://127.0.0.1:1111/rust/":{"tf":1.0}},"df":1,"/":{"docs":{},"df":0,"9":{"docs":{},"df":0,"9":{"docs":{},"df":0,".":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}},"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":7.874007874011811},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":8.18535277187245},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":10.723805294763608},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.4641016151377544}},"df":8,"_":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}}}},"w":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.605551275463989}},"df":2,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"'":{"docs":{},"df":0,"a":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"(":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2}}}}}}}}}}},"(":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.6457513110645907}},"df":2,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2,"m":{"docs":{},"df":0,"y":{"docs":{},"df":0,"_":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"[":{"docs":{},"df":0,"0":{"docs":{},"df":0,".":{"docs":{},"df":0,".":{"docs":{},"df":0,"6":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}},"_":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"[":{"docs":{},"df":0,"0":{"docs":{},"df":0,".":{"docs":{},"df":0,".":{"docs":{},"df":0,"6":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}}}},"m":{"docs":{},"df":0,"y":{"docs":{},"df":0,"_":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"_":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979}},"df":2},"v":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":5,"_":{"docs":{},"df":0,"h":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1}}}}}}}},"x":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.358898943540674},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.477225575051661},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.58257569495584}},"df":4,"_":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"_":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2}}}}}}}}}}}}}}}},"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3},"s":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.7320508075688772}},"df":1}},"v":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}},"w":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2}},"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"i":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979}},"df":3}}}}},"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.4641016151377544}},"df":2},"o":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":4,"(":{"docs":{},"df":0,"f":{"docs":{},"df":0,"6":{"docs":{},"df":0,"4":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}},"w":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":5,"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.7320508075688772}},"df":1}}}}}}},"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{},"df":0,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"m":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}}}},"y":{"docs":{},"df":0,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.23606797749979}},"df":2}}}}}}}}}}}},"m":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0}},"df":2,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}},":":{"docs":{},"df":0,":":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"g":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}},"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"y":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0}},"df":2}}}}}}},"f":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4}}}}}}}}}},"n":{"docs":{"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":12.767145334803704},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":12.767145334803704},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":12.609520212918492},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":12.609520212918492},"http://127.0.0.1:1111/rust/chapter2/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":4.242640687119285},"http://127.0.0.1:1111/rust/chapter3/4-comments/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":14.2828568570857},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":14.2828568570857}},"df":15,"(":{"docs":{},"df":0,"i":{"docs":{},"df":0,"3":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.6457513110645907}},"df":2}}}},"m":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":4}}},"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":4.0}},"df":4}}},"특":{"docs":{},"df":0,"성":{"docs":{},"df":0,"]":{"docs":{},"df":0,"(":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{},"df":0,"t":{"docs":{},"df":0,"p":{"docs":{},"df":0,"s":{"docs":{},"df":0,":":{"docs":{},"df":0,"/":{"docs":{},"df":0,"/":{"docs":{},"df":0,"d":{"docs":{},"df":0,"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,".":{"docs":{},"df":0,"r":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}},"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":3,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772}},"df":1}}},"g":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1},"l":{"docs":{},"df":0,"d":{"docs":{},"df":0,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0}},"df":1}}},"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}},"k":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1},"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.0},"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":6.48074069840786},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":6.928203230275509},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":7.211102550927978},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":7}}}},"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}},"o":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0}},"df":3,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"'":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"(":{"docs":{},"df":0,"x":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}}}},"(":{"docs":{},"df":0,"3":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2},"_":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2},"x":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}},"_":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}},"b":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4}}},"t":{"docs":{},"df":0,"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":4.358898943540674}},"df":1,"e":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1},"[":{"docs":{},"df":0,"^":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}}}},"r":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,".":{"docs":{},"df":0,".":{"docs":{},"df":0,".":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}},".":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"/":{"docs":{},"df":0,"p":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}},"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":3},"e":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1}}},"v":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0}},"df":2}},"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":2}},"o":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}}}}}},"k":{"docs":{},"df":0,"/":{"docs":{},"df":0,"j":{"docs":{},"df":0,"o":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}},"m":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903}},"df":4,"a":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772}},"df":1},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.358898943540674},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.58257569495584},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.449489742783178}},"df":6,"!":{"docs":{},"df":0,"(":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"(":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}},"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}},"{":{"docs":{},"df":0,"s":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1},"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"_":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"}":{"docs":{},"df":0,"\\":{"docs":{},"df":0,"r":{"docs":{},"df":0,"\\":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1}}}}}}}}}}}}}}}}}}}}}},"`":{"docs":{},"df":0,"(":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}},"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1}}}}},"{":{"docs":{},"df":0,"s":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1},"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"_":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"}":{"docs":{},"df":0,"\\":{"docs":{},"df":0,"r":{"docs":{},"df":0,"\\":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":1}}}}}}}}}}}}}}}}}}}}}}}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}},"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}},"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0}},"df":1}}}},"t":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2},"i":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1},"u":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":2}}},"w":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":3}}}}},"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.795831523312719},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":4.358898943540674},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":11,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":4,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"’":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}}}}},"r":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":6,"t":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3}}}}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1,"w":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":3}}}}}},"n":{"docs":{},"df":0,"ç":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}},"e":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.0}},"df":3,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2,"o":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}},"q":{"docs":{},"df":0,"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2}}}}}},"i":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":1,"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}}}},"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.449489742783178}},"df":1}}}}}}},"o":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.449489742783178}},"df":2},"m":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}}}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"f":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}}}}},"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":5,"_":{"docs":{},"df":0,"o":{"docs":{},"df":0,"f":{"docs":{},"df":0,"_":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.916079783099616},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":5.916079783099616}},"df":2,"e":{"docs":{},"df":0,"/":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"/":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"d":{"docs":{},"df":0,"_":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"_":{"docs":{},"df":0,"w":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}}}}}}}}}}}}}}}},":":{"docs":{},"df":0,":":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"d":{"docs":{},"df":0,"_":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"_":{"docs":{},"df":0,"w":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.23606797749979}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"w":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}},"u":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}}}},"s":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772}},"df":2,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"_":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"_":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":4,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"(":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"4":{"docs":{},"df":0,"0":{"docs":{},"df":0,"4":{"docs":{},"df":0,".":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{},"df":0,"m":{"docs":{},"df":0,"l":{"docs":{},"df":0,"\"":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"w":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}},"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,".":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{},"df":0,"m":{"docs":{},"df":0,"l":{"docs":{},"df":0,"\"":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"w":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1}}}}}}}}}}}}},"t":{"docs":{},"df":0,"x":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}}}}}}},"`":{"docs":{},"df":0,"4":{"docs":{},"df":0,"0":{"docs":{},"df":0,"4":{"docs":{},"df":0,".":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{},"df":0,"m":{"docs":{},"df":0,"l":{"docs":{},"df":0,"`":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"w":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}},"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,".":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{},"df":0,"m":{"docs":{},"df":0,"l":{"docs":{},"df":0,"`":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"w":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":1}}}}}}}}}}}}},"t":{"docs":{},"df":0,"x":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}}},"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"f":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,".":{"docs":{},"df":0,"f":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"_":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.23606797749979}},"df":2}}}}}}}}}}}}}}}},"f":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"_":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}},"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"w":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"f":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":2}}},"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979}},"df":3,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}},"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":3}}},"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":19.519221295943137},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":16.911534525287763},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":20.71231517720798},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":4.0}},"df":11,"\"":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2},"'":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2},"1":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2},"2":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2},"`":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2},"’":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903}},"df":3}}}}}},"d":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}}}}}}},"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772}},"df":2}}}},"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":5,"m":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}}}}},"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1}}}},"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903}},"df":5}}}},"{":{"docs":{},"df":0,"3":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}},"g":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.23606797749979}},"df":5,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":4}},"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}},"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0}},"df":1,"a":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.7320508075688772}},"df":2,".":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0}},"df":1}}}}}}}}},"m":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":6}},"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.449489742783178}},"df":1}}},"r":{"docs":{},"df":0,"b":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":1}}},"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.23606797749979}},"df":2,".":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}},"t":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1},"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2}}}},"v":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}},"c":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":1.0}},"df":2}},"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{},"df":0,"o":{"docs":{},"df":0,"/":{"docs":{},"df":0,"2":{"docs":{},"df":0,"0":{"docs":{},"df":0,"1":{"docs":{},"df":0,"0":{"docs":{},"df":0,"0":{"docs":{},"df":0,"1":{"docs":{},"df":0,"0":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}},"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2,".":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}},"_":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.7320508075688772}},"df":3}}}}},"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0},"http://127.0.0.1:1111/posts/post-2/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":6.164414002968976},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":7.745966692414834},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":12.36931687685298},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":13,"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"(":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}},"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.0}},"df":1}}}}}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter1/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.291502622129181}},"df":5,"_":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"f":{"docs":{},"df":0,"o":{"docs":{},"df":0,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0}},"df":1}}}}}}}}}}}}}},"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"(":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"=":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"_":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,".":{"docs":{},"df":0,"m":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/posts/post-1/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}},"u":{"docs":{},"df":0,"r":{"docs":{},"df":0,"l":{"docs":{},"df":0,"(":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"=":{"docs":{},"df":0,"'":{"docs":{},"df":0,"b":{"docs":{},"df":0,"o":{"docs":{},"df":0,"o":{"docs":{},"df":0,"k":{"docs":{},"df":0,".":{"docs":{},"df":0,"c":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/posts/post-1/":{"tf":1.4142135623730951}},"df":1}}}}}}}},"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"e":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/posts/post-1/":{"tf":1.0}},"df":1}}}},"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"w":{"docs":{},"df":0,"s":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,".":{"docs":{},"df":0,"c":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/posts/post-1/":{"tf":1.7320508075688772}},"df":1}}}}}}}}}}}}}}}}}}}}}}}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.7320508075688772}},"df":1}}}}}},"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2}}}}},"f":{"docs":{},"df":0,"m":{"docs":{},"df":0,"]":{"docs":{},"df":0,"^":{"docs":{},"df":0,"(":{"docs":{},"df":0,"g":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"u":{"docs":{},"df":0,"b":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}}}}}},"h":{"docs":{"http://127.0.0.1:1111/posts/post-2/":{"tf":1.0}},"df":1,"x":{"docs":{},"df":0,"r":{"docs":{},"df":0,"3":{"docs":{},"df":0,"o":{"docs":{},"df":0,"6":{"docs":{},"df":0,"y":{"docs":{},"df":0,"z":{"docs":{},"df":0,"1":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}}}}}}}}},"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":3.0}},"df":1,"h":{"docs":{},"df":0,"u":{"docs":{},"df":0,"b":{"docs":{"http://127.0.0.1:1111/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0},"http://127.0.0.1:1111/posts/post-2/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":6,"_":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"k":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/posts/post-2/":{"tf":1.4142135623730951}},"df":1}}}}}}}}},"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":1.7320508075688772}},"df":1}}}}},"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"b":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0}},"df":1}}}},"v":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.744562646538029},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.291502622129181},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.656854249492381}},"df":4,"a":{"docs":{},"df":0,"w":{"docs":{},"df":0,"a":{"docs":{},"df":0,"y":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0}},"df":2,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}},"1":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2},"2":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}}},"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.872983346207417}},"df":4},"s":{"docs":{},"df":0,"_":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{},"df":0,"i":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":2}}}}}}}}}}}}}},"l":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0}},"df":1,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}},"o":{"docs":{},"df":0,"b":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.449489742783178}},"df":4,"a":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178}},"df":2}}},"s":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}},"o":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.47213595499958},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter3/4-comments/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.291502622129181}},"df":8,"a":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3}},"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.0990195135927845},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.656854249492381},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.1622776601683795}},"df":6},"l":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}},"n":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178}},"df":2}},"o":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903}},"df":4,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}},"g":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":2.0},"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.0}},"df":2,"e":{"docs":{},"df":0,"_":{"docs":{},"df":0,"s":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0}},"df":1}}}}}}}}}}}},"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}}}},"t":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}}}},"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}}}}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772}},"df":1,"f":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0}},"df":1}}}}}}},"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1}}},"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}},"p":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":2,"e":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979}},"df":1}}}},"s":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}},"v":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1}}}}},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":5,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":5,"_":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"_":{"docs":{},"df":0,"1":{"docs":{},"df":0,"0":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}}},"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}},"e":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772}},"df":5},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"(":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1}}}}}},"`":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":1}}}}}},"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}},"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"_":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}}}},"f":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.0}},"df":2,"e":{"docs":{},"df":0,"_":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.8284271247461903}},"df":2}}}}}}}}}}}}}}}}},"p":{"docs":{"http://127.0.0.1:1111/rust/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.6457513110645907}},"df":3}},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}},"t":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}},"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.123105625617661}},"df":3}},"w":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":1}}}}}},"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.0},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.449489742783178},"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0},"http://127.0.0.1:1111/posts/post-1/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/posts/post-2/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":10.44030650891055},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":10.908712114635714},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":13.416407864998739},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":13.601470508735444},"http://127.0.0.1:1111/rust/chapter2/":{"tf":4.795831523312719},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":13.892443989449804},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":13.892443989449804}},"df":18,";":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}},"f":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}},"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}},"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772}},"df":5,";":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}},"=":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}},"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}}},"b":{"docs":{},"df":0,"o":{"docs":{},"df":0,"b":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}},"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1}}}},"j":{"docs":{},"df":0,"o":{"docs":{},"df":0,"h":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.449489742783178}},"df":1}}}}}}}},"=":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}},"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1}}}}},"b":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1},"c":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1},"d":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.0}},"df":1},"f":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1}},"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}},"u":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.47213595499958},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903}},"df":3}}}},"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.196152422706632}},"df":2}}},"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":5.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter2/":{"tf":9.433981132056603},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":6.164414002968976},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.605551275463989}},"df":8,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"(":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"f":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0}},"df":1}}}}}}}}}}}}}},".":{"docs":{},"df":0,"c":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"_":{"docs":{},"df":0,"n":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{},"df":0,"b":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":3}}}}}}}}}}}}}}}}}}}},"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{},"df":0,"(":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":5,"e":{"docs":{},"df":0,"(":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"(":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.4142135623730951}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"1":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1},":":{"docs":{},"df":0,":":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"w":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":3,"(":{"docs":{},"df":0,"2":{"docs":{},"df":0,"0":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}},"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"g":{"docs":{},"df":0,"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"g":{"docs":{},"df":0,"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"g":{"docs":{},"df":0,"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"w":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"_":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0}},"df":1}}}},"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"g":{"docs":{},"df":0,"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"w":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"i":{"docs":{},"df":0,"3":{"docs":{},"df":0,"2":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"g":{"docs":{},"df":0,"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"w":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"!":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"g":{"docs":{},"df":0,"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"g":{"docs":{},"df":0,"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"w":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"g":{"docs":{},"df":0,"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"w":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"w":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"_":{"docs":{},"df":0,"g":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter2/":{"tf":4.242640687119285}},"df":3,"e":{"docs":{},"df":0,"@":{"docs":{},"df":0,"1":{"docs":{},"df":0,".":{"docs":{},"df":0,"0":{"docs":{},"df":0,".":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}}}}}},"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}},"i":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}},"e":{"docs":{},"df":0,"b":{"docs":{},"df":0,"o":{"docs":{},"df":0,"o":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/about/":{"tf":1.0}},"df":1}}}},"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":2}}}}}}},"z":{"docs":{},"df":0,"i":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}},"h":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":6,"1":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1},"2":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1},"3":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1},"4":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1},"5":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1},"6":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1},"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772}},"df":1},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":2},"v":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1}},"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":4,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2},"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":9.1104335791443},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":5.0990195135927845},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.0990195135927845},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":8.888194417315589},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.8284271247461903}},"df":8,"e":{"docs":{},"df":0,".":{"docs":{},"df":0,"j":{"docs":{},"df":0,"o":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2,"(":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"w":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.8284271247461903}},"df":2}}}}}}}}}}}}}},"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.449489742783178}},"df":2,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"(":{"docs":{},"df":0,"m":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.6457513110645907}},"df":2}}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.23606797749979}},"df":2}}}}}}}}}}}}}}}}}},"b":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.7320508075688772}},"df":1}}},"s":{"docs":{},"df":0,".":{"docs":{},"df":0,"p":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{},"df":0,"(":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2}}}}}}}}}}}}}}},"g":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":2}},"p":{"docs":{},"df":0,"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.898979485566356},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.358898943540674},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.196152422706632},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":4}},"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}},"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1,"d":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":3,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903}},"df":2}}},"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":2}},"w":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":2}}}},"m":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2},"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}}}},"s":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":7.3484692283495345}},"df":5,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":1}},"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.449489742783178}},"df":2,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"i":{"docs":{},"df":0,"3":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}},"k":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":4}}}}},":":{"docs":{},"df":0,":":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"w":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.8284271247461903}},"df":2}}}}}}}}},"k":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}},"n":{"docs":{},"df":0,"’":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":3}}}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":1},"v":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.0990195135927845}},"df":3,"n":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}},"’":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.0}},"df":3}}}},"o":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}},"y":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772}},"df":4,".":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"(":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"e":{"docs":{},"df":0,"d":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}}}}}}}}}}}}}},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":4,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.0},"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":5,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0}},"df":1}}}}}}}},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"/":{"docs":{},"df":0,"h":{"docs":{},"df":0,"1":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}},"2":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}},"3":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}},"4":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}},"5":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}},"6":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}}}}}}}},"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2}}}},"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}}}}}}},"p":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.898979485566356},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":6.082762530298219}},"df":4},"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1},"t":{"docs":{},"df":0,"_":{"docs":{},"df":0,"e":{"docs":{},"df":0,"y":{"docs":{},"df":0,"e":{"docs":{},"df":0,"d":{"docs":{},"df":0,"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1}}}}}}}}}}},"v":{"docs":{},"df":0,"i":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}},"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}},"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.69041575982343},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":4.47213595499958},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":6.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":4.69041575982343}},"df":4,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}}}}},"l":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":3},"l":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.477225575051661},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":5.477225575051661},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/4-comments/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.291502622129181},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":5.196152422706632}},"df":14,"(":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"r":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}},"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"(":{"docs":{},"df":0,"*":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}},"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}},"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}},"r":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1}}}}},".":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{},"df":0,"m":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.4641016151377544}},"df":2}}}},"t":{"docs":{},"df":0,"x":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2}}}},":":{"docs":{},"df":0,":":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}}}},"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"g":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":4.242640687119285}},"df":1,".":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":1.0}},"df":1}}}}}}},"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.47213595499958},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":4.47213595499958}},"df":2,"/":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"_":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"_":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}},":":{"docs":{},"df":0,":":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}}}},"_":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.123105625617661},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":4.123105625617661}},"df":2,"i":{"docs":{},"df":0,"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"(":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"p":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}},"/":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"g":{"docs":{},"df":0,"o":{"docs":{},"df":0,".":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}},"s":{"docs":{},"df":0,"r":{"docs":{},"df":0,"c":{"docs":{},"df":0,"/":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"b":{"docs":{},"df":0,".":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}},":":{"docs":{},"df":0,":":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}}},"w":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"l":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":3,".":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":1.0}},"df":1}}}}}}}},"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.3166247903554}},"df":2}}}}},"w":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"l":{"docs":{},"df":0,"d":{"docs":{},"df":0,".":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":1.0}},"df":1}}}}}}}}},"p":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":6.708203932499369},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":4.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.898979485566356},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.916079783099616},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":4.123105625617661}},"df":12,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}}}},"n":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1},"d":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1}}}}}}},"r":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.0},"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":7.211102550927978},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":7.14142842854285},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/4-comments/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":9.695359714832659},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":6.0}},"df":10,"\"":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1},"'":{"docs":{"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.4142135623730951}},"df":1},"’":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.358898943540674}},"df":3}},"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}}}},"x":{"docs":{},"df":0,"0":{"docs":{},"df":0,"x":{"docs":{},"df":0,"f":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1}}}}}},"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"r":{"docs":{},"df":0,"b":{"docs":{},"df":0,"g":{"docs":{},"df":0,"z":{"docs":{},"df":0,"c":{"docs":{},"df":0,"g":{"docs":{},"df":0,"w":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}}}}}}}}},"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":6.324555320336759},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":6.324555320336759}},"df":2,"d":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}},"e":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":2}},"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2}}}}}}},"g":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3}},"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}},"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":1}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":2,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}},"o":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.7320508075688772}},"df":1,"a":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}},"c":{"docs":{},"df":0,"k":{"docs":{},"df":0,"e":{"docs":{},"df":0,"y":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}}}},"l":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2},"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":6.164414002968976},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.830951894845301},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":7.211102550927978},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":4},"e":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":1},"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}},"m":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.23606797749979}},"df":5,"/":{"docs":{},"df":0,".":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"g":{"docs":{},"df":0,"o":{"docs":{},"df":0,"/":{"docs":{},"df":0,"b":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}},"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}},"o":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}},"o":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1},"k":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"y":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}},"p":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2,"f":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter3/4-comments/":{"tf":1.0}},"df":1}}}}},"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}}}}},"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"z":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0}},"df":2}}}}},"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}},"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"_":{"docs":{},"df":0,"e":{"docs":{},"df":0,"b":{"docs":{},"df":0,"o":{"docs":{},"df":0,"o":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}},"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":7.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":6.324555320336759}},"df":5,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,".":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2}},":":{"docs":{},"df":0,":":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"d":{"docs":{},"df":0,"_":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"_":{"docs":{},"df":0,"w":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.6457513110645907}},"df":2}}}}}}}}}}}}}}}}}}}}}},"u":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2},"s":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}},"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1}}},"w":{"docs":{},"df":0,"\"":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1},"`":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/posts/post-1/":{"tf":2.6457513110645907}},"df":1,"=":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{},"df":0,"t":{"docs":{},"df":0,"p":{"docs":{},"df":0,"s":{"docs":{},"df":0,":":{"docs":{},"df":0,"/":{"docs":{},"df":0,"/":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,".":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"/":{"docs":{},"df":0,"a":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}},"h":{"docs":{},"df":0,"t":{"docs":{},"df":0,"t":{"docs":{},"df":0,"p":{"docs":{},"df":0,"s":{"docs":{},"df":0,":":{"docs":{},"df":0,"/":{"docs":{},"df":0,"/":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,".":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"/":{"docs":{},"df":0,"a":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"g":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"u":{"docs":{},"df":0,"b":{"docs":{},"df":0,".":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"/":{"docs":{},"df":0,"u":{"docs":{},"df":0,"p":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}},"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,":":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"@":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"v":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,".":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"@":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"v":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,".":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"/":{"docs":{},"df":0,"a":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"s":{"docs":{},"df":0,"v":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2,"(":{"docs":{},"df":0,"i":{"docs":{},"df":0,"3":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}},"t":{"docs":{},"df":0,"m":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/":{"tf":1.0},"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":4.58257569495584},"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.242640687119285},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":4.242640687119285}},"df":7,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}},"5":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}},"t":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.898979485566356},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":4.898979485566356},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":5,"/":{"docs":{},"df":0,"1":{"docs":{},"df":0,".":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.358898943540674},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":4.358898943540674}},"df":2,"\\":{"docs":{},"df":0,"r":{"docs":{},"df":0,"\\":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}},":":{"docs":{},"df":0,"/":{"docs":{},"df":0,"/":{"docs":{},"df":0,"1":{"docs":{},"df":0,"2":{"docs":{},"df":0,"7":{"docs":{},"df":0,".":{"docs":{},"df":0,"0":{"docs":{},"df":0,".":{"docs":{},"df":0,"0":{"docs":{},"df":0,".":{"docs":{},"df":0,"1":{"docs":{},"df":0,":":{"docs":{},"df":0,"7":{"docs":{},"df":0,"8":{"docs":{},"df":0,"7":{"docs":{},"df":0,"8":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2,"/":{"docs":{},"df":0,"s":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"e":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}},"_":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"q":{"docs":{},"df":0,"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.449489742783178}},"df":2}}}}}}}},"s":{"docs":{},"df":0,":":{"docs":{},"df":0,"/":{"docs":{},"df":0,"/":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,".":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}}}}}},"c":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,".":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2,"/":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}},"d":{"docs":{},"df":0,"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,".":{"docs":{},"df":0,"r":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.449489742783178}},"df":7}}}}},"s":{"docs":{},"df":0,".":{"docs":{},"df":0,"r":{"docs":{},"df":0,"s":{"docs":{},"df":0,"/":{"docs":{},"df":0,"q":{"docs":{},"df":0,"u":{"docs":{},"df":0,"o":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}},"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,".":{"docs":{},"df":0,"w":{"docs":{},"df":0,"i":{"docs":{},"df":0,"k":{"docs":{},"df":0,"i":{"docs":{},"df":0,"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"a":{"docs":{},"df":0,".":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"g":{"docs":{},"df":0,"/":{"docs":{},"df":0,"w":{"docs":{},"df":0,"i":{"docs":{},"df":0,"k":{"docs":{},"df":0,"i":{"docs":{},"df":0,"/":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"p":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,".":{"docs":{},"df":0,"g":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"u":{"docs":{},"df":0,"b":{"docs":{},"df":0,".":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"/":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"/":{"docs":{},"df":0,"d":{"docs":{},"df":0,"o":{"docs":{},"df":0,"j":{"docs":{},"df":0,"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,".":{"docs":{},"df":0,"j":{"docs":{},"df":0,"p":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"r":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}},"s":{"docs":{},"df":0,"h":{"docs":{},"df":0,".":{"docs":{},"df":0,"r":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"p":{"docs":{},"df":0,".":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":1.0}},"df":1}}}}}}}}}}},"w":{"docs":{},"df":0,"w":{"docs":{},"df":0,"w":{"docs":{},"df":0,".":{"docs":{},"df":0,"r":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}},"u":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2},"g":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2},"o":{"docs":{"http://127.0.0.1:1111/":{"tf":1.0}},"df":1}},"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":3,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"f":{"docs":{},"df":0,"l":{"docs":{},"df":0,"y":{"docs":{},"df":0,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}},"b":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}},"y":{"docs":{},"df":0,"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"p":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}},"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}},"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}},"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}}}}}}},"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772}},"df":1}}}}}}}},"i":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0}},"df":1}},"'":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1}},".":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"_":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"(":{"docs":{},"df":0,")":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}},"/":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.4142135623730951}},"df":5}},"1":{"docs":{},"df":0,"2":{"docs":{},"df":0,"8":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}},"6":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}},"3":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":7.416198487095663},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":7.416198487095663},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":8.831760866327848},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":8.831760866327848},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":7.874007874011811},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":7.280109889280518}},"df":10,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}},"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}},"f":{"docs":{},"df":0,"6":{"docs":{},"df":0,"4":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}},"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}},"6":{"docs":{},"df":0,"4":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0}},"df":3}},"8":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.8284271247461903}},"df":5},"`":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0}},"df":1}},"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.7320508075688772}},"df":1}}}}},"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1,".":{"docs":{},"df":0,"p":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0}},"df":1}}}},"s":{"docs":{},"df":0,"/":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0}},"df":1}}}},"f":{"docs":{},"df":0,"a":{"docs":{},"df":0,"v":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.4142135623730951}},"df":1}}}}}}},"s":{"docs":{},"df":0,"a":{"docs":{},"df":0,"f":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0}},"df":1}}}}},"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,".":{"docs":{},"df":0,"w":{"docs":{},"df":0,"e":{"docs":{},"df":0,"b":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"i":{"docs":{},"df":0,"f":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}},"d":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":7.681145747868608},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":7.681145747868608}},"df":5,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,".":{"docs":{},"df":0,".":{"docs":{},"df":0,".":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1}}}}}}}}}},"=":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.7320508075688772}},"df":1}}}}}},"1":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}},"_":{"docs":{},"df":0,"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0}},"df":2}}}}},"e":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":3,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3}},"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.4641016151377544}},"df":3,"!":{"docs":{},"df":0,"[":{"docs":{},"df":0,".":{"docs":{},"df":0,".":{"docs":{},"df":0,".":{"docs":{},"df":0,"]":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1}}}}}}}}}}}},"\"":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}},"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}},"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}},"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,".":{"docs":{},"df":0,".":{"docs":{},"df":0,".":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}},":":{"docs":{},"df":0,":":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}},"k":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}}}}}},"i":{"docs":{},"df":0,"f":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.58257569495584},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903}},"df":5}}}}},"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}},"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":3,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907}},"df":2}}}}},"l":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1}},"e":{"docs":{},"df":0,"e":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1}}},"g":{"docs":{},"df":0,"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":8.602325267042627},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":7.745966692414834},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":6.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979}},"df":5,"e":{"docs":{},"df":0,"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.123105625617661},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":4.123105625617661}},"df":2,"e":{"docs":{},"df":0,"=":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}},"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178}},"df":3}}}}}},"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.7320508075688772}},"df":2,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979}},"df":3}}}},"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}},"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979}},"df":3}}},"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":7.14142842854285},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.656854249492381},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.0}},"df":6}}},"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":2}}},"l":{"docs":{"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":5.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":6.855654600401044},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":6.855654600401044},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":8.18535277187245},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":7.54983443527075}},"df":7,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}},"'":{"docs":{},"df":0,"a":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}}}}},".":{"docs":{},"df":0,".":{"docs":{},"df":0,".":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}},"`":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":6}}}},"x":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}},"_":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"_":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.23606797749979}},"df":2,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}},"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}},"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}},"t":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"t":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"t":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":11.916375287812984},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":15.264337522473747},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":12.767145334803704},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.4641016151377544}},"df":7,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":3}}}}}}},"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1,"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":2,"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":4}}}}}}},"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/posts/post-1/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.69041575982343},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":6,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"p":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":2,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"'":{"docs":{},"df":0,"a":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2}}}}}}}}},"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"p":{"docs":{},"df":0,"t":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"p":{"docs":{},"df":0,"t":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"p":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":3}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}},"s":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}},"o":{"docs":{},"df":0,"v":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.242640687119285},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":4}}}}},"n":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1,"_":{"docs":{},"df":0,"m":{"docs":{},"df":0,"y":{"docs":{},"df":0,"_":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}}},"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"q":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}},"c":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2},"l":{"docs":{},"df":0,"u":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.795831523312719},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.47213595499958},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.5677643628300215},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":6},"s":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772}},"df":1}}},"o":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":3,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3}}}},"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772}},"df":1}}}},"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":1,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}}}}},"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":4,"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3}}}}}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}}}}}}},"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1},"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":4}}}}}},"u":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1}}},"d":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":3,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":4}},"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":3}}}},"x":{"docs":{"http://127.0.0.1:1111/posts/post-1/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.898979485566356},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.795831523312719},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":8.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.6457513110645907}},"df":10,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{},"df":0,"x":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"f":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"z":{"docs":{},"df":0,"e":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}},"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"z":{"docs":{},"df":0,"e":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"z":{"docs":{},"df":0,"e":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"z":{"docs":{},"df":0,"e":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"d":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"o":{"docs":{},"df":0,"p":{"docs":{},"df":0,"s":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"z":{"docs":{},"df":0,"e":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"{":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"}":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}},".":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{},"df":0,"m":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/posts/post-1/":{"tf":1.0}},"df":1}}}}},"m":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}},"i":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1,"a":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1},"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.69041575982343},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.242640687119285},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.358898943540674}},"df":3},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":3,"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}}},"v":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":3}}}}},"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}}},"e":{"docs":{},"df":0,"f":{"docs":{},"df":0,"f":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772}},"df":1}}}}},"q":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}},"r":{"docs":{},"df":0,"m":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1}}},"v":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}},"x":{"docs":{},"df":0,"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}}},"f":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.1622776601683795}},"df":2}},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":3}}}},"l":{"docs":{},"df":0,"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772}},"df":1}}}}},"o":{"docs":{"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":5,"r":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.385164807134504},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.744562646538029},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":4.123105625617661},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":6.708203932499369},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":4.58257569495584}},"df":11}}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"u":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1}}}}}}}}}}},"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":2}}},"i":{"docs":{},"df":0,"m":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1}}}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":1,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":5}}},"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":4}}},"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.58257569495584},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.898979485566356}},"df":4}},"u":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}},"p":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter2/":{"tf":4.123105625617661},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.3166247903554}},"df":4,"/":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{},"df":0,"p":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}}}}}}},"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3}}},"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.1622776601683795}},"df":1}}}},"r":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.123105625617661},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":6}}},"i":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.898979485566356},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.58257569495584},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":6.782329983125268},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":5},"g":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}},"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4}}},"i":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1}}},"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0}},"df":1}}}},"l":{"docs":{"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.795831523312719},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":6},"n":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":7.937253933193772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":7.810249675906654},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":9.848857801796104}},"df":3,"e":{"docs":{},"df":0,"’":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}}},"t":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/to do/chapter5/1-defining-and-instantiating-structs/":{"tf":1.0}},"df":3}}}},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":9.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":6.324555320336759},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":8.18535277187245},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":6}}},"r":{"docs":{},"df":0,"u":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1}}}}}},"t":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.0}},"df":1,"(":{"docs":{},"df":0,"i":{"docs":{},"df":0,"3":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}},"e":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.385164807134504},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.449489742783178}},"df":9,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"_":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"_":{"docs":{},"df":0,"f":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}},"s":{"docs":{},"df":0,"—":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}}}}},"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.5677643628300215},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979}},"df":2,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"_":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2,".":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0}},"df":2}}}}}}}}}}}}}},"l":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2},"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979}},"df":3},"s":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":2,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178}},"df":4}}},"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}},"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":3,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}}}}},"f":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1,"a":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":5}},"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}},"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.242640687119285},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":2}}},"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"v":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}},"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2}}}},"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":4,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"_":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"(":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2},"a":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}}},"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979}},"df":2}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}},"u":{"docs":{},"df":0,"p":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}},"v":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}},"o":{"docs":{},"df":0,"_":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}},"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"d":{"docs":{},"df":0,"u":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":5,"t":{"docs":{"http://127.0.0.1:1111/rust/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2}}}}}},"u":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}},"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.58257569495584},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":4,"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0}},"df":1}}}}}}}},"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3}}},"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.8284271247461903}},"df":2}}}}},"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1,"i":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}}}}},"o":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1},"k":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":2},"l":{"docs":{},"df":0,"v":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178}},"df":3}}}}},"o":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter2/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":5,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.449489742783178}},"df":2,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.23606797749979}},"df":2}}},"]":{"docs":{},"df":0,"(":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}}}},"k":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"(":{"docs":{},"df":0,")":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":2,"(":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"_":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"m":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.4142135623730951}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}},"{":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772}},"df":2}}}}}}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"(":{"docs":{},"df":0,")":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}},"p":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.47213595499958},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":4.47213595499958}},"df":4,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"d":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.605551275463989}},"df":2,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"v":{"docs":{},"df":0,"4":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2,"(":{"docs":{},"df":0,"1":{"docs":{},"df":0,"2":{"docs":{},"df":0,"7":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"f":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"(":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"1":{"docs":{},"df":0,"2":{"docs":{},"df":0,"7":{"docs":{},"df":0,".":{"docs":{},"df":0,"0":{"docs":{},"df":0,".":{"docs":{},"df":0,"0":{"docs":{},"df":0,".":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}}}}}}},"`":{"docs":{},"df":0,"1":{"docs":{},"df":0,"2":{"docs":{},"df":0,"7":{"docs":{},"df":0,".":{"docs":{},"df":0,"0":{"docs":{},"df":0,".":{"docs":{},"df":0,"0":{"docs":{},"df":0,".":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}},"6":{"docs":{},"df":0,"(":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"f":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"(":{"docs":{},"df":0,"\"":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":1}}}},"`":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":1}}}}}}}}}}}}}}}}}}}}}},"k":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.4641016151377544}},"df":2,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"v":{"docs":{},"df":0,"4":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":2},"6":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2}}}}}}}}}}}},"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.8284271247461903}},"df":1}}},"v":{"docs":{},"df":0,"4":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"d":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}},"6":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"d":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}},"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"f":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.58257569495584},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}},"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}},"s":{"docs":{},"df":0,"_":{"docs":{},"df":0,"o":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2}},"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"d":{"docs":{},"df":0,"a":{"docs":{},"df":0,"y":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}},"h":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}},"i":{"docs":{},"df":0,"z":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.4142135623730951}},"df":3}},"n":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1}},"`":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":1}},"’":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.196152422706632},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.242640687119285},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.0}},"df":3}}},"o":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2}},"s":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":5}}},"t":{"docs":{},"df":0,"\"":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":3},"'":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":3},"_":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"d":{"docs":{},"df":0,"s":{"docs":{},"df":0,"_":{"docs":{},"df":0,"t":{"docs":{},"df":0,"w":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.8284271247461903}},"df":2}}}}}}}},"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"s":{"docs":{},"df":0,"_":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"_":{"docs":{},"df":0,"o":{"docs":{},"df":0,"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"_":{"docs":{},"df":0,"7":{"docs":{},"df":0,"5":{"docs":{},"df":0,"_":{"docs":{},"df":0,"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"_":{"docs":{},"df":0,"w":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"n":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"_":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"w":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.4641016151377544}},"df":2}}}}},"a":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1,"i":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}},"c":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.0},"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0}},"df":2}}}},"e":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":9.055385138137417},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":6.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":9.1104335791443},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":4.47213595499958}},"df":9,".":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}},"1":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"2":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"1":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}},"2":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2},"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"y":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"z":{"docs":{},"df":0,"e":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"f":{"docs":{},"df":0,"y":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"w":{"docs":{},"df":0,"s":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"t":{"docs":{},"df":0,"w":{"docs":{},"df":0,"e":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"i":{"docs":{},"df":0,"3":{"docs":{},"df":0,"2":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"’":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}},"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":13.490737563232042},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":4.358898943540674},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.385164807134504},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.0990195135927845},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":7,"(":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}},"_":{"docs":{},"df":0,"m":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}},"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2,"=":{"docs":{},"df":0,"t":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}},"t":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}},"_":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}},"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}},"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979}},"df":4}}}},"’":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":7.280109889280518},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":6.855654600401044},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":8.602325267042627},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1},"l":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}},"’":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/4-comments/":{"tf":1.4142135623730951}},"df":3}}},"j":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1,"u":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1}}}}},"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"c":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"p":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.0}},"df":3}}}}}}}}},"e":{"docs":{},"df":0,"k":{"docs":{},"df":0,"y":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/":{"tf":1.0}},"df":1}}}},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"j":{"docs":{},"df":0,"a":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/":{"tf":1.0}},"df":1}}}}},"o":{"docs":{},"df":0,"b":{"docs":{"http://127.0.0.1:1111/posts/post-2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":7.483314773547883},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":5.916079783099616},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":6},"h":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":3.1622776601683795}},"df":1}},"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.123105625617661},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.8284271247461903}},"df":4,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772}},"df":4,"e":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"(":{"docs":{},"df":0,")":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.8284271247461903}},"df":2}}}}},"_":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}},"t":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}}}}}}}},"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}},"u":{"docs":{},"df":0,"r":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"y":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3}}}}},"y":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}},"s":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0},"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":1.0}},"df":3},"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1}},"m":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3}},"n":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1},"g":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.7320508075688772}},"df":1}}}},"k":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4,"\"":{"docs":{},"df":0,".":{"docs":{},"df":0,".":{"docs":{},"df":0,"=":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"z":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}},"`":{"docs":{},"df":0,".":{"docs":{},"df":0,".":{"docs":{},"df":0,"=":{"docs":{},"df":0,"`":{"docs":{},"df":0,"z":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1}}}}}},"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.7320508075688772}},"df":2,"(":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{},"df":0,"=":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0}},"df":1}}}}}}}}}},".":{"docs":{},"df":0,"a":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"_":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0}},"df":1}}}}}}}}},"e":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0}},"df":1}}}}}}},"b":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0}},"df":3},"e":{"docs":{},"df":0,"e":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.196152422706632},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.872983346207417}},"df":5}},"p":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":1}},"y":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":6.4031242374328485},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":9,"/":{"docs":{},"df":0,"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":1}}}}},"b":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0}},"df":1}}},"w":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.477225575051661},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":6.557438524302},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":8,"s":{"docs":{},"df":0,".":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{},"df":0,"m":{"docs":{},"df":0,"l":{"docs":{},"df":0,"#":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"w":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}},"’":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}},"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.0}},"df":2}}}}},"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.0990195135927845},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":6.48074069840786},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.8284271247461903}},"df":6}},"t":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}}}},"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.7320508075688772}},"df":1}}}}},"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"w":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}},"o":{"docs":{},"df":0,"w":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":6.557438524302},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":6.855654600401044},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":7.810249675906654},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.23606797749979}},"df":6,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"d":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0}},"df":1}}}},"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.872983346207417}},"df":4}}}},"o":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.7320508075688772}},"df":1}}},"l":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":5.656854249492381},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":4,"\"":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1},"[":{"docs":{},"df":0,"^":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}}}}},"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1}}},"c":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1},"u":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.8284271247461903}},"df":1}},"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979}},"df":1},"g":{"docs":{},"df":0,".":{"docs":{},"df":0,"g":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"u":{"docs":{},"df":0,"b":{"docs":{},"df":0,".":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"/":{"docs":{},"df":0,"r":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}},"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"g":{"docs":{},"df":0,"/":{"docs":{},"df":0,"b":{"docs":{},"df":0,"o":{"docs":{},"df":0,"o":{"docs":{},"df":0,"k":{"docs":{},"df":0,"/":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{},"df":0,"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"x":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1}}}}}}}},"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"0":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1},"3":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1},"5":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1},"7":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1},"9":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":1}},"1":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":3},"3":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1},"5":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1},"6":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1},"7":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2},"8":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}},"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"g":{"docs":{},"df":0,"o":{"docs":{},"df":0,"/":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"f":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"/":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"i":{"docs":{},"df":0,"f":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,".":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{},"df":0,"m":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0}},"df":4,"#":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"d":{"docs":{},"df":0,"/":{"docs":{},"df":0,"o":{"docs":{},"df":0,"p":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"/":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{},"df":0,".":{"docs":{},"df":0,"o":{"docs":{},"df":0,"p":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,".":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{},"df":0,"m":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1,"#":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"d":{"docs":{},"df":0,".":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"w":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{},"df":0,"_":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"_":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"s":{"docs":{},"df":0,"/":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}},"/":{"docs":{},"df":0,"r":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"/":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"/":{"docs":{},"df":0,"5":{"docs":{},"df":0,"3":{"docs":{},"df":0,"6":{"docs":{},"df":0,"6":{"docs":{},"df":0,"7":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}},"=":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1}}}}}}},"`":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"`":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":1}}}}}}}},"u":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.0},"http://127.0.0.1:1111/rust/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.830951894845301},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.5677643628300215},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":6.48074069840786}},"df":8,"e":{"docs":{},"df":0,"’":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}},"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.7320508075688772}},"df":1}}}}},"r":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.0}},"df":3,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":4,".":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"_":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"d":{"docs":{},"df":0,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"s":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}}}}}}}}}},"w":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}},"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"_":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"d":{"docs":{},"df":0,"_":{"docs":{},"df":0,"s":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2}}}}}}}}}}}}}}},"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":8.18535277187245},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":7.14142842854285}},"df":3,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"(":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}}}}}},"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"_":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}},"n":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{},"df":0,"b":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"_":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2}}}}}}}}}}}}}}}},"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}},"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"_":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}},"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}},"i":{"docs":{},"df":0,"3":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"n":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{},"df":0,"b":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"_":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}},"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}},"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}},"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.123105625617661},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.196152422706632},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":5,"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"_":{"docs":{},"df":0,"o":{"docs":{},"df":0,"f":{"docs":{},"df":0,"_":{"docs":{},"df":0,"f":{"docs":{},"df":0,"i":{"docs":{},"df":0,"r":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"_":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2,"e":{"docs":{},"df":0,"(":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}}},"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}},"t":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1,"r":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.449489742783178}},"df":5},"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/posts/post-2/":{"tf":1.0}},"df":1}}},"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":1}},"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1}}}},"y":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1},"z":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2},"y":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"g":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.7320508075688772}},"df":1}}}}}}}}}}}}}}}},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979}},"df":2},"f":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":6.164414002968976},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":4.795831523312719}},"df":2,".":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,".":{"docs":{},"df":0,"b":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{},"df":0,"(":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"u":{"docs":{},"df":0,"p":{"docs":{},"df":0,"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2}}}}}}}}},"_":{"docs":{},"df":0,"m":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}}}}}}}}}}},"k":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":3},"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1},"r":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.358898943540674},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.3166247903554}},"df":4}},"v":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979}},"df":3}},"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":2},"f":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":4}},"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1}}},"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.3166247903554}},"df":7,"]":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"y":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1}}}}},"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}},"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.58257569495584},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.23606797749979}},"df":5,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1},"}":{"docs":{},"df":0,"\\":{"docs":{},"df":0,"r":{"docs":{},"df":0,"\\":{"docs":{},"df":0,"n":{"docs":{},"df":0,"\\":{"docs":{},"df":0,"r":{"docs":{},"df":0,"\\":{"docs":{},"df":0,"n":{"docs":{},"df":0,"{":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0}},"df":2}}}}}}}}}}}}}}}}}},"s":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.872983346207417}},"df":6,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.123105625617661}},"df":3,"\"":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1},"'":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0}},"df":3},"`":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1},"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.3166247903554}},"df":5}}},"’":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":10.04987562112089},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":8.06225774829855},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":8.660254037844387}},"df":3}},"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":6.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":7,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}}},"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1,"b":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":6,".":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.1622776601683795}},"df":2}},"c":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.7320508075688772}},"df":1},"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1,"o":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.7320508075688772}},"df":1}}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":9.695359714832659},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.477225575051661},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":9.1104335791443}},"df":6},"y":{"docs":{},"df":0,"\"":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1},"`":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1},"’":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":4}}}}}},"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.47213595499958},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.449489742783178}},"df":2}}}},"e":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1},"f":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":1,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.123105625617661},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":14.491376746189438},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":4.0}},"df":8}}}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}},"g":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{},"df":0,"w":{"docs":{},"df":0,"e":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}}}},"k":{"docs":{},"df":0,"e":{"docs":{},"df":0,"w":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":1}}}}},"m":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":4,"_":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,".":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"_":{"docs":{},"df":0,"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,"(":{"docs":{},"df":0,"8":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}},"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.0}},"df":2,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772}},"df":1}},"`":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":1}}}}}},":":{"docs":{},"df":0,":":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"w":{"docs":{},"df":0,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"m":{"docs":{},"df":0,"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{},"df":0,"_":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"n":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":3.605551275463989},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":11.445523142259598},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":4.123105625617661},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":6.244997998398398},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter2/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/4-comments/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":7.416198487095663},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":14,".":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"(":{"docs":{},"df":0,"q":{"docs":{},"df":0,"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.23606797749979}},"df":2}}}}}}}}}}}}}},"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"_":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772}},"df":2}}}}}}}},"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"_":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"(":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"q":{"docs":{},"df":0,"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"a":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1}}},"g":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}},"k":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/docs/config-options/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":7,".":{"docs":{},"df":0,"b":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{},"df":0,"_":{"docs":{},"df":0,"m":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}},"e":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0}},"df":1}}},"r":{"docs":{"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":1.0}},"df":1}}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772}},"df":1,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}},"u":{"docs":{},"df":0,"x":{"docs":{"http://127.0.0.1:1111/rust/chapter1/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":6}}},"q":{"docs":{},"df":0,"u":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/":{"tf":1.0}},"df":1}}}},"s":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2},"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0},"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.0},"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":22.538855339169288},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":14.491376746189438},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":15.556349186104045},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":9.848857801796104},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":19.519221295943137},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":12.529964086141668}},"df":16,".":{"docs":{},"df":0,"p":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{},"df":0,"(":{"docs":{},"df":0,"7":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}},"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"_":{"docs":{},"df":0,"b":{"docs":{},"df":0,"y":{"docs":{},"df":0,"_":{"docs":{},"df":0,"k":{"docs":{},"df":0,"e":{"docs":{},"df":0,"y":{"docs":{},"df":0,"(":{"docs":{},"df":0,"|":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0}},"df":2}}}}}}}}}}}}}}},"_":{"docs":{},"df":0,"o":{"docs":{},"df":0,"f":{"docs":{},"df":0,"_":{"docs":{},"df":0,"n":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{},"df":0,"b":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"s":{"docs":{},"df":0,".":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"(":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{},"df":0,"(":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"_":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}}}}},"|":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}},"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}},"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"i":{"docs":{},"df":0,"3":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}},"e":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.123105625617661},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.449489742783178}},"df":2,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,".":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0}},"df":2,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"(":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"k":{"docs":{},"df":0,"e":{"docs":{},"df":0,"(":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}}}}}}}}}}}}}}}},"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"8":{"docs":{},"df":0,"6":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.7320508075688772}},"df":1}},"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.477225575051661},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.291502622129181},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":4,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1}}}}}}}}}}},"’":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}},"t":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":3}}},"v":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":3,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0}},"df":2}}}}}}},"o":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":3}},"b":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1}}},"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":5,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/posts/post-2/":{"tf":1.0}},"df":1}}}}},"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":6,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"1":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"c":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"p":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}},"k":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.656854249492381},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.1622776601683795}},"df":3,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"m":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"g":{"docs":{},"df":0,"u":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}},"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2,"i":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.744562646538029},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.123105625617661}},"df":4},"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}},"l":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2},"n":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/4-comments/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.291502622129181},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.0}},"df":6,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":4},"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.196152422706632},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":5.0}},"df":2,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"'":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"(":{"docs":{},"df":0,"x":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":2}}}}}}}}}}}},"(":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"1":{"docs":{},"df":0,".":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"_":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":2}}}}}}}}}}}}}},"x":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2}},"_":{"docs":{},"df":0,"w":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"_":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"_":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"'":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"o":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":5.0990195135927845},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":8.306623862918075},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":7.745966692414834},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":9.38083151964686}},"df":5},"p":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.5677643628300215},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":7.416198487095663},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter2/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":10,"b":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2}}}}},"s":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":3.872983346207417}},"df":1,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"/":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1}}}}}}}}}}}}},"s":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":1}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.47213595499958}},"df":3},"v":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}},"w":{"docs":{"http://127.0.0.1:1111/rust/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":4,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":2,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3}}}}}}},"s":{"docs":{"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":3},"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":9,".":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/posts/post-1/":{"tf":1.0}},"df":1}}}}},";":{"docs":{},"df":0,"!":{"docs":{},"df":0,"d":{"docs":{},"df":0,"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"y":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}},"\"":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}},"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"'":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}},"i":{"docs":{},"df":0,"3":{"docs":{},"df":0,"2":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}},"8":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}},"t":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}},"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}},"l":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2,";":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}},"=":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}},"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1}}}},"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1}}}}}}}},".":{"docs":{},"df":0,".":{"docs":{},"df":0,".":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0}},"df":1}}}}}},"/":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{},"df":0,"q":{"docs":{},"df":0,"u":{"docs":{},"df":0,"o":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}}}}}}},"o":{"docs":{},"df":0,"d":{"docs":{},"df":0,"y":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}},"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}},"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"s":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0}},"df":1}}}}}}}}},"i":{"docs":{},"df":0,"v":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0},"http://127.0.0.1:1111/posts/post-1/":{"tf":1.0}},"df":3}}}}}},"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}}},"t":{"docs":{},"df":0,"m":{"docs":{},"df":0,"l":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}},"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}},"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}},"p":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}},"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}},"b":{"docs":{},"df":0,"o":{"docs":{},"df":0,"d":{"docs":{},"df":0,"y":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}},"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}},"r":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.0}},"df":1}}}}},"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1}}}}}},"=":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}},"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1}}}}},"[":{"docs":{},"df":0,"t":{"docs":{},"df":0,"]":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}},"a":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.6457513110645907}},"df":1,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"t":{"docs":{},"df":0,",":{"docs":{},"df":0,"a":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}},"b":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{},"df":0,"m":{"docs":{},"df":0,"l":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"/":{"docs":{},"df":0,"b":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}},"e":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"_":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}},"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{},"df":0,"q":{"docs":{},"df":0,"u":{"docs":{},"df":0,"o":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}}}}}}},"o":{"docs":{},"df":0,"d":{"docs":{},"df":0,"y":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}}},"r":{"docs":{},"df":0,"/":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}}}}}}}}}}}}},"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1,";":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"/":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"/":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"@":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"v":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,".":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}},"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}}}}},"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"s":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0}},"df":1}}}}}}}}},"i":{"docs":{},"df":0,"v":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0},"http://127.0.0.1:1111/posts/post-1/":{"tf":1.0}},"df":3,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"b":{"docs":{},"df":0,"r":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"b":{"docs":{},"df":0,"r":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"b":{"docs":{},"df":0,"r":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"/":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"v":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/posts/post-1/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"s":{"docs":{},"df":0,"r":{"docs":{},"df":0,"c":{"docs":{},"df":0,"/":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"b":{"docs":{},"df":0,".":{"docs":{},"df":0,"r":{"docs":{},"df":0,"s":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"/":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"v":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}},"o":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}},"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}}},"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"_":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0}},"df":1}}}}}}}}}}},"f":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"b":{"docs":{},"df":0,"o":{"docs":{},"df":0,"o":{"docs":{},"df":0,"k":{"docs":{},"df":0,"_":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}},"g":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"u":{"docs":{},"df":0,"b":{"docs":{},"df":0,"_":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}},"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"_":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}},"o":{"docs":{},"df":0,"o":{"docs":{},"df":0,"g":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"_":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}},"h":{"docs":{},"df":0,"1":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"h":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1},"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"!":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"/":{"docs":{},"df":0,"h":{"docs":{},"df":0,"1":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}},"o":{"docs":{},"df":0,"o":{"docs":{},"df":0,"p":{"docs":{},"df":0,"s":{"docs":{},"df":0,"!":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"/":{"docs":{},"df":0,"h":{"docs":{},"df":0,"1":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}},"2":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"h":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}},"3":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"h":{"docs":{},"df":0,"3":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}},"4":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"h":{"docs":{},"df":0,"4":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}},"5":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"h":{"docs":{},"df":0,"5":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}},"6":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"h":{"docs":{},"df":0,"6":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}}},"r":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1}}}},"t":{"docs":{},"df":0,"m":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}},"t":{"docs":{},"df":0,"p":{"docs":{},"df":0,"s":{"docs":{},"df":0,":":{"docs":{},"df":0,"/":{"docs":{},"df":0,"/":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,".":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}}}}}}}}},"d":{"docs":{},"df":0,"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,".":{"docs":{},"df":0,"r":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}},"g":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"u":{"docs":{},"df":0,"b":{"docs":{},"df":0,".":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"/":{"docs":{},"df":0,"r":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}},"i":{"docs":{},"df":0,"8":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2},"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"_":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}},"k":{"docs":{},"df":0,"e":{"docs":{},"df":0,"y":{"docs":{},"df":0,"b":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"_":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}},"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1},"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1}}}}}},"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1}}}}}}}}}}},"e":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1}}}},"f":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1}}}}}},"u":{"docs":{},"df":0,"c":{"docs":{},"df":0,"i":{"docs":{},"df":0,"b":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1}}}}}}},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1}}}}},"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1}}}}},"n":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1}}}}},"p":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}},"u":{"docs":{},"df":0,"r":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}},"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"b":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}}}}}}}}},"n":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/posts/post-1/":{"tf":2.6457513110645907}},"df":1,"e":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"_":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}},"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"_":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}},"o":{"docs":{},"df":0,"d":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"_":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}},"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}},"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"v":{"docs":{"http://127.0.0.1:1111/posts/post-1/":{"tf":1.0}},"df":1}}},"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}},"r":{"docs":{},"df":0,"c":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{},"df":0,"_":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}},"p":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1,";":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"/":{"docs":{},"df":0,"p":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}}}},"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0}},"df":1}}}}}}},"h":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}},"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}},"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}},"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"_":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"_":{"docs":{},"df":0,"a":{"docs":{},"df":0,"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}},"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"y":{"docs":{},"df":0,"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"=":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"y":{"docs":{},"df":0,"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}},"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"/":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}},"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{},"df":0,"o":{"docs":{},"df":0,"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"f":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{},"df":0,"_":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}},"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.449489742783178}},"df":2}}},"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"/":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}},"f":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}}}}}}}},"u":{"docs":{},"df":0,"m":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"y":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}},"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}},"b":{"docs":{},"df":0,"o":{"docs":{},"df":0,"d":{"docs":{},"df":0,"y":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}},"d":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"d":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"/":{"docs":{},"df":0,"t":{"docs":{},"df":0,"d":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}}}}}}}}},"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1,"e":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"/":{"docs":{},"df":0,"t":{"docs":{},"df":0,"d":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}},"x":{"docs":{},"df":0,"t":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"/":{"docs":{},"df":0,"t":{"docs":{},"df":0,"d":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}}}}},"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}},"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}}}},"h":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"c":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"p":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"/":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}},"o":{"docs":{},"df":0,"p":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"/":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}},"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"!":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"/":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}}}},"r":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.0}},"df":1}}}},"w":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"_":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}},"y":{"docs":{},"df":0,"p":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}},"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1}}}},"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"z":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}},"y":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{},"df":0,"_":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"_":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"k":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}},"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"q":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0}},"df":1}}}}}}}}},"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0}},"df":1}}}}}}},"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0}},"df":1}}}}}}}}}}}},"식":{"docs":{},"df":0,"별":{"docs":{},"df":0,"=":{"docs":{},"df":0,"유":{"docs":{},"df":0,"형":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1}}}}}}}}}},"u":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter3/4-comments/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":3,"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979}},"df":1}}},"y":{"docs":{},"df":0,"_":{"docs":{},"df":0,"n":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{},"df":0,"b":{"docs":{"http://127.0.0.1:1111/rust/chapter3/4-comments/":{"tf":1.4142135623730951}},"df":1}}}}}}}},"k":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}},"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":4,".":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}}}},"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{},"df":0,"(":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"w":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}},"a":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2,"h":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":2}}},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}},"o":{"docs":{"http://127.0.0.1:1111/rust/chapter1/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":1.0}},"df":4},"r":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0},"http://127.0.0.1:1111/rust/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":6.324555320336759},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":12.36931687685298},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.385164807134504},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":9,"_":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}}},"r":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.3166247903554}},"df":2}}},"u":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0}},"df":1}}},"s":{"docs":{},"df":0,"—":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"_":{"docs":{},"df":0,"e":{"docs":{},"df":0,"q":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}}}}}}}}},"’":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0}},"df":1}}}},"d":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.1622776601683795}},"df":5}},"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}},"i":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1},"n":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/posts/post-2/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":13.341664064126334},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":11.313708498984761},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":7.280109889280518},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":6.782329983125268},"http://127.0.0.1:1111/rust/chapter2/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter3/4-comments/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":10.04987562112089},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":9.273618495495704}},"df":16,".":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":2.6457513110645907}},"df":1}},"p":{"docs":{},"df":0,"d":{"docs":{},"df":0,"b":{"docs":{"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":1.0}},"df":1}}},"r":{"docs":{"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":9}},"a":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1},"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}},"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772}},"df":2}}}}}},"j":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":4}}},"k":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":10.63014581273465},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":8.306623862918075},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":10.816653826391969},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":8,"s":{"docs":{},"df":0,"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"p":{"docs":{},"df":0,"y":{"docs":{},"df":0,"(":{"docs":{},"df":0,"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"_":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}},"x":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}},"l":{"docs":{},"df":0,"f":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}},"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.605551275463989}},"df":4}},"d":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1}}}},"g":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0}},"df":1}},"i":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":6.708203932499369},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":6.6332495807108}},"df":4,"f":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}},"p":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":4}}}},"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":3}}},"u":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4}}}},"p":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0},"http://127.0.0.1:1111/rust/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":7.211102550927978},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.23606797749979}},"df":10,"(":{"docs":{},"df":0,"|":{"docs":{},"df":0,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772}},"df":2}}}}}}}},".":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"y":{"docs":{},"df":0,"(":{"docs":{},"df":0,"w":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"_":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"(":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"(":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2},"f":{"docs":{},"df":0,"i":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"d":{"docs":{},"df":0,"_":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}},"b":{"docs":{},"df":0,"o":{"docs":{},"df":0,"x":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.7320508075688772}},"df":2,"(":{"docs":{},"df":0,"z":{"docs":{},"df":0,"o":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"=":{"docs":{},"df":0,"6":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0}},"df":1}}}}}}}}}}},"r":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1,"c":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1}},"k":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.0}},"df":3,"d":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/":{"tf":1.0},"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0},"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":6}}}},"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3}}}},"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.449489742783178}},"df":1,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"/":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1}}}}}}}}}}}},"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/posts/post-2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178}},"df":3}},"o":{"docs":{},"df":0,"d":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,".":{"docs":{},"df":0,"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0}},"df":1}}}}},"_":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"v":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0}},"df":1}}}},"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0}},"df":1}}}}}}}}}}}}}},"t":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.744562646538029},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":15.84297951775486},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":6.48074069840786},"http://127.0.0.1:1111/rust/chapter2/":{"tf":4.69041575982343},"http://127.0.0.1:1111/rust/chapter22/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":11.445523142259598},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":5.916079783099616}},"df":10,"(":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"e":{"docs":{},"df":0,"d":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}},"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}},"h":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":3,"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3}}}}},"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903}},"df":4}}}},"x":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.449489742783178}},"df":6,"i":{"docs":{},"df":0,"m":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":3}}}}}},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2,".":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"_":{"docs":{},"df":0,"f":{"docs":{},"df":0,"r":{"docs":{},"df":0,"u":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}},"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}},"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.916079783099616},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":6.708203932499369},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":7.483314773547883}},"df":3,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":3,"f":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":3,"i":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1}}}},"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":7.280109889280518},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":7.14142842854285},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":4}}}},"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":4}}}},"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":2,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}},"y":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"x":{"docs":{},"df":0,"(":{"docs":{},"df":0,"2":{"docs":{},"df":0,"0":{"docs":{},"df":0,"1":{"docs":{},"df":0,"8":{"docs":{"http://127.0.0.1:1111/about/":{"tf":1.0}},"df":1}}}}}}}}}},"e":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":2}},"m":{"docs":{},"df":0,"b":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":5}}},"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":6.164414002968976},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.795831523312719},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":7.937253933193772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":5}}}},"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2}},"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.605551275463989}},"df":3}}}},"u":{"docs":{"http://127.0.0.1:1111/posts/post-1/":{"tf":1.0}},"df":1}},"r":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2},"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":3.1622776601683795}},"df":2,".":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0}},"df":1}}}}}}}},"s":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3,"a":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":10.63014581273465},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.5677643628300215},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.744562646538029},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.8284271247461903}},"df":7,"e":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772}},"df":2,"(":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2},"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"h":{"docs":{},"df":0,"s":{"docs":{},"df":0,"v":{"docs":{},"df":0,"(":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2},"h":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}},"r":{"docs":{},"df":0,"g":{"docs":{},"df":0,"b":{"docs":{},"df":0,"(":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}},"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}},"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.23606797749979}},"df":2}}}}},"m":{"docs":{},"df":0,"o":{"docs":{},"df":0,"v":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":4}}},"q":{"docs":{},"df":0,"u":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772}},"df":4}}}},"w":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2,"e":{"docs":{},"df":0,"(":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"f":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"(":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":1}}}}}},"`":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}},"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}},"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}},"’":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2}}}},"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.3166247903554}},"df":2,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2,"a":{"docs":{"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0}},"df":1,"]":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}},"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}},"d":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":4}}}},"p":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":2}}},"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0}},"df":1}}}}}}}},"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2,"s":{"docs":{},"df":0,"(":{"docs":{},"df":0,"u":{"docs":{},"df":0,"3":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}},"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":11.575836902790225},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":10.908712114635714},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":14.966629547095765},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/to do/chapter5/3-method-syntax/":{"tf":1.0}},"df":9,"(":{"docs":{},"df":0,".":{"docs":{},"df":0,".":{"docs":{},"df":0,".":{"docs":{},"df":0,")":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"b":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}},":":{"docs":{},"df":0,":":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,".":{"docs":{},"df":0,".":{"docs":{},"df":0,".":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"s":{"docs":{},"df":0,"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"i":{"docs":{},"df":0,"f":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}},"_":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0}},"df":1}}}},"’":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":3}}}}}},"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"p":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178}},"df":1}}}}}}},"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.605551275463989}},"df":2,"d":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":2}}},"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772}},"df":2,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"s":{"docs":{},"df":0,"(":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"f":{"docs":{},"df":0,".":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}},"u":{"docs":{},"df":0,"3":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}},"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}},"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4},"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1,"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":6.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":6.0}},"df":2,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"f":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}}}},"r":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"(":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"f":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}}}}}}}},"m":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":5},"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"]":{"docs":{},"df":0,"(":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{},"df":0,"t":{"docs":{},"df":0,"p":{"docs":{},"df":0,"s":{"docs":{},"df":0,":":{"docs":{},"df":0,"/":{"docs":{},"df":0,"/":{"docs":{},"df":0,"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,".":{"docs":{},"df":0,"g":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"u":{"docs":{},"df":0,"b":{"docs":{},"df":0,".":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"/":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"/":{"docs":{},"df":0,"m":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,".":{"docs":{},"df":0,"p":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1},"u":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}},"s":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":10}}}}},"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":5},"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4,"e":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}},"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}}}}}}}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.23606797749979}},"df":2,"i":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1}}},"x":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":4,"(":{"docs":{},"df":0,"c":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}},"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}},"u":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"x":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}},"k":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":3}}}},"m":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":1.0}},"df":2},"o":{"docs":{},"df":0,"b":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0}},"df":1}}},"c":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.4641016151377544}},"df":1,"_":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}},"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.58257569495584},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":4.58257569495584}},"df":2,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"w":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}},"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.0990195135927845},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":5.0990195135927845},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":6.6332495807108},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":6.557438524302}},"df":6,".":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":4}},"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":4,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":4}},"i":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":3,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.795831523312719},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4}}},"u":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":7.937253933193772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter22/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":14.247806848775006},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.0}},"df":5,"a":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":2}},"e":{"docs":{},"df":0,"’":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":2}}}}},"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.449489742783178}},"df":1}}}},"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1}}},"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3}}}},"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"y":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}},"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"p":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979}},"df":3}}}}}},"t":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":2,"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}}}},"r":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":10.816653826391969},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":4.47213595499958},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":9.433981132056603},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":12.288205727444508},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":5.291502622129181}},"df":13}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"_":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{},"df":0,"e":{"docs":{},"df":0,"d":{"docs":{},"df":0,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}},"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}}}},"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}}}}},"v":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":8.94427190999916},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":5.291502622129181},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.795831523312719},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":7.810249675906654},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":4.123105625617661}},"df":6,"_":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"y":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"(":{"docs":{},"df":0,"n":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{},"df":0,"_":{"docs":{},"df":0,"s":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}},"o":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}},"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}},"z":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"/":{"docs":{},"df":0,"5":{"docs":{},"df":0,".":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}},"p":{"docs":{},"df":0,"s":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.23606797749979}},"df":4}}}}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"i":{"docs":{},"df":0,"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"j":{"docs":{},"df":0,"o":{"docs":{},"df":0,"b":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}},"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"j":{"docs":{},"df":0,"o":{"docs":{},"df":0,"b":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}},"s":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.6457513110645907}},"df":4},"v":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772}},"df":3}}},"u":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.47213595499958},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.47213595499958}},"df":4}},"g":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}}},"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1,"b":{"docs":{},"df":0,"y":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}},"p":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":8.774964387392123},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.744562646538029},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/4-comments/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":6.6332495807108}},"df":6,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"m":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}}}}}}}},"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.4142135623730951}},"df":3}}}}}},"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0}},"df":1}}}}}}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.385164807134504},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":5.385164807134504},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":4.898979485566356},"http://127.0.0.1:1111/rust/chapter2/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":6.48074069840786},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":6.48074069840786}},"df":10,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":8.426149773176359},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.477225575051661},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":7.483314773547883},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.605551275463989}},"df":9}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.69041575982343},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178}},"df":3}},"e":{"docs":{},"df":0,"x":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":6.928203230275509},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":5.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.6457513110645907}},"df":4,"\"":{"docs":{},"df":0,"/":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}},"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"i":{"docs":{},"df":0,"3":{"docs":{},"df":0,"2":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}},":":{"docs":{},"df":0,":":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"w":{"docs":{},"df":0,"(":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2},"5":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}},"g":{"docs":{},"df":0,"u":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":4}}}}},"’":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}},"u":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}},"y":{"docs":{},"df":0,"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.6457513110645907}},"df":2,"e":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"d":{"docs":{},"df":0,"_":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"(":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}},"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"_":{"docs":{},"df":0,"m":{"docs":{},"df":0,"o":{"docs":{},"df":0,"d":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"_":{"docs":{},"df":0,"m":{"docs":{},"df":0,"o":{"docs":{},"df":0,"d":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"f":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,"y":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"f":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,"y":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"_":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}},"b":{"docs":{},"df":0,"o":{"docs":{},"df":0,"x":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.47213595499958},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":4.242640687119285}},"df":2,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"t":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2,";":{"docs":{},"df":0,"(":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}},"{":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"}":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}},"(":{"docs":{},"df":0,"x":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}},":":{"docs":{},"df":0,":":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"w":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2,"(":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"f":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"(":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"r":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1}}}}},"`":{"docs":{},"df":0,"r":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":1}}}}}}}}}}}}}}}}}},"x":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}},"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}},"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.0}},"df":7,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.7320508075688772}},"df":1}},"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}},"e":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0},"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0},"http://127.0.0.1:1111/posts/post-2/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":11.135528725660043},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":11.269427669584644},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":4.123105625617661},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":13.638181696985855},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.8284271247461903}},"df":13,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}},"s":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979}},"df":1}}}},"및":{"docs":{},"df":0,"q":{"docs":{},"df":0,"u":{"docs":{},"df":0,"o":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1}}}}}}},"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772}},"df":2},"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}},"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":3}}},"v":{"docs":{"http://127.0.0.1:1111/posts/post-1/":{"tf":1.0}},"df":1,"b":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/posts/post-1/":{"tf":1.0}},"df":1}}},"i":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/posts/post-1/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":5}}}},"b":{"docs":{},"df":0,"s":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"&":{"docs":{},"df":0,"n":{"docs":{},"df":0,"b":{"docs":{},"df":0,"s":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0}},"df":2}}}}}}}}},"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1,"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}},"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907}},"df":3,"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":2}}}}}}}}},"e":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":11.445523142259598},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":9.695359714832659},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/4-comments/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":10.535653752852738}},"df":7,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2}}},"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":3,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}}}}},"q":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1,"e":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"/":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}}}}}}}},"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.3166247903554}},"df":5}},"t":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"{":{"docs":{},"df":0,"t":{"docs":{},"df":0,"c":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772}},"df":2}}}}}}}}}}}},"w":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2}}}}},"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.795831523312719},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.0}},"df":4}}},"w":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.0},"http://127.0.0.1:1111/posts/post-2/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":10.63014581273465},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":5.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":10.816653826391969},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":4.242640687119285},"http://127.0.0.1:1111/rust/chapter2/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":9.695359714832659},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":4.123105625617661}},"df":11,"(":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}},"i":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.8284271247461903}},"df":2}},"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}},"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"z":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.0}},"df":2}}},"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4}}}},"x":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4}},"_":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"_":{"docs":{},"df":0,"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.449489742783178}},"df":2}}}}}}}}}}}}},"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}},"f":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}},"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":2}}},"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}},"s":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.358898943540674},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.1622776601683795}},"df":2,"e":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"z":{"docs":{},"df":0,"e":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"t":{"docs":{},"df":0,"w":{"docs":{},"df":0,"e":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}},"y":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"z":{"docs":{},"df":0,"e":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"w":{"docs":{},"df":0,"s":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"t":{"docs":{},"df":0,"w":{"docs":{},"df":0,"e":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"w":{"docs":{},"df":0,"s":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"t":{"docs":{},"df":0,"w":{"docs":{},"df":0,"e":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{},"df":0,"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}},"o":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"f":{"docs":{},"df":0,"y":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"z":{"docs":{},"df":0,"e":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"y":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"z":{"docs":{},"df":0,"e":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/posts/post-1/":{"tf":1.0}},"df":1}}}}}},"t":{"docs":{},"df":0,"y":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.47213595499958},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.4641016151377544}},"df":2}}}},"x":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":8.06225774829855},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":4.58257569495584},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.830951894845301},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":6.082762530298219},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":6,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"m":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772}},"df":4}}}}}}}}},"_":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}},"반":{"docs":{},"df":0,"환":{"docs":{},"df":0,"합":{"docs":{},"df":0,"니":{"docs":{},"df":0,"다":{"docs":{},"df":0,".":{"docs":{},"df":0,"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}},"h":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1},"l":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}},"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":4,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}},"k":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}},"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}},"g":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772}},"df":1,"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.385164807134504},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":4.123105625617661},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":8}}}}},"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.291502622129181},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":5.291502622129181}},"df":2},"s":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1},"l":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.449489742783178}},"df":1}},"t":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}},"o":{"docs":{},"df":0,"_":{"docs":{},"df":0,"d":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}},"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}},"t":{"docs":{},"df":0,"y":{"docs":{},"df":0,"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"_":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.4142135623730951}},"df":1}}}}}}}}}}},"b":{"docs":{},"df":0,"o":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.4641016151377544}},"df":2}}}},"d":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":6.557438524302},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.3166247903554}},"df":2}},"n":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.0},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":6,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"m":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}}}},"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"m":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}}}}}}}},"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.242640687119285},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.196152422706632},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":4.358898943540674},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":6.4031242374328485},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":5.291502622129181}},"df":7,"x":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}}}}},"z":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":3}}}}},"r":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":4}}}},"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":3}},"e":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":7.937253933193772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":5.0990195135927845},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.916079783099616},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":4.242640687119285},"http://127.0.0.1:1111/rust/chapter2/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":7.681145747868608},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":4.123105625617661}},"df":13},"f":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":2}}}}},"h":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":5},"i":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":3},"f":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2},"y":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2}}}}},"(":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}},"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2,".":{"docs":{},"df":0,"s":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"(":{"docs":{},"df":0,"'":{"docs":{},"df":0,".":{"docs":{},"df":0,"'":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"t":{"docs":{},"df":0,"(":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"(":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}}},"`":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"m":{"docs":{},"df":0,"b":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1}}}},"w":{"docs":{"http://127.0.0.1:1111/about/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":10.63014581273465},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":6.244997998398398},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":8.06225774829855},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":6,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1}}}}},"s":{"docs":{},"df":0,"/":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}}}},"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.385164807134504},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":5.5677643628300215}},"df":6,"a":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.0}},"df":1},"’":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}},"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.123105625617661},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":4.123105625617661},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter2/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":7,"_":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2}}},"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2},"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"_":{"docs":{},"df":0,"o":{"docs":{},"df":0,"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0}},"df":2}}}}}}}}}},"b":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":8.774964387392123},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":6.6332495807108},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":7.874007874011811},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter2/":{"tf":4.58257569495584},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":5.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":8.660254037844387},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":4.242640687119285}},"df":10,"_":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.8284271247461903}},"df":2}}}}}}}},"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":4}}},"n":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.8284271247461903}},"df":1,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"/":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1}}}}}}}}}}}},"x":{"docs":{},"df":0,"d":{"docs":{},"df":0,"l":{"docs":{},"df":0,"_":{"docs":{},"df":0,"1":{"docs":{},"df":0,"9":{"docs":{},"df":0,"o":{"docs":{},"df":0,"q":{"docs":{},"df":0,"w":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}}}}}}}}}},"o":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.0}},"df":1,"(":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}},"b":{"docs":{},"df":0,"e":{"docs":{},"df":0,"y":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}},"j":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.58257569495584},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":7,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}},".":{"docs":{},"df":0,"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}},"s":{"docs":{},"df":0,".":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{},"df":0,"m":{"docs":{},"df":0,"l":{"docs":{},"df":0,"#":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1}}}}}}}}},"’":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}},"s":{"docs":{},"df":0,"c":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}},"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"v":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1}}}},"v":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}}}}},"c":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":2}}}}},"u":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.358898943540674},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.0}},"df":6,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":1}}}},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}},"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"0":{"docs":{},"df":0,"o":{"docs":{},"df":0,"7":{"docs":{},"df":0,"7":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1}}}}}},"o":{"docs":{},"df":0,"b":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1}}},"u":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1}}}}}}}},"d":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2},"i":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1}}},"f":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772}},"df":1,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":4}},"i":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":1,"i":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.0}},"df":1}}}},"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}},"h":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3},"k":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":9.433981132056603},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":9.433981132056603},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter2/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.58257569495584},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":4.0}},"df":7,"(":{"docs":{},"df":0,"_":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4},"a":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772}},"df":2}},"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"f":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0}},"df":2}}}}}},"f":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2},"i":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2}}},"j":{"docs":{},"df":0,"o":{"docs":{},"df":0,"b":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772}},"df":2}}},"n":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":5}}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":3},"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2}}}}}}}},"\\":{"docs":{},"df":0,"r":{"docs":{},"df":0,"\\":{"docs":{},"df":0,"n":{"docs":{},"df":0,"\\":{"docs":{},"df":0,"r":{"docs":{},"df":0,"\\":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}},"_":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}},"a":{"docs":{},"df":0,"y":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4}},"및":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}},"l":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907}},"df":2,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":2}}}},"m":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4}}},"n":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.0},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":11.61895003862225},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":9.746794344808963},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":11.789826122551595},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":9,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.5677643628300215},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":5},"e":{"docs":{},"df":0,"_":{"docs":{},"df":0,"b":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2,".":{"docs":{},"df":0,"p":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{},"df":0,"(":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"f":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"(":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"h":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0}},"df":2}}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}},"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":2}},"y":{"docs":{},"df":0,"_":{"docs":{},"df":0,"b":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}},"s":{"docs":{},"df":0,"c":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1}}}}}},"t":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178}},"df":2}},"w":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}},"o":{"docs":{},"df":0,"p":{"docs":{},"df":0,".":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{},"df":0,"m":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1}}}}}}},"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.123105625617661},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":7},"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":7.14142842854285},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":7.211102550927978},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":9.433981132056603},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":6,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}}}},"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":3,"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":2}}}}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":4,"i":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0}},"df":3},"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/docs/config-options/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.656854249492381},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.47213595499958},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":7.874007874011811},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":4.47213595499958}},"df":10,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"i":{"docs":{},"df":0,"3":{"docs":{},"df":0,"2":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"f":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"r":{"docs":{},"df":0,"c":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}},"t":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}},"v":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}},"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}},"i":{"docs":{},"df":0,"3":{"docs":{},"df":0,"2":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.6457513110645907}},"df":4}}}}},"8":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2}}}}},"j":{"docs":{},"df":0,"o":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"(":{"docs":{},"df":0,")":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}}}}}}}}}}}}}}},"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,"s":{"docs":{},"df":0,"c":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"j":{"docs":{},"df":0,"o":{"docs":{},"df":0,"b":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}}},"r":{"docs":{},"df":0,"c":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}}},"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"f":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":4}}}}}}}}}}}},"h":{"docs":{},"df":0,"i":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}},"t":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.605551275463989}},"df":6,";":{"docs":{},"df":0,"6":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}},"h":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"j":{"docs":{},"df":0,"o":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"(":{"docs":{},"df":0,")":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}},":":{"docs":{},"df":0,":":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}},"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}},"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"w":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}},"_":{"docs":{},"df":0,"f":{"docs":{},"df":0,"6":{"docs":{},"df":0,"4":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"(":{"docs":{},"df":0,"5":{"docs":{},"df":0,".":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}},"i":{"docs":{},"df":0,"3":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"(":{"docs":{},"df":0,"5":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}},"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"c":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"p":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}}},"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"f":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}},"r":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"b":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"x":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}},"_":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}},"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":4}}},"b":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"x":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1}}}}}},"c":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0}},"df":1}}},"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0}},"df":2,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/docs/config-options/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.0},"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter2/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.385164807134504},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":10,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2},"2":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"e":{"docs":{},"df":0,"q":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":2.23606797749979}},"df":1}}},"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":3.0}},"df":1}}}}},"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":2.449489742783178}},"df":1}}}}}}}}}}},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}},"특":{"docs":{},"df":0,"성":{"docs":{},"df":0,"은":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{},"df":0,"및":{"docs":{},"df":0,"e":{"docs":{},"df":0,"q":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}},"g":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.0}},"df":3,"i":{"docs":{},"df":0,"z":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}}}}},"i":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":3}}},"g":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":7}}}},"p":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}}}}},"s":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":4,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}},"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":4,".":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2},"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":4}}}}}},"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4},"w":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":4}}}}},"x":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}},"_":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}}}}}},"w":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178}},"df":3}}}}}}},"u":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2}}}}},"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"v":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":2}}}}},"t":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":10.908712114635714},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":7.483314773547883},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.656854249492381},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":9.591663046625438},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.7416573867739413}},"df":9,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}},"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.3166247903554}},"df":4}},"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1,"e":{"docs":{},"df":0,"_":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0}},"df":2,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}},"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":4.0}},"df":2}}}}}}},"v":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":4}}},"p":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":3.605551275463989},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":8.831760866327848},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.242640687119285},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.291502622129181}},"df":8,".":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}},"t":{"docs":{},"df":0,"x":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.1622776601683795}},"df":2}}}}}}},"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907}},"df":3}}},"w":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}}}}},"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.385164807134504},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":7,"a":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":3}},"f":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"_":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1}}}}}}}},"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907}},"df":1}}}},"k":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}},"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":3}},"o":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.4641016151377544}},"df":2}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}},"i":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":5}}},"v":{"docs":{},"df":0,"i":{"docs":{},"df":0,"e":{"docs":{},"df":0,"w":{"docs":{"http://127.0.0.1:1111/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":2}}}},"w":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2}}}},"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":4,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}}}}}}}}}},"w":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":5,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.242640687119285},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178}},"df":2,"s":{"docs":{},"df":0,"h":{"docs":{},"df":0,"i":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":9.219544457292887},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":8.831760866327848},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/to do/chapter4/":{"tf":1.0},"http://127.0.0.1:1111/rust/to do/chapter4/1-what-is-ownership/":{"tf":1.0}},"df":11}}}}}}}}},"p":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":6,".":{"docs":{},"df":0,"x":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}},"1":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2,".":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"p":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}},"m":{"docs":{},"df":0,"i":{"docs":{},"df":0,"x":{"docs":{},"df":0,"u":{"docs":{},"df":0,"p":{"docs":{},"df":0,"(":{"docs":{},"df":0,"p":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}},"2":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2},"3":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2,".":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2},"x":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}},"a":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2,"c":{"docs":{},"df":0,"k":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":6.164414002968976},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":6.324555320336759},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":8,"e":{"docs":{},"df":0,"’":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":1}}}}}},"g":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/docs/config-options/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.0},"http://127.0.0.1:1111/posts/post-2/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.3166247903554}},"df":6,"'":{"docs":{"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.7320508075688772}},"df":1}},"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.4142135623730951}},"df":1}}},"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}},"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907}},"df":3,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"t":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.23606797749979}},"df":2}}}}}}}}}},"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.4641016151377544}},"df":2,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"_":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}}}}}}}}}},"e":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772}},"df":1}}}}},"i":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":7.681145747868608},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":4.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.47213595499958},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":9.055385138137417},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":5.5677643628300215}},"df":7,"!":{"docs":{},"df":0,"(":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}},"g":{"docs":{},"df":0,"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}}}}},"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}},"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}},"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979}},"df":1}}}}}}}},"`":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}},"g":{"docs":{},"df":0,"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}},"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1}}},"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1}}},"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.23606797749979}},"df":1}}}}}}}}},"1":{"docs":{},"df":0,"4":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}},".":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{},"df":0,"m":{"docs":{},"df":0,"l":{"docs":{},"df":0,"#":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":1}}}}}}}},":":{"docs":{},"df":0,":":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}},"k":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.6457513110645907}},"df":8}}},"o":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.7320508075688772}},"df":1}}}}},"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}},"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":6.782329983125268},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":8.366600265340756},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":13.490737563232042},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.8284271247461903}},"df":7,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1,"’":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}}}}}}},"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":6.4031242374328485},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.69041575982343}},"df":4,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979}},"df":4}}},"’":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}},"k":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.7320508075688772}},"df":1},"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.123105625617661},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter2/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":8,"e":{"docs":{},"df":0,"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"f":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.47213595499958},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":4.47213595499958}},"df":2,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}},"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}}},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0}},"df":1}}}}}}}},"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3}}},"t":{"docs":{"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":7.0710678118654755},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":6.928203230275509},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":7.681145747868608},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":5,"i":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":3,"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772}},"df":2}}}},"e":{"docs":{},"df":0,"q":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.1622776601683795}},"df":4,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"{":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"}":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}},"r":{"docs":{},"df":0,"h":{"docs":{},"df":0,"s":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}},"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":4,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}},"c":{"docs":{},"df":0,"i":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.0}},"df":1}},"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.242640687119285},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.58257569495584},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.5677643628300215}},"df":3,"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}}}}}}}}}},"s":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":12.922847983320086},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":8.06225774829855},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.898979485566356},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":6.164414002968976}},"df":6},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":2}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2,"\"":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}}},"h":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.358898943540674},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":10.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.8284271247461903}},"df":9,"\"":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}},"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,".":{"docs":{},"df":0,".":{"docs":{},"df":0,".":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"s":{"docs":{},"df":0,"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"i":{"docs":{},"df":0,"f":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}},":":{"docs":{},"df":0,":":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,".":{"docs":{},"df":0,".":{"docs":{},"df":0,".":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}}}}}}}},"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}},"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":15.968719422671311},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":4.69041575982343},"http://127.0.0.1:1111/rust/chapter22/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":8.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":7,"’":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}},"u":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979}},"df":1}},"y":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}}},"c":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772}},"df":2},"d":{"docs":{},"df":0,"b":{"docs":{"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":1.0}},"df":1}},"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/":{"tf":1.0}},"df":1}}}}},"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2}}}},"g":{"docs":{},"df":0,"u":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2}}}},"n":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":2}},"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}},"o":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.23606797749979}},"df":5,"e":{"docs":{},"df":0,"’":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}},"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":4,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1,"a":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"_":{"docs":{},"df":0,"o":{"docs":{},"df":0,"f":{"docs":{},"df":0,"_":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"x":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0}},"df":2}}}}}}}}}}}}}},"f":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3,"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3}}}}},"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.916079783099616},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.58257569495584},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":6}}}},"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}}},"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}},"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1}},"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/posts/post-2/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":3}}}},"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}},"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/posts/post-2/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979}},"df":5,".":{"docs":{},"df":0,"f":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772}},"df":2}}}},"’":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}},"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}},"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}},"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":1}}}}},"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1}}}}}},"o":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0}},"df":1}}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}},"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2,"c":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":4}},"e":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1,"/":{"docs":{},"df":0,"d":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"g":{"docs":{},"df":0,"h":{"docs":{},"df":0,"n":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}}}}}}}},"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.7416573867739413}},"df":3}},"g":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1},"k":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}}}},"l":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1},"o":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0}},"df":2,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"f":{"docs":{},"df":0,"l":{"docs":{},"df":0,"y":{"docs":{},"df":0,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}},"n":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0}},"df":1,"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}}},"p":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":2}},"q":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}},"t":{"docs":{},"df":0,"t":{"docs":{},"df":0,"s":{"docs":{},"df":0,"b":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{},"df":0,"g":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}},"x":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.23606797749979}},"df":2}}}},"k":{"docs":{},"df":0,".":{"docs":{},"df":0,"e":{"docs":{},"df":0,"y":{"docs":{},"df":0,"j":{"docs":{},"df":0,"1":{"docs":{},"df":0,"i":{"docs":{},"df":0,"j":{"docs":{},"df":0,"o":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"m":{"docs":{},"df":0,"f":{"docs":{},"df":0,"0":{"docs":{},"df":0,"y":{"docs":{},"df":0,"w":{"docs":{},"df":0,"5":{"docs":{},"df":0,"z":{"docs":{},"df":0,"a":{"docs":{},"df":0,"h":{"docs":{},"df":0,"j":{"docs":{},"df":0,"l":{"docs":{},"df":0,"c":{"docs":{},"df":0,"2":{"docs":{},"df":0,"h":{"docs":{},"df":0,"0":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"c":{"docs":{},"df":0,"j":{"docs":{},"df":0,"h":{"docs":{},"df":0,"i":{"docs":{},"df":0,"j":{"docs":{},"df":0,"o":{"docs":{},"df":0,"i":{"docs":{},"df":0,"y":{"docs":{},"df":0,"2":{"docs":{},"df":0,"t":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"2":{"docs":{},"df":0,"s":{"docs":{},"df":0,"2":{"docs":{},"df":0,"n":{"docs":{},"df":0,"m":{"docs":{},"df":0,"m":{"docs":{},"df":0,"3":{"docs":{},"df":0,"m":{"docs":{},"df":0,"d":{"docs":{},"df":0,"d":{"docs":{},"df":0,"0":{"docs":{},"df":0,"z":{"docs":{},"df":0,"z":{"docs":{},"df":0,"j":{"docs":{},"df":0,"z":{"docs":{},"df":0,"b":{"docs":{},"df":0,"x":{"docs":{},"df":0,"f":{"docs":{},"df":0,"t":{"docs":{},"df":0,"c":{"docs":{},"df":0,"3":{"docs":{},"df":0,"y":{"docs":{},"df":0,"2":{"docs":{},"df":0,"y":{"docs":{},"df":0,"m":{"docs":{},"df":0,"u":{"docs":{},"df":0,"0":{"docs":{},"df":0,"n":{"docs":{},"df":0,"y":{"docs":{},"df":0,"j":{"docs":{},"df":0,"9":{"docs":{},"df":0,".":{"docs":{},"df":0,"0":{"docs":{},"df":0,"r":{"docs":{},"df":0,"h":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"j":{"docs":{},"df":0,"p":{"docs":{},"df":0,"k":{"docs":{},"df":0,"b":{"docs":{},"df":0,"x":{"docs":{},"df":0,"h":{"docs":{},"df":0,"w":{"docs":{},"df":0,"w":{"docs":{},"df":0,"3":{"docs":{},"df":0,"x":{"docs":{},"df":0,"g":{"docs":{},"df":0,"p":{"docs":{},"df":0,"n":{"docs":{},"df":0,"n":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.795831523312719},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.795831523312719},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.291502622129181}},"df":5,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0}},"df":1,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979}},"df":3}}}}}},"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":3}},"n":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":4,"t":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":3}},"t":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":1},"f":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":2}}}}},"y":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":1}}}},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter2/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":6}}},"o":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}},"u":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":3,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.4142135623730951}},"df":1}}},"s":{"docs":{},"df":0,"_":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":3,"e":{"docs":{},"df":0,"(":{"docs":{},"df":0,"5":{"docs":{"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.4142135623730951}},"df":1},"f":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2},"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}},"x":{"docs":{"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":3}}}}}}}}},"o":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979}},"df":1,".":{"docs":{},"df":0,"t":{"docs":{},"df":0,"x":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.47213595499958},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":4.358898943540674}},"df":2}}}}}},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":7.280109889280518},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":8.660254037844387},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":7.14142842854285},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":8.18535277187245},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":4.58257569495584}},"df":9,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"f":{"docs":{},"df":0,"3":{"docs":{},"df":0,"2":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2}}}}}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.1622776601683795}},"df":2,";":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"x":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}},"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":1}}}}}}}}},"x":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2},"2":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}},"(":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2},"i":{"docs":{},"df":0,"3":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}},"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"i":{"docs":{},"df":0,"3":{"docs":{},"df":0,"2":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"x":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"5":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"f":{"docs":{},"df":0,"6":{"docs":{},"df":0,"4":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"y":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"1":{"docs":{},"df":0,"0":{"docs":{},"df":0,".":{"docs":{},"df":0,"4":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"p":{"docs":{},"df":0,"2":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"x":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"y":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"c":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"m":{"docs":{},"df":0,"i":{"docs":{},"df":0,"x":{"docs":{},"df":0,"u":{"docs":{},"df":0,"p":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"p":{"docs":{},"df":0,"1":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"p":{"docs":{},"df":0,"2":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"p":{"docs":{},"df":0,"3":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"i":{"docs":{},"df":0,"3":{"docs":{},"df":0,"2":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"x":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"x":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"p":{"docs":{},"df":0,"1":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"p":{"docs":{},"df":0,"3":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"y":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"y":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"p":{"docs":{},"df":0,"2":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"l":{"docs":{},"df":0,"n":{"docs":{},"df":0,"!":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"p":{"docs":{},"df":0,"3":{"docs":{},"df":0,".":{"docs":{},"df":0,"x":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"x":{"docs":{},"df":0,"1":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"y":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"y":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}},"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":8.774964387392123},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":8.48528137423857},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.0}},"df":4,"—":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}},"’":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}},"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}},"k":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}}}},"l":{"docs":{},"df":0,"s":{"docs":{},"df":0,"k":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}},"o":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":7.745966692414834},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.6457513110645907}},"df":2,".":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.449489742783178}},"df":2}}}}}}},"c":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}},"p":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}},"r":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.0}},"df":1,"a":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.449489742783178}},"df":1},"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":2}}},"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":3.0}},"df":1}}}}},"u":{"docs":{},"df":0,"g":{"docs":{},"df":0,"u":{"docs":{},"df":0,"ê":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1}}}}}},"s":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1},"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907}},"df":3}},"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.385164807134504},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":6.244997998398398},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":5}}}},"t":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":2.0},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.449489742783178},"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0},"http://127.0.0.1:1111/posts/":{"tf":1.0},"http://127.0.0.1:1111/posts/post-1/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":7}},"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4}}}}},"w":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":4,"s":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":4}}}}}}}},"p":{"docs":{},"df":0,"v":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.7320508075688772}},"df":1}},"r":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.0}},"df":1,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178}},"df":3}}}}},"e":{"docs":{"http://127.0.0.1:1111/posts/post-1/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1}}}}},"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":4}},"i":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3}}},"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"f":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}},"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3}}}},"f":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":4}},"i":{"docs":{},"df":0,"x":{"docs":{"http://127.0.0.1:1111/posts/post-1/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":4}}},"l":{"docs":{},"df":0,"u":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":5}}},"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1}}}}},"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":3}}},"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1},"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178}},"df":3}},"r":{"docs":{},"df":0,"v":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}},"s":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":3,"u":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}},"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}}},"i":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.449489742783178}},"df":1}}},"t":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":5,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}}},"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.123105625617661},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.47213595499958}},"df":3}}},"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.69041575982343},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":4.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.898979485566356},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":4.58257569495584}},"df":11,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":4}}}}}},"i":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1,"c":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}},"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2,"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":2}}},"y":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.8284271247461903}},"df":2,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2},"y":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}},"i":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":3}}},"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"i":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2}}}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":9.273618495495704},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":7.745966692414834},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":6.082762530298219},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":5,"!":{"docs":{},"df":0,"(":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}},"f":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"v":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}},"`":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1}}},"f":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"v":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1}}}}}}}},"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"(":{"docs":{},"df":0,"x":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}},"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}},"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"d":{"docs":{},"df":0,"_":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.0}},"df":1,"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"(":{"docs":{},"df":0,"5":{"docs":{"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.0}},"df":1},"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}},"l":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.196152422706632},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":5.196152422706632},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.123105625617661},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":4.123105625617661},"http://127.0.0.1:1111/rust/chapter2/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":6.244997998398398},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":5.916079783099616}},"df":10,"!":{"docs":{},"df":0,"(":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"*":{"docs":{},"df":0,"w":{"docs":{},"df":0,"a":{"docs":{},"df":0,"v":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}},"1":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":1},"a":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979}},"df":2,"b":{"docs":{},"df":0,"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}},"f":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1}},"n":{"docs":{},"df":0,"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}},"y":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1}}}},"p":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}}},"b":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979}},"df":1,"e":{"docs":{},"df":0,"f":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0}},"df":1}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":1}}}}},"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"c":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}},"n":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":1,"\"":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}},"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772}},"df":1}}}},"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}},"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2}}}},"u":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"s":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979}},"df":1}}}}}}}}}}}}}}}},"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"f":{"docs":{},"df":0,"a":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1}}}}}},"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}},"f":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979}},"df":1}}}},"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1}}}},"g":{"docs":{},"df":0,"o":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":3}},"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":2.0}},"df":1}}}}},"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0}},"df":5}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"\"":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.449489742783178}},"df":2}}}},"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":3}},"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1,"'":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1},"m":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}},"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979}},"df":1}},"j":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}},"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2}}},"u":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}},"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1}}}},"o":{"docs":{},"df":0,"v":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}},"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}},"e":{"docs":{},"df":0,"w":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}},"o":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}},"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178}},"df":1}},"p":{"docs":{},"df":0,".":{"docs":{},"df":0,"x":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}},"3":{"docs":{},"df":0,".":{"docs":{},"df":0,"x":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}},"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":2.23606797749979}},"df":1}}}},"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}}}},"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":1,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1},"2":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1},"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":1}}},"q":{"docs":{},"df":0,"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}},"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2}}}}}},"s":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1},"2":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0}},"df":1}}}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}},"h":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178}},"df":1}}},"o":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772}},"df":1,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1}}}}},"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":1}}}},"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}},"h":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.196152422706632}},"df":3,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}},"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1},"r":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1}}},"o":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":3.1622776601683795}},"df":1}},"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"d":{"docs":{},"df":0,"a":{"docs":{},"df":0,"y":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}},"w":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}},"u":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1},"s":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0}},"df":1}},"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}},"w":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772}},"df":1}}},"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178}},"df":1}}}},"x":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3},"y":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1,"o":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":3.4641016151377544}},"df":1}}},"{":{"docs":{},"df":0,"b":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1},"c":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1},"i":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1},"k":{"docs":{},"df":0,"e":{"docs":{},"df":0,"y":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}},"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1}}}}},"`":{"docs":{},"df":0,"*":{"docs":{},"df":0,"w":{"docs":{},"df":0,"a":{"docs":{},"df":0,"v":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1}}}},"1":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":1},"a":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.23606797749979}},"df":2,"b":{"docs":{},"df":0,"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1}}}}}},"f":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":1}},"g":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.0}},"df":1}}}},"n":{"docs":{},"df":0,"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}},"o":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.0}},"df":1}}},"y":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":1}}}},"p":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1}}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":1,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}},"b":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.23606797749979}},"df":1,"e":{"docs":{},"df":0,"f":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0}},"df":1}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":1}}}}},"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"c":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1}}}},"n":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":1,"`":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1}}}},"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772}},"df":1}}}},"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.4142135623730951}},"df":1}}},"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1}}}}},"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.0}},"df":3}}}},"u":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"s":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.23606797749979}},"df":1}}}}}}}}}}}}}}}},"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"f":{"docs":{},"df":0,"a":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":1}}}}}},"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1}}}},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1}}}},"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.0}},"df":1}}},"f":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.23606797749979}},"df":1}}}},"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":1}}}},"g":{"docs":{},"df":0,"o":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}},"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.0}},"df":3}}}},"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":1}},"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1,"'":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1},"m":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}},"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.23606797749979}},"df":1}},"j":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1}}}},"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1}},"i":{"docs":{},"df":0,"f":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"f":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.4142135623730951}},"df":1}}}}}},"u":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}},"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":1}}}},"o":{"docs":{},"df":0,"v":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1}}},"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1}},"e":{"docs":{},"df":0,"w":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}},"o":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1},"u":{"docs":{},"df":0,"m":{"docs":{},"df":0,"b":{"docs":{"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":2.449489742783178}},"df":1}}}},"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.449489742783178}},"df":1}},"p":{"docs":{},"df":0,".":{"docs":{},"df":0,"x":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}},"3":{"docs":{},"df":0,".":{"docs":{},"df":0,"x":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}},"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1}}}},"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1}}}}}}},"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":1,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1},"2":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1},"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":1}}},"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.0}},"df":1}}}},"q":{"docs":{},"df":0,"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1}}}}}}},"s":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1},"2":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0}},"df":1}}}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1}},"h":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.449489742783178}},"df":1}}},"o":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772}},"df":1,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":1}}}}},"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":1}}}},"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1}}},"h":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":5.196152422706632}},"df":6,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}},"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":1},"r":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":1}}},"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"d":{"docs":{},"df":0,"a":{"docs":{},"df":0,"y":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1}}}}}},"w":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1}}},"u":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1},"s":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0}},"df":1}},"w":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":1}}},"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.449489742783178}},"df":1}}}},"x":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2},"y":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1},"{":{"docs":{},"df":0,"b":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1},"c":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1},"i":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1},"k":{"docs":{},"df":0,"e":{"docs":{},"df":0,"y":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}},"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":1}}},"n":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{},"df":0,"b":{"docs":{"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.4142135623730951}},"df":1}}}}}},"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":1}}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}},"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"2":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"'":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}},"s":{"docs":{},"df":0,"_":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"_":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"_":{"docs":{},"df":0,"1":{"docs":{},"df":0,"0":{"docs":{},"df":0,"(":{"docs":{},"df":0,"4":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2},"8":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2},"a":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}},"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1,"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}},"v":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.0}},"df":4}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":6.082762530298219},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.1622776601683795}},"df":4}},"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}},"o":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1,"b":{"docs":{},"df":0,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.23606797749979}},"df":4}}},"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.916079783099616},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":6.928203230275509},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.3166247903554}},"df":5,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}},"c":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2,"_":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.449489742783178}},"df":2,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"k":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}},"_":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"b":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}},"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2,"i":{"docs":{},"df":0,"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"(":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}}},"e":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":1,"d":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":6.082762530298219},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}}},"s":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.242640687119285},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.477225575051661},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.4641016151377544}},"df":5,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2,"(":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.6457513110645907}},"df":2}}}}}}}},"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":2}}}}}},"d":{"docs":{},"df":0,"u":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.358898943540674},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":4,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":5}}}},"f":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.69041575982343},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":6,"e":{"docs":{},"df":0,".":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"v":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4}}}}}}}}}},"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}},"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":11.489125293076057},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":6.708203932499369},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter3/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":10.63014581273465},"http://127.0.0.1:1111/rust/to do/chapter5/2-an-example-program-using-structs/":{"tf":1.0}},"df":9,"m":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.123105625617661}},"df":5},"’":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":3}}},"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772}},"df":2}}}}},"j":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":7.0710678118654755},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":6.164414002968976},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.0990195135927845},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.449489742783178}},"df":9,"/":{"docs":{},"df":0,"s":{"docs":{},"df":0,"r":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}},"s":{"docs":{},"df":0,"/":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"_":{"docs":{},"df":0,"w":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"l":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":1.0}},"df":1}}}}}}}}}}},"n":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}},"’":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3}}}}},"m":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2}},"o":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1}},"p":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}},"n":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":3}},"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178}},"df":2}},"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}},"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2,"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":3}},"t":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979}},"df":3}}}},"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0}},"df":1}},"s":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0}},"df":1}}},"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":3}}},"o":{"docs":{"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":1.0}},"df":1,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}},"t":{"docs":{},"df":0,"y":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":2}}}}},"v":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0}},"df":1,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}},"i":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.23606797749979},"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":6.782329983125268},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.916079783099616},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":6.708203932499369}},"df":6}}}}},"s":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}},"e":{"docs":{},"df":0,"u":{"docs":{},"df":0,"d":{"docs":{},"df":0,"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}}}}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0}},"df":2}},"u":{"docs":{},"df":0,"b":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":8.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":7.937253933193772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.916079783099616},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":5.916079783099616},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":9.797958971132712},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":9.797958971132712}},"df":6,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.47213595499958},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":7.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":5,"_":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"p":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/posts/post-2/":{"tf":1.0}},"df":1}}}}}},"s":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/about/":{"tf":1.0},"http://127.0.0.1:1111/posts/post-2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.656854249492381},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772}},"df":5}}}}},"l":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2,"d":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/":{"tf":1.0}},"df":1}}}}}},"p":{"docs":{},"df":0,"p":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}},"r":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":4},"o":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.123105625617661},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903}},"df":3}}},"u":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1}},"s":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/posts/post-2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.449489742783178}},"df":6,"_":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.449489742783178}},"df":2}}}}}},"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.795831523312719},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.0}},"df":5}},"y":{"docs":{"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":1.0}},"df":1,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":1.4142135623730951}},"df":1}}}}}},"q":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2,"l":{"docs":{},"df":0,"p":{"docs":{},"df":0,"_":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{},"df":0,"i":{"docs":{},"df":0,"f":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0}},"df":2}}}}}}}},"u":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"f":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}},"t":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}},"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0}},"df":1}}}},"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.8284271247461903}},"df":2,"(":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}},"’":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}}},"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":8.426149773176359},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":6.782329983125268}},"df":2},"y":{"docs":{},"df":0,".":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"_":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":2}}}}},"u":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.6457513110645907}},"df":1}}},"i":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1,"c":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":2,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":3}},"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":3}}}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":7,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}},"o":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.6457513110645907}},"df":4,"a":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2},"e":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"q":{"docs":{},"df":0,"u":{"docs":{},"df":0,"o":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}},"i":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1}}}}}}}},"r":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.123105625617661},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":4.123105625617661},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.69041575982343},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":4.358898943540674}},"df":7,"#":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"(":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"e":{"docs":{},"df":0,"d":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}},"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}},".":{"docs":{},"df":0,"s":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"_":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"_":{"docs":{},"df":0,"m":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{},"df":0,"(":{"docs":{},"df":0,"3":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}},"w":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0}},"df":2}}}}}},"1":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":4.0}},"df":4},"2":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.605551275463989}},"df":4},"3":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.6457513110645907}},"df":2},"\\":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.4142135623730951}},"df":3,"\\":{"docs":{},"df":0,"r":{"docs":{},"df":0,"\\":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}},"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}},"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979}},"df":3}},"d":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.0}},"df":1}}},"i":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}},"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}},"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.795831523312719},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":4.795831523312719},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter2/":{"tf":4.795831523312719},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.0}},"df":7,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"r":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":3}}},"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"_":{"docs":{},"df":0,"r":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":3,"(":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"_":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"(":{"docs":{},"df":0,"1":{"docs":{},"df":0,".":{"docs":{},"df":0,".":{"docs":{},"df":0,"=":{"docs":{},"df":0,"1":{"docs":{},"df":0,"0":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":3}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.7320508075688772}},"df":1}}}}},"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.7320508075688772}},"df":1}}}},"o":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":3}}},"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.7416573867739413}},"df":4,"e":{"docs":{},"df":0,"f":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}},"u":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}},"t":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}},"k":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1}},"r":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":3}},"t":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1},"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}}},"w":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":6.782329983125268},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":3}},"b":{"docs":{"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":1.0}},"df":1},"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":10.344080432788601},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":10.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":4,"\"":{"docs":{},"df":0,"b":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1,".":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"d":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}},"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1}}}}},"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}},"m":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":1,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772}},"df":1}},"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"i":{"docs":{},"df":0,"3":{"docs":{},"df":0,"2":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2}}}}}}}}}}}}}}}}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"f":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1,"l":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}},":":{"docs":{},"df":0,":":{"docs":{},"df":0,"c":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.0}},"df":2,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.6457513110645907}},"df":2},"b":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2},"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}},"d":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0}},"df":2,"e":{"docs":{},"df":0,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"b":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}}}}}}}}}}}}},"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"w":{"docs":{},"df":0,"(":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"(":{"docs":{},"df":0,"1":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2}},"5":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2},"r":{"docs":{},"df":0,"c":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"c":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}}},"m":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"w":{"docs":{},"df":0,"(":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}},"n":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2}},"o":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.449489742783178}},"df":2}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"f":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"w":{"docs":{},"df":0,"(":{"docs":{},"df":0,"5":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.6457513110645907}},"df":2},"b":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}},"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2}}}}}}}}}}}}}}}}}}}}}},"w":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"k":{"docs":{},"df":0,"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"b":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}},"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2}}}}}}}}}}}}}}}}}}}}}},"a":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1},"유":{"docs":{},"df":0,"형":{"docs":{},"df":0,"은":{"docs":{},"df":0,"w":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"k":{"docs":{},"df":0,"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}},"인":{"docs":{},"df":0,"스":{"docs":{},"df":0,"턴":{"docs":{},"df":0,"스":{"docs":{},"df":0,"는":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}},"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":3,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3}},"d":{"docs":{"http://127.0.0.1:1111/posts/post-2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.477225575051661},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.477225575051661},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter2/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":6.557438524302},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.23606797749979}},"df":9,"_":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":2.8284271247461903}},"df":1,"e":{"docs":{},"df":0,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"m":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":2}}}}}}}}}}}}},"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"_":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.0}},"df":2}}}}}},"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"_":{"docs":{},"df":0,"f":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"_":{"docs":{},"df":0,"f":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.6457513110645907}},"df":2}}}}}}}}}}}}}}}}}},"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":3}}},"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}},"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":3},"m":{"docs":{"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":3}},"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3,"f":{"docs":{},"df":0,"a":{"docs":{},"df":0,"v":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0}},"df":1}}}}}}}}}}}},"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2}},"t":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}},"z":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1}},"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979}},"df":3}}},"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}}}}},"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.58257569495584},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.58257569495584},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.196152422706632}},"df":4,"—":{"docs":{},"df":0,"f":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}}}}},"b":{"docs":{},"df":0,"u":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}},"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.0}},"df":3},"p":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3}},"e":{"docs":{},"df":0,"i":{"docs":{},"df":0,"v":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.477225575051661},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":8.246211251235321},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":4.58257569495584},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903}},"df":5,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,".":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{},"df":0,"(":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"w":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{},"df":0,"(":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"v":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772}},"df":2,"(":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"w":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"—":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}}}}},"o":{"docs":{},"df":0,"g":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":2,"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}},"m":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}},"p":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}},"r":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1}},"v":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907}},"df":1,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979}},"df":1}}}},"t":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.898979485566356},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":4.898979485566356}},"df":2,".":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}},"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"_":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"d":{"docs":{},"df":0,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2},"3":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}},"w":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2}}}}}}},"2":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.449489742783178}},"df":2},"3":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":2},"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":6.4031242374328485},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":6.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":9.433981132056603},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":8.426149773176359}},"df":4,"e":{"docs":{},"df":0,".":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}},"w":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}},":":{"docs":{},"df":0,":":{"docs":{},"df":0,"s":{"docs":{},"df":0,"q":{"docs":{},"df":0,"u":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"(":{"docs":{},"df":0,"3":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}},"i":{"docs":{},"df":0,"f":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}},"u":{"docs":{},"df":0,"r":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.196152422706632},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}},"v":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.23606797749979}},"df":4}},"d":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":5,"e":{"docs":{},"df":0,"f":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.0}},"df":1}}}},"i":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907}},"df":1}}}}},"u":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979}},"df":3},"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":1}}}},"f":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":4,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":3}}}}},"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":7.681145747868608},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":7.211102550927978}},"df":2,"l":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"/":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"r":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}},"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"r":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":1,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}},"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}},"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0}},"df":1,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}},"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"r":{"docs":{},"df":0,"c":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}}}}}}}}}}}}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}},"w":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"k":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1}},"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}},"약":{"docs":{},"df":0,"함":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1}}}}}}}}},":":{"docs":{},"df":0,":":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"w":{"docs":{},"df":0,"(":{"docs":{},"df":0,"r":{"docs":{},"df":0,"c":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"c":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}},"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"w":{"docs":{},"df":0,"(":{"docs":{},"df":0,"n":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}},"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0}},"df":2,"!":{"docs":{},"df":0,"[":{"docs":{},"df":0,"r":{"docs":{},"df":0,"c":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"c":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2}}}}}}}}}}}}}}}}}}}}}}}},"w":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"k":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"w":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0}},"df":2}}}}}}}}}}}}}}}}}}},"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":15.459624833740307},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":6.6332495807108},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter22/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":16.55294535724685},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":4.242640687119285},"http://127.0.0.1:1111/rust/to do/chapter4/2-references-and-borrowing/":{"tf":1.0}},"df":10,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178}},"df":4,"e":{"docs":{},"df":0,"_":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"_":{"docs":{},"df":0,"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}},"’":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":1}}}}}}},"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}},"m":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.23606797749979}},"df":2}}},"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1}}}}},"u":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":2},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.242640687119285},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"y":{"docs":{},"df":0,".":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{},"df":0,"m":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}},"g":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":2,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}}}}}}},"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1,"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772}},"df":1}}}},"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":4,"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":1}}}}}}},"i":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}}}}}},"j":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":3}}}},"l":{"docs":{"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.358898943540674},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":4,"=":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"y":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/posts/post-1/":{"tf":2.6457513110645907}},"df":1}}}}}}}}}}}},"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.795831523312719},"http://127.0.0.1:1111/rust/to do/chapter5/":{"tf":1.0}},"df":5,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{},"df":0,"i":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.0}},"df":3}}}}}}}},"x":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.898979485566356},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":6.855654600401044},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":9}},"v":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":3}},"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":3,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}}}}},"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.1622776601683795}},"df":4,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.4142135623730951}},"df":3,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}}}}},"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"b":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907}},"df":3}}},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":3}}},"o":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2},"v":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.1622776601683795}},"df":5,"e":{"docs":{},"df":0,"_":{"docs":{},"df":0,"f":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"y":{"docs":{},"df":0,"_":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.449489742783178}},"df":2}}}}}}}}}}}}}},"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":3}},"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":4.0},"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772}},"df":5}}}},"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"g":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}}}}},"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":3,"(":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0}},"df":2}}}},"e":{"docs":{},"df":0,"d":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2}}}}}},"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979}},"df":3}}}},"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":6}},"i":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.23606797749979}},"df":2}},"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":3}},"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772}},"df":3}}}}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.872983346207417}},"df":5,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178}},"df":5}}}}},"o":{"docs":{},"df":0,"d":{"docs":{},"df":0,"u":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}}},"u":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}},"q":{"docs":{},"df":0,"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":11.704699910719626},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.0}},"df":4,"_":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.449489742783178}},"df":2}}}},"’":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}},"i":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.477225575051661},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":6.324555320336759},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.0}},"df":5}}}},"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}},"u":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.3166247903554}},"df":2}}},"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1}}}},"r":{"docs":{},"df":0,"v":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2}},"i":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2},"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":1}},"z":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}},"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"v":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":5}},"u":{"docs":{},"df":0,"r":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":4}}}},"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":3}}},"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":4},"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":7.3484692283495345},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":4}}}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178}},"df":3,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}},"u":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.898979485566356},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.0}},"df":3,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"f":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"_":{"docs":{},"df":0,"o":{"docs":{},"df":0,"f":{"docs":{},"df":0,"_":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"d":{"docs":{},"df":0,"_":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"_":{"docs":{},"df":0,"w":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"d":{"docs":{},"df":0,"_":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"_":{"docs":{},"df":0,"w":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4}}},"u":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}}},"y":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"(":{"docs":{},"df":0,"2":{"docs":{},"df":0,"0":{"docs":{},"df":0,"1":{"docs":{},"df":0,"7":{"docs":{"http://127.0.0.1:1111/about/":{"tf":1.0}},"df":1}}}}}}}}}}},"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":12.165525060596439},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":8.54400374531753},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.385164807134504},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter2/":{"tf":4.898979485566356},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":11.090536506409418},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":7.681145747868608}},"df":11,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.23606797749979}},"df":6,";":{"docs":{},"df":0,"(":{"docs":{},"df":0,")":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772}},"df":2}}}}},"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"f":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.449489742783178}},"df":2}}}}}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.23606797749979}},"df":4}}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.4641016151377544}},"df":6,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}},"h":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}},"u":{"docs":{},"df":0,"8":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2},"s":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2,"i":{"docs":{},"df":0,"z":{"docs":{},"df":0,"e":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}},".":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"_":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}}}}}},"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"(":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}}},"\\":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}}},"`":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1}}}}}}},"`":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}},"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"w":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772}},"df":2}}}}}}},"9":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1},":":{"docs":{},"df":0,":":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"w":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}},"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"?":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"o":{"docs":{},"df":0,"p":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"o":{"docs":{},"df":0,"p":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"?":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"o":{"docs":{},"df":0,"p":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"t":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"?":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"o":{"docs":{},"df":0,"p":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"o":{"docs":{},"df":0,"p":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"?":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"o":{"docs":{},"df":0,"p":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"o":{"docs":{},"df":0,"k":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"o":{"docs":{},"df":0,"k":{"docs":{},"df":0,"_":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"o":{"docs":{},"df":0,"p":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"1":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"1":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"1":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"l":{"docs":{},"df":0,"n":{"docs":{},"df":0,"!":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"2":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"l":{"docs":{},"df":0,"n":{"docs":{},"df":0,"!":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}},"s":{"docs":{},"df":0,".":{"docs":{},"df":0,"p":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{},"df":0,"(":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2}}}}}}}}}}}}}},"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":1}}},"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2,"e":{"docs":{},"df":0,"v":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":2}}}},"u":{"docs":{},"df":0,"r":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":13.076696830622021},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":9.486832980505138},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":16.186414056238647},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":5.0990195135927845}},"df":7,"s":{"docs":{},"df":0,"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0}},"df":2}}}}}},"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"_":{"docs":{},"df":0,"t":{"docs":{},"df":0,"y":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}},"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"z":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"(":{"docs":{},"df":0,"s":{"docs":{},"df":0,"w":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}}},"w":{"docs":{},"df":0,"e":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.23606797749979}},"df":2}}}}},"u":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":2}},"v":{"docs":{"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.0}},"df":1,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}},"r":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2}}},"i":{"docs":{},"df":0,"e":{"docs":{},"df":0,"w":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":3}}},"o":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}},"w":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1}}},"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":2,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}}}}},"f":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772}},"df":2,"(":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"q":{"docs":{},"df":0,"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1}}}}}}}}}},"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2,"b":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2,"(":{"docs":{},"df":0,"i":{"docs":{},"df":0,"3":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}},"h":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.1622776601683795}},"df":2,"s":{"docs":{},"df":0,"=":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}},"i":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1}},"g":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.47213595499958},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907}},"df":6,"f":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}},"i":{"docs":{},"df":0,"d":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}},"p":{"docs":{},"df":0,"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.1622776601683795}},"df":2}}}}},"s":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":3}},"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907}},"df":1}}}},"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}},"n":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":3}},"o":{"docs":{},"df":0,"b":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979}},"df":2}}}},"c":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1}},"l":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":2,"=":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"v":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/posts/post-1/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}},"l":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907}},"df":1}},"o":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2},"t":{"docs":{"http://127.0.0.1:1111/posts/post-2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.916079783099616}},"df":4,"’":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}},"u":{"docs":{},"df":0,"g":{"docs":{},"df":0,"h":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}},"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":3,"e":{"docs":{},"df":0,"(":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}},"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}},"i":{"docs":{},"df":0,"p":{"docs":{},"df":0,"_":{"docs":{},"df":0,"k":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}},"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"d":{"docs":{},"df":0,"r":{"docs":{},"df":0,"k":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"v":{"docs":{},"df":0,"4":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2},"6":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}},"w":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":3}},"s":{"docs":{"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2},"u":{"docs":{},"df":0,"b":{"docs":{},"df":0,"b":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979}},"df":1}}},"i":{"docs":{"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.0}},"df":3}},"l":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0},"http://127.0.0.1:1111/rust/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":6.4031242374328485},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":7.937253933193772}},"df":6}},"n":{"docs":{"http://127.0.0.1:1111/posts/post-2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":20.42057785666214},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":14.071247279470288},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":9.695359714832659},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":5.5677643628300215},"http://127.0.0.1:1111/rust/chapter2/":{"tf":4.242640687119285},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":4.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":9.273618495495704},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":6.557438524302}},"df":14,"(":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"f":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.8284271247461903}},"df":2}}}}}}},"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1}}},"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1}}},"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.196152422706632},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.0}},"df":3}}}},"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/":{"tf":1.0},"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/":{"tf":7.0},"http://127.0.0.1:1111/rust/chapter1/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":4.58257569495584},"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":5.385164807134504},"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":4.123105625617661},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":12.884098726725126},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":13.74772708486752},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":14.933184523068078},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":15.132745950421556},"http://127.0.0.1:1111/rust/chapter2/":{"tf":5.385164807134504},"http://127.0.0.1:1111/rust/chapter22/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter3/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":5.744562646538029},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter3/4-comments/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":13.784048752090222},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":14.106735979665885}},"df":21,"\"":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1},"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"/":{"docs":{},"df":0,"p":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}},"/":{"docs":{},"df":0,"_":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,".":{"docs":{},"df":0,"m":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/posts/post-1/":{"tf":1.0}},"df":1}}}}}}}}}},"_":{"docs":{},"df":0,"b":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":4,"e":{"docs":{},"df":0,"=":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.23606797749979}},"df":6},"f":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}},"e":{"docs":{},"df":0,"g":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"_":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"w":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}},"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.449489742783178}},"df":11}}}}},"c":{"docs":{"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":4.0},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.795831523312719},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":4.795831523312719}},"df":14,"/":{"docs":{},"df":0,"d":{"docs":{},"df":0,"5":{"docs":{},"df":0,"a":{"docs":{},"df":0,"8":{"docs":{},"df":0,"2":{"docs":{},"df":0,"b":{"docs":{},"df":0,"b":{"docs":{},"df":0,"d":{"docs":{},"df":0,"2":{"docs":{},"df":0,"6":{"docs":{},"df":0,"e":{"docs":{},"df":0,"1":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"8":{"docs":{},"df":0,"b":{"docs":{},"df":0,"7":{"docs":{},"df":0,"4":{"docs":{},"df":0,"0":{"docs":{},"df":0,"1":{"docs":{},"df":0,"f":{"docs":{},"df":0,"6":{"docs":{},"df":0,"a":{"docs":{},"df":0,"7":{"docs":{},"df":0,"1":{"docs":{},"df":0,"8":{"docs":{},"df":0,"a":{"docs":{},"df":0,"9":{"docs":{},"df":0,"c":{"docs":{},"df":0,"5":{"docs":{},"df":0,"7":{"docs":{},"df":0,"c":{"docs":{},"df":0,"9":{"docs":{},"df":0,"6":{"docs":{},"df":0,"9":{"docs":{},"df":0,"0":{"docs":{},"df":0,"5":{"docs":{},"df":0,"4":{"docs":{},"df":0,"8":{"docs":{},"df":0,"3":{"docs":{},"df":0,"/":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"b":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"y":{"docs":{},"df":0,"/":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"/":{"docs":{},"df":0,"s":{"docs":{},"df":0,"r":{"docs":{},"df":0,"c":{"docs":{},"df":0,"/":{"docs":{},"df":0,"c":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,".":{"docs":{},"df":0,"r":{"docs":{},"df":0,"s":{"docs":{},"df":0,":":{"docs":{},"df":0,"7":{"docs":{},"df":0,"8":{"docs":{},"df":0,"3":{"docs":{},"df":0,":":{"docs":{},"df":0,"8":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0}},"df":1}}}}}}}}}}}},"o":{"docs":{},"df":0,"p":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,".":{"docs":{},"df":0,"r":{"docs":{},"df":0,"s":{"docs":{},"df":0,":":{"docs":{},"df":0,"5":{"docs":{},"df":0,"1":{"docs":{},"df":0,"8":{"docs":{},"df":0,":":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4}}}},"2":{"docs":{},"df":0,"2":{"docs":{},"df":0,":":{"docs":{},"df":0,"5":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4}}}}}}}}}}}}}}}}}}}}}}}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"d":{"docs":{},"df":0,"/":{"docs":{},"df":0,"s":{"docs":{},"df":0,"r":{"docs":{},"df":0,"c":{"docs":{},"df":0,"/":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"/":{"docs":{},"df":0,"m":{"docs":{},"df":0,"o":{"docs":{},"df":0,"d":{"docs":{},"df":0,".":{"docs":{},"df":0,"r":{"docs":{},"df":0,"s":{"docs":{},"df":0,":":{"docs":{},"df":0,"1":{"docs":{},"df":0,"5":{"docs":{},"df":0,"8":{"docs":{},"df":0,"1":{"docs":{},"df":0,":":{"docs":{},"df":0,"1":{"docs":{},"df":0,"7":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}},"5":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}},"7":{"docs":{},"df":0,"0":{"docs":{},"df":0,"4":{"docs":{},"df":0,":":{"docs":{},"df":0,"8":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"e":{"docs":{},"df":0,"0":{"docs":{},"df":0,"9":{"docs":{},"df":0,"2":{"docs":{},"df":0,"d":{"docs":{},"df":0,"0":{"docs":{},"df":0,"b":{"docs":{},"df":0,"6":{"docs":{},"df":0,"b":{"docs":{},"df":0,"4":{"docs":{},"df":0,"3":{"docs":{},"df":0,"f":{"docs":{},"df":0,"2":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"9":{"docs":{},"df":0,"6":{"docs":{},"df":0,"7":{"docs":{},"df":0,"a":{"docs":{},"df":0,"f":{"docs":{},"df":0,"0":{"docs":{},"df":0,"8":{"docs":{},"df":0,"8":{"docs":{},"df":0,"7":{"docs":{},"df":0,"8":{"docs":{},"df":0,"7":{"docs":{},"df":0,"3":{"docs":{},"df":0,"1":{"docs":{},"df":0,"5":{"docs":{},"df":0,"1":{"docs":{},"df":0,"b":{"docs":{},"df":0,"b":{"docs":{},"df":0,"1":{"docs":{},"df":0,"c":{"docs":{},"df":0,"0":{"docs":{},"df":0,"b":{"docs":{},"df":0,"1":{"docs":{},"df":0,"8":{"docs":{},"df":0,"d":{"docs":{},"df":0,"3":{"docs":{},"df":0,"/":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"b":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"y":{"docs":{},"df":0,"/":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"/":{"docs":{},"df":0,"s":{"docs":{},"df":0,"r":{"docs":{},"df":0,"c":{"docs":{},"df":0,"/":{"docs":{},"df":0,"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"/":{"docs":{},"df":0,"m":{"docs":{},"df":0,"o":{"docs":{},"df":0,"d":{"docs":{},"df":0,".":{"docs":{},"df":0,"r":{"docs":{},"df":0,"s":{"docs":{},"df":0,":":{"docs":{},"df":0,"2":{"docs":{},"df":0,"5":{"docs":{},"df":0,"9":{"docs":{},"df":0,"1":{"docs":{},"df":0,":":{"docs":{},"df":0,"9":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}}}},"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"/":{"docs":{},"df":0,"s":{"docs":{},"df":0,"r":{"docs":{},"df":0,"c":{"docs":{},"df":0,"/":{"docs":{},"df":0,"o":{"docs":{},"df":0,"p":{"docs":{},"df":0,"s":{"docs":{},"df":0,"/":{"docs":{},"df":0,"f":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,".":{"docs":{},"df":0,"r":{"docs":{},"df":0,"s":{"docs":{},"df":0,":":{"docs":{},"df":0,"2":{"docs":{},"df":0,"4":{"docs":{},"df":0,"8":{"docs":{},"df":0,":":{"docs":{},"df":0,"5":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}},"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,".":{"docs":{},"df":0,"r":{"docs":{},"df":0,"s":{"docs":{},"df":0,":":{"docs":{},"df":0,"1":{"docs":{},"df":0,"4":{"docs":{},"df":0,"2":{"docs":{},"df":0,":":{"docs":{},"df":0,"1":{"docs":{},"df":0,"4":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}},"8":{"docs":{},"df":0,"4":{"docs":{},"df":0,":":{"docs":{},"df":0,"5":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}},"s":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"/":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,".":{"docs":{},"df":0,"r":{"docs":{},"df":0,"s":{"docs":{},"df":0,":":{"docs":{},"df":0,"1":{"docs":{},"df":0,"8":{"docs":{},"df":0,":":{"docs":{},"df":0,"9":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}},"2":{"docs":{},"df":0,"4":{"docs":{},"df":0,"2":{"docs":{},"df":0,":":{"docs":{},"df":0,"1":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"d":{"docs":{},"df":0,"/":{"docs":{},"df":0,"s":{"docs":{},"df":0,"r":{"docs":{},"df":0,"c":{"docs":{},"df":0,"/":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,".":{"docs":{},"df":0,"r":{"docs":{},"df":0,"s":{"docs":{},"df":0,":":{"docs":{},"df":0,"5":{"docs":{},"df":0,"8":{"docs":{},"df":0,"4":{"docs":{},"df":0,":":{"docs":{},"df":0,"5":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"d":{"docs":{},"df":0,"o":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}},"f":{"docs":{},"df":0,"i":{"docs":{},"df":0,"x":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772}},"df":2}},"m":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.6457513110645907}},"df":4}}},"i":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}},"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4}}}}}}}},"u":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.3166247903554}},"df":4,".":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}},"’":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.5677643628300215},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.47213595499958}},"df":3}}}},"v":{"docs":{},"df":0,":":{"docs":{},"df":0,"9":{"docs":{},"df":0,"9":{"docs":{},"df":0,".":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}},"x":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.3166247903554}},"df":2,".":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"v":{"docs":{},"df":0,"(":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"w":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}}}}}}},"y":{"docs":{},"df":0,"b":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2},"e":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}},"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":9.848857801796104},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":9.848857801796104}},"df":6,"'":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2},".":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"_":{"docs":{},"df":0,"b":{"docs":{},"df":0,"y":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":2}}}}}},"c":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":2}}}}},"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.8284271247461903}},"df":2}}},"p":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{},"df":0,"(":{"docs":{},"df":0,"'":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}},"_":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2,"(":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"b":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}},"`":{"docs":{},"df":0,"b":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}},"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"z":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}},"1":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":6.855654600401044},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":6.855654600401044}},"df":4,".":{"docs":{},"df":0,"c":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}}}}},"p":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{},"df":0,"_":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"(":{"docs":{},"df":0,"s":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}},"[":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}}},"2":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.916079783099616},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":5.916079783099616}},"df":4},"3":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.0}},"df":2},"a":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.0}},"df":1},"f":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0}},"df":1,"_":{"docs":{},"df":0,"p":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"d":{"docs":{},"df":0,"_":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"b":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0}},"df":1}}}}}}}}}}}}}},"e":{"docs":{"http://127.0.0.1:1111/posts/post-1/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.196152422706632},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.196152422706632},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907}},"df":5,"t":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903}},"df":3}}}},"i":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.7320508075688772}},"df":1}}},"k":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2}},"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}},"e":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1},"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}},"m":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":8.717797887081348},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":7.14142842854285},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":12.288205727444508}},"df":5},"p":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":3,"e":{"docs":{},"df":0,".":{"docs":{},"df":0,"t":{"docs":{},"df":0,"x":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0}},"df":2}}}}}}}},"s":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/posts/post-1/":{"tf":2.0}},"df":1}},"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"f":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":2}}}},"u":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"_":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1}}}}}}}}},"v":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3}},"w":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3},"y":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3}},"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903}},"df":1}},"e":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.23606797749979}},"df":2}}},"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":3}}}},"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772}},"df":1}}},"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"d":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":2}}}}},"i":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}},"o":{"docs":{},"df":0,"p":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/posts/post-2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":7.745966692414834},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.69041575982343},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":12.569805089976535},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":4.242640687119285}},"df":10}},"r":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.123105625617661},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.1622776601683795}},"df":2,"s":{"docs":{},"df":0,".":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"y":{"docs":{},"df":0,"(":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"f":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"(":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,"\"":{"docs":{},"df":0,")":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"_":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"(":{"docs":{},"df":0,"5":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}},"y":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{},"df":0,"\"":{"docs":{},"df":0,")":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"_":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"(":{"docs":{},"df":0,"5":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}},"`":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,"`":{"docs":{},"df":0,")":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"_":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"(":{"docs":{},"df":0,"5":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}},"y":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{},"df":0,"`":{"docs":{},"df":0,")":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"_":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"(":{"docs":{},"df":0,"5":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"_":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"p":{"docs":{},"df":0,"i":{"docs":{},"df":0,"e":{"docs":{},"df":0,"d":{"docs":{},"df":0,"(":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"w":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{},"df":0,"_":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"(":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"(":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"f":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"(":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178}},"df":1}}},"y":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":1}}}}}}},"`":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.449489742783178}},"df":1}}},"y":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"_":{"docs":{},"df":0,"s":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"k":{"docs":{},"df":0,"e":{"docs":{},"df":0,"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}},"e":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":2}}},"i":{"docs":{},"df":0,"p":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":2}}}},"s":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/posts/post-1/":{"tf":1.0}},"df":1}}},"d":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":1.0}},"df":1}},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":8.246211251235321},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":4.123105625617661},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":4,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"a":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"(":{"docs":{},"df":0,"q":{"docs":{},"df":0,"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907}},"df":1}}}}}}}}}}}},"`":{"docs":{},"df":0,"a":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"(":{"docs":{},"df":0,"q":{"docs":{},"df":0,"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.6457513110645907}},"df":1}}}}}}}}}}}}}}}},"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"f":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,".":{"docs":{},"df":0,"q":{"docs":{},"df":0,"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}}}}}}}}},"q":{"docs":{},"df":0,"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2}}}}}},"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"_":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.4641016151377544}},"df":2,"i":{"docs":{},"df":0,"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"a":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}},"`":{"docs":{},"df":0,"a":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1}}}}}}}}},"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"f":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,".":{"docs":{},"df":0,"q":{"docs":{},"df":0,"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}},"q":{"docs":{},"df":0,"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}},"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"_":{"docs":{},"df":0,"f":{"docs":{},"df":0,"r":{"docs":{},"df":0,"u":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.6457513110645907}},"df":2}}}}}}}}}}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":1,"_":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"_":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}},"c":{"docs":{"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0}},"df":3,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":6.082762530298219},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":6,"_":{"docs":{},"df":0,"w":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2,"(":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}}}}}},"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2},"y":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.23606797749979}},"df":2}}}}}}}}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/posts/post-2/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter2/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":6,"_":{"docs":{},"df":0,"n":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{},"df":0,"b":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":3}}}}},"s":{"docs":{},"df":0,".":{"docs":{},"df":0,"g":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"u":{"docs":{},"df":0,"b":{"docs":{},"df":0,"_":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"k":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/posts/post-2/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}},"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/docs/config-options/":{"tf":2.23606797749979},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":7.483314773547883},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":6.324555320336759},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":6.708203932499369}},"df":6}}}},"u":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":1}}},"d":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.0}},"df":1},"e":{"docs":{"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":9.38083151964686},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":7.3484692283495345},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":7.745966692414834},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":9,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0}},"df":1},"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178}},"df":3},"n":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.0}},"df":4}},"g":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}},"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/posts/post-2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":4}}},"f":{"docs":{"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.0990195135927845},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":5.0990195135927845},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":6.48074069840786},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":6.0}},"df":7,".":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2,".":{"docs":{},"df":0,"j":{"docs":{},"df":0,"o":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}},"a":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}},"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}},"d":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}},"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}},"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.23606797749979}},"df":4}}}}}},"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":4},"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}},"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"x":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}},"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,".":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"(":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}}},"`":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}},"o":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"_":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0}},"df":2}}}}}}}}}},"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}},"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,".":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"_":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"f":{"docs":{},"df":0,"(":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"w":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{},"df":0,"(":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"(":{"docs":{},"df":0,"j":{"docs":{},"df":0,"o":{"docs":{},"df":0,"b":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"w":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"(":{"docs":{},"df":0,"j":{"docs":{},"df":0,"o":{"docs":{},"df":0,"b":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"w":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}},"t":{"docs":{},"df":0,"_":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,".":{"docs":{},"df":0,"b":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{},"df":0,"_":{"docs":{},"df":0,"m":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2,"(":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"p":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{},"df":0,"(":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"f":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"(":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"p":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{},"df":0,"(":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"f":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"(":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"u":{"docs":{},"df":0,"m":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"z":{"docs":{},"df":0,"e":{"docs":{},"df":0,"_":{"docs":{},"df":0,"a":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}},"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"_":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}},"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}},"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4}}}},"w":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.449489742783178}},"df":4}}}},"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0}},"df":2}}}},"x":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":4,".":{"docs":{},"df":0,"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{},"df":0,"i":{"docs":{},"df":0,"(":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}},"y":{"docs":{},"df":0,".":{"docs":{},"df":0,"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{},"df":0,"i":{"docs":{},"df":0,"(":{"docs":{},"df":0,"2":{"docs":{},"df":0,")":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"s":{"docs":{},"df":0,"q":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}},":":{"docs":{},"df":0,":":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2,"]":{"docs":{},"df":0,"(":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"f":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}},"k":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"s":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"y":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}},"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"y":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}},"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{},"df":0,"p":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}},"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}}}},"u":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"s":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"m":{"docs":{},"df":0,"i":{"docs":{},"df":0,"x":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}},"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"r":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"t":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"r":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"t":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"c":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,"_":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"y":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"t":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"y":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"a":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}},"m":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"/":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}}}}},"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":3}}},"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2,"_":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"k":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}},"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178}},"df":3}}}}}},"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.4142135623730951}},"df":1}}}},"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":8.54400374531753},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":4.358898943540674},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":7.416198487095663},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":4.69041575982343},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":5,"(":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}},"w":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}},"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.23606797749979}},"df":2}}}}}}}}},"`":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1}}},"w":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1}}}}}},".":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{},"df":0,"m":{"docs":{},"df":0,"l":{"docs":{},"df":0,"#":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}},"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.0990195135927845},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":4.242640687119285}},"df":2}}},"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907}},"df":3,"i":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1},"u":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178}},"df":1}}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979}},"df":3,"_":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.0}},"df":2}}}}}}},"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}}}}},"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.69041575982343}},"df":4}},"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"b":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1}}}}},"q":{"docs":{},"df":0,"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":4,"e":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}}}}}}}},"t":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2}}}}}},"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":5,"a":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}},"o":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}},"v":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":4,"e":{"docs":{},"df":0,"_":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}}}},"r":{"docs":{"http://127.0.0.1:1111/rust/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":8.246211251235321},"http://127.0.0.1:1111/rust/chapter22/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":6,"’":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}},"i":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}}}},"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1}}}}},"t":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0},"http://127.0.0.1:1111/posts/post-1/":{"tf":1.0},"http://127.0.0.1:1111/posts/post-2/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":6.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.898979485566356}},"df":8,"_":{"docs":{},"df":0,"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0}},"df":2,"e":{"docs":{},"df":0,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"m":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}},"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"_":{"docs":{},"df":0,"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.8284271247461903}},"df":2}}}}},"’":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}},"u":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.6457513110645907}},"df":3}}},"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":4}}}},"h":{"docs":{"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":1.0}},"df":1,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.4142135623730951}},"df":3}}},"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979}},"df":1}}},"z":{"docs":{},"df":0,"z":{"docs":{},"df":0,"/":{"docs":{},"df":0,"z":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/posts/post-2/":{"tf":1.0}},"df":1}}}}}}}},"p":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}},"r":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":7.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.1622776601683795}},"df":5}}},"e":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}},"l":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2},"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}},"r":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}},"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1,"f":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":2,"\"":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1},"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}},"p":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3},"r":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0}},"df":2,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.449489742783178}},"df":2,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2}}},"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2}}}}}}}}}}},"l":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1},"o":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.8284271247461903}},"df":2,"_":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"z":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0}},"df":2,"e":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}},"s":{"docs":{},"df":0,".":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"_":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"(":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"f":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"(":{"docs":{},"df":0,"|":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}},"_":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"_":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2,"i":{"docs":{},"df":0,"z":{"docs":{},"df":0,"e":{"docs":{},"df":0,"(":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}}}}},"’":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}},"p":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1},"r":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903}},"df":3,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0}},"df":3}},"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.0}},"df":1}}},"e":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1},"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907}},"df":2}},"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979}},"df":2}}}}}},"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"d":{"docs":{},"df":0,"_":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.7416573867739413}},"df":2,"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"(":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}},"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}},"n":{"docs":{},"df":0,"’":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3}}}}}},"w":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":7.810249675906654},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":6.928203230275509},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":7.3484692283495345}},"df":6,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}}},"e":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}}}},"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}},"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":6.244997998398398},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.242640687119285},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":6.928203230275509},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4}}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1}}}}}},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}},"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.58257569495584},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.3166247903554}},"df":3,"d":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":2}}}}}}},"i":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":1}},"d":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":3}},"g":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":4,"_":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.4641016151377544}},"df":2}}}}}}}}},"a":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3},"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.123105625617661},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":8.306623862918075},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":5}}}},"i":{"docs":{},"df":0,"f":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}}}}}},"k":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}},"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}},"m":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.0990195135927845},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.291502622129181},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.385164807134504}},"df":5,"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979}},"df":3}}}}}},"p":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178}},"df":4,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":3},"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772}},"df":2}}},"i":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":2,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"y":{"docs":{},"df":0,"’":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2}}}}},"f":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3}}}}},"u":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0}},"df":1,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":4}}}}}},"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.358898943540674},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.872983346207417}},"df":5}}},"p":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}},"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1},"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":2,"e":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/docs/config-options/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/posts/post-2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":7},"u":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.744562646538029}},"df":3}}}},"x":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":4,"_":{"docs":{},"df":0,"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"_":{"docs":{},"df":0,"f":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1}}}}}}}}}}},"t":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}},"z":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.5677643628300215},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":6.855654600401044},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":7,"d":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}},"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"(":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}},"k":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}},"t":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0}},"df":1}}}}},"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}},"p":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1}}},"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1}}},"e":{"docs":{},"df":0,"e":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.3166247903554}},"df":2}},"p":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}},"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":6.324555320336759},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":10.04987562112089},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/to do/chapter4/3-the-slice-type/":{"tf":1.0}},"df":6,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"f":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"_":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"w":{"docs":{},"df":0,"_":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"s":{"docs":{},"df":0,"_":{"docs":{},"df":0,"m":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0}},"df":2,"(":{"docs":{},"df":0,"p":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2,".":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"d":{"docs":{},"df":0,"(":{"docs":{},"df":0,"m":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}},"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}}},"d":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}},"g":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1,"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3}}}}}},"o":{"docs":{},"df":0,"g":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1}}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1},"w":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":2,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":3}},"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}},"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.123105625617661},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter2/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":5,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903}},"df":5,".":{"docs":{},"df":0,"w":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}},"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"t":{"docs":{},"df":0,"_":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"d":{"docs":{},"df":0,"_":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}},"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}},"r":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":7.745966692414834},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":4}}}},"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}},"i":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":6.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":6.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":6.48074069840786},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":6.48074069840786},"http://127.0.0.1:1111/rust/chapter2/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":4.0}},"df":7,"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.23606797749979},"http://127.0.0.1:1111/docs/config-options/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.449489742783178}},"df":3}}}}},"u":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}},"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"i":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.7320508075688772}},"df":1}}},"k":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2}}}},"d":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.7320508075688772}},"df":1}}},"f":{"docs":{},"df":0,"t":{"docs":{},"df":0,"w":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3}}}}},"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":3}},"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178}},"df":3,"a":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1}}},"v":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":3}},"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2},"2":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2},"3":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2},"e":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}},"'":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2},"1":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}},"3":{"docs":{},"df":0,"u":{"docs":{},"df":0,"8":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}}},"4":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2},"5":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.6457513110645907}},"df":4,".":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}},"0":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}},"_":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0}},"df":2},"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}},"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}},"f":{"docs":{},"df":0,"6":{"docs":{},"df":0,"4":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}},"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.0}},"df":4,"3":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}},"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}},"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}},"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"x":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2}}},"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2,"o":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}},"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2,"e":{"docs":{},"df":0,"f":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}}}},"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}},"h":{"docs":{},"df":0,"i":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}},"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"f":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"(":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1}}}}}},"`":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":1}}}}}}}}}}}}}}}}}}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2,")":{"docs":{},"df":0,"및":{"docs":{},"df":0,"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}},"h":{"docs":{},"df":0,"i":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.6457513110645907}},"df":2}}}}},"o":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}},"v":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}},"x":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.605551275463989}},"df":4}},"_":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"b":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}},"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}}}},"f":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}}}}},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2}}}}},"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"(":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"p":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}},"u":{"docs":{},"df":0,"m":{"docs":{},"df":0,"b":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}}}},"o":{"docs":{},"df":0,"p":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"_":{"docs":{},"df":0,"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.449489742783178}},"df":2}}}}}}}}}}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.1622776601683795}},"df":2,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,".":{"docs":{},"df":0,"p":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{},"df":0,"_":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2}}}}}}}}}}}}}}}},"b":{"docs":{},"df":0,"o":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.6457513110645907}},"df":2}}}},"d":{"docs":{},"df":0,"a":{"docs":{},"df":0,"y":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}},"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979}},"df":3,"e":{"docs":{},"df":0,"@":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,".":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}},"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"j":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":1.0}},"df":1}}}}}}},"t":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter3/4-comments/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.795831523312719}},"df":8},"i":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903}},"df":3}}},"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"1":{"docs":{},"df":0,"2":{"docs":{},"df":0,"3":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}},"w":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2}},"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":3}}}},"변":{"docs":{},"df":0,"종":{"docs":{},"df":0,"이":{"docs":{},"df":0,"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}},"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772}},"df":1,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}}}},"r":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903}},"df":4,"_":{"docs":{},"df":0,"b":{"docs":{},"df":0,"y":{"docs":{},"df":0,"_":{"docs":{},"df":0,"k":{"docs":{},"df":0,"e":{"docs":{},"df":0,"y":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.3166247903554}},"df":2}}}}}},"o":{"docs":{},"df":0,"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0}},"df":2,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,".":{"docs":{},"df":0,"p":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{},"df":0,"(":{"docs":{},"df":0,"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}}}}}}}}}}}}}}},"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}},"p":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2},"r":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178}},"df":4}}}},"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.47213595499958},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.123105625617661}},"df":6,"s":{"docs":{},"df":0,".":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":1.7320508075688772}},"df":1}}}},"_":{"docs":{},"df":0,"n":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":1.0}},"df":1}}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":1.0}},"df":1}}}}}}},"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2},"r":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}},"w":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":7.874007874011811},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":5.385164807134504},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0}},"df":4,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}},"d":{"docs":{},"df":0,"x":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":4}},"c":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1,"i":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":4}},"f":{"docs":{"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.242640687119285}},"df":5,"i":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0},"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":7.745966692414834},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":7.937253933193772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":9.486832980505138},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":9}}}},"e":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1}},"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1}}},"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}},"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":3,"_":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"_":{"docs":{},"df":0,"m":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.8284271247461903}},"df":2,"(":{"docs":{},"df":0,"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772}},"df":2}}}}}}}}}}},"w":{"docs":{},"df":0,"h":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}},"o":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}}}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979}},"df":4}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2,"l":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"f":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"(":{"docs":{},"df":0,"1":{"docs":{},"df":0,"0":{"docs":{},"df":0,".":{"docs":{},"df":0,"1":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"(":{"docs":{},"df":0,"3":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}},"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"t":{"docs":{},"df":0,"(":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"f":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"(":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}},"`":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"q":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0}},"df":2,"!":{"docs":{},"df":0,"(":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}},"(":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"p":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}},"u":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.449489742783178}},"df":3,"e":{"docs":{},"df":0,"(":{"docs":{},"df":0,"3":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1},"s":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}},"i":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}}}}},"r":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":4.0},"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":9,"/":{"docs":{},"df":0,"b":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}},"f":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"_":{"docs":{},"df":0,"o":{"docs":{},"df":0,"f":{"docs":{},"df":0,"_":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2,"e":{"docs":{},"df":0,".":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.8284271247461903}},"df":2}},"/":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,".":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}},"/":{"docs":{},"df":0,"m":{"docs":{},"df":0,"o":{"docs":{},"df":0,"d":{"docs":{},"df":0,".":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}},"m":{"docs":{},"df":0,"o":{"docs":{},"df":0,"d":{"docs":{},"df":0,".":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}},"g":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,".":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":2}},"/":{"docs":{},"df":0,"m":{"docs":{},"df":0,"o":{"docs":{},"df":0,"d":{"docs":{},"df":0,".":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}},"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,".":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}},"/":{"docs":{},"df":0,"m":{"docs":{},"df":0,"o":{"docs":{},"df":0,"d":{"docs":{},"df":0,".":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}},"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"b":{"docs":{},"df":0,".":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":9.695359714832659},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":9.643650760992955},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.0990195135927845},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":5.0990195135927845},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.656854249492381},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":5.656854249492381}},"df":6,"s":{"docs":{},"df":0,":":{"docs":{},"df":0,"1":{"docs":{},"df":0,"0":{"docs":{},"df":0,":":{"docs":{},"df":0,"9":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}},"1":{"docs":{},"df":0,":":{"docs":{},"df":0,"9":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4}}},"2":{"docs":{},"df":0,":":{"docs":{},"df":0,"2":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}},"3":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}},"9":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}},"3":{"docs":{},"df":0,":":{"docs":{},"df":0,"1":{"docs":{},"df":0,"3":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}},"9":{"docs":{},"df":0,":":{"docs":{},"df":0,"9":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}},":":{"docs":{},"df":0,"2":{"docs":{},"df":0,"5":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}},"2":{"docs":{},"df":0,"6":{"docs":{},"df":0,":":{"docs":{},"df":0,"4":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}},"8":{"docs":{},"df":0,":":{"docs":{},"df":0,"5":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}},"9":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}},":":{"docs":{},"df":0,"5":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}}},"3":{"docs":{},"df":0,":":{"docs":{},"df":0,"9":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}}},"4":{"docs":{},"df":0,"4":{"docs":{},"df":0,":":{"docs":{},"df":0,"9":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}},"8":{"docs":{},"df":0,":":{"docs":{},"df":0,"5":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}},"9":{"docs":{},"df":0,":":{"docs":{},"df":0,"5":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}},"5":{"docs":{},"df":0,"2":{"docs":{},"df":0,":":{"docs":{},"df":0,"1":{"docs":{},"df":0,"3":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}},"2":{"docs":{},"df":0,"7":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}},"8":{"docs":{},"df":0,":":{"docs":{},"df":0,"1":{"docs":{},"df":0,"3":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}},"6":{"docs":{},"df":0,"0":{"docs":{},"df":0,":":{"docs":{},"df":0,"5":{"docs":{},"df":0,"3":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}},"7":{"docs":{},"df":0,"2":{"docs":{},"df":0,":":{"docs":{},"df":0,"2":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}},":":{"docs":{},"df":0,"5":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4}}},"9":{"docs":{},"df":0,":":{"docs":{},"df":0,"2":{"docs":{},"df":0,"8":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}},"3":{"docs":{},"df":0,"7":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}},"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1,".":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":9.539392014169456},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":9.486832980505138},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":7.3484692283495345},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":7.3484692283495345},"http://127.0.0.1:1111/rust/chapter2/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter3/4-comments/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":9.16515138991168},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":9.16515138991168}},"df":13,"s":{"docs":{},"df":0,":":{"docs":{},"df":0,"1":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2,":":{"docs":{},"df":0,"1":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}},"3":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}},"5":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0}},"df":1}}},"1":{"docs":{},"df":0,":":{"docs":{},"df":0,"1":{"docs":{},"df":0,"6":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}},"3":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2},"6":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}},"5":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}},"2":{"docs":{},"df":0,":":{"docs":{},"df":0,"2":{"docs":{},"df":0,"8":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}},"4":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2,":":{"docs":{},"df":0,"1":{"docs":{},"df":0,"9":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}},"6":{"docs":{},"df":0,":":{"docs":{},"df":0,"7":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}},"7":{"docs":{},"df":0,":":{"docs":{},"df":0,"1":{"docs":{},"df":0,"4":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}},"8":{"docs":{},"df":0,":":{"docs":{},"df":0,"3":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}},"5":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}},"9":{"docs":{},"df":0,":":{"docs":{},"df":0,"1":{"docs":{},"df":0,"9":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1}},"5":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}},":":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}},"2":{"docs":{},"df":0,"0":{"docs":{},"df":0,":":{"docs":{},"df":0,"4":{"docs":{},"df":0,"3":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}},"6":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}},"2":{"docs":{},"df":0,":":{"docs":{},"df":0,"2":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0}},"df":1}}}},"6":{"docs":{},"df":0,":":{"docs":{},"df":0,"1":{"docs":{},"df":0,"3":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}},"7":{"docs":{},"df":0,":":{"docs":{},"df":0,"2":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}},"8":{"docs":{},"df":0,":":{"docs":{},"df":0,"4":{"docs":{},"df":0,"7":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0}},"df":1}}}},":":{"docs":{},"df":0,"1":{"docs":{},"df":0,"3":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.0}},"df":3},"4":{"docs":{"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.7320508075688772}},"df":1}},"2":{"docs":{},"df":0,"8":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}},"5":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2},"8":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2},"9":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":3}}},"3":{"docs":{},"df":0,":":{"docs":{},"df":0,"1":{"docs":{},"df":0,"3":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4},"4":{"docs":{"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":1.0}},"df":1},"5":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}},"2":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}},"9":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}},"4":{"docs":{},"df":0,":":{"docs":{},"df":0,"1":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2},"4":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}},"4":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2,"4":{"docs":{"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.0}},"df":1},"8":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2},"9":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}},"5":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":7},"8":{"docs":{"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.0}},"df":1},"9":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}},"5":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2,":":{"docs":{},"df":0,"1":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2},"4":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2},"6":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2},"7":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}},"2":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2},"8":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2},"9":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}},"6":{"docs":{},"df":0,":":{"docs":{},"df":0,"1":{"docs":{},"df":0,"3":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2},"4":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2},"8":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}},"3":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2},"2":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}},"4":{"docs":{},"df":0,"4":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}},"5":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4}}},"7":{"docs":{},"df":0,":":{"docs":{},"df":0,"2":{"docs":{},"df":0,"4":{"docs":{"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.0}},"df":1}},"3":{"docs":{},"df":0,"8":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}},"8":{"docs":{},"df":0,":":{"docs":{},"df":0,"2":{"docs":{},"df":0,"3":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}},"5":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}},"9":{"docs":{},"df":0,":":{"docs":{},"df":0,"3":{"docs":{},"df":0,"3":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2},"6":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}},"s":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":1.0}},"df":1},"g":{"docs":{"http://127.0.0.1:1111/":{"tf":1.4142135623730951}},"df":1}},"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0}},"df":1}},"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.0990195135927845},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0}},"df":3}},"c":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.830951894845301},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":7,".":{"docs":{},"df":0,"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}},"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{},"df":0,"(":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2},"2":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2},"3":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}},"e":{"docs":{},"df":0,"d":{"docs":{},"df":0,"b":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}}}},"o":{"docs":{},"df":0,"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"f":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0}},"df":1}}}}}}}}}},"g":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1},"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772}},"df":1}}}},"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":8.366600265340756},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.47213595499958},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":7.3484692283495345}},"df":5}}}},"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"y":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}}}},"r":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/":{"tf":1.0}},"df":1}},"t":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":6.082762530298219},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":6.082762530298219},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":7.280109889280518}},"df":5,".":{"docs":{},"df":0,".":{"docs":{},"df":0,"=":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0}},"df":1}}}}}},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"_":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2,".":{"docs":{},"df":0,".":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"_":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}},"t":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.69041575982343},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.5677643628300215},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.6457513110645907}},"df":8,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.47213595499958},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.123105625617661},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.242640687119285}},"df":4}}}}},"i":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.830951894845301},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.0}},"df":6,"\"":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}},"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.6457513110645907}},"df":2}}}},"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}},"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}},"u":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":4,"s":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}}},"_":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.0}},"df":2,"e":{"docs":{},"df":0,"}":{"docs":{},"df":0,"\\":{"docs":{},"df":0,"r":{"docs":{},"df":0,"\\":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}}}}}}}}},"y":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":2}},"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":6,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"f":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.23606797749979}},"df":2}}}}}}}}}}},"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":3}}}}},"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"(":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}},"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.0}},"df":2}}}}}}}}}}}}}}}}}}}},"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"v":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.8284271247461903}},"df":2,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.449489742783178}},"df":2,"s":{"docs":{},"df":0,"_":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}},"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4}}}}}}}}}}}},"f":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":6,"6":{"docs":{},"df":0,"4":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"s":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"p":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}},"m":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":4,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"y":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":4}}}}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}},"s":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"f":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.4641016151377544}},"df":2}}}}}}}},"i":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter2/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.6457513110645907}},"df":6,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"b":{"docs":{},"df":0,"u":{"docs":{},"df":0,"f":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}},"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2,";":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}},"k":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}},"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}},"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":6}}}}}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.4142135623730951}},"df":1}}}}},"w":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2}}}},"{":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":2}}}}}}}}},"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"k":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}},"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"d":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.23606797749979}},"df":2}}}}}}}}},"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"i":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"d":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}},"t":{"docs":{},"df":0,"c":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}},"o":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2,"s":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}},"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}},"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"m":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"m":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"r":{"docs":{},"df":0,"c":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"r":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.23606797749979}},"df":2}},"{":{"docs":{},"df":0,"r":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}},"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}},"s":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}},"y":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}},"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,"s":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.23606797749979}},"df":2,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"i":{"docs":{},"df":0,"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"j":{"docs":{},"df":0,"o":{"docs":{},"df":0,"b":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}},"u":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2}}}}},"{":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}},"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0}},"df":4}}}}},"i":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"d":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":4}}}}}}}}},"{":{"docs":{},"df":0,"c":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}},"s":{"docs":{},"df":0,"y":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,"s":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}},"🧵":{"docs":{},"df":0,":":{"docs":{},"df":0,"b":{"docs":{},"df":0,"u":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}},"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":4}}},"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.4142135623730951}},"df":1}},"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":4}}}},"e":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/posts/post-2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903}},"df":4}},"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}},"l":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":6.164414002968976},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.58257569495584},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":6.557438524302},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":5}}},"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}},"p":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.3166247903554}},"df":4},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":4}},"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":7.211102550927978},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.656854249492381},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":8.366600265340756}},"df":5,".":{"docs":{},"df":0,"g":{"docs":{},"df":0,"i":{"docs":{},"df":0,"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"w":{"docs":{},"df":0,"a":{"docs":{},"df":0,"y":{"docs":{},"df":0,"(":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"_":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"f":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2},"2":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}},"i":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":1},"m":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"o":{"docs":{},"df":0,"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}}}}}}},"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.898979485566356},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":4.898979485566356}},"df":6,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.7416573867739413}},"df":2}}},"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{},"df":0,"f":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"w":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":3}}}}}}}}}}},"n":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}},"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"g":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0}},"df":1}}}}},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":7.0710678118654755},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":5.0990195135927845},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":4,".":{"docs":{},"df":0,"f":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{},"df":0,"(":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"w":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"m":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}},"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"w":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.449489742783178}},"df":2}}}}}},"w":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"_":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"(":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,".":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"_":{"docs":{},"df":0,"b":{"docs":{},"df":0,"y":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"(":{"docs":{},"df":0,")":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"w":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.449489742783178}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1,"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1}}}},"k":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"g":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1}}}}}}}}},"n":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":9.1104335791443},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":5.196152422706632},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.830951894845301},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter2/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":18.35755975068582},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":9.797958971132712}},"df":10,"\"":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":1,"—":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}},"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":4}}},"1":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":2,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}},"2":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.0}},"df":2,".":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"_":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2}}}}}}}},":":{"docs":{},"df":0,":":{"docs":{},"df":0,"f":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.47213595499958},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":4.47213595499958}},"df":2,"(":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"(":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}},"1":{"docs":{},"df":0,"2":{"docs":{},"df":0,"7":{"docs":{},"df":0,".":{"docs":{},"df":0,"0":{"docs":{},"df":0,".":{"docs":{},"df":0,"0":{"docs":{},"df":0,".":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}}}}}},":":{"docs":{},"df":0,":":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}},"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"c":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}},"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"@":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,".":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":1}}}}}}}}}}}},"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"@":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,".":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}},"b":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1},"l":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":1,"e":{"docs":{},"df":0,"b":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}}}}},"o":{"docs":{},"df":0,"o":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1}}}},"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}},"d":{"docs":{},"df":0,"o":{"docs":{},"df":0,"b":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}},"f":{"docs":{},"df":0,"a":{"docs":{},"df":0,"v":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}}},"o":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":1},"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}},"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}},"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.5677643628300215}},"df":2}}}},"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.449489742783178}},"df":2},"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":1}},"r":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"_":{"docs":{},"df":0,"e":{"docs":{},"df":0,"b":{"docs":{},"df":0,"o":{"docs":{},"df":0,"o":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":1}}}}}}}}}}},"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"b":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{},"df":0,"g":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":1}}}}}}},"n":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}},"l":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1,"n":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":1}}}},"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}},"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1},"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}},"o":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1},"t":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}},"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}},"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"u":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}}},"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"t":{"docs":{},"df":0,"s":{"docs":{},"df":0,"b":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{},"df":0,"g":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":1}}}}}}}}},"u":{"docs":{},"df":0,"p":{"docs":{},"df":0,"p":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}},"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1},"s":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}},"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1}}}},"o":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1,"e":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"@":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,".":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":1}}}}}}}}}}}}}}},"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"1":{"docs":{},"df":0,"2":{"docs":{},"df":0,"3":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":1}}}}}}}}}}}}}},"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":1,"a":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":1}},"h":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}}},"o":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":1}},"w":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}},"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"l":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}}}}},"x":{"docs":{},"df":0,"y":{"docs":{},"df":0,"z":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":1}}},"y":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}},"`":{"docs":{},"df":0,"(":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}},"1":{"docs":{},"df":0,"2":{"docs":{},"df":0,"7":{"docs":{},"df":0,".":{"docs":{},"df":0,"0":{"docs":{},"df":0,".":{"docs":{},"df":0,"0":{"docs":{},"df":0,".":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}},":":{"docs":{},"df":0,":":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}},"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"c":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}},"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"@":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,".":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":1}}}}}}}}}}}},"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"@":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,".":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}},"b":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":1},"l":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":1,"e":{"docs":{},"df":0,"b":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}},"o":{"docs":{},"df":0,"o":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":1}}}},"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}},"d":{"docs":{},"df":0,"o":{"docs":{},"df":0,"b":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}},"f":{"docs":{},"df":0,"a":{"docs":{},"df":0,"v":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}},"o":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":1}}},"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":5.5677643628300215}},"df":2}}}},"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":1}},"r":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"_":{"docs":{},"df":0,"e":{"docs":{},"df":0,"b":{"docs":{},"df":0,"o":{"docs":{},"df":0,"o":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":1}}}}}}}}}}},"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"b":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{},"df":0,"g":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":1}}}}}}},"n":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}},"l":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1,"n":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":1}}}},"m":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1}},"o":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1},"t":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1}}},"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}},"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"u":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}},"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"t":{"docs":{},"df":0,"s":{"docs":{},"df":0,"b":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{},"df":0,"g":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":1}}}}}}}}},"u":{"docs":{},"df":0,"p":{"docs":{},"df":0,"p":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1}}}}},"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1},"s":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1}}},"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":1}}}},"o":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":1,"e":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"@":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,".":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":1}}}}}}}}}}}}}}},"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"1":{"docs":{},"df":0,"2":{"docs":{},"df":0,"3":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":1}}}}}}}}}}}}}},"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1}}}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":1,"a":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":1}},"o":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":1}},"w":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}},"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"l":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}},"x":{"docs":{},"df":0,"y":{"docs":{},"df":0,"z":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":1}}},"y":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}},"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}},"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"w":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter2/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":6}}}}},"_":{"docs":{},"df":0,"f":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}},"`":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":1},"i":{"docs":{},"df":0,"f":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2},"y":{"docs":{},"df":0,"!":{"docs":{},"df":0,"(":{"docs":{},"df":0,"#":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}},"’":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}},"v":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}},"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3,"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.449489742783178}},"df":2,"입":{"docs":{},"df":0,"니":{"docs":{},"df":0,"다":{"docs":{},"df":0,".":{"docs":{},"df":0,"[":{"docs":{},"df":0,"유":{"docs":{},"df":0,"형":{"docs":{},"df":0,"에":{"docs":{},"df":0,"는":{"docs":{},"df":0,"w":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"k":{"docs":{},"df":0,"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}},"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"u":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}},"u":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":7.3484692283495345},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":4.242640687119285},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":10.344080432788601},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":5.830951894845301},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":15.165750888103101},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":6.6332495807108},"http://127.0.0.1:1111/rust/to do/chapter5/":{"tf":1.0},"http://127.0.0.1:1111/rust/to do/chapter5/1-defining-and-instantiating-structs/":{"tf":1.0},"http://127.0.0.1:1111/rust/to do/chapter5/2-an-example-program-using-structs/":{"tf":1.0}},"df":12,"\"":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1},"_":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"k":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}},"y":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}},"u":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":6.708203932499369},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.47213595499958},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.0990195135927845},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/to do/chapter5/":{"tf":1.0}},"df":6}},"’":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.1622776601683795}},"df":2}}},"g":{"docs":{},"df":0,"g":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}},"u":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}},"d":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":3}}},"f":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":5}},"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}},"y":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.0},"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903}},"df":8,"s":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.0}},"df":1}}}}}}}}},"u":{"docs":{},"df":0,"b":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1}}}}}}},"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}}}}}},"j":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":3}}}},"m":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}},"o":{"docs":{},"df":0,"d":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":2,"e":{"docs":{},"df":0,"’":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}}}},"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":1}}}},"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"q":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979}},"df":1}},"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979}},"df":3}}}},"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}},"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}},"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772}},"df":2},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":3,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"b":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}}}}}}}},"c":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.0}},"df":3,"e":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":1}},"s":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907}},"df":4,"f":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":2}}}}}}}}},"h":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.898979485566356},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":6.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.477225575051661},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":4}},"d":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}}},"g":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":1}},"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":3}}}}},"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}}}}},"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":5,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"i":{"docs":{},"df":0,"6":{"docs":{},"df":0,"4":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}},"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.358898943540674},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.6457513110645907}},"df":3,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":7.3484692283495345},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":5.830951894845301}},"df":4,"z":{"docs":{},"df":0,"e":{"docs":{},"df":0,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.449489742783178}},"df":2}}}}}}}}}},"_":{"docs":{},"df":0,"a":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":2,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}}}}}}}}},"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"f":{"docs":{},"df":0,"y":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"y":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"t":{"docs":{},"df":0,"w":{"docs":{},"df":0,"e":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"z":{"docs":{},"df":0,"e":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"z":{"docs":{},"df":0,"e":{"docs":{},"df":0,"_":{"docs":{},"df":0,"a":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"z":{"docs":{},"df":0,"e":{"docs":{},"df":0,"_":{"docs":{},"df":0,"a":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"y":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"y":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"(":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}},"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2,"(":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}},"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.242640687119285},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":4.123105625617661},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.8284271247461903}},"df":7,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"_":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}},"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}},"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}}}}}},"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178}},"df":1}}},"s":{"docs":{},"df":0,"c":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"p":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}},"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}},"p":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.7320508075688772}},"df":1}},"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903}},"df":4}},"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":2}}}},"r":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.58257569495584},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903}},"df":3},"f":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}},"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}},"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}}},"s":{"docs":{},"df":0,"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}},"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}},"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"k":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}},"w":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}},"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4}}}}},"y":{"docs":{},"df":0,"m":{"docs":{},"df":0,"b":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":5,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.6457513110645907}},"df":1}}}}}}}}},"p":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}},"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.0}},"df":2,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2,"e":{"docs":{},"df":0,"(":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"p":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"w":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}},"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.47213595499958},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":6,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1}}}},"{":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,"s":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}},"h":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}},"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"y":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0}},"df":1}}}},"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}},"x":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":7.3484692283495345},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":7.681145747868608},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/to do/chapter5/3-method-syntax/":{"tf":1.0}},"df":9,".":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{},"df":0,"m":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1,"#":{"docs":{},"df":0,"w":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.291502622129181},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.358898943540674}},"df":5}}}}}},"t":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.196152422706632},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":5.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.196152422706632},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":5.0},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":7.681145747868608},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":6.708203932499369}},"df":8,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4,";":{"docs":{},"df":0,"(":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}}},"]":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}},"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"e":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"o":{"docs":{},"df":0,"k":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"t":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"e":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"t":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"e":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"t":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"d":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"f":{"docs":{},"df":0,"s":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"f":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"e":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"d":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"f":{"docs":{},"df":0,"3":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}},"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"t":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"y":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"x":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}},"a":{"docs":{},"df":0,"b":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":3,".":{"docs":{},"df":0,"s":{"docs":{},"df":0,"v":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0}},"df":1}}}},"l":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.0},"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0},"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.47213595499958},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907}},"df":5,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}},"c":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2,"i":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1}},"k":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}}},"g":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}},"i":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.0}},"df":3,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}},"j":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1},"k":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":8.54400374531753},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":7.874007874011811},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":8.888194417315589},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":6,"_":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}}},"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"y":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}}},"w":{"docs":{},"df":0,"h":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"(":{"docs":{},"df":0,"|":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772}},"df":2}}}}}}}}}}},"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0}},"df":1},"s":{"docs":{},"df":0,"_":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"_":{"docs":{},"df":0,"g":{"docs":{},"df":0,"i":{"docs":{},"df":0,"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"_":{"docs":{},"df":0,"b":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2,"(":{"docs":{},"df":0,"a":{"docs":{},"df":0,"_":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}},"s":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}},"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"_":{"docs":{},"df":0,"t":{"docs":{},"df":0,"y":{"docs":{},"df":0,"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"(":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}}},"o":{"docs":{},"df":0,"w":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{},"df":0,"i":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2,"(":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2,"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"_":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}},"l":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.47213595499958},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.0}},"df":3}},"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}},"p":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}},"r":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0}},"df":3,"(":{"docs":{"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":7.615773105863909},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":7.615773105863909},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter2/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.8284271247461903}},"df":11},"/":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"b":{"docs":{},"df":0,"u":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":1.4142135623730951}},"df":1,"/":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}},"b":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":2.0}},"df":1}}}}}},"c":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}}},"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}},"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2}}},"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"p":{"docs":{},"df":0,"s":{"docs":{},"df":0,"/":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.605551275463989}},"df":2,"_":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}}}},"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"m":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}},"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}},"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"_":{"docs":{},"df":0,"g":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2}}}}}}}}}}}},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"_":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2}}}}}}}}}}}}}}}},"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"_":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}},"m":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.23606797749979}},"df":2}}}}}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2}}}}}}}},"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"y":{"docs":{},"df":0,"_":{"docs":{},"df":0,"f":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}}}}}}},"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}},"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}},"f":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":2.0}},"df":1}}}}},"g":{"docs":{},"df":0,"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"_":{"docs":{},"df":0,"g":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":2.6457513110645907}},"df":1}}}}}}}}}}}},"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0}},"df":2,"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"g":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":2.23606797749979}},"df":1}}}}}}}}}}},"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}},"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"o":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.7320508075688772}},"df":1}}}},"m":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.872983346207417}},"df":2}}}}}}}},"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2},"t":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":4}}}}}}}},"s":{"docs":{},"df":0,"h":{"docs":{},"df":0,"i":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}},"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772}},"df":2}}}}},"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":1.4142135623730951}},"df":1}}}}}}}}},"o":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":1.7320508075688772}},"df":1}}}}}}},"\\":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"b":{"docs":{},"df":0,"u":{"docs":{},"df":0,"g":{"docs":{},"df":0,"\\":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"g":{"docs":{},"df":0,"o":{"docs":{},"df":0,".":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":1.4142135623730951}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}},"s":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.23606797749979},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":5,"2":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}}},"c":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.605551275463989}},"df":2,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772}},"df":2,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"b":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"(":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"1":{"docs":{},"df":0,"2":{"docs":{},"df":0,"7":{"docs":{},"df":0,".":{"docs":{},"df":0,"0":{"docs":{},"df":0,".":{"docs":{},"df":0,"0":{"docs":{},"df":0,".":{"docs":{},"df":0,"1":{"docs":{},"df":0,":":{"docs":{},"df":0,"7":{"docs":{},"df":0,"8":{"docs":{},"df":0,"7":{"docs":{},"df":0,"8":{"docs":{},"df":0,"\"":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"w":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178}},"df":1}}}}}}}}}}}}}}}}}}}}}}}},"`":{"docs":{},"df":0,"1":{"docs":{},"df":0,"2":{"docs":{},"df":0,"7":{"docs":{},"df":0,".":{"docs":{},"df":0,"0":{"docs":{},"df":0,".":{"docs":{},"df":0,"0":{"docs":{},"df":0,".":{"docs":{},"df":0,"1":{"docs":{},"df":0,":":{"docs":{},"df":0,"7":{"docs":{},"df":0,"8":{"docs":{},"df":0,"7":{"docs":{},"df":0,"8":{"docs":{},"df":0,"`":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"w":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.449489742783178}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.605551275463989}},"df":2}}}}}}}},"d":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0}},"df":2}},"e":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1,"c":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1}},"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":4,"_":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}},"’":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":1}}},"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"n":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1},"q":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.1622776601683795}},"df":3}}}}}},"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979}},"df":1}}}},"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"p":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}},"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.795831523312719}},"df":4}},"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,"_":{"docs":{},"df":0,"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0}},"df":2,".":{"docs":{},"df":0,"p":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2,"(":{"docs":{},"df":0,"$":{"docs":{},"df":0,"x":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}},"1":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2},"2":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2},"3":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}},"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.23606797749979},"http://127.0.0.1:1111/docs/theme-extension/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/posts/post-1/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":6,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,".":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"/":{"docs":{},"df":0,"t":{"docs":{},"df":0,"d":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}}}}}},"/":{"docs":{},"df":0,"b":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,".":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{},"df":0,"m":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/posts/post-1/":{"tf":1.0}},"df":1}}}}}}}},"o":{"docs":{},"df":0,"o":{"docs":{},"df":0,"k":{"docs":{},"df":0,"_":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,".":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{},"df":0,"m":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/posts/post-1/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}},"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772}},"df":2,"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}}}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}},"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}},"r":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/":{"tf":1.0}},"df":1},"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903}},"df":3,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":4,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}}}}},"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":28.513154858766505},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":18.81488772222678},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":6,"(":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1},"s":{"docs":{},"df":0,"/":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"m":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,".":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.23606797749979}},"df":2}},"/":{"docs":{},"df":0,"m":{"docs":{},"df":0,"o":{"docs":{},"df":0,"d":{"docs":{},"df":0,".":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2}}}}}}}}}}}},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"_":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,".":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.0}},"df":2}}}}}}}}}}}}}}}}}}},":":{"docs":{},"df":0,":":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"d":{"docs":{},"df":0,"_":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"e":{"docs":{},"df":0,"_":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"_":{"docs":{},"df":0,"t":{"docs":{},"df":0,"w":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}}}},"w":{"docs":{},"df":0,"o":{"docs":{},"df":0,"_":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"_":{"docs":{},"df":0,"t":{"docs":{},"df":0,"w":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}}}}}},"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.23606797749979}},"df":2}}}}},"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"_":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}},"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}},"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}}}},"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"_":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"_":{"docs":{},"df":0,"1":{"docs":{},"df":0,"0":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.8284271247461903}},"df":2}}}}}}}}}}}}},"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"_":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.8284271247461903}},"df":2}}}}}}}}}}}}}}}}}}}}},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}}},"t":{"docs":{},"df":0,"_":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"d":{"docs":{},"df":0,"s":{"docs":{},"df":0,"_":{"docs":{},"df":0,"t":{"docs":{},"df":0,"w":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.449489742783178}},"df":2}}}}}}}},"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"s":{"docs":{},"df":0,"_":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"_":{"docs":{},"df":0,"o":{"docs":{},"df":0,"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"_":{"docs":{},"df":0,"7":{"docs":{},"df":0,"5":{"docs":{},"df":0,"_":{"docs":{},"df":0,"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"_":{"docs":{},"df":0,"w":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"n":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"_":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"w":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2}}}}}}},"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"_":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"d":{"docs":{},"df":0,"_":{"docs":{},"df":0,"s":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.449489742783178}},"df":2}}}}}}}}}}}}}}}}}}}},"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"_":{"docs":{},"df":0,"h":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.23606797749979}},"df":2}}}}}}}}}},"s":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"t":{"docs":{},"df":0,"_":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"d":{"docs":{},"df":0,"_":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}}}}}}}}}}}}}}}},"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"_":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"_":{"docs":{},"df":0,"w":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"_":{"docs":{},"df":0,"f":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.8284271247461903}},"df":2}}}},"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0}},"df":2}}}}}}}}}}}}}}}}}}}}}},"’":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1}}},"x":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0}},"df":1,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":3.605551275463989},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0},"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.291502622129181},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.196152422706632},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.23606797749979}},"df":10,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"/":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}}}}}}}}},"'":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1},"(":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}},".":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"/":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}}}}}},"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"(":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"t":{"docs":{},"df":0,"(":{"docs":{},"df":0,")":{"docs":{},"df":0,"?":{"docs":{},"df":0,".":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"s":{"docs":{},"df":0,"(":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}}}}},"s":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"_":{"docs":{},"df":0,"w":{"docs":{},"df":0,"h":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}},"/":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{},"df":0,"m":{"docs":{},"df":0,"l":{"docs":{},"df":0,",":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"/":{"docs":{},"df":0,"x":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{},"df":0,"m":{"docs":{},"df":0,"l":{"docs":{},"df":0,"+":{"docs":{},"df":0,"x":{"docs":{},"df":0,"m":{"docs":{},"df":0,"l":{"docs":{},"df":0,",":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"/":{"docs":{},"df":0,"x":{"docs":{},"df":0,"m":{"docs":{},"df":0,"l":{"docs":{},"df":0,";":{"docs":{},"df":0,"q":{"docs":{},"df":0,"=":{"docs":{},"df":0,"0":{"docs":{},"df":0,".":{"docs":{},"df":0,"9":{"docs":{},"df":0,",":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"/":{"docs":{},"df":0,"a":{"docs":{},"df":0,"v":{"docs":{},"df":0,"i":{"docs":{},"df":0,"f":{"docs":{},"df":0,",":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"/":{"docs":{},"df":0,"w":{"docs":{},"df":0,"e":{"docs":{},"df":0,"b":{"docs":{},"df":0,"p":{"docs":{},"df":0,",":{"docs":{},"df":0,"*":{"docs":{},"df":0,"/":{"docs":{},"df":0,"*":{"docs":{},"df":0,";":{"docs":{},"df":0,"q":{"docs":{},"df":0,"=":{"docs":{},"df":0,"0":{"docs":{},"df":0,".":{"docs":{},"df":0,"8":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},":":{"docs":{},"df":0,"\\":{"docs":{},"df":0,"n":{"docs":{},"df":0,"{":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2}}}}}}}},"]":{"docs":{},"df":0,"(":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{},"df":0,"t":{"docs":{},"df":0,"p":{"docs":{},"df":0,"s":{"docs":{},"df":0,":":{"docs":{},"df":0,"/":{"docs":{},"df":0,"/":{"docs":{},"df":0,"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,".":{"docs":{},"df":0,"g":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"u":{"docs":{},"df":0,"b":{"docs":{},"df":0,".":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"/":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"/":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"m":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"o":{"docs":{},"df":0,"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,".":{"docs":{},"df":0,"j":{"docs":{},"df":0,"p":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"[":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}},"_":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1,"_":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}},"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"\\":{"docs":{},"df":0,"n":{"docs":{},"df":0,"h":{"docs":{},"df":0,"i":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"?":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"?":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"o":{"docs":{},"df":0,"p":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3}},"t":{"docs":{},"df":0,"\"":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1},"’":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.196152422706632}},"df":3}}},"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}},"e":{"docs":{"http://127.0.0.1:1111/":{"tf":1.0},"http://127.0.0.1:1111/docs/config-options/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0},"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0},"http://127.0.0.1:1111/posts/post-1/":{"tf":2.23606797749979}},"df":6},"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"v":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2}}}}},"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1}},"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"\"":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772}},"df":1},"'":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2},"`":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":1},"a":{"docs":{},"df":0,"f":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}},"b":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":2}},"f":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.4641016151377544}},"df":3}}},"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}}}}}},"’":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":6.244997998398398}},"df":3}}},"y":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772}},"df":1}},"`":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":1}},"’":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":3}},"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.242640687119285},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.605551275463989}},"df":3},"v":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}},"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903}},"df":3},"k":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.0}},"df":3}},"r":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.123105625617661},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.8284271247461903}},"df":5}},"s":{"docs":{},"df":0,"_":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"_":{"docs":{},"df":0,"w":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"_":{"docs":{},"df":0,"f":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}},"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}},"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"g":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}}}}},"s":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.69041575982343},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.795831523312719},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.385164807134504}},"df":3}},"u":{"docs":{},"df":0,"g":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.0}},"df":3,"t":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0},"http://127.0.0.1:1111/posts/post-1/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":5,".":{"docs":{},"df":0,"c":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/posts/post-1/":{"tf":1.0}},"df":1}}}}}}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":16.583123951777},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":7.937253933193772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":13.856406460551018},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":5.830951894845301},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.6457513110645907}},"df":9,".":{"docs":{},"df":0,"j":{"docs":{},"df":0,"o":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"(":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"w":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772}},"df":2}}}}}}}}}}}}}},":":{"docs":{},"df":0,":":{"docs":{},"df":0,"j":{"docs":{},"df":0,"o":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2,"e":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"(":{"docs":{},"df":0,")":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772}},"df":2}}}}}}}}}}}}}}}}}}},"s":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"e":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2,"(":{"docs":{},"df":0,"d":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"f":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"_":{"docs":{},"df":0,"m":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"(":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.449489742783178}},"df":2}}}}}}}},"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"s":{"docs":{},"df":0,"(":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2},"2":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2},"5":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}}},"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"w":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.123105625617661},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":4.123105625617661},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":4.0}},"df":4,"(":{"docs":{},"df":0,"m":{"docs":{},"df":0,"o":{"docs":{},"df":0,"v":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.123105625617661},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":4.123105625617661},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0}},"df":4}}}}}}}}}}},"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":9.797958971132712},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":9.797958971132712}},"df":2,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"w":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.6457513110645907}},"df":2,"(":{"docs":{},"df":0,"4":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.23606797749979}},"df":2}}}}}}}}}}},"s":{"docs":{},"df":0,"=":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}},"—":{"docs":{},"df":0,"w":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}},"’":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178}},"df":1}}},"e":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.58257569495584},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.47213595499958},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.4641016151377544}},"df":7,"_":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{},"df":0,"s":{"docs":{},"df":0,"_":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"_":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":1.4142135623730951}},"df":1}}}}}}}}}}}}}}}}}},"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"g":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.358898943540674}},"df":5,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":3}}},"p":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0}},"df":1}}}}}},"w":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":1}}},"u":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907}},"df":3,"n":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.8284271247461903}},"df":2}}}},"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":2,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2},"e":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1},"g":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}},"l":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0}},"df":1}},"m":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1,"e":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":9.539392014169456},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":7.54983443527075},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":8.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":7,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"d":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}},"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}},"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1}}}}}},"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772}},"df":1}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2}}}}},"t":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":6.0},"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.0},"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":5,"e":{"docs":{},"df":0,"=":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"v":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}}}}}},"l":{"docs":{},"df":0,"s":{"docs":{},"df":0,"v":{"docs":{},"df":0,"1":{"docs":{},"df":0,".":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":1.0}},"df":1}}}}}},"o":{"docs":{},"df":0,"_":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0}},"df":2}}}}}}}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.23606797749979}},"df":6}}},"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772}},"df":2}}}},"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.6457513110645907}},"df":2}}},"c":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.4142135623730951}},"df":1},"d":{"docs":{},"df":0,"a":{"docs":{},"df":0,"y":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/4-comments/":{"tf":1.4142135623730951}},"df":2}},"o":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4}},"e":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2},"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.872983346207417}},"df":3}}}},"k":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0},"http://127.0.0.1:1111/posts/post-2/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":5,"(":{"docs":{},"df":0,"c":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/posts/post-2/":{"tf":1.0}},"df":1}}}}}},"s":{"docs":{},"df":0,"(":{"docs":{},"df":0,"c":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/posts/post-2/":{"tf":1.0}},"df":1}}}}}},"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.291502622129181},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":5.291502622129181}},"df":2}}}}}}}}},"l":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":2}},"m":{"docs":{},"df":0,"'":{"docs":{"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":1.0}},"df":1},"l":{"docs":{"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":1.0}},"df":1}},"n":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}},"o":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":2},"l":{"docs":{"http://127.0.0.1:1111/rust/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907}},"df":5,"b":{"docs":{},"df":0,"o":{"docs":{},"df":0,"x":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":2}}},"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}},"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1}}}}},"p":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979}},"df":5,"i":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":3}}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":4,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"y":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"y":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":5}}},"u":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2}},"g":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}},"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}}}},"w":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.58257569495584},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.3166247903554}},"df":3,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.23606797749979}},"df":2}}}},"d":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":2,"o":{"docs":{},"df":0,"f":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}},"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}}},"i":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1},"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178}},"df":1},"t":{"docs":{"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0},"http://127.0.0.1:1111/rust/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":10.908712114635714},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":15.937377450509228},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":5.830951894845301},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":12.806248474865697},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":4.58257569495584}},"df":10,"\"":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1}}}}}}}}},"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"f":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"(":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"i":{"docs":{},"df":0,"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"_":{"docs":{},"df":0,"i":{"docs":{},"df":0,"f":{"docs":{},"df":0,"_":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},":":{"docs":{},"df":0,":":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"d":{"docs":{},"df":0,"(":{"docs":{},"df":0,".":{"docs":{},"df":0,".":{"docs":{},"df":0,".":{"docs":{},"df":0,")":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"b":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}},"s":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}},".":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{},"df":0,"m":{"docs":{},"df":0,"l":{"docs":{},"df":0,"#":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"r":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}},"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}},"’":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":3},"구":{"docs":{},"df":0,"문":{"docs":{},"df":0,"은":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"z":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1}}}}}}}},"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"f":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":5}},"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":2}}}},"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1}},"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":6}}},"m":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.7416573867739413}},"df":1}}}},"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}},"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}},"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3}},"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.898979485566356}},"df":5,".":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{},"df":0,"m":{"docs":{},"df":0,"l":{"docs":{},"df":0,"#":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}},"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0}},"df":1}}},"i":{"docs":{"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":8.426149773176359},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":4.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":7.745966692414834},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":4.0},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":8.717797887081348},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":4.69041575982343}},"df":12,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}},"c":{"docs":{},"df":0,"k":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":2,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2}}}}},"m":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":2},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"q":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.7320508075688772}},"df":1}}}}},"v":{"docs":{},"df":0,"i":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":3}}}}},"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1}}}},"u":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.1622776601683795}},"df":10},"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2}},"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}}}},"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772}},"df":3}}},"y":{"docs":{},"df":0,"_":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"v":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0}},"df":2}}}}}}},"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"d":{"docs":{},"df":0,"a":{"docs":{},"df":0,"y":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}},"n":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.0}},"df":1}},"p":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":2.449489742783178}},"df":1,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":7.280109889280518},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":6.928203230275509},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":5}},"r":{"docs":{},"df":0,"b":{"docs":{},"df":0,"o":{"docs":{},"df":0,"f":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}},"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.1622776601683795}},"df":4},"p":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1}}},"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0}},"df":1,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,".":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{},"df":0,"m":{"docs":{},"df":0,"l":{"docs":{},"df":0,"#":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}},"v":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.23606797749979}},"df":2},"w":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}},"e":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.744562646538029},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":4.123105625617661}},"df":2,".":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}},"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{},"df":0,"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"g":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"t":{"docs":{},"df":0,"w":{"docs":{},"df":0,"e":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{},"df":0,"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"g":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"y":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"t":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{},"df":0,"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"g":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"y":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{},"df":0,"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"i":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":1}}}}}}}},"l":{"docs":{},"df":0,"v":{"docs":{"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.0}},"df":1}}},"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":4}},"g":{"docs":{"http://127.0.0.1:1111/":{"tf":1.0}},"df":1},"t":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0}},"df":1}}}}},"o":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":8.94427190999916},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":8.246211251235321},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":9.327379053088816}},"df":6,"_":{"docs":{},"df":0,"b":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2,".":{"docs":{},"df":0,"p":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{},"df":0,"(":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"f":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"(":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"x":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.3166247903554}},"df":2,".":{"docs":{},"df":0,"c":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}},"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2,"(":{"docs":{},"df":0,"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"w":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.449489742783178}},"df":2}}}}}}}}}}}}}}}}},"1":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2,".":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"(":{"docs":{},"df":0,"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"w":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1}},"y":{"docs":{},"df":0,"p":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":4.69041575982343},"http://127.0.0.1:1111/rust/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":16.401219466856727},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":4.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":19.519221295943137},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":5.477225575051661},"http://127.0.0.1:1111/rust/chapter2/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":22.627416997969522},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":4.358898943540674},"http://127.0.0.1:1111/rust/to do/chapter4/3-the-slice-type/":{"tf":1.0}},"df":16,"\"":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"n":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"/":{"docs":{},"df":0,"e":{"docs":{},"df":0,"q":{"docs":{},"df":0,"u":{"docs":{},"df":0,"i":{"docs":{},"df":0,"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}},"b":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}},"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}}}}},"h":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"w":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}},"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"=":{"docs":{},"df":0,"t":{"docs":{},"df":0,"y":{"docs":{},"df":0,"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}},",":{"docs":{},"df":0,")":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}}},":":{"docs":{},"df":0,":":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}},"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"d":{"docs":{},"df":0,"(":{"docs":{},"df":0,".":{"docs":{},"df":0,".":{"docs":{},"df":0,".":{"docs":{},"df":0,")":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"b":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}},"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}},"o":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}},"s":{"docs":{},"df":0,".":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{},"df":0,"m":{"docs":{},"df":0,"l":{"docs":{},"df":0,"#":{"docs":{},"df":0,"d":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}}},"e":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0}},"df":1}}},"w":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}},"—":{"docs":{},"df":0,"f":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}},"’":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":3}},"i":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":2}},"o":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1,"r":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/posts/post-1/":{"tf":1.0}},"df":1}}}}}},"u":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.23606797749979}},"df":7,"\"":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}},"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2,";":{"docs":{},"df":0,"(":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}},"+":{"docs":{},"df":0,"0":{"docs":{},"df":0,"0":{"docs":{},"df":0,"0":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1}}}},"1":{"docs":{},"df":0,"0":{"docs":{},"df":0,"f":{"docs":{},"df":0,"f":{"docs":{},"df":0,"f":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1}}}}}},"d":{"docs":{},"df":0,"7":{"docs":{},"df":0,"f":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1}}}},"e":{"docs":{},"df":0,"0":{"docs":{},"df":0,"0":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1}}}}},"3":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":4.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter2/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.291502622129181},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":5.291502622129181}},"df":9}},"6":{"docs":{},"df":0,"4":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}},"8":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.1622776601683795}},"df":5},"b":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/posts/post-2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":1.0}},"df":2}}}}},"g":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1}}},"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1}}}}}}},"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":2}},"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.0}},"df":1,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"/":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}},"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}},"m":{"docs":{},"df":0,"b":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}},"b":{"docs":{},"df":0,"o":{"docs":{},"df":0,"x":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}},"c":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}}}},"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}},"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4},"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772}},"df":1}}}}}}}}},"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":4}}}},"f":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":3}}},"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.1622776601683795}},"df":3,"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}},"s":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.7416573867739413}},"df":2}}},"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/to do/chapter4/":{"tf":1.0}},"df":4}}},"o":{"docs":{},"df":0,"o":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}}}},"o":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}},"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}},"x":{"docs":{},"df":0,"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":2}}}}}},"f":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}}}},"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":2}}}}}},"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}},"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979}},"df":2}}},"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}}},"f":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}},"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":1.0}},"df":1}}}}},"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772}},"df":2,"\"":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}},"q":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":2}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.358898943540674},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":6,"_":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":2.0}},"df":1}}}}}},"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.5677643628300215},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":5.5677643628300215}},"df":2}}}}},"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}}}}},"k":{"docs":{},"df":0,"n":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178}},"df":2}}}}},"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":4}}},"i":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":3},"m":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1}}}},"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2}}}},"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.0}},"df":2}}}}}}}}},"o":{"docs":{},"df":0,"p":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":7.483314773547883},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":7.483314773547883},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter2/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.8284271247461903}},"df":11}}}},"r":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0}},"df":2}}},"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907}},"df":2}}}}},"l":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1},"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"v":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}},"o":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1}}},"s":{"docs":{},"df":0,"a":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":11.180339887498949},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":6.0}},"df":4,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2}}}}},"e":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":2}},"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3}},"z":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1}},"p":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.8284271247461903}},"df":1,".":{"docs":{},"df":0,"j":{"docs":{},"df":0,"p":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":4.0}},"df":1}}}}}}}}},"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.0}},"df":2}}}}},"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.605551275463989}},"df":3}}},"u":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":7,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}},"w":{"docs":{},"df":0,"i":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}},"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":1}}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.47213595499958},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":4.358898943540674},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.605551275463989}},"df":6,"(":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}},"_":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2,"_":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"f":{"docs":{},"df":0,"a":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}},"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.795831523312719},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":4.58257569495584},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":4,"e":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"f":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"(":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}},"(":{"docs":{},"df":0,"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"w":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}},"메":{"docs":{},"df":0,"서":{"docs":{},"df":0,"드":{"docs":{},"df":0,"는":{"docs":{},"df":0,"]":{"docs":{},"df":0,"(":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{},"df":0,"t":{"docs":{},"df":0,"p":{"docs":{},"df":0,"s":{"docs":{},"df":0,":":{"docs":{},"df":0,"/":{"docs":{},"df":0,"/":{"docs":{},"df":0,"d":{"docs":{},"df":0,"o":{"docs":{},"df":0,"c":{"docs":{},"df":0,".":{"docs":{},"df":0,"r":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}}}},"y":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}},"p":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/posts/post-2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":7.416198487095663},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.5677643628300215},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":6.48074069840786}},"df":7,"d":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.58257569495584},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter2/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.358898943540674},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":8}}},"f":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}},"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":4}}}},"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.6457513110645907}},"df":2}}}},"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}},"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3}},"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}},"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}}},"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1,"e":{"docs":{},"df":0,"!":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"u":{"docs":{},"df":0,"p":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"/":{"docs":{},"df":0,"a":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}},"]":{"docs":{},"df":0,"(":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{},"df":0,"t":{"docs":{},"df":0,"p":{"docs":{},"df":0,"s":{"docs":{},"df":0,":":{"docs":{},"df":0,"/":{"docs":{},"df":0,"/":{"docs":{},"df":0,"g":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"u":{"docs":{},"df":0,"b":{"docs":{},"df":0,".":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"/":{"docs":{},"df":0,"u":{"docs":{},"df":0,"p":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"i":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1}}}}}},"w":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}},"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.8284271247461903}},"df":2},"l":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772}},"df":3}},"s":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":3.3166247903554},"http://127.0.0.1:1111/docs/config-options/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":3.605551275463989},"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.0},"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":2.0},"http://127.0.0.1:1111/posts/post-2/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":25.495097567963924},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":11.269427669584644},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":22.715633383201094},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":7.14142842854285},"http://127.0.0.1:1111/rust/chapter2/":{"tf":4.58257569495584},"http://127.0.0.1:1111/rust/chapter22/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":26.962937525425527},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":10.862780491200215},"http://127.0.0.1:1111/rust/to do/chapter5/":{"tf":1.0},"http://127.0.0.1:1111/rust/to do/chapter5/2-an-example-program-using-structs/":{"tf":1.0}},"df":18,",":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,";":{"docs":{},"df":0,"q":{"docs":{},"df":0,"=":{"docs":{},"df":0,"0":{"docs":{},"df":0,".":{"docs":{},"df":0,"5":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}},"a":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2,"b":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}},"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":3}},"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}},"r":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":6.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":7.280109889280518},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":4.58257569495584}},"df":7,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"'":{"docs":{},"df":0,"a":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}},"1":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.7416573867739413}},"df":2,".":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}},"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}}}}},"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"n":{"docs":{},"df":0,"_":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}},"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}},"2":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.6457513110645907}},"df":2},"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"_":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"y":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/posts/post-1/":{"tf":2.0}},"df":1}}}}}}}}}}}}}}}}},"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"f":{"docs":{},"df":0,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2},"2":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2},"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,".":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"w":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{},"df":0,"_":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"_":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}},"n":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":6.708203932499369},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":5.916079783099616}},"df":2,"e":{"docs":{},"df":0,"_":{"docs":{},"df":0,"f":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.6457513110645907}},"df":2,"e":{"docs":{},"df":0,".":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"_":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"_":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"m":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}}}}}}}}}}}}}}}},"_":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}}}}}}}},"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"f":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"%":{"docs":{},"df":0,"\\":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"j":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":1.4142135623730951}},"df":1}}}}}}}}}}}}}}}},"’":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":2}}},"i":{"docs":{},"df":0,"z":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.477225575051661},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":5.385164807134504},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.6457513110645907}},"df":8}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":2,"e":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"k":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}},"u":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903}},"df":5}}}},"t":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":4.0}},"df":9},"i":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":3}}}},"v":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":6.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":6.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.242640687119285},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":4.242640687119285}},"df":6,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":4}}},".":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"(":{"docs":{},"df":0,"1":{"docs":{},"df":0,"0":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}},"2":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}},"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"(":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}},"p":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{},"df":0,"(":{"docs":{},"df":0,"5":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2},"6":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2},"7":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2},"8":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}},"0":{"docs":{},"df":0,".":{"docs":{},"df":0,"1":{"docs":{},"df":0,".":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":8.660254037844387},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":8.660254037844387},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":5.0},"http://127.0.0.1:1111/rust/chapter2/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.385164807134504},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":5.385164807134504}},"df":12}}},"2":{"docs":{},"df":0,".":{"docs":{},"df":0,"1":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0}},"df":1},"4":{"docs":{},"df":0,"4":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.4142135623730951}},"df":1}},"7":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.4142135623730951}},"df":1}},"2":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0}},"df":1},"8":{"docs":{},"df":0,"6":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0}},"df":1}},"9":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.4142135623730951}},"df":1}}},"3":{"docs":{},"df":0,".":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0}},"df":1},"1":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.4142135623730951}},"df":1}}},"6":{"docs":{},"df":0,".":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0}},"df":1},"4":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.4142135623730951}},"df":1}}},"8":{"docs":{},"df":0,".":{"docs":{},"df":0,"5":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter2/":{"tf":2.0}},"df":3},"6":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0}},"df":1}}}}},"1":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.8284271247461903}},"df":2,".":{"docs":{},"df":0,"0":{"docs":{},"df":0,".":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.7320508075688772}},"df":1}}},"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0}},"df":2,"(":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{},"df":0,"(":{"docs":{},"df":0,"|":{"docs":{},"df":0,"x":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772}},"df":2}}}}}}}}}}}}}},"3":{"docs":{},"df":0,".":{"docs":{},"df":0,"0":{"docs":{},"df":0,".":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0}},"df":2}}}}},"_":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.3166247903554}},"df":2,".":{"docs":{},"df":0,"s":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}},"2":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2},"4":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.23606797749979}},"df":2,"(":{"docs":{},"df":0,"i":{"docs":{},"df":0,"p":{"docs":{},"df":0,"v":{"docs":{},"df":0,"4":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"d":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}},"u":{"docs":{},"df":0,"8":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}},"6":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.449489742783178}},"df":2,"(":{"docs":{},"df":0,"i":{"docs":{},"df":0,"p":{"docs":{},"df":0,"v":{"docs":{},"df":0,"6":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"d":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}},"[":{"docs":{},"df":0,"9":{"docs":{},"df":0,"9":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}},"a":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.69041575982343},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":4.69041575982343},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":4,"i":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.830951894845301},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":9.746794344808963},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.6457513110645907}},"df":5,"l":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}},"u":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":23.259406699226016},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":10.198039027185569},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":16.911534525287763},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":4.358898943540674},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":24.289915602982237},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":6.0}},"df":12,"e":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"—":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}},"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}},"u":{"docs":{},"df":0,"3":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}},".":{"docs":{},"df":0,"b":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{},"df":0,"_":{"docs":{},"df":0,"m":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}},"_":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"_":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"s":{"docs":{},"df":0,"(":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"q":{"docs":{},"df":0,"u":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"(":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"k":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"g":{"docs":{},"df":0,"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}},"i":{"docs":{},"df":0,"3":{"docs":{},"df":0,"2":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}},"s":{"docs":{},"df":0,".":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"_":{"docs":{},"df":0,"m":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{},"df":0,"_":{"docs":{},"df":0,"p":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}},"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}},"[":{"docs":{},"df":0,".":{"docs":{},"df":0,".":{"docs":{},"df":0,"m":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}},"m":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}},"}":{"docs":{},"df":0,"{":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"_":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.0}},"df":1}}}}}}}}}}}},"’":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}},"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.6457513110645907}},"df":4,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":10.14889156509222},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":4.123105625617661},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":11.224972160321824},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":3.3166247903554},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":9.746794344808963},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.449489742783178}},"df":12}},"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":6.082762530298219},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.291502622129181},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter2/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":8.774964387392123},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":7,"(":{"docs":{},"df":0,"x":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1}},"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":3}}},"o":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":3,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}},"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}},"c":{"docs":{"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":1.0}},"df":1,"s":{"docs":{},"df":0,"=":{"docs":{},"df":0,"g":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":1.0}},"df":1}}}}}},"e":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.358898943540674},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":4.358898943540674},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.47213595499958},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":4.242640687119285},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":3.872983346207417}},"df":6,"!":{"docs":{},"df":0,"[":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1},"r":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}},"'":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}},"1":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.449489742783178}},"df":6,"0":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2},"2":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}}},"2":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2},"3":{"docs":{},"df":0,"4":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.23606797749979}},"df":2}},"`":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1},"r":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1}}}}},"s":{"docs":{},"df":0,"h":{"docs":{},"df":0,"i":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}},"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.8284271247461903}},"df":1}},"`":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.8284271247461903}},"df":1}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}},"_":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0}},"df":4}}}},"i":{"docs":{},"df":0,"3":{"docs":{},"df":0,"2":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4}}}}}},"r":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}},"s":{"docs":{},"df":0,"h":{"docs":{},"df":0,"i":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}},"o":{"docs":{},"df":0,"e":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}}}},"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}},"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":4}}}}}}}}},"t":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2,";":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{},"df":0,"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"g":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"d":{"docs":{},"df":0,"i":{"docs":{},"df":0,"s":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"y":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"t":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{},"df":0,"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"h":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"j":{"docs":{},"df":0,"o":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"(":{"docs":{},"df":0,")":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"u":{"docs":{},"df":0,"3":{"docs":{},"df":0,"2":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}},"w":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"k":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.23606797749979}},"df":2}}}}}}}}}}}}},":":{"docs":{},"df":0,":":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"w":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":6}}},"w":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"y":{"docs":{},"df":0,"(":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.449489742783178}},"df":2}}}}}}}}}}}}}}}}},"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0},"http://127.0.0.1:1111/rust/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":7.937253933193772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.196152422706632},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":8.888194417315589}},"df":8}}}},"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":2,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,".":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}},"h":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1}}}}}},"l":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.8284271247461903}},"df":1,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"/":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1}}}}}}}}}},"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.23606797749979}},"df":1,"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"/":{"docs":{},"df":0,"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}}}}}}}},"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2,"b":{"docs":{},"df":0,"o":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":5}}},"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.242640687119285},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.0990195135927845}},"df":3,"f":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":4}}},"s":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":3},"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":6.324555320336759},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.58257569495584}},"df":8}}},"u":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}},"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":4}}}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"b":{"docs":{},"df":0,"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1}}}}}}}}},"i":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":3},"c":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":3}},"d":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1}},"m":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1,"e":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0}},"df":1,"(":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{},"df":0,"=":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{},"df":0,"_":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0}},"df":1}}}}}}}}}}}}}},"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.449489742783178}},"df":3}}}},"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1,"a":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}},"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2}},"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":5}},"u":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":6}}}},"t":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951}},"df":1,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}},"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"u":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.7320508075688772}},"df":1},"t":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":3.0}},"df":1}}}}}},"w":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}},"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2,"_":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0}},"df":1}}}}},"t":{"docs":{"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.7320508075688772}},"df":1}},"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979}},"df":1}}}}}},"w":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":4,"a":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.7416573867739413}},"df":4,"—":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}},"l":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.7320508075688772}},"df":1}}}}},"k":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":2}},"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0},"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.0},"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":9.797958971132712},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":9.695359714832659},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":10.63014581273465}},"df":8}},"r":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.358898943540674},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.4641016151377544},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.291502622129181},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":8,"(":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}},"i":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"f":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"_":{"docs":{},"df":0,"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"_":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}}},"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"d":{"docs":{},"df":0,"_":{"docs":{},"df":0,"i":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":4}}}}}},"m":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"_":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0}},"df":3}}}}}}},"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.0}},"df":1}}}}},"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}},"s":{"docs":{},"df":0,"n":{"docs":{},"df":0,"’":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}},"t":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0}},"df":1,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}},"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1,"w":{"docs":{},"df":0,"a":{"docs":{},"df":0,"y":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}}},"v":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}},"y":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":8.94427190999916},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":7.280109889280518},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":10.908712114635714}},"df":5}},"e":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1},"l":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951}},"df":1}},"v":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2}},"'":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2},"l":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":2}},"r":{"docs":{"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":3},"v":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}},"a":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":6.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":3.1622776601683795}},"df":2,"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.23606797749979}},"df":2}}}}}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":1}}},"b":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.385164807134504},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.4142135623730951}},"df":5,"g":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0}},"df":1}},"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"i":{"docs":{},"df":0,"f":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0}},"df":1}}}}}}}},"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2}}}},"e":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.0}},"df":2,"d":{"docs":{},"df":0,"a":{"docs":{},"df":0,"y":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}}}},"i":{"docs":{},"df":0,"g":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}},"l":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/about/":{"tf":1.0},"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":3}}},"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.291502622129181},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.242640687119285},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.0}},"df":3}},"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"’":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}},"’":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.3166247903554}},"df":3},"l":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":13.114877048604},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":9.643650760992955},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":11.489125293076057}},"df":3}},"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":8.12403840463596},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":6.928203230275509},"http://127.0.0.1:1111/rust/chapter3/4-comments/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":7.0710678118654755}},"df":4},"v":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":8.366600265340756},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":7.681145747868608},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":8.0}},"df":3}}},"h":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"v":{"docs":{"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979}},"df":4}},"’":{"docs":{"http://127.0.0.1:1111/rust/chapter3/4-comments/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979}},"df":2}}},"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"v":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1},"b":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}},"’":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2}}},"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.291502622129181},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.916079783099616},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":6}}}},"w":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/4-comments/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":4}},"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"v":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}},"s":{"docs":{},"df":0,"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0}},"df":1,"\"":{"docs":{},"df":0,".":{"docs":{},"df":0,"t":{"docs":{},"df":0,"o":{"docs":{},"df":0,"_":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0}},"df":1}}}}}}}}}}}},"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}}}}}},"o":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1},"l":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":5}},"s":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.872983346207417}},"df":3}}}},"i":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}},"t":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.0990195135927845},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":4.58257569495584},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":6.48074069840786},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":5.196152422706632}},"df":4,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}},"1":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}},"l":{"docs":{},"df":0,"d":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":3}}}}}},"n":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":3,"d":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1,"o":{"docs":{},"df":0,"w":{"docs":{"http://127.0.0.1:1111/rust/chapter1/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0}},"df":7}}},"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}},"p":{"docs":{"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.0}},"df":1},"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}},"s":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1},"h":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3}},"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"_":{"docs":{},"df":0,"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}},"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.69041575982343},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":6.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":6.164414002968976}},"df":5}},"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":5.385164807134504},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.898979485566356},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":6.855654600401044},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":8}}},"—":{"docs":{},"df":0,"y":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}}},"z":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0}},"df":2,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"f":{"docs":{},"df":0,"l":{"docs":{},"df":0,"y":{"docs":{},"df":0,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}}}}},"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"'":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":3}},"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":4}}},"t":{"docs":{},"df":0,"_":{"docs":{},"df":0,"w":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2}}}}}},"’":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":6.6332495807108},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.898979485566356},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":6.164414002968976}},"df":3}}},"r":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.605551275463989},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":7.681145747868608},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":4.898979485566356}},"df":6,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":2},"p":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/":{"tf":1.0}},"df":1}}}}}},"k":{"docs":{"http://127.0.0.1:1111/about/":{"tf":1.0},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.449489742783178},"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":8.774964387392123},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":7.416198487095663},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":8.602325267042627},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.23606797749979}},"df":7,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":12.165525060596439},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":10.14889156509222}},"df":2,".":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0}},"df":2}},"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0}},"df":2,".":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"(":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"\"":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"j":{"docs":{},"df":0,"o":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"(":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"w":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}},"`":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"`":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"j":{"docs":{},"df":0,"o":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"(":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"w":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"j":{"docs":{},"df":0,"o":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"(":{"docs":{},"df":0,")":{"docs":{},"df":0,".":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"w":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772}},"df":2}}}}}}}}}}}}},"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772}},"df":2}}}}}}}}}}},":":{"docs":{},"df":0,":":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"w":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.6457513110645907}},"df":2}}}}},"s":{"docs":{},"df":0,".":{"docs":{},"df":0,"p":{"docs":{},"df":0,"u":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{},"df":0,"(":{"docs":{},"df":0,"w":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"k":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"w":{"docs":{},"df":0,"(":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.449489742783178}},"df":2}}}}}}}}}}}}}}}}}}}}},"’":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.0}},"df":1}}},"f":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{"http://127.0.0.1:1111/posts/post-2/":{"tf":1.7320508075688772}},"df":1}}}},"s":{"docs":{},"df":0,"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":6.557438524302},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":4,"e":{"docs":{},"df":0,"—":{"docs":{},"df":0,"w":{"docs":{},"df":0,"e":{"docs":{},"df":0,"’":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}}}}}}}},"l":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter2/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter3/4-comments/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":4.47213595499958},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":4.47213595499958}},"df":14}},"r":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":3}},"s":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":2},"t":{"docs":{},"df":0,"h":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":3,"w":{"docs":{},"df":0,"h":{"docs":{},"df":0,"i":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}}}},"u":{"docs":{},"df":0,"l":{"docs":{},"df":0,"d":{"docs":{},"df":0,"n":{"docs":{},"df":0,"’":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.7416573867739413}},"df":3}}},"’":{"docs":{},"df":0,"v":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}}}}},"w":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":2}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":5,"p":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951}},"df":3,"(":{"docs":{},"df":0,"v":{"docs":{},"df":0,"e":{"docs":{},"df":0,"c":{"docs":{},"df":0,"!":{"docs":{},"df":0,"[":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,":":{"docs":{},"df":0,":":{"docs":{},"df":0,"f":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"(":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}}}},"`":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}},"&":{"docs":{},"df":0,"l":{"docs":{},"df":0,"t":{"docs":{},"df":0,";":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}}}}},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{},"df":0,"_":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1,"a":{"docs":{},"df":0,"d":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1}}}}}}}}}},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"k":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}}},"t":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/posts/post-2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":8.306623862918075},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":7.615773105863909},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter22/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":7.211102550927978},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":8,"!":{"docs":{},"df":0,"(":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}},"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"m":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}},"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":6}}}},"_":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2,"l":{"docs":{},"df":0,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"m":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}}}},"f":{"docs":{},"df":0,"m":{"docs":{},"df":0,"t":{"docs":{},"df":0,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"m":{"docs":{},"df":0,"u":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951}},"df":2}}}}}}}}}}}}},"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{},"df":0,"(":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}},"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.1622776601683795},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.0}},"df":4}}}}},"o":{"docs":{},"df":0,"n":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":3}},"t":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.23606797749979}},"df":3}}}},"w":{"docs":{},"df":0,"w":{"docs":{},"df":0,".":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,".":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{},"df":0,"m":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0}},"df":1}}}}}}}}}}}}},"y":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"w":{"docs":{},"df":0,"y":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}},"x":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":6.164414002968976},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":6.164414002968976},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":12.24744871391589},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":12.165525060596439},"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":6.557438524302},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":6.164414002968976},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":9.746794344808963},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":8.717797887081348}},"df":12,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}},".":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1},"1":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1},"2":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0}},"df":1},"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2}}},"y":{"docs":{},"df":0,".":{"docs":{},"df":0,"z":{"docs":{"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":1.0}},"df":1}}}},"1":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2},"2":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2},"8":{"docs":{},"df":0,"6":{"docs":{},"df":0,"_":{"docs":{},"df":0,"6":{"docs":{},"df":0,"4":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772}},"df":2}}}}},":":{"docs":{},"df":0,"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"p":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.7320508075688772}},"df":2}}}}},"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"'":{"docs":{},"df":0,"b":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"'":{"docs":{},"df":0,"b":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"'":{"docs":{},"df":0,"a":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"r":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"'":{"docs":{},"df":0,"a":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"'":{"docs":{},"df":0,"b":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"'":{"docs":{},"df":0,"b":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"'":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}}}}}}}},"i":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1},"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1},"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}},"y":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"'":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"x":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"y":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"'":{"docs":{},"df":0,"a":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"x":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}},"p":{"docs":{},"df":0,"o":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"t":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"u":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"x":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"t":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"y":{"docs":{},"df":0,"`":{"docs":{},"df":0,"`":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}}}}}},"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}}}}}},"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":1.0}},"df":1}}}},"h":{"docs":{},"df":0,"t":{"docs":{},"df":0,"m":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}},"k":{"docs":{},"df":0,"u":{"docs":{},"df":0,"f":{"docs":{},"df":0,"f":{"docs":{},"df":0,"1":{"docs":{},"df":0,"n":{"docs":{},"df":0,"n":{"docs":{},"df":0,"b":{"docs":{},"df":0,"a":{"docs":{},"df":0,"8":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}}}}}}}}},"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.8284271247461903}},"df":1}}}}},"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":1}},"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}}}}}}}},"y":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.23606797749979}},"df":1,"z":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}},"y":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.47213595499958},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":4.47213595499958},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":10.44030650891055},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":10.344080432788601},"http://127.0.0.1:1111/rust/chapter2/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":2.449489742783178},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":4.123105625617661},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":8.426149773176359},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":7.54983443527075}},"df":11,".":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":2}}}}},"l":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2}}}},"1":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.7320508075688772}},"df":2}}}},"2":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2,"&":{"docs":{},"df":0,"g":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.4142135623730951}},"df":2,";":{"docs":{},"df":0,"(":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2}}}}}}}}}},"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"k":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":3.7416573867739413},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":2.23606797749979}},"df":2}}},"e":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1,"a":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":3}},"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":2.0}},"df":4}}}}},"i":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":1}}}},"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.8284271247461903}},"df":1}}}}},"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":1},"v":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.4142135623730951}},"df":2}},"'":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}},"r":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0}},"df":1}},"`":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":1},"v":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951}},"df":1}},"r":{"docs":{},"df":0,"s":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"f":{"docs":{"http://127.0.0.1:1111/posts/post-2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0}},"df":3}}}}},"t":{"docs":{},"df":0,"u":{"docs":{},"df":0,"b":{"docs":{"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0}},"df":1,"e":{"docs":{},"df":0,"(":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{},"df":0,"=":{"docs":{},"df":0,"\"":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"_":{"docs":{},"df":0,"i":{"docs":{},"df":0,"d":{"docs":{},"df":0,"_":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0}},"df":1}}}}}}}}}}}}}}}}}}},"’":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.23606797749979},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.7320508075688772},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":2.0}},"df":3},"l":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.69041575982343},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":5.196152422706632},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.477225575051661}},"df":3}},"r":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.69041575982343},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":4.242640687119285},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":5.0990195135927845}},"df":3},"v":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":4.123105625617661},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.872983346207417},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":3.4641016151377544}},"df":3}}}},"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"k":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":2.0}},"df":1}}}}}}}}},"u":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0}},"df":1}},"y":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"k":{"docs":{},"df":0,"e":{"docs":{},"df":0,"7":{"docs":{},"df":0,"b":{"docs":{},"df":0,"f":{"docs":{},"df":0,"u":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951}},"df":1}}}}}}}},"y":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":1.0}},"df":2}}}},"z":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":2.6457513110645907},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":2.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":7,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2,"r":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":2.8284271247461903},"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":3.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.7320508075688772}},"df":5}}},"i":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2,"(":{"docs":{},"df":0,"&":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,";":{"docs":{},"df":0,"b":{"docs":{},"df":0,"u":{"docs":{},"df":0,"f":{"docs":{},"df":0,"f":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"[":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2}}}}}}}}}}}}}}}},"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/":{"tf":2.449489742783178},"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0},"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.0},"http://127.0.0.1:1111/posts/post-1/":{"tf":1.4142135623730951},"http://127.0.0.1:1111/posts/post-2/":{"tf":2.0}},"df":6}}}}}},"title":{"root":{"docs":{},"df":0,"1":{"docs":{},"df":0,"0":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2},"1":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2},"7":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0}},"df":2},"8":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}},"2":{"docs":{"http://127.0.0.1:1111/posts/post-1/":{"tf":1.0}},"df":1,"1":{"docs":{"http://127.0.0.1:1111/rust/chapter17-21/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0}},"df":2}},"4":{"docs":{"http://127.0.0.1:1111/rust/chapter4-10/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":2},"b":{"docs":{},"df":0,"a":{"docs":{},"df":0,"s":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}},"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/posts/post-2/":{"tf":1.0}},"df":1}}},"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{"http://127.0.0.1:1111/rust/to do/chapter4/2-references-and-borrowing/":{"tf":1.0}},"df":1}}}}}},"c":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"g":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":1.0}},"df":1}}}},"o":{"docs":{},"df":0,"m":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter3/4-comments/":{"tf":1.0}},"df":1}}},"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter3/":{"tf":1.0}},"df":1}}}},"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{},"df":0,"p":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter3/":{"tf":1.0}},"df":1}}}},"f":{"docs":{},"df":0,"i":{"docs":{},"df":0,"g":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0}},"df":1}}},"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.0}},"df":1}}}}}}},"d":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/to do/chapter5/":{"tf":1.0}},"df":2}}},"e":{"docs":{},"df":0,"e":{"docs":{},"df":0,"p":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"u":{"docs":{},"df":0,"g":{"docs":{},"df":0,"h":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0}},"df":1}}}}}}}}},"f":{"docs":{},"df":0,"i":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/to do/chapter5/1-defining-and-instantiating-structs/":{"tf":1.0}},"df":1}}},"p":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"y":{"docs":{"http://127.0.0.1:1111/posts/post-2/":{"tf":1.0}},"df":1}}}}},"o":{"docs":{},"df":0,"c":{"docs":{"http://127.0.0.1:1111/docs/":{"tf":1.0}},"df":1}}},"e":{"docs":{},"df":0,"x":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"p":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/to do/chapter5/2-an-example-program-using-structs/":{"tf":1.0}},"df":1}}}},"t":{"docs":{},"df":0,"e":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0}},"df":1},"s":{"docs":{"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.0}},"df":1}}}}}},"f":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"tf":1.0}},"df":1}}},"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"tf":1.0}},"df":1}}}}}}}},"g":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0}},"df":1}}},"e":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter1/":{"tf":1.0}},"df":1}},"i":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"u":{"docs":{},"df":0,"b":{"docs":{"http://127.0.0.1:1111/posts/post-2/":{"tf":1.0}},"df":1}}}}},"u":{"docs":{},"df":0,"e":{"docs":{},"df":0,"s":{"docs":{},"df":0,"s":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0}},"df":1}}}}},"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"l":{"docs":{},"df":0,"o":{"docs":{"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"tf":1.0}},"df":2}}}}},"i":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"tf":1.0}},"df":1},"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{"http://127.0.0.1:1111/rust/to do/chapter5/1-defining-and-instantiating-structs/":{"tf":1.0}},"df":1}}}}}},"t":{"docs":{},"df":0,"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"d":{"docs":{},"df":0,"u":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/":{"tf":1.0}},"df":1}}}}}}}}},"m":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"k":{"docs":{},"df":0,"d":{"docs":{},"df":0,"o":{"docs":{},"df":0,"w":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0}},"df":1}}}}}}},"e":{"docs":{},"df":0,"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/to do/chapter5/3-method-syntax/":{"tf":1.0}},"df":1}}}}},"u":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":1.0}},"df":1}}}}}},"o":{"docs":{},"df":0,"p":{"docs":{},"df":0,"t":{"docs":{},"df":0,"i":{"docs":{},"df":0,"o":{"docs":{},"df":0,"n":{"docs":{"http://127.0.0.1:1111/docs/config-options/":{"tf":1.0}},"df":1}}}}},"w":{"docs":{},"df":0,"n":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"s":{"docs":{},"df":0,"h":{"docs":{},"df":0,"i":{"docs":{},"df":0,"p":{"docs":{"http://127.0.0.1:1111/rust/to do/chapter4/":{"tf":1.0},"http://127.0.0.1:1111/rust/to do/chapter4/1-what-is-ownership/":{"tf":1.0}},"df":2}}}}}}}}},"p":{"docs":{},"df":0,"a":{"docs":{},"df":0,"g":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/posts/post-2/":{"tf":1.0}},"df":1}}},"o":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/posts/":{"tf":1.0}},"df":1}}},"r":{"docs":{},"df":0,"o":{"docs":{},"df":0,"g":{"docs":{},"df":0,"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/rust/chapter2/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter3/":{"tf":1.0},"http://127.0.0.1:1111/rust/to do/chapter5/2-an-example-program-using-structs/":{"tf":1.0}},"df":3}}}}}}},"r":{"docs":{},"df":0,"e":{"docs":{},"df":0,"f":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/to do/chapter4/2-references-and-borrowing/":{"tf":1.0}},"df":1}}},"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/to do/chapter5/":{"tf":1.0}},"df":1}}}}},"s":{"docs":{},"df":0,"h":{"docs":{},"df":0,"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/docs/extended-shortcodes/":{"tf":1.0}},"df":1}}}}}}},"l":{"docs":{},"df":0,"i":{"docs":{},"df":0,"c":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/to do/chapter4/3-the-slice-type/":{"tf":1.0}},"df":1}}}},"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter1/":{"tf":1.0}},"df":1}}},"r":{"docs":{},"df":0,"u":{"docs":{},"df":0,"c":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/to do/chapter5/":{"tf":1.0},"http://127.0.0.1:1111/rust/to do/chapter5/1-defining-and-instantiating-structs/":{"tf":1.0},"http://127.0.0.1:1111/rust/to do/chapter5/2-an-example-program-using-structs/":{"tf":1.0}},"df":3,"u":{"docs":{},"df":0,"r":{"docs":{"http://127.0.0.1:1111/rust/to do/chapter5/":{"tf":1.0}},"df":1}}}}}}},"y":{"docs":{},"df":0,"n":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"x":{"docs":{"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"tf":1.0},"http://127.0.0.1:1111/rust/to do/chapter5/3-method-syntax/":{"tf":1.0}},"df":2}}}}}},"t":{"docs":{},"df":0,"h":{"docs":{},"df":0,"e":{"docs":{},"df":0,"m":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/docs/theme-extension/":{"tf":1.0}},"df":1}}}},"r":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"s":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{},"df":0,"t":{"docs":{"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"tf":1.0},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"tf":1.0}},"df":3}}}}}}},"y":{"docs":{},"df":0,"p":{"docs":{},"df":0,"e":{"docs":{"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"tf":1.0},"http://127.0.0.1:1111/rust/to do/chapter4/3-the-slice-type/":{"tf":1.0}},"df":2}}}},"u":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{},"df":0,"e":{"docs":{},"df":0,"r":{"docs":{},"df":0,"s":{"docs":{},"df":0,"t":{"docs":{},"df":0,"a":{"docs":{},"df":0,"n":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/to do/chapter4/":{"tf":1.0}},"df":1}}}}}}}}},"s":{"docs":{"http://127.0.0.1:1111/posts/post-2/":{"tf":1.0},"http://127.0.0.1:1111/rust/to do/chapter5/":{"tf":1.0},"http://127.0.0.1:1111/rust/to do/chapter5/2-an-example-program-using-structs/":{"tf":1.0}},"df":3}},"v":{"docs":{},"df":0,"a":{"docs":{},"df":0,"r":{"docs":{},"df":0,"i":{"docs":{},"df":0,"a":{"docs":{},"df":0,"b":{"docs":{},"df":0,"l":{"docs":{"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"tf":1.0}},"df":1}}}}}}},"w":{"docs":{},"df":0,"e":{"docs":{},"df":0,"l":{"docs":{},"df":0,"c":{"docs":{},"df":0,"o":{"docs":{},"df":0,"m":{"docs":{"http://127.0.0.1:1111/about/":{"tf":1.0},"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"tf":1.0}},"df":2}}}}},"o":{"docs":{},"df":0,"r":{"docs":{},"df":0,"l":{"docs":{},"df":0,"d":{"docs":{"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"tf":1.0}},"df":1}}}}},"z":{"docs":{},"df":0,"o":{"docs":{},"df":0,"l":{"docs":{},"df":0,"a":{"docs":{"http://127.0.0.1:1111/":{"tf":1.0}},"df":1}}}}}}},"documentStore":{"save":true,"docs":{"http://127.0.0.1:1111/":{"body":"\n졸라 (Zola)\n\nZola는 Hugo, Pelican 및 Jekyll 과 유사한 정적 사이트 생성기(SSG)입니다.\nRust 로 작성되었으며 Jinja2 , Django 템플릿 , Liquid 및 Twig 와 유사한 Tera 템플릿 엔진을 사용합니다.\n콘텐츠는 강력하게 정의되고 호환성이 높은 Markdown 사양인 CommonMark(사용법)으로 작성됩니다.\nZola는 pulldown-cmark를 사용하여 마크다운 파일을 구문 분석합니다. 이 라이브러리의 목표는 CommonMark 사양을 100% 준수하는 것입니다.\n각주 구문 분석, Github 테이블, Github 작업 목록 및 취소선과 같은 몇 가지 추가 기능을 추가합니다.\nSSG는 동적 템플릿을 사용하여 콘텐츠를 정적 HTML 페이지로 변환합니다. 따라서 정적 사이트는 매우 빠르고 데이터베이스가 필요하지 않으므로 호스팅하기 쉽습니다.\nWordPress, Drupal 및 Django와 같은 정적 사이트와 동적 사이트 간의 비교는 여기에서 찾을 수 있습니다.\n-Zola 공식홈페이지 Overview\n\n\n테마 (Theme)\n\nZola 홈페이지에서 제공하는 테마들 중에 DeepThought를 기본으로 제작했습니다.\n선택한 이유는 이 테마를 이용해서 사이트를 만드는 걸 잘 설명해주는 유튜브 영상이 있었기 때문입니다.\n다른 테마들도 훌륭하기 때문에 하나씩 적용해 볼 예정입니다.\n\n","id":"http://127.0.0.1:1111/","title":"Zola를 이용해서 만든 사이트입니다."},"http://127.0.0.1:1111/about/":{"body":"\n  \n\n취미로 코딩하는 성형외과 전문의\n\n\"WORK EXPERIENCE\"\n\n스케치성형외과 (NOW)\n강남엘성형외과\n리엔장성형외과\n...\n\n\n\"EDUCATION\"\n\n성형외과전문의, 가톨릭중앙의료원\"\n가톨릭대학교 의과대학\n\n\n\"PUBLISH (co-author)\"\n\n미용성형외과학, 군자출판사(2019)\nComplication Guidebook, Medytox(2018)\n필러 안전 시술가이드, Restylane(2017)\n...\n\n\n\n","id":"http://127.0.0.1:1111/about/","title":"Welcome"},"http://127.0.0.1:1111/docs/":{"body":"","id":"http://127.0.0.1:1111/docs/","title":"Docs"},"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"body":"This article offers a sample of basic Markdown syntax that can be used in Zola content files.\n\nLet's face it: Writing content for the Web is tiresome. WYSIWYG editors help alleviate this task, but they generally result in horrible code, or worse yet, ugly web pages.\nMarkdown is a better way to write HTML, without all the complexities and ugliness that usually accompanies it.\nSome of the key benefits are:\n\nMarkdown is simple to learn, with minimal extra characters, so it's also quicker to write content.\nLess chance of errors when writing in Markdown.\nProduces valid XHTML output.\nKeeps the content and the visual display separate, so you cannot mess up the look of your site.\nWrite in any text editor or Markdown application you like.\nMarkdown is a joy to use!\n\nWithout further delay, let us go over the main elements of Markdown and what the resulting HTML looks like!\nHeadings\nHeadings from h1 through h6 are constructed with a # for each level:\n# h1 Heading\n## h2 Heading\n### h3 Heading\n#### h4 Heading\n##### h5 Heading\n###### h6 Heading\n\nThe HTML looks like this:\n&lt;h1&gt;h1 Heading&lt;/h1&gt;\n&lt;h2&gt;h2 Heading&lt;/h2&gt;\n&lt;h3&gt;h3 Heading&lt;/h3&gt;\n&lt;h4&gt;h4 Heading&lt;/h4&gt;\n&lt;h5&gt;h5 Heading&lt;/h5&gt;\n&lt;h6&gt;h6 Heading&lt;/h6&gt;\n\nComments\nComments should be HTML compatible.\n&lt;!--\nThis is a comment\n--&gt;\n\nComment below should NOT be seen:\n\nHorizontal Rules\nThe HTML &lt;hr&gt; element is for creating a \"thematic break\" between paragraph-level elements.\nIn Markdown, you can create a &lt;hr&gt; with any of the following:\n\n___: three consecutive underscores\n---: three consecutive dashes\n***: three consecutive asterisks\n\nThe rendered output looks like this:\n\n\n\nBody\nBody written as normal, plain text will be wrapped with &lt;p&gt;&lt;/p&gt; tags in the rendered HTML.\nSo this body:\nLorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri,\nanimal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex,\nsoluta officiis concludaturque ei qui, vide sensibus vim ad.\n\nThe HTML looks like this:\n&lt;p&gt;Lorem ipsum dolor sit amet, graecis denique ei vel, at duo primis mandamus. Et legere ocurreret pri, animal tacimates complectitur ad cum. Cu eum inermis inimicus efficiendi. Labore officiis his ex, soluta officiis concludaturque ei qui, vide sensibus vim ad.&lt;/p&gt;\n\nA line break can be done with one blank line.\nInline HTML\nIf you need a certain HTML tag (with a class) you can simply use HTML:\nParagraph in Markdown.\n\n&lt;div class=\"class\"&gt;\n    This is &lt;b&gt;HTML&lt;/b&gt;\n&lt;/div&gt;\n\nParagraph in Markdown.\n\nEmphasis\nBold\nFor emphasizing a snippet of text with a heavier font-weight.\nThe following snippet of text is rendered as bold text.\n**rendered as bold text**\n__rendered as bold text__\n\nThe HTML looks like this:\n&lt;strong&gt;rendered as bold text&lt;/strong&gt;\n\nItalics\nFor emphasizing a snippet of text with italics.\nThe following snippet of text is rendered as italicized text.\n*rendered as italicized text*\n_rendered as italicized text_\n\nThe HTML looks like this:\n&lt;em&gt;rendered as italicized text&lt;/em&gt;\n\nStrikethrough\nIn [GFM]^(GitHub flavored Markdown) you can do strikethroughs.\n~~Strike through this text.~~\n\nThe HTML looks like this:\n&lt;del&gt;Strike through this text.&lt;/del&gt;\n\nBlockquotes\nFor quoting blocks of content from another source within your document.\nAdd &gt; before any text you want to quote:\n&gt; **Fusion Drive** combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined.\n\nThe rendered output looks like this:\n\nFusion Drive combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined.\n\nThe HTML looks like this:\n&lt;blockquote&gt;\n  &lt;p&gt;\n    &lt;strong&gt;Fusion Drive&lt;/strong&gt; combines a hard drive with a flash storage (solid-state drive) and presents it as a single logical volume with the space of both drives combined.\n  &lt;/p&gt;\n&lt;/blockquote&gt;\n\nBlockquotes can also be nested:\n&gt; Donec massa lacus, ultricies a ullamcorper in, fermentum sed augue.\nNunc augue augue, aliquam non hendrerit ac, commodo vel nisi.\n&gt;&gt; Sed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor\nodio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam.\n\nThe rendered output looks like this:\n\nDonec massa lacus, ultricies a ullamcorper in, fermentum sed augue.\nNunc augue augue, aliquam non hendrerit ac, commodo vel nisi.\n\nSed adipiscing elit vitae augue consectetur a gravida nunc vehicula. Donec auctor\nodio non est accumsan facilisis. Aliquam id turpis in dolor tincidunt mollis ac eu diam.\n\n\nLists\nUnordered\nA list of items in which the order of the items does not explicitly matter.\nYou may use any of the following symbols to denote bullets for each list item:\n* valid bullet\n- valid bullet\n+ valid bullet\n\nFor example:\n* Lorem ipsum dolor sit amet\n* Consectetur adipiscing elit\n* Integer molestie lorem at massa\n* Facilisis in pretium nisl aliquet\n* Nulla volutpat aliquam velit\n  * Phasellus iaculis neque\n  * Purus sodales ultricies\n  * Vestibulum laoreet porttitor sem\n  * Ac tristique libero volutpat at\n* Faucibus porta lacus fringilla vel\n* Aenean sit amet erat nunc\n* Eget porttitor lorem\n\nThe rendered output looks like this:\n\nLorem ipsum dolor sit amet\nConsectetur adipiscing elit\nInteger molestie lorem at massa\nFacilisis in pretium nisl aliquet\nNulla volutpat aliquam velit\n\nPhasellus iaculis neque\nPurus sodales ultricies\nVestibulum laoreet porttitor sem\nAc tristique libero volutpat at\n\n\nFaucibus porta lacus fringilla vel\nAenean sit amet erat nunc\nEget porttitor lorem\n\nThe HTML looks like this:\n&lt;ul&gt;\n  &lt;li&gt;Lorem ipsum dolor sit amet&lt;/li&gt;\n  &lt;li&gt;Consectetur adipiscing elit&lt;/li&gt;\n  &lt;li&gt;Integer molestie lorem at massa&lt;/li&gt;\n  &lt;li&gt;Facilisis in pretium nisl aliquet&lt;/li&gt;\n  &lt;li&gt;Nulla volutpat aliquam velit\n    &lt;ul&gt;\n      &lt;li&gt;Phasellus iaculis neque&lt;/li&gt;\n      &lt;li&gt;Purus sodales ultricies&lt;/li&gt;\n      &lt;li&gt;Vestibulum laoreet porttitor sem&lt;/li&gt;\n      &lt;li&gt;Ac tristique libero volutpat at&lt;/li&gt;\n    &lt;/ul&gt;\n  &lt;/li&gt;\n  &lt;li&gt;Faucibus porta lacus fringilla vel&lt;/li&gt;\n  &lt;li&gt;Aenean sit amet erat nunc&lt;/li&gt;\n  &lt;li&gt;Eget porttitor lorem&lt;/li&gt;\n&lt;/ul&gt;\n\nOrdered\nA list of items in which the order of items does explicitly matter.\n1. Lorem ipsum dolor sit amet\n2. Consectetur adipiscing elit\n3. Integer molestie lorem at massa\n4. Facilisis in pretium nisl aliquet\n5. Nulla volutpat aliquam velit\n6. Faucibus porta lacus fringilla vel\n7. Aenean sit amet erat nunc\n8. Eget porttitor lorem\n\nThe rendered output looks like this:\n\nLorem ipsum dolor sit amet\nConsectetur adipiscing elit\nInteger molestie lorem at massa\nFacilisis in pretium nisl aliquet\nNulla volutpat aliquam velit\nFaucibus porta lacus fringilla vel\nAenean sit amet erat nunc\nEget porttitor lorem\n\nThe HTML looks like this:\n&lt;ol&gt;\n  &lt;li&gt;Lorem ipsum dolor sit amet&lt;/li&gt;\n  &lt;li&gt;Consectetur adipiscing elit&lt;/li&gt;\n  &lt;li&gt;Integer molestie lorem at massa&lt;/li&gt;\n  &lt;li&gt;Facilisis in pretium nisl aliquet&lt;/li&gt;\n  &lt;li&gt;Nulla volutpat aliquam velit&lt;/li&gt;\n  &lt;li&gt;Faucibus porta lacus fringilla vel&lt;/li&gt;\n  &lt;li&gt;Aenean sit amet erat nunc&lt;/li&gt;\n  &lt;li&gt;Eget porttitor lorem&lt;/li&gt;\n&lt;/ol&gt;\n\nTask Lists\nTask lists allow you to create a list of items with checkboxes. To create a task list, add dashes (-) and brackets with a space ([ ]) before task list items. To select a checkbox, add an x in between the brackets ([x]).\n- [x] Write the press release\n- [ ] Update the website\n- [ ] Contact the media\n\nThe rendered output looks like this:\n\n\nWrite the press release\n\nUpdate the website\n\nContact the media\n\nCode\nInline Code\nWrap inline snippets of code with `.\nIn this example, `&lt;section&gt;&lt;/section&gt;` should be wrapped as **code**.\n\nThe rendered output looks like this:\nIn this example, &lt;section&gt;&lt;/section&gt; should be wrapped as code.\nThe HTML looks like this:\n&lt;p&gt;\n  In this example, &lt;code&gt;&amp;lt;section&amp;gt;&amp;lt;/section&amp;gt;&lt;/code&gt; should be wrapped with &lt;strong&gt;code&lt;/strong&gt;.\n&lt;/p&gt;\n\nIndented Code\nOr indent several lines of code by at least four spaces, as in:\n    // Some comments\n    line 1 of code\n    line 2 of code\n    line 3 of code\n\nThe rendered output looks like this:\n// Some comments\nline 1 of code\nline 2 of code\nline 3 of code\n\nThe HTML looks like this:\n&lt;pre&gt;\n  &lt;code&gt;\n    // Some comments\n    line 1 of code\n    line 2 of code\n    line 3 of code\n  &lt;/code&gt;\n&lt;/pre&gt;\n\nTables\nTables are created by adding pipes as dividers between each cell, and by adding a line of dashes (also separated by bars) beneath the header. Note that the pipes do not need to be vertically aligned.\n| Option | Description |\n| ------ | ----------- |\n| data   | path to data files to supply the data that will be passed into templates. |\n| engine | engine to be used for processing templates. Handlebars is the default. |\n| ext    | extension to be used for dest files. |\n\nThe rendered output looks like this:\nOptionDescription\ndatapath to data files to supply the data that will be passed into templates.\nengineengine to be used for processing templates. Handlebars is the default.\nextextension to be used for dest files.\n\nThe HTML looks like this:\n&lt;table&gt;\n  &lt;thead&gt;\n    &lt;tr&gt;\n      &lt;th&gt;Option&lt;/th&gt;\n      &lt;th&gt;Description&lt;/th&gt;\n    &lt;/tr&gt;\n  &lt;/thead&gt;\n  &lt;tbody&gt;\n    &lt;tr&gt;\n      &lt;td&gt;data&lt;/td&gt;\n      &lt;td&gt;path to data files to supply the data that will be passed into templates.&lt;/td&gt;\n    &lt;/tr&gt;\n    &lt;tr&gt;\n      &lt;td&gt;engine&lt;/td&gt;\n      &lt;td&gt;engine to be used for processing templates. Handlebars is the default.&lt;/td&gt;\n    &lt;/tr&gt;\n    &lt;tr&gt;\n      &lt;td&gt;ext&lt;/td&gt;\n      &lt;td&gt;extension to be used for dest files.&lt;/td&gt;\n    &lt;/tr&gt;\n  &lt;/tbody&gt;\n&lt;/table&gt;\n\nLinks\nBasic Link\n&lt;https://assemble.io&gt;\n&lt;contact@revolunet.com&gt;\n[Assemble](https://assemble.io)\n\nThe rendered output looks like this (hover over the link, there is no tooltip):\nhttps://assemble.io\ncontact@revolunet.com\nAssemble\nThe HTML looks like this:\n&lt;a href=\"https://assemble.io\"&gt;https://assemble.io&lt;/a&gt;\n&lt;a href=\"mailto:contact@revolunet.com\"&gt;contact@revolunet.com&lt;/a&gt;\n&lt;a href=\"https://assemble.io\"&gt;Assemble&lt;/a&gt;\n\nAdd a Title\n[Upstage](https://github.com/upstage/ \"Visit Upstage!\")\n\nThe rendered output looks like this (hover over the link, there should be a tooltip):\nUpstage\nThe HTML looks like this:\n&lt;a href=\"https://github.com/upstage/\" title=\"Visit Upstage!\"&gt;Upstage&lt;/a&gt;\n\nNamed Anchors\nNamed anchors enable you to jump to the specified anchor point on the same page. For example, each of these chapters:\n## Table of Contents\n  * [Chapter 1](#chapter-1)\n  * [Chapter 2](#chapter-2)\n  * [Chapter 3](#chapter-3)\n\nwill jump to these sections:\n## Chapter 1 &lt;a id=\"chapter-1\"&gt;&lt;/a&gt;\nContent for chapter one.\n\n## Chapter 2 &lt;a id=\"chapter-2\"&gt;&lt;/a&gt;\nContent for chapter one.\n\n## Chapter 3 &lt;a id=\"chapter-3\"&gt;&lt;/a&gt;\nContent for chapter one.\n\nFootnotes\nFootnotes allow you to add notes and references without cluttering the body of the document. When you create a footnote, a superscript number with a link appears where you added the footnote reference. Readers can click the link to jump to the content of the footnote at the bottom of the page.\nTo create a footnote reference, add a caret and an identifier inside brackets ([^1]). Identifiers can be numbers or words, but they can’t contain spaces or tabs. Identifiers only correlate the footnote reference with the footnote itself — in the output, footnotes are numbered sequentially.\nAdd the footnote using another caret and number inside brackets with a colon and text ([^1]: My footnote.). You don’t have to put footnotes at the end of the document. You can put them anywhere except inside other elements like lists, block quotes, and tables.\nThis is a digital footnote[^1].\nThis is a footnote with \"label\"[^label]\n\n[^1]: This is a digital footnote\n[^label]: This is a footnote with \"label\"\n\nThis is a digital footnote1.\nThis is a footnote with \"label\"2\n1\nThis is a digital footnote\n2: This is a footnote with \"label\"\n\nImages\nImages have a similar syntax to links but include a preceding exclamation point.\n![Minion](https://octodex.github.com/images/minion.png)\n\n\nor:\n![Alt text](https://octodex.github.com/images/stormtroopocat.jpg \"The Stormtroopocat\")\n\n\nLike links, images also have a footnote style syntax:\n![Alt text][id]\n\n\nWith a reference later in the document defining the URL location:\n[id]: https://octodex.github.com/images/dojocat.jpg  \"The Dojocat\"\n\n","id":"http://127.0.0.1:1111/docs/basic-markdown-syntax/","title":"Basic Markdown Syntax"},"http://127.0.0.1:1111/docs/config-options/":{"body":"DeepThought theme provides some config option like option to add favicon to your site, add avatar for profile, setup social links for the profile etc\nSite Configurations\nAuthor Details\nYou can configure author details in [extra.author] of config.toml file.\n[extra.author]\nname = \"&lt;your_name&gt;\"\navatar = \"&lt;path_to_avatar&gt;\"\n\nFavicon Setup\nYou can configure favicon in [extra.favicon] of config.toml file. You can use something like realfavicongenerator to generate your favicon.\n[extra.favicon]\nfavicon_16x16 = \"/icons/favicon-16x16.png\"\nfavicon_32x32 = \"/icons/favicon-32x32.png\"\napple_touch_icon = \"/icons/apple-touch-icon.png\"\nsafari_pinned_tab = \"/icons/safari-pinned-tab.svg\"\nwebmanifest = \"/icons/site.webmanifest\"\n\nSocial Link Setup\nYou can configure social links in [extra.social] of config.toml file.\n[extra.social]\nemail = \"&lt;email_id&gt;\"\nfacebook = \"&lt;facebook_username&gt;\"\ngithub = \"&lt;github_username&gt;\"\ngitlab = \"&lt;gitlab_username&gt;\"\nkeybase = \"&lt;keybase_username&gt;\"\nlinkedin = \"&lt;linkedin_username&gt;\"\nstackoverflow = \"&lt;stackoverflow_userid&gt;\"\ntwitter = \"&lt;twitter_username&gt;\"\ninstagram = \"&lt;instagram_username&gt;\"\nbehance = \"&lt;behance_username&gt;\"\ngoogle_scholar = \"&lt;googlescholar_userid&gt;\"\norcid = \"&lt;orcid_userid&gt;\"\nmastodon_username = \"&lt;mastadon_username&gt;\"\nmastodon_server = \"&lt;mastodon_server&gt;\" (if not set, defaults to mastodon.social)\n\nGoogle Analytics Setup\nDeepThought supports google analytics out of the box. You can configure google in [extra.analytics] of config.toml file. \n[extra.analytics]\ngoogle = \"&lt;your_gtag&gt;\"\n\nDisqus Comments Setup\nDeepThought supports disqus commenting out of the box. You can configure disqus in [extra.commenting] of config.toml file. \n[extra.commenting]\ndisqus = \"&lt;your_disqus&gt;\"\n\nExternal Libraries\nMermaid, Chart and Galleria\nTo gain the features displayed in Extended Shortcodes,\nenable the libraries you want to use in the [extra] section of config.toml.\nchart.enabled = true\nmermaid.enabled = true\ngalleria.enabled = true\n\nMapbox\nDeepThought supports Mapbox out of the box to add maps in your posts.\nYou can enable it and set an access token in the [extra.mapbox] section of config.toml.\n[extra.mapbox]\nenabled = true\naccess_token = \"&lt;your_access_token&gt;\"\n\nKaTeX\nThis theme contains math formula support using KaTeX.\nTo enable KaTeX in your project, set the following in the [extra] section of config.toml:\n[extra]\nkatex.enabled = true\nkatex.auto_render = true    # automatic rendering without shortcodes\n\nSection Configurations\nApart from standard config you can also add a description in your _index.md file for your sections that appears in listing.\ndescription = \"Blog posts accumulated over the time.\"\n\nPage Configurations\nEnable Table Of Content\nIn order to enable toc for your post change as below code snippet in your page.\n[extra]\ntoc = true\n\nEnable Comments\nIn order to enable comments for your post change as below code snippet in your page.\n[extra]\ncomments = true\n\n","id":"http://127.0.0.1:1111/docs/config-options/","title":"Config Options"},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"body":"DeepThought theme provides multiple shortcodes on top of built-in ones in Zola.\nPlease, have a look at the Config Options\nthat explain how to enable them.\nMermaid\nMermaid is a library helping you to generate diagram and flowcharts from text, in a similar manner as Markdown.\nFlowchart\nTo put a flowchart in your post use below snippet\nCode\n{% mermaid() %}\ngraph TD;\n    A--&gt;B;\n    A--&gt;C;\n    B--&gt;D;\n    C--&gt;D;\n{% end %}\n\nOutput\ngraph TD;\nA--&gt;B;\nA--&gt;C;\nB--&gt;D;\nC--&gt;D;\n\nSequence Diagram\nTo put a sequence diagram in your post use below snippet\nCode\n{% mermaid() %}\nsequenceDiagram\n  participant Alice\n  participant Bob\n  Alice-&gt;&gt;John: Hello John, how are you?\n  loop Healthcheck\n    John-&gt;&gt;John: Fight against hypochondria\n  end\n  Note right of John: Rational thoughts &lt;br/&gt;prevail!\n  John--&gt;&gt;Alice: Great!\n  John-&gt;&gt;Bob: How about you?\n  Bob--&gt;&gt;John: Jolly good!\n{% end %}\n\nOutput\nsequenceDiagram\n  participant Alice\n  participant Bob\n  Alice-&gt;&gt;John: Hello John, how are you?\n  loop Healthcheck\n    John-&gt;&gt;John: Fight against hypochondria\n  end\n  Note right of John: Rational thoughts &lt;br/&gt;prevail!\n  John--&gt;&gt;Alice: Great!\n  John-&gt;&gt;Bob: How about you?\n  Bob--&gt;&gt;John: Jolly good!\n\nGantt diagram\nTo put a gantt diagram in your post use below snippet\nCode\n{% mermaid() %}\ngantt\n  dateFormat YYYY-MM-DD\n  title Adding GANTT diagram to mermaid\n  excludes weekdays 2014-01-10\n\n  section A section\n  Completed task :done, des1, 2014-01-06,2014-01-08\n  Active task :active, des2, 2014-01-09, 3d\n  Future task : des3, after des2, 5d\n  Future task2 : des4, after des3, 5d\n{% end %}\n\nOutput\ngantt\n  dateFormat YYYY-MM-DD\n  title Adding GANTT diagram to mermaid\n  excludes weekdays 2014-01-10\n\n  section A section\n  Completed task :done, des1, 2014-01-06,2014-01-08\n  Active task :active, des2, 2014-01-09, 3d\n  Future task : des3, after des2, 5d\n  Future task2 : des4, after des3, 5d\nClass diagram - experimental\nTo put a class diagram in your post use below snippet\nCode\n{% mermaid() %}\nclassDiagram\n  Class01 &lt;|-- AveryLongClass : Cool\n  Class03 _-- Class04\n  Class05 o-- Class06\n  Class07 .. Class08\n  Class09 --&gt; C2 : Where am i?\n  Class09 --_ C3\n  Class09 --|&gt; Class07\n  Class07 : equals()\n  Class07 : Object[] elementData\n  Class01 : size()\n  Class01 : int chimp\n  Class01 : int gorilla\n  Class08 &lt;--&gt; C2: Cool label\n{% end %}\n\nOutput\nclassDiagram\n  Class01 &lt;|-- AveryLongClass : Cool\n  Class03 _-- Class04\n  Class05 o-- Class06\n  Class07 .. Class08\n  Class09 --&gt; C2 : Where am i?\n  Class09 --_ C3\n  Class09 --|&gt; Class07\n  Class07 : equals()\n  Class07 : Object[] elementData\n  Class01 : size()\n  Class01 : int chimp\n  Class01 : int gorilla\n  Class08 &lt;--&gt; C2: Cool label\n\nEntity Relationship Diagram - experimental\nTo put an ER diagram in your post use below snippet\nCode\n{% mermaid() %}\nerDiagram\n    CUSTOMER ||--o{ ORDER : places\n    ORDER ||--|{ LINE-ITEM : contains\n    CUSTOMER }|..|{ DELIVERY-ADDRESS : uses\n{% end %}\n\nOutput\nerDiagram\n    CUSTOMER ||--o{ ORDER : places\n    ORDER ||--|{ LINE-ITEM : contains\n    CUSTOMER }|..|{ DELIVERY-ADDRESS : uses\n\nUser Journey Diagram\nTo put an user journey diagram in your post use below snippet\nCode\n{% mermaid() %}\n  journey\n  title My working day\n  section Go to work\n  Make tea: 5: Me\n  Go upstairs: 3: Me\n  Do work: 1: Me, Cat\n  section Go home\n  Go downstairs: 5: Me\n  Sit down: 5: Me\n{% end %}\n\nOutput\njourney\n  title My working day\n  section Go to work\n  Make tea: 5: Me\n  Go upstairs: 3: Me\n  Do work: 1: Me, Cat\n  section Go home\n  Go downstairs: 5: Me\n  Sit down: 5: Me\n\nMapbox\nMapbox GL JS is a JavaScript library that uses WebGL to render interactive maps from vector tiles and Mapbox styles.\nCode\n{% mapbox(zoom=6) %}\n{\n  \"type\": \"FeatureCollection\",\n  \"features\": [\n    {\n      \"type\": \"Feature\",\n      \"geometry\": {\n        \"type\": \"Point\",\n        \"coordinates\": [78.016667, 27.183333]\n      },\n      \"properties\": {\n        \"title\": \"Agra\",\n        \"description\": \"Agra is a major tourist destination because of its many Mughal-era buildings, most notably the Taj Mahal, Agra Fort and Fatehpur Sikri, all of which are UNESCO World Heritage Sites.\"\n      }\n    },\n    {\n      \"type\": \"Feature\",\n      \"geometry\": {\n        \"type\": \"Point\",\n        \"coordinates\": [77.2, 28.6]\n      },\n      \"properties\": {\n        \"title\": \"New Delhi\",\n        \"description\": \"New Delhi is the capital of India and an administrative district of NCT Delhi.\"\n      }\n    }\n  ]\n}\n{% end %}\n\nOutput\n\n    \n        pk.eyJ1IjoicmF0YW5zaHJlc2h0aGEiLCJhIjoiY2tla2s2NmM3MDd0ZzJzbXFtc3Y2YmU0NyJ9.0RhUnJPKbxHWw3xGPnnBlA\n    \n    \n        6\n    \n     \n        {\n  \"type\": \"FeatureCollection\",\n  \"features\": [\n    {\n      \"type\": \"Feature\",\n      \"geometry\": {\n        \"type\": \"Point\",\n        \"coordinates\": [78.016667, 27.183333]\n      },\n      \"properties\": {\n        \"title\": \"Agra\",\n        \"description\": \"Agra is a major tourist destination because of its many Mughal-era buildings, most notably the Taj Mahal, Agra Fort and Fatehpur Sikri, all of which are UNESCO World Heritage Sites.\"\n      }\n    },\n    {\n      \"type\": \"Feature\",\n      \"geometry\": {\n        \"type\": \"Point\",\n        \"coordinates\": [77.2, 28.6]\n      },\n      \"properties\": {\n        \"title\": \"New Delhi\",\n        \"description\": \"New Delhi is the capital of India and an administrative district of NCT Delhi.\"\n      }\n    }\n  ]\n}\n    \n\n\nChart\nChart.xkcd is a chart library plots “sketchy”, “cartoony” or “hand-drawn” styled charts.\nLine chart\nLine chart displays series of data points in the form of lines. It can be used to show trend data, or comparison of different data sets.\nCode\n{% chart() %}\n{\n  \"type\": \"Line\",\n  \"title\": \"Monthly income of an indie developer\",\n  \"xLabel\": \"Month\",\n  \"yLabel\": \"$ Dollars\",\n  \"data\": {\n    \"labels\": [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\"],\n    \"datasets\": [\n      {\n        \"label\": \"Plan\",\n        \"data\": [30, 70, 200, 300, 500, 800, 1500, 2900, 5000, 8000]\n      },\n      {\n        \"label\": \"Reality\",\n        \"data\": [0, 1, 30, 70, 80, 100, 50, 80, 40, 150]\n      }\n    ]\n  }\n}\n{% end %}\n\nOutput\n{\n  \"type\": \"Line\",\n  \"title\": \"Monthly income of an indie developer\",\n  \"xLabel\": \"Month\",\n  \"yLabel\": \"$ Dollars\",\n  \"data\": {\n    \"labels\": [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\"],\n    \"datasets\": [\n      {\n        \"label\": \"Plan\",\n        \"data\": [30, 70, 200, 300, 500, 800, 1500, 2900, 5000, 8000]\n      },\n      {\n        \"label\": \"Reality\",\n        \"data\": [0, 1, 30, 70, 80, 100, 50, 80, 40, 150]\n      }\n    ]\n  }\n}\nXY chart\nXY chart is used to plot points by specifying their XY coordinates.\nCode\n{% chart() %}\n{\n  \"type\": \"XY\",\n  \"title\": \"Pokemon farms\",\n  \"xLabel\": \"Coordinate\",\n  \"yLabel\": \"Count\",\n  \"data\": {\n    \"datasets\": [\n      {\n        \"label\": \"Pikachu\",\n        \"data\": [\n          {\n            \"x\": 3,\n            \"y\": 10\n          },\n          {\n            \"x\": 4,\n            \"y\": 122\n          },\n          {\n            \"x\": 10,\n            \"y\": 100\n          }\n        ]\n      },\n      {\n        \"label\": \"Squirtle\",\n        \"data\": [\n          {\n            \"x\": 1,\n            \"y\": 1\n          },\n          {\n            \"x\": 3,\n            \"y\": 3\n          }\n        ]\n      },\n      {\n        \"label\": \"Charizard\",\n        \"data\": [\n          {\n            \"x\": 2,\n            \"y\": 5\n          },\n          {\n            \"x\": 6,\n            \"y\": 8\n          }\n        ]\n      }\n    ]\n  },\n  \"options\": {\n    \"xTickCount\": 5,\n    \"yTickCount\": 5,\n    \"showLine\": false,\n    \"dotSize\": 1\n  }\n}\n{% end %}\n\nOutput\n{\n  \"type\": \"XY\",\n  \"title\": \"Pokemon farms\",\n  \"xLabel\": \"Coordinate\",\n  \"yLabel\": \"Count\",\n  \"data\": {\n    \"datasets\": [\n      {\n        \"label\": \"Pikachu\",\n        \"data\": [\n          {\n            \"x\": 3,\n            \"y\": 10\n          },\n          {\n            \"x\": 4,\n            \"y\": 122\n          },\n          {\n            \"x\": 10,\n            \"y\": 100\n          }\n        ]\n      },\n      {\n        \"label\": \"Squirtle\",\n        \"data\": [\n          {\n            \"x\": 1,\n            \"y\": 1\n          },\n          {\n            \"x\": 3,\n            \"y\": 3\n          }\n        ]\n      },\n      {\n        \"label\": \"Charizard\",\n        \"data\": [\n          {\n            \"x\": 2,\n            \"y\": 5\n          },\n          {\n            \"x\": 6,\n            \"y\": 8\n          }\n        ]\n      }\n    ]\n  },\n  \"options\": {\n    \"xTickCount\": 5,\n    \"yTickCount\": 5,\n    \"showLine\": false,\n    \"dotSize\": 1\n  }\n}\nBar chart\nA bar chart provides a way of showing data values represented as vertical bars\nCode\n{% chart() %}\n{\n  \"type\": \"Bar\",\n  \"title\": \"How to feel powerful ?\",\n  \"xLabel\": \"Platforms\",\n  \"yLabel\": \"Count\",\n  \"data\": {\n    \"labels\": [\"Earn Money\", \"Get Famous\", \"Use terminal in front of non-programmers\"],\n    \"datasets\": [\n      {\n        \"data\": [30, 45, 100]\n      }\n    ]\n  },\n  \"options\": {\n    \"yTickCount\": 2,\n    \"dataColors\": [\"Red\", \"Green\", \"Blue\"]\n  }\n}\n{% end %}\n\nOutput\n{\n  \"type\": \"Bar\",\n  \"title\": \"How to feel powerful ?\",\n  \"xLabel\": \"Platforms\",\n  \"yLabel\": \"Count\",\n  \"data\": {\n    \"labels\": [\"Earn Money\", \"Get Famous\", \"Use terminal in front of non-programmers\"],\n    \"datasets\": [\n      {\n        \"data\": [30, 45, 100]\n      }\n    ]\n  },\n  \"options\": {\n    \"yTickCount\": 2,\n    \"dataColors\": [\"Red\", \"Green\", \"Blue\"]\n  }\n}\nStacked bar chart\nA stacked bar chart provides a way of showing data values represented as vertical bars\nCode\n{% chart() %}\n{\n  \"type\": \"StackedBar\",\n  \"title\": \"Issues and PR Submissions\",\n  \"xLabel\": \"Month\",\n  \"yLabel\": \"Count\",\n  \"data\": {\n    \"labels\": [\"Jan\", \"Feb\", \"Mar\", \"April\", \"May\"],\n    \"datasets\": [\n      {\n        \"label\": \"Issues\",\n        \"data\": [12, 19, 11, 29, 17]\n      },\n      {\n        \"label\": \"PRs\",\n        \"data\": [3, 5, 2, 4, 1]\n      },\n      {\n        \"label\": \"Merges\",\n        \"data\": [2, 3, 0, 1, 1]\n      }\n    ]\n  }\n}\n{% end %}\n\nOutput\n{\n  \"type\": \"StackedBar\",\n  \"title\": \"Issues and PR Submissions\",\n  \"xLabel\": \"Month\",\n  \"yLabel\": \"Count\",\n  \"data\": {\n    \"labels\": [\"Jan\", \"Feb\", \"Mar\", \"April\", \"May\"],\n    \"datasets\": [\n      {\n        \"label\": \"Issues\",\n        \"data\": [12, 19, 11, 29, 17]\n      },\n      {\n        \"label\": \"PRs\",\n        \"data\": [3, 5, 2, 4, 1]\n      },\n      {\n        \"label\": \"Merges\",\n        \"data\": [2, 3, 0, 1, 1]\n      }\n    ]\n  }\n}\nPie/Doughnut chart\nA pie/doughnut chart provides a way of illustrating numerical proportion.\nCode\n{% chart() %}\n{\n  \"type\": \"Pie\",\n  \"title\": \"What Tim is made of\",\n  \"data\": {\n    \"labels\": [\"a\", \"b\", \"e\", \"f\", \"g\"],\n    \"datasets\": [\n      {\n        \"data\": [500, 200, 80, 90, 100]\n      }\n    ]\n  }\n}\n{% end %}\n\nOutput\n{\n  \"type\": \"Pie\",\n  \"title\": \"What Tim is made of\",\n  \"data\": {\n    \"labels\": [\"a\", \"b\", \"e\", \"f\", \"g\"],\n    \"datasets\": [\n      {\n        \"data\": [500, 200, 80, 90, 100]\n      }\n    ]\n  }\n}\nRadar chart\nA radar chart provides a way of displaying multivariate data in the form of a two-dimensional chart of three or more quantitative variables represented on axes starting from the same point.\nCode\n{% chart() %}\n{\n  \"type\": \"Radar\",\n  \"title\": \"Letters in random words\",\n  \"data\": {\n    \"labels\": [\"c\", \"h\", \"a\", \"r\", \"t\"],\n    \"datasets\": [\n      {\n        \"label\": \"ccharrrt\",\n        \"data\": [2, 1, 1, 3, 1]\n      },\n      {\n        \"label\": \"chhaart\",\n        \"data\": [1, 2, 2, 1, 1]\n      }\n    ]\n  },\n  \"options\": {\n    \"showLegend\": true,\n    \"showLabels\": true\n  }\n}\n{% end %}\n\nOutput\n{\n  \"type\": \"Radar\",\n  \"title\": \"Letters in random words\",\n  \"data\": {\n    \"labels\": [\"c\", \"h\", \"a\", \"r\", \"t\"],\n    \"datasets\": [\n      {\n        \"label\": \"ccharrrt\",\n        \"data\": [2, 1, 1, 3, 1]\n      },\n      {\n        \"label\": \"chhaart\",\n        \"data\": [1, 2, 2, 1, 1]\n      }\n    ]\n  },\n  \"options\": {\n    \"showLegend\": true,\n    \"showLabels\": true\n  }\n}\nGalleria\nGalleria is a framework that simplifies the process of creating beautiful image galleries for the web and mobile devices.\nCode\n{% galleria() %}\n{\n  \"images\": [\n    {\n      \"src\": \"alexandre-dinaut-GHxr3O6yZ1c-unsplash.jpg\",\n      \"title\": \"Clouds &amp; Mountains\",\n      \"description\": \"Just hanging out with each other.\"\n    },\n    {\n      \"src\": \"chandler-cruttenden-YYemke7BfuE-unsplash.jpg\",\n      \"title\": \"Crop\",\n      \"description\": \"Waiting for the harvest.\"\n    },\n    {\n      \"src\": \"jung-ho-park-7aZtpsyaWVM-unsplash.jpg\",\n      \"title\": \"The Fog\",\n      \"description\": \"Engulfing everything.\"\n    },\n    {\n      \"src\": \"kitera-dent-BIj4LObC6es-unsplash.jpg\",\n      \"title\": \"Just Plants\",\n      \"description\": \"Backdrop of ocean.\"\n    },\n    {\n      \"src\": \"koes-nadi-XkUFF1nnbA8-unsplash.jpg\",\n      \"title\": \"Whoa\",\n      \"description\": \"Something to look at.\"\n    },\n    {\n      \"src\": \"lazyartistgallery-HHaIRbgzcGw-unsplash.jpg\",\n      \"title\": \"Let's Chill\",\n      \"description\": \"Three birds just chilling !!\"\n    },\n    {\n      \"src\": \"saira-nUxdL_19OQw-unsplash.jpg\",\n      \"title\": \"Canyon\",\n      \"description\": \"Might of nature.\"\n    },\n    {\n      \"src\": \"waldemar-brandt-2hAEHCt25eM-unsplash.jpg\",\n      \"title\": \"Evening\",\n      \"description\": \"Time to wind down.\"\n    }\n  ]\n}\n{% end %}\n\nOutput\n{\n  \"images\": [\n    {\n      \"src\": \"alexandre-dinaut-GHxr3O6yZ1c-unsplash.jpg\",\n      \"title\": \"Clouds &amp; Mountains\",\n      \"description\": \"Just hanging out with each other.\"\n    },\n    {\n      \"src\": \"chandler-cruttenden-YYemke7BfuE-unsplash.jpg\",\n      \"title\": \"Crop\",\n      \"description\": \"Waiting for the harvest.\"\n    },\n    {\n      \"src\": \"jung-ho-park-7aZtpsyaWVM-unsplash.jpg\",\n      \"title\": \"The Fog\",\n      \"description\": \"Engulfing everything.\"\n    },\n    {\n      \"src\": \"kitera-dent-BIj4LObC6es-unsplash.jpg\",\n      \"title\": \"Just Plants\",\n      \"description\": \"Backdrop of ocean.\"\n    },\n    {\n      \"src\": \"koes-nadi-XkUFF1nnbA8-unsplash.jpg\",\n      \"title\": \"Whoa\",\n      \"description\": \"Something to look at.\"\n    },\n    {\n      \"src\": \"lazyartistgallery-HHaIRbgzcGw-unsplash.jpg\",\n      \"title\": \"Let's Chill\",\n      \"description\": \"Three birds just chilling !!\"\n    },\n    {\n      \"src\": \"saira-nUxdL_19OQw-unsplash.jpg\",\n      \"title\": \"Canyon\",\n      \"description\": \"Might of nature.\"\n    },\n    {\n      \"src\": \"waldemar-brandt-2hAEHCt25eM-unsplash.jpg\",\n      \"title\": \"Evening\",\n      \"description\": \"Time to wind down.\"\n    }\n  ]\n}KaTeX\nKaTeX is a math typesetting library based on TeX.\nCode\n{% katex(block=true) %}\n\\KaTeX\n{% end %}\n\nOutput\n\nPhoto By:\n\nALEXANDRE DINAUT on Unsplash\nChandler Cruttenden on Unsplash\nJung Ho Park on Unsplash\nKitera Dent on Unsplash\nKoes nadi on Unsplash\nLazyartistgallery on Unsplash\nSaira on Unsplash\nWaldemar Brandt on Unsplash\n\n","id":"http://127.0.0.1:1111/docs/extended-shortcodes/","title":"Extended Shortcodes"},"http://127.0.0.1:1111/docs/theme-extension/":{"body":"DeepThought theme can be extended with usual Zola extension mechanisms.\nReplacing a template\nAs any theme, all DeepThought templates can be replaced to override a whole template.\nBlocks to extend\nIf you don't want to replace a whole DeepThought template, but override parts of it, you can extend the template and redefine some specific blocks.\nHere is a WIP list of blocks in DeepThought templates to override:\nTemplate location1BlockDescription\nbase.htmluser_custom_stylesheetCustom stylesheet (css or saas) to fine-tune DeepThought styling\nbase.htmltitleCustomize default page's titles\nbase.htmlanalyticsProvide your own analytics script. Google Analytics by default\nbase.htmlheaderCustomize page's header\nbase.htmlcontentCustomize page's content\nbase.htmlsearchProvide your own search box partial template\nbase.htmlpaginationOverride default pagination\nbase.htmlcommentProvide your own pagination partial template\nbase.htmlother_lang_search_jsProvide custom search behavior, eg. to use languages others than English\nbase.htmluser_custom_jsProvide any custom JS scripts at the end of the body of the page\n\n\n1\nRelative to the templates directory\n\n","id":"http://127.0.0.1:1111/docs/theme-extension/","title":"Theme extension"},"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"body":"This is a small example post of stuff you can do with the DeepThought theme.\nWe'll try to represent all possible markdown and shortcode combinations here\nso you can develop easily.\nHere's some lists\n\nlet's list some stuff\nunordered, of course.\n\n\nWe can also order lists\n\nAnd nesting here works too\nWe can do whatever we want!\n\n\nAnd drop back to the original indentation.\n\nHeaders\nSmaller\nSmaller still!\nCan't really get much smaller than this\nEven if you try\nIt won't do anything\nWe can also italicize stuff, or make it bold.\nCode\nWant some Rust code?  We got Rust code.\n\n// `vst` uses macros, so we'll need to specify that we're using them!\n#[macro_use]\nextern crate vst;\n\n// We're implementing a trait `Plugin` that does all the VST-y stuff for us.\nimpl Plugin for Whisper {\n    fn get_info(&amp;self) -&gt; Info {\n        Info {\n            name: \"Whisper\".to_string()\n        }\n    }\n}\n\n\nWe can also add a filename to our code blocks which is super useful when\nproviding tutorials, etc.  Here's some HTML we can insert into our\nmarkdown file right before the code block.  (Meta, right?)\n\n  www.index.html\n\n&lt;div class='filename'&gt;\n  &lt;div&gt;src/lib.rs&lt;/div&gt;\n&lt;/div&gt;\n\nIf we want, we can also specify inline code which is useful for the small stuff.\nHorizontal rules\nWe have them!\n\nYoutube\nwith youtube(id=\"the_id_here\")\n\n    \n    \n\nVimeo\nwith vimeo(id=\"id_here\")\n\n    \n    \n\nLinks\nOf Course\nTables\nYou can make tables in markdown, too!  Who would have thought.  Are these styled yet?\nFirst HeaderSecond Header\nContent CellContent Cell\nContent CellContent Cell\n\nFoldable Text\n\n    Title 1\n    Content 1 Content 1 Content 1 Content 1 Content 1\n\n\n    Title 2\n    Content 2 Content 2 Content 2 Content 2 Content 2\n\nWe can do that like this:\n&lt;details&gt;\n    &lt;summary&gt;Title 1&lt;/summary&gt;\n    &lt;p&gt;Content 1 Content 1 Content 1 Content 1 Content 1&lt;/p&gt;\n&lt;/details&gt;\n\n","id":"http://127.0.0.1:1111/docs/welcome-to-deep-thought/","title":"Welcome to DeepThought"},"http://127.0.0.1:1111/posts/":{"body":"\n\n","id":"http://127.0.0.1:1111/posts/","title":"Posts"},"http://127.0.0.1:1111/posts/post-1/":{"body":"zola 의 Deep-Thought theme 을 이용해서 만들던 중, Book theme 을 함께 쓰려고 조금씩 수정을 했습니다.\n그 과정에서 겪은 시행착오를 메모합니다.\n원하는 글꼴로 통일\nTypora 의 newsprint css 를 다운받아 /sass 폴더에 복사합니다.\n확장자를 css 에서 scss로 바꿔줍니다.\n뒤에 {% block user_custom_stylesheet %} 블럭을 이용해서 적용해줍니다.\n\ncss 를 복사해오기\nzola 는 sass 파일로 작성한 다음, build 할 때 css 파일로 만듭니다.\nBook theme 를 사용하려면 테마의 sass 파일들을 /sass 폴더로 복사해서 가져와야 합니다.\n파일이름이 구별되도록 book.sass 파일을 제외한 나머지 파일에 _book 이라는 prefix를 붙여줍니다.\n(앞에 _ 를 붙이지 않으면 book.sass에서 import 가 되지 않습니다.)\nbook.sass 파일안에 import 도 파일이름에 맞게 고쳐줍니다.\n\n각 메뉴에 맞게 css 적용하기\n기존 Deep-Thought 테마를 사용하는 곳에는 글꼴 선택 정도의 테마를 적용합니다.\n/templates/base.html 에 아래 스타일을 추가합니다.\n{% block user_custom_stylesheet %}\n    {# 전체 글꼴 적용 #}\n    &lt;link rel=\"stylesheet\" href=\"{{ get_url(path='newsprint.css') | safe }}\"&gt;\n{% endblock %}\n\nBook 테마를 사용하는 곳에는 book에서 가져온 css 만 적용하는데, 나머지는 원래 css를 적용해서 통일감을 유지합니다.\n/templates/book_index.html 에 아래 스타일을 추가합니다.\n{% block user_custom_stylesheet %}\n    {# book 의 css를 불러온 후, deep-thought의 css를 덮어썼다. #}\n    &lt;link rel=\"stylesheet\" href=\"{{ get_url(path='book.css') | safe }}\"&gt;\n    &lt;link rel=\"stylesheet\" href=\"{{ get_url(path='deep-thought.css') | safe }}\"&gt;\n    {# 전체 글꼴 적용 #}\n    &lt;link rel=\"stylesheet\" href=\"{{ get_url(path='newsprint.css') | safe }}\"&gt;\n{% endblock %}\n\n약간 차이가 남는데 어쩔수 없습니다. css를 다 뜯어고치기엔 너무 귀찮다.......\n\n전용 template 를 만들기\nbook theme 의 /templates 폴더에서 파일을 복사해옵니다.\nprefix 를 붙여서 book_index.html, book_page.html, book_sectinn.html 파일로 이름을 변경합니다.\n아래와 같이 조금씩 수정해줍니다.\n- book_index.html\nbase.html을 복사해서 book_index.html 을 만듭니다.\n{% extends \"DeepThought/templates/base.html\" %} 를 {% extends \"base.html\" %} 로 수정합니다.\ncss 를 불러오기 위해 아래 코드를 추가합니다.\n{% block user_custom_stylesheet %}\n    {# book 의 css를 불러온 후, deep-thought의 css를 덮어썼다. #}\n    &lt;link rel=\"stylesheet\" href=\"{{ get_url(path='book.css') | safe }}\"&gt;\n    &lt;link rel=\"stylesheet\" href=\"   \"&gt;\n    {# 본문형식을 맞춰본다 #}\n    &lt;link rel=\"stylesheet\" href=\"{{ get_url(path='newsprint.css') | safe }}\"&gt;\n{% endblock %}\n\n{% block content %} 에 book theme 의 /templates 폴더애 있는 index.html 의  를 복사해붙여넣습니다.\nnavigation 이 nav bar 와 겹치지 않게 위치를 내려줍니다.\n            {% block before_menu %}\n            {# lt.side menu 가 상단 navbar에 가리지 않게 내린다  #}\n            &lt;div&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/div&gt;\n            {% endblock before_menu %}\n            &lt;nav role=\"navigation\"&gt;\n\nblock content 가 겹치면 오류가 나기 때문에 이름을 book_content 로 바꿔어줍니다.\n               &lt;div class=\"book-content\"&gt;\n                    {% block book_content %}\n                    {% endblock book_content %}\n                &lt;/div&gt;\n\n- book_section.html, book_page.html 수정\n{% extends \"book_index.html\" %} 로 수정하고, 아래 내용도 적당히 수정해줍니다.\npre, post 화살표가 적절히 작동하려면 {% set index = get_section(path=\"_index.md\") %} 에서 _index.md 대신 rust/_index.md 식으로 바꿔주어야 합니다.\n","id":"http://127.0.0.1:1111/posts/post-1/","title":"테마 2가지 사용하기"},"http://127.0.0.1:1111/posts/post-2/":{"body":"zola 를 이용해 만든 블로그를 localhost 에서 github-Pages 로 이동하는 과정입니다.\nzola 의 Documention을 따라하면서 놓친 부분을 추가해서 메모해둡니다.\nGithub Actions\nGithub-Pages에 Zola-Page를 배포하기 위해 Github Actions를 사용하는 것은 매우 쉽습니다.\n기본적으로 세 가지가 필요합니다.\n\nPersonal access token 이 없다면 생성\nGithub Action 만들기\n리포지토리 설정에서 Github 페이지 섹션을 확인\n\n아래와 같이 순서대로 하면 됩니다.\n1. Personal access token\n동일한 리포지토리에 사이트를 게시하는 경우 해당 단계를 따를 필요가 없습니다.\n그러나 여전히 GITHUB_TOKEN 이 자동으로 전달되게 해야 합니다. \n- 토큰을 생성합니다.\n여기를 클릭 하거나,\ngithub 페이지 오른쪽 상단 아바타 &gt; Settings &gt; Developer Settings &gt; Personal access tokens &gt; Tokens(classic) &gt; Generate new Token(classic) 으로 이동합니다.\n이름과 유효기간을 정하고, Select scopes 에서 public_repo 권한을 부여합니다.\nGenerate token 을 클릭하면 token 이 나오는데, 잘 복사해둡니다.\n- 토큰을 환경변수에 저장\n리포지토리로 이동하여 상단의 Settings &gt; Environments &gt; New Environment 를 클릭합니다.\nenvironment 이름을 적은 다음 나오는 페이지에서 Environment secrets &gt; add secret 를 클릭합니다.\nName 은 TOKEN, Secret 에는 위에서 생성한 token값을 붙여넣습니다.\n\n2. Github Action 만들기\n- 만들기\n리포지토리 상단의 Actions &gt; New workflow &gt; set up a workflow yourself → 를 클릭합니다.\n아래의 내용을 붙여넣습니다.\nname: Zola on GitHub Pages\n\non: \n push:\n  branches:\n   - main\n\njobs:\n  build:\n    name: Publish site\n    runs-on: ubuntu-latest\n    steps:\n    - name: Checkout main\n      uses: actions/checkout@v3.0.0\n    - name: Build and deploy\n      uses: shalzz/zola-deploy-action@v0.17.2\n      env:\n        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n\n작업은 선택한 분기에 대해서만 실행되므로, branch 이름이 main 이 아니라면 master 또는 다른 이름으로 수정합니다.\n- 권한수정\n리포지토리 상단의 setting &gt; actions &gt; general 을 클릭합니다.\n아래쪽의 workflow permission 에서 Read and write permission 선택합니다.\n\n3. Github 페이지 섹션을 확인\n리포지토리 상단의 setting &gt; Pages 를 클릭합니다.\nBuild and deployment 에서 Branch 가 gh-pages 로 설정되어 있고, 디렉토리가 /(root) 인지 확인합니다. \n","id":"http://127.0.0.1:1111/posts/post-2/","title":"blog Deployment using Github Pages"},"http://127.0.0.1:1111/rust/":{"body":"\nNote: 이 책의 판본은 No Starch Press에서 인쇄 및 전자책 형식으로 제공되는 The Rust Programming Language와 동일합니다.\n\nRust에 대한 소개서인 The Rust Programming Language에 오신 것을 환영합니다. Rust 프로그래밍 언어는 더 빠르고 안정적인 소프트웨어를 작성하는 데 도움이 됩니다.\nHigh-level ergonomics과 low-level control는 프로그래밍 언어 디자인에서 종종 상충됩니다. Rust는 그 충돌에 도전합니다. Rust는 강력한 기술 역량과 훌륭한 개발자 경험 사이의 균형을 통해, 전통적인 갈등없이 low-level control(예: 메모리 사용)을 할 수 있는 옵셥을 제공합니다.\n러스트는 누구를 위한 것인가\nRust는 다양한 이유로 많은 사람들에게 이상적입니다. 가장 중요한 몇 가지 그룹을 살펴보겠습니다.\n- 개발자 팀\nRust는 다양한 수준의 시스템 프로그래밍 지식을 가진 대규모 개발자 팀 간의 협업을 위한 생산적인 도구임이 입증되었습니다. 저수준 코드는 대부분의 다른 언어에서 숙련된 개발자의 광범위한 테스트와 신중한 코드 검토를 통해서만 발견할 수 있는 다양한 미묘한 버그에 취약합니다. Rust에서 컴파일러는 동시성 버그를 포함하여 이러한 애매한 버그가 있는 코드를 컴파일하는 것을 거부함으로써 게이트키퍼 역할을 합니다. 컴파일러와 함께 작업함으로써 팀은 버그를 추적하는 대신 프로그램의 논리에 집중하는 데 시간을 할애할 수 있습니다.\nRust는 또한 시스템 프로그래밍 세계에 최신 개발자 도구를 제공합니다.\n포함된 종속성 관리자 및 빌드 도구인 Cargo는 Rust 생태계 전체에서 종속성을 쉽고 일관성 있게 추가, 컴파일 및 관리합니다.\nRustfmt 서식 도구는 개발자 간에 일관된 코딩 스타일을 보장합니다.\nRust Language Server는 코드 완성 및 인라인 오류 메시지를 위한 통합 개발 환경(IDE) 통합을 지원합니다.\nRust 생태계에서 이러한 도구와 다른 도구를 사용함으로써 개발자는 시스템 수준 코드를 작성하는 동안 생산성을 높일 수 있습니다.\n- 학생\nRust는 학생들과 시스템 개념에 대해 배우는 데 관심이 있는 사람들을 위한 것입니다. Rust를 사용하여 많은 사람들이 운영 체제 개발과 같은 주제에 대해 배웠습니다. 커뮤니티는 학생들을 매우 환영하며 기꺼이 학생들의 질문에 답변해 드립니다. 이 책과 같은 노력을 통해 Rust 팀은 더 많은 사람들, 특히 프로그래밍을 처음 접하는 사람들이 시스템 개념에 더 쉽게 접근할 수 있기를 원합니다.\n- 기업\n크고 작은 수백 개의 회사가 명령줄 도구(command line tools), 웹 서비스, DevOps 도구, 임베디드 장치, 오디오 및 비디오 분석 및 트랜스코딩, 암호 화폐, 생물 정보학, 검색 엔진, 사물 인터넷 응용 프로그램, 기계 학습, 심지어 Firefox 웹 브라우저의 주요 부분까지 다양한 작업을 위한 프로덕션에서 Rust를 사용합니다. \n- 오픈 소스 개발자\nRust는 Rust 프로그래밍 언어, 커뮤니티, 개발자 도구 및 라이브러리를 구축하려는 사람들을 위한 것입니다. 우리는 당신이 Rust 언어에 기여하기를 바랍니다.\n- 속도와 안정성을 중시하는 사람들\nRust는 언어의 속도와 안정성을 갈망하는 사람들을 위한 것입니다.\n속도란 Rust 코드가 얼마나 빨리 실행될 수 있는지와 Rust가 프로그램을 작성할 수 있는 속도를 모두 의미합니다.\nRust 컴파일러의 검사는 기능 추가 및 리팩토링을 통해 안정성을 보장합니다. 이는 개발자가 종종 수정을 두려워하는 이러한 검사가 없는 언어의 취약한 레거시 코드와 대조됩니다. 비용이 들지 않는 추상화, 수동으로 작성된 코드만큼 빠르게 하위 수준 코드로 컴파일되는 상위 수준 기능을 위해 노력함으로써 Rust는 안전한 코드도 빠른 코드로 만들기 위해 노력합니다.\n- 다른사람들\nRust 언어는 다른 많은 사용자도 지원하기를 희망합니다. 여기에 언급된 사람들은 단지 가장 큰 이해관계자 중 일부일 뿐입니다. 전반적으로 Rust의 가장 큰 야망은 안전성과 생산성, 속도 및 인체 공학을 제공함으로써 프로그래머가 수십 년 동안 받아들인 장단점을 제거하는 것입니다. Rust를 사용해 보고 선택이 적합한지 확인하세요.\n이 책의 대상\n이 책은 당신이 다른 프로그래밍 언어로 코드를 작성했다고 가정하지만 어떤 언어인지에 대한 가정은 하지 않습니다. 우리는 다양한 프로그래밍 배경을 가진 사람들이 자료에 광범위하게 액세스할 수 있도록 노력했습니다. 우리는 프로그래밍이 무엇인지 또는 프로그래밍에 대해 생각하는 방법에 대해 이야기하는 데 많은 시간을 할애하지 않습니다. 프로그래밍을 처음 접하는 경우 프로그래밍에 대한 소개를 구체적으로 제공하는 책을 읽는 것이 좋습니다.\n이 책을 사용하는 방법\n일반적으로 이 책은 앞에서 뒤로 순서대로 읽는다고 가정합니다. 이후 장에서는 이전 장의 개념을 기반으로 하며 이전 장에서는 특정 주제에 대해 자세히 다루지 않을 수 있지만 이후 장에서 해당 주제를 다시 다룰 것입니다.\n이 책에는 개념 장과 프로젝트 장이라는 두 종류의 장을 볼 수 있습니다. 개념 장에서는 Rust의 한 측면에 대해 배우게 될 것입니다. 프로젝트 장에서는 지금까지 배운 내용을 적용하여 함께 작은 프로그램을 만들 것입니다. 2, 12, 20장은 프로젝트 장입니다. 나머지는 개념 장입니다.\n1장에서는 Rust를 설치하는 방법과 \"Hello, world!\"를 출력하는 프로그램을 작성하는 방법을 설명합니다. 그리고 Rust의 패키지 관리자이자 빌드 도구인 Cargo를 사용하는 방법을 설명합니다.\n2장은 숫자 추측 게임을 구축하면서 Rust로 프로그램을 작성하는 방법에 대한 실습 소개입니다. 여기서는 높은 수준의 개념을 다루고 이후 장에서 추가 세부 정보를 제공합니다. 당장 손을 더럽히고 싶다면 챕터 2가 적합합니다.\n3장에서는 다른 프로그래밍 언어와 유사한 Rust 기능을 다룹니다.\n4장에서는 Rust의 소유권 시스템(ownership system)에 대해 알아봅니다. 다음으로 넘어가기 전에 모든 세부 사항을 배우는 것을 선호하는 특히 세심한 학습자라면 2장을 건너뛰고 바로 3장을 본 다음, 배운 세부사항을 적용하고 싶을 때 2장으로 돌아가는 것이 좋습니다.\n5장에서는 구조체(structs)와 메서드(methods)에 대해 설명합니다.\n6장에서는 열거형(enums), 일치식(match expressions) 및 if let 제어 흐름 구성에 대해 설명합니다. Rust에서 사용자 정의 유형을 만들기 위해 구조체와 열거형을 사용할 것입니다.\n7장에서는 Rust의 모듈 시스템과 코드 구성을 위한 privacy rules 및 공용 API(Application Programming Interface)에 대해 배웁니다.\n8장에서는 벡터(vectors), 문자열(strings) 및 해시맵(hash maps)과 같이 표준 라이브러리가 제공하는 몇 가지 일반적인 컬렉션 데이터 구조에 대해 설명합니다.\n9장은 Rust의 오류 처리 철학과 기술을 탐구합니다.\n10장에서는 여러 유형에 적용되는 코드를 정의할 수 있는 기능을 제공하는 제네릭(generics), 특성(traits) 및 수명(lifetimes)을 파헤칩니다.\n11장은 테스트에 관한 것입니다. 테스트는 Rust의 안전 보장이 있더라도 프로그램의 논리가 올바른지 확인하는 데 필요합니다.\n12장에서는 파일 내에서 텍스트를 검색하는 grep 명령줄 도구(command line tool)의 일부 기능 구현을 직접 구축할 것입니다. 이를 위해 이전 장에서 논의한 많은 개념을 사용할 것입니다.\n13장에서는 함수형 프로그래밍 언어에서 파생된 Rust의 기능인 클로저와 이터레이터를 살펴봅니다.\n14장에서는 Cargo를 더 깊이 살펴보고 다른 사람들과 라이브러리를 공유하는 모범 사례에 대해 이야기할 것입니다.\n15장에서는 표준 라이브러리가 제공하는 스마트 포인터와 기능을 가능하게 하는 특성에 대해 설명합니다.\n16장에서 우리는 동시성 프로그래밍의 다양한 모델을 살펴보고 Rust가 두려움 없이 여러 스레드에서 프로그래밍하는 데 어떻게 도움이 되는지 이야기할 것입니다.\n17장에서는 Rust 관용구가 여러분에게 친숙한 객체 지향 프로그래밍 원칙과 어떻게 비교되는지 살펴봅니다.\n18장은 Rust 프로그램 전체에서 아이디어를 표현하는 강력한 방법인 패턴(patterns)과 패턴 일치(pattern matching)에 대한 참조입니다.\n19장에는 unsafe Rust, 매크로(macros) 및 수명(lifetimes), 특성(traits), 유형(types), 함수(functions) 및 클로저(closures) 를 포함하여 관심을 가질만한 고급 주제의 부페가 포함되어 있습니다.\n20장에서는 저수준의 다중 스레드 웹 서버를 구현하는 프로젝트를 완료합니다!\n마지막으로 일부 부록에는 참조와 유사한 형식으로 언어에 대한 유용한 정보가 포함되어 있습니다.\n부록 A는 Rust의 키워드를 다루고, 부록 B는 Rust의 연산자와 기호를 다루고, 부록 C는 표준 라이브러리에서 제공하는 파생 특성을 다루고, 부록 D는 몇 가지 유용한 개발 도구를 다루고, 부록 E는 Rust 에디션을 설명합니다. 부록 F에서 책의 번역본을 찾을 수 있으며 부록 G에서는 Rust가 어떻게 만들어지고 nightly Rust가 무엇인지 다룰 것입니다.\n이 책을 읽는 데 잘못된 방법은 없습니다. 건너뛰고 싶다면 계속 읽으세요! 혼동이 발생하면 이전 장으로 다시 이동해야 할 수도 있습니다. 그러나 당신에게 효과가 있는 것은 무엇이든 하십시오.\nRust를 배우는 과정에서 중요한 부분은 컴파일러가 표시하는 오류 메시지를 읽는 방법을 배우는 것입니다. 이러한 메시지는 작업 코드로 안내할 것입니다. 따라서 각 상황에서 컴파일러가 표시하는 오류 메시지와 함께 컴파일되지 않는 많은 예제를 제공할 것입니다.\n임의의 예제를 입력하고 실행하면 컴파일되지 않을 수 있습니다! 실행하려는 예제가 오류인지 확인하려면 주변 텍스트를 읽어보면 됩니다. Ferris는 또한 작동하지 않는 코드를 구별하는 데 도움이 됩니다.\nFerris의미\n물음표가 있는 Ferris이 코드는 컴파일되지 않습니다!\n손을 내밀고 있는 페리스이 코드 패닉!\n한쪽 집게발을 들고 어깨를 으쓱하는 Ferris이 코드는 원하는 동작을 생성하지 않습니다.\n\n대부분의 경우 컴파일되지 않는 코드의 올바른 버전으로 안내해 드립니다.\n소스 코드\n이 책이 생성된 소스 파일은 GitHub에서 찾을 수 있습니다.\n","id":"http://127.0.0.1:1111/rust/","title":"Introduction"},"http://127.0.0.1:1111/rust/chapter1/":{"body":"\nRust 여행을 시작합시다! 배울 것이 많지만 모든 여정은 어딘가에 시작점이 있습니다. 이 장에서는 다음에 대해 논의합니다.\n\nLinux, macOS, Windows에 Rust 설치하기\nHello, world!를 출력하는 프로그램 작성하기\nRust의 패키지 관리자이자 빌드 시스템인 cargo 사용하기\n\n","id":"http://127.0.0.1:1111/rust/chapter1/","title":"Getting Started"},"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"body":"첫 번째 단계는 Rust를 설치하는 것입니다. Rust 버전 및 관련 도구를 관리하기 위한 명령줄 도구인 rustup을 통해 Rust를 다운로드합니다. 다운로드하려면 인터넷 연결이 필요합니다.\n\nNote: Rustup을 사용하지 않으려면 다른 Rust 설치 방법 페이지에서 더 많은 옵션을 확인하세요.\n\n다음 단계는 Rust 컴파일러의 안정적인 최신 버전을 설치합니다. Rust의 안정성은 컴파일하는 책의 모든 예제가 최신 Rust 버전으로 계속 컴파일되도록 보장합니다. 즉, 이 단계를 사용하여 설치한 더 새롭고 안정적인 버전의 Rust는 이 책의 내용과 예상대로 작동해야 합니다. Rust는 종종 오류 메시지와 경고를 개선하기 때문에 결과가 버전마다 약간 다를 수 있습니다. \n\n명령줄(Command Line) 표기법\n이 장과 책 전반에 걸쳐 터미널에서 사용되는 몇 가지 명령을 보여드리겠습니다.\n터미널에 입력해야 하는 줄은 모두 $로 시작합니다. $ 문자를 입력할 필요가 없습니다. 각 명령의 시작을 나타내기 위해 표시되는 명령줄 프롬프트입니다.\n$로 시작하지 않는 행은 일반적으로 이전 명령의 결과물을 표시합니다.\n또한 PowerShell 관련 예제에서는 $ 대신 &gt;를 사용합니다.\n\nrustup을 Linux 또는 macOS에 설치\nLinux 또는 macOS를 사용하는 경우 터미널을 열고 다음 명령을 입력합니다:\n$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh\n이 명령은 스크립트를 다운로드하고 rustup 안정적인 최신 버전의 Rust를 설치하는 도구 설치를 시작합니다. 비밀번호를 입력하라는 메시지가 표시될 수 있습니다. 설치에 성공하면 다음 줄이 나타납니다:\nRust is installed now. Great!\n또한 Rust가 컴파일된 출력을 하나의 파일로 결합하는 데 사용하는 프로그램인 링커(linker)가 필요합니다. 이미 가지고 있을 가능성이 높습니다. 링커 오류가 발생하면 일반적으로 링커를 포함하는 C 컴파일러를 설치해야 합니다. 일부 일반적인 Rust 패키지는 C 코드에 의존하고 C 컴파일러가 필요하기 때문에 A C 컴파일러도 유용합니다.\nmacOS에서는 다음을 실행하여 C 컴파일러를 얻을 수 있습니다:\n$ xcode-select --install\nLinux 사용자는 일반적으로 배포 문서에 따라 GCC 또는 Clang을 설치해야 합니다. 예를 들어 Ubuntu를 사용하는 경우 build-essential 패키지를 설치할 수 있습니다.\nrustup을 Windows에 설치\nWindows에서는 https://www.rust-lang.org/tools/install 로 이동하여 Rust 설치 지침을 따르세요. 설치 중 특정 시점에 Visual Studio 2013 이상용 MSVC 빌드 도구도 필요하다는 메시지가 표시됩니다.\n빌드 도구를 얻으려면 Visual Studio 2022를 설치해야 합니다. 설치할 워크로드를 물으면 다음을 포함합니다:\n\n-“Desktop Development with C++”\n-The Windows 10 or 11 SDK\n-선택한 다른 언어 팩과 함께 영어 언어 팩 구성 요소\n\n이 책의 나머지 부분에서는 cmd.exe 와 PowerShell 모두에서 작동하는 명령을 사용합니다. 구체적인 차이점이 있는 경우 어떤 것을 사용해야 하는지 설명하겠습니다.\n문제 해결\nRust가 올바르게 설치되었는지 확인하려면 셸을 열고 다음 줄을 입력하십시오:\n$ rustc --version\n릴리스된 최신 안정 버전의 버전 번호, 커밋 해시 및 커밋 날짜가 다음 형식으로 표시되어야 합니다:\nrustc x.y.z (abcabcabc yyyy-mm-dd)\n이 정보가 보이면 Rust를 성공적으로 설치한 것입니다!\n이 정보가 보이지 않으면 Rust가 %PATH% 시스템 변수에 있는지 다음과 같이 확인하십시오.\nWindows CMD에서 다음을 사용합니다:\n&gt; echo %PATH%\nPowerShell에서 다음을 사용합니다:\n&gt; echo $env:Path\nLinux 및 macOS에서는 다음을 사용합니다:\n$ echo $PATH\n모든 것이 정확한데 Rust가 여전히 작동하지 않는다면 도움을 받을 수 있는 여러 곳이 있습니다. 커뮤니티 페이지 에서 다른 Rustacean(우리가 스스로를 부르는 별명)과 연락하는 방법을 알아보세요.\n업데이트 및 제거\nrustup을 통해 Rust를 설치하면 새 버전으로 업데이트하는 것이 쉽습니다. 셸에서 다음 업데이트 스크립트를 실행합니다:\n$ rustup update\nRust 및 rustup을 제거하려면 셸에서 다음 제거 스크립트를 실행합니다:\n$ rustup self uninstall\n로컬 문서\nRust 설치에는 문서의 로컬 사본도 포함되어 있어 오프라인에서 읽을 수 있습니다. rustup doc을 실행하여 브라우저에서 로컬 문서를 엽니다.\n타입(type)이나 함수(function)가 표준 라이브러리에서 제공되었는데 그것이 무엇을 하는지 또는 어떻게 사용하는지 잘 모를 때마다 API(Application Programming Interface) 문서를 사용하여 알아보세요!  \n","id":"http://127.0.0.1:1111/rust/chapter1/1-installation/","title":"Installation"},"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"body":"요약\n\n파일 형식은 카멜_형식 을 따른다.\nmain fn: 프로그램에서 처음 실행되는 함수\nindent 는 4 space 이다. tab이 아니다\n함수뒤에 !가 붙으면 Rust macro를 의미한다\n코드의 끝에는 semicolon (;) 를 붙여야한다.\ncompile하기 :  $ rustc main.rs\n파일실행하기 : $ ./main  (윈도우는  .\\main.exe)\n\nHello, World!\n이제 Rust를 설치했으므로 첫 번째 Rust 프로그램을 작성할 차례입니다. 새로운 언어를 배울 때 텍스트를 Hello, world!화면에 출력하는 작은 프로그램을 작성하는 것이 전통적이므로 여기서도 똑같이 할 것입니다!\n\n참고: 이 책은 명령줄에 대한 기본적인 지식이 있다고 가정합니다. Rust는 편집이나 도구 또는 코드가 있는 위치에 대해 특정한 요구를 하지 않으므로 명령줄 대신 통합 개발 환경(IDE)을 선호하는 경우 선호하는 IDE를 자유롭게 사용하세요. 이제 많은 IDE가 어느 정도 Rust를 지원합니다. 자세한 내용은 IDE 설명서를 확인하십시오. Rust 팀은 rust-analyzer를 통해서 훙륭한 IDE를 지원하는데 집중하고 있습니다. 자세한 내용은 부록 D 를 참조하십시오.\n\n프로젝트 디렉토리 생성\nRust 코드를 저장할 디렉토리를 만드는 것으로 시작합니다. 당신의 코드가 어디에 있는지는 Rust에게 중요하지 않지만 이 책의 연습과 프로젝트를 위해 우리는 당신의 홈 디렉토리에 프로젝트 디렉토리를 만들고 거기에 모든 프로젝트를 보관할 것을 제안합니다.\n터미널을 열고 다음 명령을 입력하여 projects 디렉토리를 만들고, projects 디렉토리 내에 \"Hello, world!\" 프로젝트 디렉토리인 hello_world 디렉토리를 만듭니다.\n\nWindows의 Linux, macOS 및 PowerShell의 경우 다음을 입력합니다.\n$ mkdir ~/projects\n$ cd ~/projects\n$ mkdir hello_world\n$ cd hello_world\n\n\nWindows CMD의 경우 다음을 입력합니다.\n&gt; mkdir \"%USERPROFILE%\\projects\"\n&gt; cd /d \"%USERPROFILE%\\projects\"\n&gt; mkdir hello_world\n&gt; cd hello_world\n\nRust 프로그램 작성 및 실행\n다음으로 새 소스 파일을 만들고 이름을 main.rs 로 지정합니다. Rust 파일은 항상 .rs 확장자로 끝납니다. 파일 이름에 두 개 이상의 단어를 사용하는 경우 규칙은 밑줄을 사용하여 구분하는 것입니다. 예를 들어 helloworld.rs 대신 hello_world.rs 를 사용합니다.\n이제 방금 만든 main.rs 파일을 열고 Listing 1-1의 코드를 입력합니다.\n\n파일명: main.rs\nfn main() {\n    println!(\"Hello, world!\");\n}\n\n목록 1-1: Hello, world! 를 프린트하는 프로그램\n\n파일을 저장하고 ~/projects/hello_world 디렉터리의 터미널 창으로 돌아갑니다. Linux 또는 macOS에서 다음 명령을 입력하여 파일을 컴파일하고 실행합니다.\n$ rustc main.rs\n$ ./main\nHello, world!\n\n\nWindows에서는 ./main 대신 .\\main.exe 명령을 입력합니다.\n&gt; rustc main.rs\n&gt; .\\main.exe\nHello, world!\n\n\n운영 체제에 관계없이 Hello, world! 문자열이 터미널에 프린트되어야 합니다. 이 출력이 표시되지 않으면 설치 섹션의 문제해결 부분을 다시 참조하여 도움을 받으세요.\n`Hello, world! 가 프린트 되었다면 축하합니다! 공식적으로 Rust 프로그램을 작성했습니다. 그것은 당신을 Rust 프로그래머로 만들어줍니다. 환영합니다!\nRust 프로그램 분석\n이 \"Hello, world!\"프로그램을 자세히 검토해 봅시다.  퍼즐의 첫 번째 조각은 다음과 같습니다.\nfn main() {\n\n}\n\n이 줄은 main 이라는 함수를 정의합니다. 이 main 의 기능은 특별합니다. 항상 모든 실행 가능한 Rust 프로그램에서 실행되는 첫 번째 코드입니다. 여기서 첫 번째 줄은 매개변수가 없고 아무 것도 반환하지 않는 main 이라는 이름의 함수를 선언합니다. 매개변수가 있으면  ()괄호 안에 들어갑니다.\n함수 본문은 {} 로 감싸져 있습니다. Rust는 모든 함수 본문 주위에 중괄호가 필요합니다. 여는 중괄호를 함수 선언과 같은 줄에 배치하고, 그 사이에 공백을 하나 추가하는 것이 좋습니다.\n\n참고: Rust 프로젝트 전체에서 표준 스타일을 고수하려면, 코드를 특정 스타일로 포맷하기 위해 호출되는 자동 포맷터 도구인 rustfmt를 사용할 수 있습니다. (자세한 내용은 부록 D rustfmt 참조 ). Rust 팀은 이 도구를 rustc 처럼 표준 Rust 배포판에 포함시켰으므로 컴퓨터에 이미 설치되어 있어야 합니다!\n\n\nmain 함수 본문에는 다음 코드가 포함됩니다.\n    println!(\"Hello, world!\");\n\n이 줄은 이 작은 프로그램의 모든 작업을 수행합니다. 화면에 텍스트를 인쇄합니다. 여기에서 주목해야 할 네 가지 중요한 세부 사항이 있습니다.\n첫째, Rust 스타일은 탭이 아닌 네 개의 공백으로 들여쓰기하는 것입니다.\n둘째, println! 는 Rust 매크로를 호출합니다. 만약 함수를 호출했다면 println(!없이 )를 입력합니다. 19장에서 Rust 매크로에 대해 더 자세히 논의할 것입니다. 지금은 !  를 사용함으로써 일반적인 함수 대신 매크로를 호출하고, 매크로가 항상 함수와 동일한 규칙을 따르지 않는다는 것을 의미한다는 것을 알아야 합니다.\n셋째, \"Hello, world!\" 문자열이 보입니다. 이 문자열을 println!의 인수로 전달하면 문자열이 화면에 출력됩니다.\n넷째, 세미콜론( ;)으로 행을 종료합니다. 이는 이 표현(expression)이 끝났고 다음 표현을 시작할 준비가 되었음을 나타냅니다. 대부분의 Rust 코드 줄은 세미콜론으로 끝납니다.\n컴파일과 실행은 별도의 단계입니다.\n방금 새로 만든 프로그램을 실행했으므로 프로세스의 각 단계를 살펴보겠습니다.\nRust 프로그램을 실행하기 전에 다음과 같이 rustc명령을 입력하고 소스 파일의 이름을 전달합니다. 그러면 Rust 컴파일러가 컴파일합니다. \n$ rustc main.rs\n\nC 또는 C++ 배경 지식이 있는 경우 이것이 gcc 또는 clang와 유사하다는 것을 알 수 있습니다. 성공적으로 컴파일한 후 Rust는 바이너리 실행 파일을 생성합니다.\n\nLinux, macOS 및 Windows의 PowerShell에서는 셸에 ls 명령을 입력하여 실행 파일을 볼 수 있습니다.\n$ ls\n&gt; main  main.rs\n\nLinux 및 macOS에서는 두 개의 파일이 표시됩니다. \n\nWindows에서 PowerShell을 사용하면 CMD를 사용하여 동일한 세 개의 파일을 확인할 수 있습니다. Windows에서 CMD를 사용하면 다음을 입력합니다.\n&gt; dir /B %= the /B option says to only show the file names =%\nmain.exe\nmain.pdb\nmain.rs\n\n여기에는 확장자가 .rs 인 소스 코드 파일, 실행 파일( Windows에서는 main.exe, 다른 모든 플랫폼에서는 main), Windows를 사용하는 경우 확장자가 .pdb 인 디버깅 정보가 포함된 파일이 표시됩니다. \n\n여기에서 다음과 같이 main 또는 main.exe 파일을 실행합니다.\n$ ./main (Linux 및 macOS)\n&gt; .\\main.exe (Windows)\n\nmain.rs 가 \"Hello, world!\"프로그램인 경우,  Hello, world! 가 터미널에 인쇄됩니다.\n\nRuby, Python 또는 JavaScript와 같은 동적 언어에 더 익숙한 경우 별도의 단계로 프로그램을 컴파일하고 실행하는 데 익숙하지 않을 수 있습니다.\nRust는 미리 컴파일된 언어입니다. 즉, 프로그램을 컴파일하고 다른 사람에게 실행 파일을 제공할 수 있으며 Rust가 설치되지 않은 상태에서도 실행할 수 있습니다. 누군가에게 .rb , .py 또는 .js 파일을 제공하는 경우 Ruby, Python 또는 JavaScript 구현이 각각 설치되어 있어야 합니다. 그러나 이러한 언어에서는 프로그램을 컴파일하고 실행하는 데 하나의 명령만 필요합니다. 언어 설계에서는 모든 것이 트레이드 오프입니다.\n\nrustc로 간단하게 컴파일하는 것은 간단한 프로그램에 적합하지만 프로젝트가 커짐에 따라 모든 옵션을 관리하고 코드를 쉽게 공유할 수 있게 만들고 싶을 것입니다. 다음으로 실제 Rust 프로그램을 작성하는 데 도움이 되는 Cargo 도구를 소개합니다.\n","id":"http://127.0.0.1:1111/rust/chapter1/2-helloworld/","title":"Hello, World!"},"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"body":"요약\n\n\ncargo : Rust의 build system, package manager\n\n\n$ cargo new hello_cargo 명령어를 실행하면 hello_cargo 폴더만들고, 그안에 git 도 설치됩니다. 실행하면 다음과 같은 파일 구조가 만들어집니다.\n\n\n├── .git\n├── .gitignore\n├── Cargo.toml : config 파일\n└── src\n    └── main.rs : 우리가 만드는 코드\n\n\n\n처음에 cargo를  안썼어도, 위와같은 구조만 만들면 cargo 사용할 수 있습니다.\n\n\n$ cargo build 를 사용하면 다음과 같은 구조가 만들어집니다.\n\n\n..\n├── Cargo.lock : Cargo가 dependencies 의 version 관리하는 파일\n├── Cargo.toml\n├── src\n│&nbsp;&nbsp; └── main.rs\n└── target\n    └── debug\n        └── hello_cargo  (여기 실행파일이 있다)\n\n\n\n\n$ cargo run :  코드를 build 하는 동시에 실행시킨다. (build 보다 더 많이 사용)\n\n\n$ cargo check : compile되는지 확인만하고, 실행은 안한다.\n\n\n$ cargo build --release\n\nrelease 용으로 compile (그냥 build 와 다르게 compile이 오래걸리는 대신, 실행이 빠르다)\n./target/release 폴더에 저장\n\n\n\nHello, Cargo!\nCargo는 Rust의 빌드 시스템이자 패키지 관리자입니다. 대부분의 Rustaceans는 이 도구를 사용하여 Rust 프로젝트를 관리합니다. 왜냐하면 Cargo가 코드 빌드, 코드가 의존하는 라이브러리 다운로드, 해당 라이브러리 빌드와 같은 많은 작업을 처리하기 때문입니다. (코드에 종속성(dependency)이 필요한 라이브러리를 호출합니다.)\n우리가 지금까지 작성한 것과 같은 가장 단순한 Rust 프로그램은 종속성이 없습니다. Cargo로 \"Hello, world!\" 프로젝트를 만들면 코드 빌드를 처리하는 Cargo의 일부만 사용합니다. 더 복잡한 Rust 프로그램을 작성하면서 종속성을 추가하게 되고 Cargo를 사용하여 프로젝트를 시작하면 종속성을 추가하는 것이 훨씬 쉬워질 것입니다.\n대부분의 Rust 프로젝트가 Cargo를 사용하기 때문에 이 책의 나머지 부분에서도 Cargo를 사용하고 있다고 가정합니다. Cargo는 설치 섹션에서 논의된 공식 설치 프로그램을 사용한 경우 Rust와 함께 설치됩니다. 다른 방법으로 Rust를 설치했다면, 터미널에 다음을 입력하여 Cargo가 설치되어 있는지 확인하세요:\n\n$ cargo --version\n\n버전 번호가 보이면 가지고 있는 것입니다! command not found와 같은 오류가 표시되면 문서를 참조해서 Cargo를 별도로 설치하는 방법을 선택하세요. \nCargo로 프로젝트 만들기\nCargo를 사용하여 새 프로젝트를 생성하고 원래의 \"Hello, world!\"프로젝트와 어떻게 다른지 살펴보겠습니다. 프로젝트 디렉토리(또는 코드를 저장하기로 결정한 위치) 로 다시 이동합니다. 그런 다음 운영 체제에서 다음을 실행합니다.\n$ cargo new hello_cargo\n$ cd hello_cargo\n\n첫 번째 명령은 hello_cargo 라는 새 디렉터리와 프로젝트를 만듭니다. 우리는 프로젝트 이름을 hello_cargo 로 지정 했고, Cargo는 같은 이름의 디렉토리에 파일을 생성합니다.\n\nhello_cargo 디렉토리 로 이동하여 파일을 확인해보십시오. Cargo가 우리를 위해 두 개의 파일과 하나의 디렉토리를 생성한 것을 볼 수 있습니다: \n├── .git\n│&nbsp;&nbsp; ├── ...\n├── .gitignore\n├── Cargo.toml\n└── src\n    └── main.rs\n\n또한 .gitignore 파일과 함께 새로운 Git 리포지토리를 초기화했습니다. 기존 Git 리포지토리 내에서 cargo new실행하는 경우 Git 파일이 생성되지 않습니다. cargo new --vcs=git 를 사용하여 이 동작을 재정의할 수 있습니다 \n\n참고: Git은 일반적인 버전 제어 시스템입니다.  --vcs플래그 를 사용하여 cargo new 를 바꿀 수 있습니다. 그러면 다른 버전 제어 시스템을 사용하거나, 버전 제어 시스템을 사용하지 않도록 변경할 수 있습니다. 사용 가능한 옵션을 보려면 cargo new --help실행하십시오.\n\n\n텍스트 편집기에서 Cargo.toml 을 엽니다. 목록 1-2의 코드와 유사해야 합니다.\n파일 이름: Cargo.toml\n[package]\nname = \"hello_cargo\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n\n[dependencies]\n\nListing 1-2: cargo new에 의해 생성된 Cargo.toml 의 내용\n이 파일은 Cargo의 구성 형식인 TOML ( Tom's Obvious, Minimal Language ) 형식입니다.\n첫 번째 줄에 있는  [package] 는 다음 문이 패키지를 구성하고 있음을 나타내는 섹션 머리글입니. 이 파일에 더 많은 정보를 추가하게되면, 다른 섹션도 추가할 것입니다.\n다음 세 줄은 Cargo가 프로그램을 컴파일하는 데 필요한 구성 정보(사용할 Rust의 name, version 및 edition)를 설정합니다. 부록 E에서 edition 키 에 대해 이야기하겠습니다.\n마지막 줄의 [dependencies] 는 프로젝트의 종속성을 나열하는 섹션의 시작 부분입니다. Rust에서는 코드 패키지를 크레이트(crates) 라고 합니다. 이 프로젝트에는 다른 크레이트가 필요하지 않지만, 2장의 첫 번째 프로젝트에는 필요할 것이므로, 이 [dependencies] 섹션을 사용할 것입니다.\n\n이제 src/main.rs를 열고 살펴보십시오.\n파일 이름: src/main.rs\nfn main() {\n    println!(\"Hello, world!\");\n}\n\n목록 1-1에서 작성한 것과 같은 프로그램입니다. 이전에 만들었던 프로그램과 Cargo가 생성한 프로젝트의 차이점은 Cargo가 src 디렉토리에 코드를 배치하고 최상위 디렉토리에 Cargo.toml 이라는 이름의 config 파일이 있다는 것입니다.\n├── Cargo.toml\n└── src\n    └── main.rs\n\nCargo는 소스 파일이 src 디렉토리 안에 있을 것으로 예상합니다. 최상위 프로젝트 디렉토리는 README 파일, 라이센스 정보, 구성 파일 및 코드와 관련되지 않은 모든 항목을 위한 것입니다. Cargo를 사용하면 프로젝트를 정리하는 데 도움이 됩니다. 모든 것은 그것을 위한 장소가 있고, 모든 것이 제자리에 있습니다.\n\n이전 장의 \"Hello, world!\"에서 했던 것처럼 Cargo를 사용하지 않고 프로젝트를 시작한 경우, 프로젝트에서 Cargo를 사용하는 프로젝트로 변환할 수 있습니다. 프로젝트 코드를 src 디렉토리로 이동하고 적절한 Cargo.toml 파일을 생성합니다.\nCargo 프로젝트 구축 및 실행\n이제 Cargo 로 \"Hello, world!\"를 빌드하고 실행할 때 무엇이 다른지 살펴보겠습니다. hello_cargo 디렉터리에서 다음 명령을 입력하여 프로젝트를 빌드합니다.\n$ cargo build\n   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)\n    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs\n\n이 명령은 현재 디렉터리가 아닌 target/debug/hello_cargo (Windows의 경우 target\\debug\\hello_cargo.exe ) 에 실행 파일을 생성합니다. 기본 빌드가 디버그 빌드이기 때문에 Cargo는 debug 라는 디렉토리에 바이너리를 넣습니다. \n├── Cargo.lock\n├── Cargo.toml\n├── src\n│&nbsp;&nbsp; └── main.rs\n└── target\n    └── debug\n        ├── build\n        ├── deps\n        ├── examples\n        ├── hello_cargo  (여기 실행파일이 있다)\n        ├── hello_cargo.d\n        └── incremental\n\n\n다음 명령으로 실행 파일을 실행할 수 있습니다.\n$ ./target/debug/hello_cargo # or .\\target\\debug\\hello_cargo.exe on Windows\nHello, world!\n\n모든 것이 잘 되었으면 터미널에 Hello, world! 가 인쇄되어야 합니다. 처음으로 cargo build실행하면 Cargo가 최상위 레벨에 새 파일인 Cargo.lock 을 생성하게 됩니다. 이 파일은 프로젝트의 정확한 종속성 버전을 추적합니다. 이 프로젝트에는 종속성이 없으므로 파일이 약간 희박합니다. 이 파일을 수동으로 변경할 필요가 없습니다. Cargo는 당신을 위해 내용물을 관리합니다.\n\n방금 cargo build로 프로젝트를 빌드하고, ./target/debug/hello_cargo를 사용하여 실행했습니다.  그런데 cargo run 이라는 하나의 명령어를 사용해서 코드를 컴파일한 다음 실행할 수 도 있습니다.\n$ cargo run\n    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs\n     Running `target/debug/hello_cargo`\nHello, world!\n\ncargo build 를 실행한 다음 바이너리에 대한 전체 경로를 사용하는 것보다,  cargo run 을 사용하는 것이 더 편리하므로 대부분의 개발자는 cargo run 을 사용합니다.\n이번에는 Cargo가 hello_cargo 를 컴파일 중임을 나타내는 출력이 표시되지 않았습니다. Cargo는 파일이 변경되지 않았음을 알아내서 다시 빌드하지 않고 바이너리만 실행했습니다. 소스 코드를 수정했다면 Cargo는 프로젝트를 실행하기 전에 다시 빌드했을 것이고, 다음과 같은 출력을 보았을 것입니다:\n$ cargo run\n   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs\n     Running `target/debug/hello_cargo`\nHello, world!\n\n\nCargo는 cargo check이라는 명령도 제공합니다. 이 명령은 코드를 신속하게 검사하여 컴파일되는지 확인합니다. 하지만 실행 파일을 생성하지는 않습니다.\n$ cargo check\n   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs\n\n실행 파일을 원하지 않는 이유는 무엇일까요?  cargo check 는 실행 파일 생성 단계를 건너뛰기 때문에 cargo build 보다 훨씬 빠릅니다. 코드를 작성하는 동안 지속적으로 작업을 확인하는 경우, cargo check를 사용하면 프로젝트가 아직 컴파일 되는지 확인하는 프로세스가 빨라집니다! 따라서 많은 Rustacean은 프로그램이 컴파일되는지 확인하기 위해 프로그램을 작성할 때 주기적으로 cargo check 을 실행합니다. 그런 다음 실행 파일을 사용할 준비가 되면 cargo build 를 실행합니다.\nCargo에 대해 지금까지 배운 내용을 요약해 보겠습니다.\n\ncargo new를 사용하여 프로젝트를 만들 수 있습니다.\ncargo build를 사용하여 프로젝트를 빌드할 수 있습니다.\ncargo run을 사용하여 한 번에 프로젝트를 빌드하고 실행할 수 있습니다.\ncargo check을 사용하여 바이너리를 생성하지 않고 오류를 확인하기 위해 프로젝트를 빌드할 수 있습니다.\nCargo는 빌드 결과를 코드와 같은 디렉토리에 저장하지 않고,  target/debug 디렉토리에 저장합니다.\n\nCargo 사용의 또 다른 이점은 작업 중인 운영 체제에 관계없이 명령이 동일하다는 것입니다. 따라서 이제부터 Linux,  macOS 대 Windows에 대한 특정 지침을 더 이상 제공하지 않습니다.\n출시를 위한 구축\n프로젝트가 최종적으로 릴리스 준비가 되면 cargo build --release를 사용하여 최적화하여 컴파일할 수 있습니다. 이 명령은 target/debug 대신 target/release 에서 실행 파일을 생성합니다.\n├── Cargo.lock\n├── Cargo.toml\n├── src\n│&nbsp;&nbsp; └── main.rs\n└── target\n    ├── debug\n    │&nbsp;&nbsp; ├── hello_cargo\n    └── release\n        └── hello_cargo (여기에 파일 생성)\n\n\n최적화는 Rust 코드를 더 빠르게 실행하게 하지만, 최적화를 켜면 프로그램을 컴파일하는 데 걸리는 시간이 길어집니다. 이것이 두 가지 다른 프로필이 있는 이유입니다. 하나는 신속하고 자주 재빌드하려는 개발용이고 다른 하나는 반복적으로 재빌드되지 않고 최대한 빠르게 실행되는 사용자에게 제공할 최종 프로그램을 빌드하기 위한 것입니다. 코드의 실행 시간을 벤치마킹하는 경우, cargo build --release 를 실행한 다음,  target/release 에서 실행 파일을 실행하고 벤치마킹해야 합니다.\n컨벤션으로서의 Cargo\n간단한 프로젝트에서는 Cargo가 단순히 rustc를 사용하는 것보다 많은 가치를 제공하지는 않습니다. 하지만 프로그램이 더 복잡해짐에 따라 Cargo는 그 가치를 입증할 것입니다. 프로그램이 여러 파일로 확장되거나 종속성이 필요하면 Cargo가 빌드를 조정하도록 하는 것이 훨씬 쉽습니다.\n이 hello_cargo프로젝트는 간단하지만 이제 남은 Rust 경력에서 사용할 실제 도구를 많이 사용합니다. 실제로 기존에 있는 프로젝트에서 작업하려면, 다음 명령을 사용하여, Git 으로 코드를 확인하고, 해당 프로젝트의 디렉터리로 변경한 다음, 빌드할 수 있습니다.\n$ git clone example.org/someproject\n$ cd someproject\n$ cargo build\n\nCargo에 대한 자세한 내용은 문서 를 확인하세요.\n요약\n당신은 이미 Rust 여행을 훌륭하게 시작했습니다! 이 장에서는 다음 방법을 배웠습니다.\n\nrustup을 사용하여 안정적인 최신 버전의 Rust를 설치합니다.\n최신 Rust 버전으로 업데이트\n로컬로 설치된 문서 열기\nrustc 를 직접 사용하여,  \"Hello, world!\"를 작성하고 실행합니다.\nCargo의 규칙을 사용하여 새 프로젝트를 생성하고 실행합니다.\n\n지금은 Rust 코드를 읽고 쓰는 데 익숙해지기 위해 보다 실질적인 프로그램을 구축할 수 있는 좋은 시간입니다. 그래서 2장에서는 추측 게임 프로그램을 만들 것입니다. Rust에서 일반적인 프로그래밍 개념이 어떻게 작동하는지 배우는 것으로 시작하려면 3장을 보고 2장으로 돌아가세요.\n","id":"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/","title":"Hello, Cargo!"},"http://127.0.0.1:1111/rust/chapter11-17/":{"body":"Writing Automated Tests\nIn his 1972 essay “The Humble Programmer,” Edsger W. Dijkstra said that “Program testing can be a very effective way to show the presence of bugs, but it is hopelessly inadequate for showing their absence.” That doesn’t mean we shouldn’t try to test as much as we can!\nCorrectness in our programs is the extent to which our code does what we intend it to do. Rust is designed with a high degree of concern about the correctness of programs, but correctness is complex and not easy to prove. Rust’s type system shoulders a huge part of this burden, but the type system cannot catch everything. As such, Rust includes support for writing automated software tests.\nSay we write a function \"add_two\" that adds 2 to whatever number is passed to it. This function’s signature accepts an integer as a parameter and returns an integer as a result. When we implement and compile that function, Rust does all the type checking and borrow checking that you’ve learned so far to ensure that, for instance, we aren’t passing a \"String\" value or an invalid reference to this function. But Rust can’t check that this function will do precisely what we intend, which is return the parameter plus 2 rather than, say, the parameter plus 10 or the parameter minus 50! That’s where tests come in.\nWe can write tests that assert, for example, that when we pass \"3\" to the \"add_two\" function, the returned value is \"5\". We can run these tests whenever we make changes to our code to make sure any existing correct behavior has not changed.\nTesting is a complex skill: although we can’t cover every detail about how to write good tests in one chapter, we’ll discuss the mechanics of Rust’s testing facilities. We’ll talk about the annotations and macros available to you when writing your tests, the default behavior and options provided for running your tests, and how to organize tests into unit tests and integration tests.\n\nHow to Write Tests\nTests are Rust functions that verify that the non-test code is functioning in the expected manner. The bodies of test functions typically perform these three actions:\n\nSet up any needed data or state.\nRun the code you want to test.\nAssert the results are what you expect.\n\nLet’s look at the features Rust provides specifically for writing tests that take these actions, which include the \"test\" attribute, a few macros, and the \"should_panic\" attribute.\nThe Anatomy of a Test Function\nAt its simplest, a test in Rust is a function that’s annotated with the \"test\" attribute. Attributes are metadata about pieces of Rust code; one example is the \"derive\" attribute we used with structs in Chapter 5. To change a function into a test function, add \"#[test]\" on the line before \"fn\". When you run your tests with the \"cargo test\" command, Rust builds a test runner binary that runs the annotated functions and reports on whether each test function passes or fails.\nWhenever we make a new library project with Cargo, a test module with a test function in it is automatically generated for us. This module gives you a template for writing your tests so you don’t have to look up the exact structure and syntax every time you start a new project. You can add as many additional test functions and as many test modules as you want!\nWe’ll explore some aspects of how tests work by experimenting with the template test before we actually test any code. Then we’ll write some real-world tests that call some code that we’ve written and assert that its behavior is correct.\nLet’s create a new library project called \"adder\" that will add two numbers:\n$ cargo new adder --lib\n     Created library \"adder\" project\n$ cd adder\n\nThe contents of the src/lib.rs file in your \"adder\" library should look like Listing 11-1.\nFilename: src/lib.rs\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn it_works() {\n        let result = 2 + 2;\n        assert_eq!(result, 4);\n    }\n}\n\nListing 11-1: The test module and function generated automatically by \"cargo new\"\nFor now, let’s ignore the top two lines and focus on the function. Note the \"#[test]\" annotation: this attribute indicates this is a test function, so the test runner knows to treat this function as a test. We might also have non-test functions in the \"tests\" module to help set up common scenarios or perform common operations, so we always need to indicate which functions are tests.\nThe example function body uses the \"assert_eq!\" macro to assert that \"result\", which contains the result of adding 2 and 2, equals 4. This assertion serves as an example of the format for a typical test. Let’s run it to see that this test passes.\nThe \"cargo test\" command runs all tests in our project, as shown in Listing 11-2.\n$ cargo test\n   Compiling adder v0.1.0 (file:///projects/adder)\n    Finished test [unoptimized + debuginfo] target(s) in 0.57s\n     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)\n\nrunning 1 test\ntest tests::it_works ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests adder\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nListing 11-2: The output from running the automatically generated test\nCargo compiled and ran the test. We see the line \"running 1 test\". The next line shows the name of the generated test function, called \"it_works\", and that the result of running that test is \"ok\". The overall summary \"test result: ok.\" means that all the tests passed, and the portion that reads \"1 passed; 0 failed\" totals the number of tests that passed or failed.\nIt’s possible to mark a test as ignored so it doesn’t run in a particular instance; we’ll cover that in the “Ignoring Some Tests Unless Specifically Requested” section later in this chapter. Because we haven’t done that here, the summary shows \"0 ignored\". We can also pass an argument to the \"cargo test\" command to run only tests whose name matches a string; this is called filtering and we’ll cover that in the “Running a Subset of Tests by Name” section. We also haven’t filtered the tests being run, so the end of the summary shows \"0 filtered out\".\nThe \"0 measured\" statistic is for benchmark tests that measure performance. Benchmark tests are, as of this writing, only available in nightly Rust. See the documentation about benchmark tests to learn more.\nThe next part of the test output starting at \"Doc-tests adder\" is for the results of any documentation tests. We don’t have any documentation tests yet, but Rust can compile any code examples that appear in our API documentation. This feature helps keep your docs and your code in sync! We’ll discuss how to write documentation tests in the “Documentation Comments as Tests” section of Chapter 14. For now, we’ll ignore the \"Doc-tests\" output.\nLet’s start to customize the test to our own needs. First change the name of the \"it_works\" function to a different name, such as \"exploration\", like so:\nFilename: src/lib.rs\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn exploration() {\n        assert_eq!(2 + 2, 4);\n    }\n}\n\nThen run \"cargo test\" again. The output now shows \"exploration\" instead of \"it_works\":\n$ cargo test\n   Compiling adder v0.1.0 (file:///projects/adder)\n    Finished test [unoptimized + debuginfo] target(s) in 0.59s\n     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)\n\nrunning 1 test\ntest tests::exploration ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests adder\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nNow we’ll add another test, but this time we’ll make a test that fails! Tests fail when something in the test function panics. Each test is run in a new thread, and when the main thread sees that a test thread has died, the test is marked as failed. In Chapter 9, we talked about how the simplest way to panic is to call the \"panic!\" macro. Enter the new test as a function named \"another\", so your src/lib.rs file looks like Listing 11-3.\nFilename: src/lib.rs\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn exploration() {\n        assert_eq!(2 + 2, 4);\n    }\n\n    #[test]\n    fn another() {\n        panic!(\"Make this test fail\");\n    }\n}\n\nListing 11-3: Adding a second test that will fail because we call the \"panic!\" macro\nRun the tests again using \"cargo test\". The output should look like Listing 11-4, which shows that our \"exploration\" test passed and \"another\" failed.\n$ cargo test\n   Compiling adder v0.1.0 (file:///projects/adder)\n    Finished test [unoptimized + debuginfo] target(s) in 0.72s\n     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)\n\nrunning 2 tests\ntest tests::another ... FAILED\ntest tests::exploration ... ok\n\nfailures:\n\n---- tests::another stdout ----\nthread \"tests::another\" panicked at \"Make this test fail\", src/lib.rs:10:9\nnote: run with \"RUST_BACKTRACE=1\" environment variable to display a backtrace\n\n\nfailures:\n    tests::another\n\ntest result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass \"--lib\"\n\nListing 11-4: Test results when one test passes and one test fails\nInstead of \"ok\", the line \"test tests::another\" shows \"FAILED\". Two new sections appear between the individual results and the summary: the first displays the detailed reason for each test failure. In this case, we get the details that \"another\" failed because it \"panicked at \"Make this test fail\"\" on line 10 in the src/lib.rs file. The next section lists just the names of all the failing tests, which is useful when there are lots of tests and lots of detailed failing test output. We can use the name of a failing test to run just that test to more easily debug it; we’ll talk more about ways to run tests in the “Controlling How Tests Are Run” section.\nThe summary line displays at the end: overall, our test result is \"FAILED\". We had one test pass and one test fail.\nNow that you’ve seen what the test results look like in different scenarios, let’s look at some macros other than \"panic!\" that are useful in tests.\nChecking Results with the \"assert!\" Macro\nThe \"assert!\" macro, provided by the standard library, is useful when you want to ensure that some condition in a test evaluates to \"true\". We give the \"assert!\" macro an argument that evaluates to a Boolean. If the value is \"true\", nothing happens and the test passes. If the value is \"false\", the \"assert!\" macro calls \"panic!\" to cause the test to fail. Using the \"assert!\" macro helps us check that our code is functioning in the way we intend.\nIn Chapter 5, Listing 5-15, we used a \"Rectangle\" struct and a \"can_hold\" method, which are repeated here in Listing 11-5. Let’s put this code in the src/lib.rs file, then write some tests for it using the \"assert!\" macro.\nFilename: src/lib.rs\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nimpl Rectangle {\n    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {\n        self.width &gt; other.width &amp;&amp; self.height &gt; other.height\n    }\n}\n\nListing 11-5: Using the \"Rectangle\" struct and its \"can_hold\" method from Chapter 5\nThe \"can_hold\" method returns a Boolean, which means it’s a perfect use case for the \"assert!\" macro. In Listing 11-6, we write a test that exercises the \"can_hold\" method by creating a \"Rectangle\" instance that has a width of 8 and a height of 7 and asserting that it can hold another \"Rectangle\" instance that has a width of 5 and a height of 1.\nFilename: src/lib.rs\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn larger_can_hold_smaller() {\n        let larger = Rectangle {\n            width: 8,\n            height: 7,\n        };\n        let smaller = Rectangle {\n            width: 5,\n            height: 1,\n        };\n\n        assert!(larger.can_hold(&amp;smaller));\n    }\n}\n\nListing 11-6: A test for \"can_hold\" that checks whether a larger rectangle can indeed hold a smaller rectangle\nNote that we’ve added a new line inside the \"tests\" module: \"use super::*;\". The \"tests\" module is a regular module that follows the usual visibility rules we covered in Chapter 7 in the “Paths for Referring to an Item in the Module Tree” section. Because the \"tests\" module is an inner module, we need to bring the code under test in the outer module into the scope of the inner module. We use a glob here so anything we define in the outer module is available to this \"tests\" module.\nWe’ve named our test \"larger_can_hold_smaller\", and we’ve created the two \"Rectangle\" instances that we need. Then we called the \"assert!\" macro and passed it the result of calling \"larger.can_hold(&amp;smaller)\". This expression is supposed to return \"true\", so our test should pass. Let’s find out!\n$ cargo test\n   Compiling rectangle v0.1.0 (file:///projects/rectangle)\n    Finished test [unoptimized + debuginfo] target(s) in 0.66s\n     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)\n\nrunning 1 test\ntest tests::larger_can_hold_smaller ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests rectangle\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nIt does pass! Let’s add another test, this time asserting that a smaller rectangle cannot hold a larger rectangle:\nFilename: src/lib.rs\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn larger_can_hold_smaller() {\n        // --snip--\n    }\n\n    #[test]\n    fn smaller_cannot_hold_larger() {\n        let larger = Rectangle {\n            width: 8,\n            height: 7,\n        };\n        let smaller = Rectangle {\n            width: 5,\n            height: 1,\n        };\n\n        assert!(!smaller.can_hold(&amp;larger));\n    }\n}\n\nBecause the correct result of the \"can_hold\" function in this case is \"false\", we need to negate that result before we pass it to the \"assert!\" macro. As a result, our test will pass if \"can_hold\" returns \"false\":\n$ cargo test\n   Compiling rectangle v0.1.0 (file:///projects/rectangle)\n    Finished test [unoptimized + debuginfo] target(s) in 0.66s\n     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)\n\nrunning 2 tests\ntest tests::larger_can_hold_smaller ... ok\ntest tests::smaller_cannot_hold_larger ... ok\n\ntest result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests rectangle\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nTwo tests that pass! Now let’s see what happens to our test results when we introduce a bug in our code. We’ll change the implementation of the \"can_hold\" method by replacing the greater-than sign with a less-than sign when it compares the widths:\n// --snip--\nimpl Rectangle {\n    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {\n        self.width &lt; other.width &amp;&amp; self.height &gt; other.height\n    }\n}\n\nRunning the tests now produces the following:\n$ cargo test\n   Compiling rectangle v0.1.0 (file:///projects/rectangle)\n    Finished test [unoptimized + debuginfo] target(s) in 0.66s\n     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)\n\nrunning 2 tests\ntest tests::larger_can_hold_smaller ... FAILED\ntest tests::smaller_cannot_hold_larger ... ok\n\nfailures:\n\n---- tests::larger_can_hold_smaller stdout ----\nthread \"tests::larger_can_hold_smaller\" panicked at \"assertion failed: larger.can_hold(&amp;smaller)\", src/lib.rs:28:9\nnote: run with \"RUST_BACKTRACE=1\" environment variable to display a backtrace\n\n\nfailures:\n    tests::larger_can_hold_smaller\n\ntest result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass \"--lib\"\n\nOur tests caught the bug! Because \"larger.width\" is 8 and \"smaller.width\" is 5, the comparison of the widths in \"can_hold\" now returns \"false\": 8 is not less than 5.\nTesting Equality with the \"assert_eq!\" and \"assert_ne!\" Macros\nA common way to verify functionality is to test for equality between the result of the code under test and the value you expect the code to return. You could do this using the \"assert!\" macro and passing it an expression using the \"==\" operator. However, this is such a common test that the standard library provides a pair of macros—\"assert_eq!\" and \"assert_ne!\"—to perform this test more conveniently. These macros compare two arguments for equality or inequality, respectively. They’ll also print the two values if the assertion fails, which makes it easier to see why the test failed; conversely, the \"assert!\" macro only indicates that it got a \"false\" value for the \"==\" expression, without printing the values that led to the \"false\" value.\nIn Listing 11-7, we write a function named \"add_two\" that adds \"2\" to its parameter, then we test this function using the \"assert_eq!\" macro.\nFilename: src/lib.rs\npub fn add_two(a: i32) -&gt; i32 {\n    a + 2\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn it_adds_two() {\n        assert_eq!(4, add_two(2));\n    }\n}\n\nListing 11-7: Testing the function \"add_two\" using the \"assert_eq!\" macro\nLet’s check that it passes!\n$ cargo test\n   Compiling adder v0.1.0 (file:///projects/adder)\n    Finished test [unoptimized + debuginfo] target(s) in 0.58s\n     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)\n\nrunning 1 test\ntest tests::it_adds_two ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests adder\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nWe pass \"4\" as the argument to \"assert_eq!\", which is equal to the result of calling \"add_two(2)\". The line for this test is \"test tests::it_adds_two ... ok\", and the \"ok\" text indicates that our test passed!\nLet’s introduce a bug into our code to see what \"assert_eq!\" looks like when it fails. Change the implementation of the \"add_two\" function to instead add \"3\":\npub fn add_two(a: i32) -&gt; i32 {\n    a + 3\n}\n\nRun the tests again:\n$ cargo test\n   Compiling adder v0.1.0 (file:///projects/adder)\n    Finished test [unoptimized + debuginfo] target(s) in 0.61s\n     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)\n\nrunning 1 test\ntest tests::it_adds_two ... FAILED\n\nfailures:\n\n---- tests::it_adds_two stdout ----\nthread \"tests::it_adds_two\" panicked at \"assertion failed: \"(left == right)\"\n  left: \"4\",\n right: \"5\"\", src/lib.rs:11:9\nnote: run with \"RUST_BACKTRACE=1\" environment variable to display a backtrace\n\n\nfailures:\n    tests::it_adds_two\n\ntest result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass \"--lib\"\n\nOur test caught the bug! The \"it_adds_two\" test failed, and the message tells us that the assertion that fails was \"assertion failed: \"(left == right)\"\" and what the \"left\" and \"right\" values are. This message helps us start debugging: the \"left\" argument was \"4\" but the \"right\" argument, where we had \"add_two(2)\", was \"5\". You can imagine that this would be especially helpful when we have a lot of tests going on.\nNote that in some languages and test frameworks, the parameters to equality assertion functions are called \"expected\" and \"actual\", and the order in which we specify the arguments matters. However, in Rust, they’re called \"left\" and \"right\", and the order in which we specify the value we expect and the value the code produces doesn’t matter. We could write the assertion in this test as \"assert_eq!(add_two(2), 4)\", which would result in the same failure message that displays \"assertion failed: \"(left == right)\"\".\nThe \"assert_ne!\" macro will pass if the two values we give it are not equal and fail if they’re equal. This macro is most useful for cases when we’re not sure what a value will be, but we know what the value definitely shouldn’t be. For example, if we’re testing a function that is guaranteed to change its input in some way, but the way in which the input is changed depends on the day of the week that we run our tests, the best thing to assert might be that the output of the function is not equal to the input.\nUnder the surface, the \"assert_eq!\" and \"assert_ne!\" macros use the operators \"==\" and \"!=\", respectively. When the assertions fail, these macros print their arguments using debug formatting, which means the values being compared must implement the \"PartialEq\" and \"Debug\" traits. All primitive types and most of the standard library types implement these traits. For structs and enums that you define yourself, you’ll need to implement \"PartialEq\" to assert equality of those types. You’ll also need to implement \"Debug\" to print the values when the assertion fails. Because both traits are derivable traits, as mentioned in Listing 5-12 in Chapter 5, this is usually as straightforward as adding the \"#[derive(PartialEq, Debug)]\" annotation to your struct or enum definition. See Appendix C, “Derivable Traits,” for more details about these and other derivable traits.\nAdding Custom Failure Messages\nYou can also add a custom message to be printed with the failure message as optional arguments to the \"assert!\", \"assert_eq!\", and \"assert_ne!\" macros. Any arguments specified after the required arguments are passed along to the \"format!\" macro (discussed in Chapter 8 in the “Concatenation with the \"+\" Operator or the \"format!\" Macro” section), so you can pass a format string that contains \"{}\" placeholders and values to go in those placeholders. Custom messages are useful for documenting what an assertion means; when a test fails, you’ll have a better idea of what the problem is with the code.\nFor example, let’s say we have a function that greets people by name and we want to test that the name we pass into the function appears in the output:\nFilename: src/lib.rs\npub fn greeting(name: &amp;str) -&gt; String {\n    format!(\"Hello {}!\", name)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn greeting_contains_name() {\n        let result = greeting(\"Carol\");\n        assert!(result.contains(\"Carol\"));\n    }\n}\n\nThe requirements for this program haven’t been agreed upon yet, and we’re pretty sure the \"Hello\" text at the beginning of the greeting will change. We decided we don’t want to have to update the test when the requirements change, so instead of checking for exact equality to the value returned from the \"greeting\" function, we’ll just assert that the output contains the text of the input parameter.\nNow let’s introduce a bug into this code by changing \"greeting\" to exclude \"name\" to see what the default test failure looks like:\npub fn greeting(name: &amp;str) -&gt; String {\n    String::from(\"Hello!\")\n}\n\nRunning this test produces the following:\n$ cargo test\n   Compiling greeter v0.1.0 (file:///projects/greeter)\n    Finished test [unoptimized + debuginfo] target(s) in 0.91s\n     Running unittests src/lib.rs (target/debug/deps/greeter-170b942eb5bf5e3a)\n\nrunning 1 test\ntest tests::greeting_contains_name ... FAILED\n\nfailures:\n\n---- tests::greeting_contains_name stdout ----\nthread \"tests::greeting_contains_name\" panicked at \"assertion failed: result.contains(\\\"Carol\\\")\", src/lib.rs:12:9\nnote: run with \"RUST_BACKTRACE=1\" environment variable to display a backtrace\n\n\nfailures:\n    tests::greeting_contains_name\n\ntest result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass \"--lib\"\n\nThis result just indicates that the assertion failed and which line the assertion is on. A more useful failure message would print the value from the \"greeting\" function. Let’s add a custom failure message composed of a format string with a placeholder filled in with the actual value we got from the \"greeting\" function:\n    #[test]\n    fn greeting_contains_name() {\n        let result = greeting(\"Carol\");\n        assert!(\n            result.contains(\"Carol\"),\n            \"Greeting did not contain name, value was \"{}\"\",\n            result\n        );\n    }\n\nNow when we run the test, we’ll get a more informative error message:\n$ cargo test\n   Compiling greeter v0.1.0 (file:///projects/greeter)\n    Finished test [unoptimized + debuginfo] target(s) in 0.93s\n     Running unittests src/lib.rs (target/debug/deps/greeter-170b942eb5bf5e3a)\n\nrunning 1 test\ntest tests::greeting_contains_name ... FAILED\n\nfailures:\n\n---- tests::greeting_contains_name stdout ----\nthread \"tests::greeting_contains_name\" panicked at \"Greeting did not contain name, value was \"Hello!\"\", src/lib.rs:12:9\nnote: run with \"RUST_BACKTRACE=1\" environment variable to display a backtrace\n\n\nfailures:\n    tests::greeting_contains_name\n\ntest result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass \"--lib\"\n\nWe can see the value we actually got in the test output, which would help us debug what happened instead of what we were expecting to happen.\nChecking for Panics with \"should_panic\"\nIn addition to checking return values, it’s important to check that our code handles error conditions as we expect. For example, consider the \"Guess\" type that we created in Chapter 9, Listing 9-13. Other code that uses \"Guess\" depends on the guarantee that \"Guess\" instances will contain only values between 1 and 100. We can write a test that ensures that attempting to create a \"Guess\" instance with a value outside that range panics.\nWe do this by adding the attribute \"should_panic\" to our test function. The test passes if the code inside the function panics; the test fails if the code inside the function doesn’t panic.\nListing 11-8 shows a test that checks that the error conditions of \"Guess::new\" happen when we expect them to.\nFilename: src/lib.rs\npub struct Guess {\n    value: i32,\n}\n\nimpl Guess {\n    pub fn new(value: i32) -&gt; Guess {\n        if value &lt; 1 || value &gt; 100 {\n            panic!(\"Guess value must be between 1 and 100, got {}.\", value);\n        }\n\n        Guess { value }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn greater_than_100() {\n        Guess::new(200);\n    }\n}\n\nListing 11-8: Testing that a condition will cause a \"panic!\"\nWe place the \"#[should_panic]\" attribute after the \"#[test]\" attribute and before the test function it applies to. Let’s look at the result when this test passes:\n$ cargo test\n   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n    Finished test [unoptimized + debuginfo] target(s) in 0.58s\n     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)\n\nrunning 1 test\ntest tests::greater_than_100 - should panic ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests guessing_game\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nLooks good! Now let’s introduce a bug in our code by removing the condition that the \"new\" function will panic if the value is greater than 100:\n// --snip--\nimpl Guess {\n    pub fn new(value: i32) -&gt; Guess {\n        if value &lt; 1 {\n            panic!(\"Guess value must be between 1 and 100, got {}.\", value);\n        }\n\n        Guess { value }\n    }\n}\n\nWhen we run the test in Listing 11-8, it will fail:\n$ cargo test\n   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n    Finished test [unoptimized + debuginfo] target(s) in 0.62s\n     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)\n\nrunning 1 test\ntest tests::greater_than_100 - should panic ... FAILED\n\nfailures:\n\n---- tests::greater_than_100 stdout ----\nnote: test did not panic as expected\n\nfailures:\n    tests::greater_than_100\n\ntest result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass \"--lib\"\n\nWe don’t get a very helpful message in this case, but when we look at the test function, we see that it’s annotated with \"#[should_panic]\". The failure we got means that the code in the test function did not cause a panic.\nTests that use \"should_panic\" can be imprecise. A \"should_panic\" test would pass even if the test panics for a different reason from the one we were expecting. To make \"should_panic\" tests more precise, we can add an optional \"expected\" parameter to the \"should_panic\" attribute. The test harness will make sure that the failure message contains the provided text. For example, consider the modified code for \"Guess\" in Listing 11-9 where the \"new\" function panics with different messages depending on whether the value is too small or too large.\nFilename: src/lib.rs\n// --snip--\n\nimpl Guess {\n    pub fn new(value: i32) -&gt; Guess {\n        if value &lt; 1 {\n            panic!(\n                \"Guess value must be greater than or equal to 1, got {}.\",\n                value\n            );\n        } else if value &gt; 100 {\n            panic!(\n                \"Guess value must be less than or equal to 100, got {}.\",\n                value\n            );\n        }\n\n        Guess { value }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic(expected = \"less than or equal to 100\")]\n    fn greater_than_100() {\n        Guess::new(200);\n    }\n}\n\nListing 11-9: Testing for a \"panic!\" with a panic message containing a specified substring\nThis test will pass because the value we put in the \"should_panic\" attribute’s \"expected\" parameter is a substring of the message that the \"Guess::new\" function panics with. We could have specified the entire panic message that we expect, which in this case would be \"Guess value must be less than or equal to 100, got 200.\" What you choose to specify depends on how much of the panic message is unique or dynamic and how precise you want your test to be. In this case, a substring of the panic message is enough to ensure that the code in the test function executes the \"else if value &gt; 100\" case.\nTo see what happens when a \"should_panic\" test with an \"expected\" message fails, let’s again introduce a bug into our code by swapping the bodies of the \"if value &lt; 1\" and the \"else if value &gt; 100\" blocks:\n        if value &lt; 1 {\n            panic!(\n                \"Guess value must be less than or equal to 100, got {}.\",\n                value\n            );\n        } else if value &gt; 100 {\n            panic!(\n                \"Guess value must be greater than or equal to 1, got {}.\",\n                value\n            );\n        }\n\nThis time when we run the \"should_panic\" test, it will fail:\n$ cargo test\n   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n    Finished test [unoptimized + debuginfo] target(s) in 0.66s\n     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)\n\nrunning 1 test\ntest tests::greater_than_100 - should panic ... FAILED\n\nfailures:\n\n---- tests::greater_than_100 stdout ----\nthread \"tests::greater_than_100\" panicked at \"Guess value must be greater than or equal to 1, got 200.\", src/lib.rs:13:13\nnote: run with \"RUST_BACKTRACE=1\" environment variable to display a backtrace\nnote: panic did not contain expected string\n      panic message: \"\"Guess value must be greater than or equal to 1, got 200.\"\",\n expected substring: \"\"less than or equal to 100\"\"\n\nfailures:\n    tests::greater_than_100\n\ntest result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass \"--lib\"\n\nThe failure message indicates that this test did indeed panic as we expected, but the panic message did not include the expected string \"\"Guess value must be less than or equal to 100\"\". The panic message that we did get in this case was \"Guess value must be greater than or equal to 1, got 200.\" Now we can start figuring out where our bug is!\nUsing \"Result\" in Tests\nOur tests so far all panic when they fail. We can also write tests that use \"Result&lt;T, E&gt;\"! Here’s the test from Listing 11-1, rewritten to use \"Result&lt;T, E&gt;\" and return an \"Err\" instead of panicking:\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn it_works() -&gt; Result&lt;(), String&gt; {\n        if 2 + 2 == 4 {\n            Ok(())\n        } else {\n            Err(String::from(\"two plus two does not equal four\"))\n        }\n    }\n}\n\nThe \"it_works\" function now has the \"Result&lt;(), String&gt;\" return type. In the body of the function, rather than calling the \"assert_eq!\" macro, we return \"Ok(())\" when the test passes and an \"Err\" with a \"String\" inside when the test fails.\nWriting tests so they return a \"Result&lt;T, E&gt;\" enables you to use the question mark operator in the body of tests, which can be a convenient way to write tests that should fail if any operation within them returns an \"Err\" variant.\nYou can’t use the \"#[should_panic]\" annotation on tests that use \"Result&lt;T, E&gt;\". To assert that an operation returns an \"Err\" variant, don’t use the question mark operator on the \"Result&lt;T, E&gt;\" value. Instead, use \"assert!(value.is_err())\".\nNow that you know several ways to write tests, let’s look at what is happening when we run our tests and explore the different options we can use with \"cargo test\".\n\nControlling How Tests Are Run\nJust as \"cargo run\" compiles your code and then runs the resulting binary, \"cargo test\" compiles your code in test mode and runs the resulting test binary. The default behavior of the binary produced by \"cargo test\" is to run all the tests in parallel and capture output generated during test runs, preventing the output from being displayed and making it easier to read the output related to the test results. You can, however, specify command line options to change this default behavior.\nSome command line options go to \"cargo test\", and some go to the resulting test binary. To separate these two types of arguments, you list the arguments that go to \"cargo test\" followed by the separator \"--\" and then the ones that go to the test binary. Running \"cargo test --help\" displays the options you can use with \"cargo test\", and running \"cargo test -- --help\" displays the options you can use after the separator.\nRunning Tests in Parallel or Consecutively\nWhen you run multiple tests, by default they run in parallel using threads, meaning they finish running faster and you get feedback quicker. Because the tests are running at the same time, you must make sure your tests don’t depend on each other or on any shared state, including a shared environment, such as the current working directory or environment variables.\nFor example, say each of your tests runs some code that creates a file on disk named test-output.txt and writes some data to that file. Then each test reads the data in that file and asserts that the file contains a particular value, which is different in each test. Because the tests run at the same time, one test might overwrite the file in the time between another test writing and reading the file. The second test will then fail, not because the code is incorrect but because the tests have interfered with each other while running in parallel. One solution is to make sure each test writes to a different file; another solution is to run the tests one at a time.\nIf you don’t want to run the tests in parallel or if you want more fine-grained control over the number of threads used, you can send the \"--test-threads\" flag and the number of threads you want to use to the test binary. Take a look at the following example:\n$ cargo test -- --test-threads=1\n\nWe set the number of test threads to \"1\", telling the program not to use any parallelism. Running the tests using one thread will take longer than running them in parallel, but the tests won’t interfere with each other if they share state.\nShowing Function Output\nBy default, if a test passes, Rust’s test library captures anything printed to standard output. For example, if we call \"println!\" in a test and the test passes, we won’t see the \"println!\" output in the terminal; we’ll see only the line that indicates the test passed. If a test fails, we’ll see whatever was printed to standard output with the rest of the failure message.\nAs an example, Listing 11-10 has a silly function that prints the value of its parameter and returns 10, as well as a test that passes and a test that fails.\nFilename: src/lib.rs\nfn prints_and_returns_10(a: i32) -&gt; i32 {\n    println!(\"I got the value {}\", a);\n    10\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn this_test_will_pass() {\n        let value = prints_and_returns_10(4);\n        assert_eq!(10, value);\n    }\n\n    #[test]\n    fn this_test_will_fail() {\n        let value = prints_and_returns_10(8);\n        assert_eq!(5, value);\n    }\n}\n\nListing 11-10: Tests for a function that calls \"println!\"\nWhen we run these tests with \"cargo test\", we’ll see the following output:\n$ cargo test\n   Compiling silly-function v0.1.0 (file:///projects/silly-function)\n    Finished test [unoptimized + debuginfo] target(s) in 0.58s\n     Running unittests src/lib.rs (target/debug/deps/silly_function-160869f38cff9166)\n\nrunning 2 tests\ntest tests::this_test_will_fail ... FAILED\ntest tests::this_test_will_pass ... ok\n\nfailures:\n\n---- tests::this_test_will_fail stdout ----\nI got the value 8\nthread \"tests::this_test_will_fail\" panicked at \"assertion failed: \"(left == right)\"\n  left: \"5\",\n right: \"10\"\", src/lib.rs:19:9\nnote: run with \"RUST_BACKTRACE=1\" environment variable to display a backtrace\n\n\nfailures:\n    tests::this_test_will_fail\n\ntest result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass \"--lib\"\n\nNote that nowhere in this output do we see \"I got the value 4\", which is what is printed when the test that passes runs. That output has been captured. The output from the test that failed, \"I got the value 8\", appears in the section of the test summary output, which also shows the cause of the test failure.\nIf we want to see printed values for passing tests as well, we can tell Rust to also show the output of successful tests with \"--show-output\".\n$ cargo test -- --show-output\n\nWhen we run the tests in Listing 11-10 again with the \"--show-output\" flag, we see the following output:\n$ cargo test -- --show-output\n   Compiling silly-function v0.1.0 (file:///projects/silly-function)\n    Finished test [unoptimized + debuginfo] target(s) in 0.60s\n     Running unittests src/lib.rs (target/debug/deps/silly_function-160869f38cff9166)\n\nrunning 2 tests\ntest tests::this_test_will_fail ... FAILED\ntest tests::this_test_will_pass ... ok\n\nsuccesses:\n\n---- tests::this_test_will_pass stdout ----\nI got the value 4\n\n\nsuccesses:\n    tests::this_test_will_pass\n\nfailures:\n\n---- tests::this_test_will_fail stdout ----\nI got the value 8\nthread \"tests::this_test_will_fail\" panicked at \"assertion failed: \"(left == right)\"\n  left: \"5\",\n right: \"10\"\", src/lib.rs:19:9\nnote: run with \"RUST_BACKTRACE=1\" environment variable to display a backtrace\n\n\nfailures:\n    tests::this_test_will_fail\n\ntest result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass \"--lib\"\n\nRunning a Subset of Tests by Name\nSometimes, running a full test suite can take a long time. If you’re working on code in a particular area, you might want to run only the tests pertaining to that code. You can choose which tests to run by passing \"cargo test\" the name or names of the test(s) you want to run as an argument.\nTo demonstrate how to run a subset of tests, we’ll first create three tests for our \"add_two\" function, as shown in Listing 11-11, and choose which ones to run.\nFilename: src/lib.rs\npub fn add_two(a: i32) -&gt; i32 {\n    a + 2\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn add_two_and_two() {\n        assert_eq!(4, add_two(2));\n    }\n\n    #[test]\n    fn add_three_and_two() {\n        assert_eq!(5, add_two(3));\n    }\n\n    #[test]\n    fn one_hundred() {\n        assert_eq!(102, add_two(100));\n    }\n}\n\nListing 11-11: Three tests with three different names\nIf we run the tests without passing any arguments, as we saw earlier, all the tests will run in parallel:\n$ cargo test\n   Compiling adder v0.1.0 (file:///projects/adder)\n    Finished test [unoptimized + debuginfo] target(s) in 0.62s\n     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)\n\nrunning 3 tests\ntest tests::add_three_and_two ... ok\ntest tests::add_two_and_two ... ok\ntest tests::one_hundred ... ok\n\ntest result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests adder\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nRunning Single Tests\nWe can pass the name of any test function to \"cargo test\" to run only that test:\n$ cargo test one_hundred\n   Compiling adder v0.1.0 (file:///projects/adder)\n    Finished test [unoptimized + debuginfo] target(s) in 0.69s\n     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)\n\nrunning 1 test\ntest tests::one_hundred ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out; finished in 0.00s\n\nOnly the test with the name \"one_hundred\" ran; the other two tests didn’t match that name. The test output lets us know we had more tests that didn’t run by displaying \"2 filtered out\" at the end.\nWe can’t specify the names of multiple tests in this way; only the first value given to \"cargo test\" will be used. But there is a way to run multiple tests.\nFiltering to Run Multiple Tests\nWe can specify part of a test name, and any test whose name matches that value will be run. For example, because two of our tests’ names contain \"add\", we can run those two by running \"cargo test add\":\n$ cargo test add\n   Compiling adder v0.1.0 (file:///projects/adder)\n    Finished test [unoptimized + debuginfo] target(s) in 0.61s\n     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)\n\nrunning 2 tests\ntest tests::add_three_and_two ... ok\ntest tests::add_two_and_two ... ok\n\ntest result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s\n\nThis command ran all tests with \"add\" in the name and filtered out the test named \"one_hundred\". Also note that the module in which a test appears becomes part of the test’s name, so we can run all the tests in a module by filtering on the module’s name.\nIgnoring Some Tests Unless Specifically Requested\nSometimes a few specific tests can be very time-consuming to execute, so you might want to exclude them during most runs of \"cargo test\". Rather than listing as arguments all tests you do want to run, you can instead annotate the time-consuming tests using the \"ignore\" attribute to exclude them, as shown here:\nFilename: src/lib.rs\n#[test]\nfn it_works() {\n    assert_eq!(2 + 2, 4);\n}\n\n#[test]\n#[ignore]\nfn expensive_test() {\n    // code that takes an hour to run\n}\n\nAfter \"#[test]\" we add the \"#[ignore]\" line to the test we want to exclude. Now when we run our tests, \"it_works\" runs, but \"expensive_test\" doesn’t:\n$ cargo test\n   Compiling adder v0.1.0 (file:///projects/adder)\n    Finished test [unoptimized + debuginfo] target(s) in 0.60s\n     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)\n\nrunning 2 tests\ntest expensive_test ... ignored\ntest it_works ... ok\n\ntest result: ok. 1 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests adder\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nThe \"expensive_test\" function is listed as \"ignored\". If we want to run only the ignored tests, we can use \"cargo test -- --ignored\":\n$ cargo test -- --ignored\n   Compiling adder v0.1.0 (file:///projects/adder)\n    Finished test [unoptimized + debuginfo] target(s) in 0.61s\n     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)\n\nrunning 1 test\ntest expensive_test ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s\n\n   Doc-tests adder\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nBy controlling which tests run, you can make sure your \"cargo test\" results will be fast. When you’re at a point where it makes sense to check the results of the \"ignored\" tests and you have time to wait for the results, you can run \"cargo test -- --ignored\" instead. If you want to run all tests whether they’re ignored or not, you can run \"cargo test -- --include-ignored\".\n\nTest Organization\nAs mentioned at the start of the chapter, testing is a complex discipline, and different people use different terminology and organization. The Rust community thinks about tests in terms of two main categories: unit tests and integration tests. Unit tests are small and more focused, testing one module in isolation at a time, and can test private interfaces. Integration tests are entirely external to your library and use your code in the same way any other external code would, using only the public interface and potentially exercising multiple modules per test.\nWriting both kinds of tests is important to ensure that the pieces of your library are doing what you expect them to, separately and together.\nUnit Tests\nThe purpose of unit tests is to test each unit of code in isolation from the rest of the code to quickly pinpoint where code is and isn’t working as expected. You’ll put unit tests in the src directory in each file with the code that they’re testing. The convention is to create a module named \"tests\" in each file to contain the test functions and to annotate the module with \"cfg(test)\".\n[The Tests Module and \"#cfg(test)]\"\nThe \"#[cfg(test)]\" annotation on the tests module tells Rust to compile and run the test code only when you run \"cargo test\", not when you run \"cargo build\". This saves compile time when you only want to build the library and saves space in the resulting compiled artifact because the tests are not included. You’ll see that because integration tests go in a different directory, they don’t need the \"#[cfg(test)]\" annotation. However, because unit tests go in the same files as the code, you’ll use \"#[cfg(test)]\" to specify that they shouldn’t be included in the compiled result.\nRecall that when we generated the new \"adder\" project in the first section of this chapter, Cargo generated this code for us:\nFilename: src/lib.rs\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn it_works() {\n        let result = 2 + 2;\n        assert_eq!(result, 4);\n    }\n}\n\nThis code is the automatically generated test module. The attribute \"cfg\" stands for configuration and tells Rust that the following item should only be included given a certain configuration option. In this case, the configuration option is \"test\", which is provided by Rust for compiling and running tests. By using the \"cfg\" attribute, Cargo compiles our test code only if we actively run the tests with \"cargo test\". This includes any helper functions that might be within this module, in addition to the functions annotated with \"#[test]\".\nTesting Private Functions\nThere’s debate within the testing community about whether or not private functions should be tested directly, and other languages make it difficult or impossible to test private functions. Regardless of which testing ideology you adhere to, Rust’s privacy rules do allow you to test private functions. Consider the code in Listing 11-12 with the private function \"internal_adder\".\nFilename: src/lib.rs\npub fn add_two(a: i32) -&gt; i32 {\n    internal_adder(a, 2)\n}\n\nfn internal_adder(a: i32, b: i32) -&gt; i32 {\n    a + b\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn internal() {\n        assert_eq!(4, internal_adder(2, 2));\n    }\n}\n\nListing 11-12: Testing a private function\nNote that the \"internal_adder\" function is not marked as \"pub\". Tests are just Rust code, and the \"tests\" module is just another module. As we discussed in the “Paths for Referring to an Item in the Module Tree” section, items in child modules can use the items in their ancestor modules. In this test, we bring all of the \"test\" module’s parent’s items into scope with \"use super::*\", and then the test can call \"internal_adder\". If you don’t think private functions should be tested, there’s nothing in Rust that will compel you to do so.\nIntegration Tests\nIn Rust, integration tests are entirely external to your library. They use your library in the same way any other code would, which means they can only call functions that are part of your library’s public API. Their purpose is to test whether many parts of your library work together correctly. Units of code that work correctly on their own could have problems when integrated, so test coverage of the integrated code is important as well. To create integration tests, you first need a tests directory.\nThe tests Directory\nWe create a tests directory at the top level of our project directory, next to src. Cargo knows to look for integration test files in this directory. We can then make as many test files as we want, and Cargo will compile each of the files as an individual crate.\nLet’s create an integration test. With the code in Listing 11-12 still in the src/lib.rs file, make a tests directory, and create a new file named tests/integration_test.rs. Your directory structure should look like this:\nadder\n├── Cargo.lock\n├── Cargo.toml\n├── src\n│   └── lib.rs\n└── tests\n    └── integration_test.rs\n\nEnter the code in Listing 11-13 into the tests/integration_test.rs file:\nFilename: tests/integration_test.rs\nuse adder;\n\n#[test]\nfn it_adds_two() {\n    assert_eq!(4, adder::add_two(2));\n}\n\nListing 11-13: An integration test of a function in the \"adder\" crate\nEach file in the \"tests\" directory is a separate crate, so we need to bring our library into each test crate’s scope. For that reason we add \"use adder\" at the top of the code, which we didn’t need in the unit tests.\nWe don’t need to annotate any code in tests/integration_test.rs with \"#[cfg(test)]\". Cargo treats the \"tests\" directory specially and compiles files in this directory only when we run \"cargo test\". Run \"cargo test\" now:\n$ cargo test\n   Compiling adder v0.1.0 (file:///projects/adder)\n    Finished test [unoptimized + debuginfo] target(s) in 1.31s\n     Running unittests src/lib.rs (target/debug/deps/adder-1082c4b063a8fbe6)\n\nrunning 1 test\ntest tests::internal ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n     Running tests/integration_test.rs (target/debug/deps/integration_test-1082c4b063a8fbe6)\n\nrunning 1 test\ntest it_adds_two ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests adder\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nThe three sections of output include the unit tests, the integration test, and the doc tests. Note that if any test in a section fails, the following sections will not be run. For example, if a unit test fails, there won’t be any output for integration and doc tests because those tests will only be run if all unit tests are passing.\nThe first section for the unit tests is the same as we’ve been seeing: one line for each unit test (one named \"internal\" that we added in Listing 11-12) and then a summary line for the unit tests.\nThe integration tests section starts with the line \"Running tests/integration_test.rs\". Next, there is a line for each test function in that integration test and a summary line for the results of the integration test just before the \"Doc-tests adder\" section starts.\nEach integration test file has its own section, so if we add more files in the tests directory, there will be more integration test sections.\nWe can still run a particular integration test function by specifying the test function’s name as an argument to \"cargo test\". To run all the tests in a particular integration test file, use the \"--test\" argument of \"cargo test\" followed by the name of the file:\n$ cargo test --test integration_test\n   Compiling adder v0.1.0 (file:///projects/adder)\n    Finished test [unoptimized + debuginfo] target(s) in 0.64s\n     Running tests/integration_test.rs (target/debug/deps/integration_test-82e7799c1bc62298)\n\nrunning 1 test\ntest it_adds_two ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nThis command runs only the tests in the tests/integration_test.rs file.\nSubmodules in Integration Tests\nAs you add more integration tests, you might want to make more files in the tests directory to help organize them; for example, you can group the test functions by the functionality they’re testing. As mentioned earlier, each file in the tests directory is compiled as its own separate crate, which is useful for creating separate scopes to more closely imitate the way end users will be using your crate. However, this means files in the tests directory don’t share the same behavior as files in src do, as you learned in Chapter 7 regarding how to separate code into modules and files.\nThe different behavior of tests directory files is most noticeable when you have a set of helper functions to use in multiple integration test files and you try to follow the steps in the “Separating Modules into Different Files” section of Chapter 7 to extract them into a common module. For example, if we create tests/common.rs and place a function named \"setup\" in it, we can add some code to \"setup\" that we want to call from multiple test functions in multiple test files:\nFilename: tests/common.rs\npub fn setup() {\n    // setup code specific to your library\"s tests would go here\n}\n\nWhen we run the tests again, we’ll see a new section in the test output for the common.rs file, even though this file doesn’t contain any test functions nor did we call the \"setup\" function from anywhere:\n$ cargo test\n   Compiling adder v0.1.0 (file:///projects/adder)\n    Finished test [unoptimized + debuginfo] target(s) in 0.89s\n     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)\n\nrunning 1 test\ntest tests::internal ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n     Running tests/common.rs (target/debug/deps/common-92948b65e88960b4)\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n     Running tests/integration_test.rs (target/debug/deps/integration_test-92948b65e88960b4)\n\nrunning 1 test\ntest it_adds_two ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests adder\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nHaving \"common\" appear in the test results with \"running 0 tests\" displayed for it is not what we wanted. We just wanted to share some code with the other integration test files.\nTo avoid having \"common\" appear in the test output, instead of creating tests/common.rs, we’ll create tests/common/mod.rs. The project directory now looks like this:\n├── Cargo.lock\n├── Cargo.toml\n├── src\n│   └── lib.rs\n└── tests\n    ├── common\n    │   └── mod.rs\n    └── integration_test.rs\n\nThis is the older naming convention that Rust also understands that we mentioned in the “Alternate File Paths” section of Chapter 7. Naming the file this way tells Rust not to treat the \"common\" module as an integration test file. When we move the \"setup\" function code into tests/common/mod.rs and delete the tests/common.rs file, the section in the test output will no longer appear. Files in subdirectories of the tests directory don’t get compiled as separate crates or have sections in the test output.\nAfter we’ve created tests/common/mod.rs, we can use it from any of the integration test files as a module. Here’s an example of calling the \"setup\" function from the \"it_adds_two\" test in tests/integration_test.rs:\nFilename: tests/integration_test.rs\nuse adder;\n\nmod common;\n\n#[test]\nfn it_adds_two() {\n    common::setup();\n    assert_eq!(4, adder::add_two(2));\n}\n\nNote that the \"mod common;\" declaration is the same as the module declaration we demonstrated in Listing 7-21. Then in the test function, we can call the \"common::setup()\" function.\nIntegration Tests for Binary Crates\nIf our project is a binary crate that only contains a src/main.rs file and doesn’t have a src/lib.rs file, we can’t create integration tests in the tests directory and bring functions defined in the src/main.rs file into scope with a \"use\" statement. Only library crates expose functions that other crates can use; binary crates are meant to be run on their own.\nThis is one of the reasons Rust projects that provide a binary have a straightforward src/main.rs file that calls logic that lives in the src/lib.rs file. Using that structure, integration tests can test the library crate with \"use\" to make the important functionality available. If the important functionality works, the small amount of code in the src/main.rs file will work as well, and that small amount of code doesn’t need to be tested.\nSummary\nRust’s testing features provide a way to specify how code should function to ensure it continues to work as you expect, even as you make changes. Unit tests exercise different parts of a library separately and can test private implementation details. Integration tests check that many parts of the library work together correctly, and they use the library’s public API to test the code in the same way external code will use it. Even though Rust’s type system and ownership rules help prevent some kinds of bugs, tests are still important to reduce logic bugs having to do with how your code is expected to behave.\nLet’s combine the knowledge you learned in this chapter and in previous chapters to work on a project!\n\n12\nAn I/O Project: Building a Command Line Program\nThis chapter is a recap of the many skills you’ve learned so far and an exploration of a few more standard library features. We’ll build a command line tool that interacts with file and command line input/output to practice some of the Rust concepts you now have under your belt.\nRust’s speed, safety, single binary output, and cross-platform support make it an ideal language for creating command line tools, so for our project, we’ll make our own version of the classic command line search tool \"grep\" (globally search a regular expression and print). In the simplest use case, \"grep\" searches a specified file for a specified string. To do so, \"grep\" takes as its arguments a file path and a string. Then it reads the file, finds lines in that file that contain the string argument, and prints those lines.\nAlong the way, we’ll show how to make our command line tool use the terminal features that many other command line tools use. We’ll read the value of an environment variable to allow the user to configure the behavior of our tool. We’ll also print error messages to the standard error bash stream (\"stderr\") instead of standard output (\"stdout\"), so, for example, the user can redirect successful output to a file while still seeing error messages onscreen.\nOne Rust community member, Andrew Gallant, has already created a fully featured, very fast version of \"grep\", called \"ripgrep\". By comparison, our version will be fairly simple, but this chapter will give you some of the background knowledge you need to understand a real-world project such as \"ripgrep\".\nOur \"grep\" project will combine a number of concepts you’ve learned so far:\n\nOrganizing code (using what you learned about modules in Chapter 7)\nUsing vectors and strings (collections, Chapter 8)\nHandling errors (Chapter 9)\nUsing traits and lifetimes where appropriate (Chapter 10)\nWriting tests (Chapter 11)\n\nWe’ll also briefly introduce closures, iterators, and trait objects, which Chapters 13 and 17 will cover in detail.\n\nAccepting Command Line Arguments\nLet’s create a new project with, as always, \"cargo new\". We’ll call our project \"minigrep\" to distinguish it from the \"grep\" tool that you might already have on your system.\n$ cargo new minigrep\n     Created binary (application) \"minigrep\" project\n$ cd minigrep\n\nThe first task is to make \"minigrep\" accept its two command line arguments: the file path and a string to search for. That is, we want to be able to run our program with \"cargo run\", two hyphens to indicate the following arguments are for our program rather than for \"cargo\", a string to search for, and a path to a file to search in, like so:\n$ cargo run -- searchstring example-filename.txt\n\nRight now, the program generated by \"cargo new\" cannot process arguments we give it. Some existing libraries on crates.io can help with writing a program that accepts command line arguments, but because you’re just learning this concept, let’s implement this capability ourselves.\nReading the Argument Values\nTo enable \"minigrep\" to read the values of command line arguments we pass to it, we’ll need the \"std::env::args\" function provided in Rust’s standard library. This function returns an iterator of the command line arguments passed to \"minigrep\". We’ll cover iterators fully in Chapter 13. For now, you only need to know two details about iterators: iterators produce a series of values, and we can call the \"collect\" method on an iterator to turn it into a collection, such as a vector, that contains all the elements the iterator produces.\nThe code in Listing 12-1 allows your \"minigrep\" program to read any command line arguments passed to it and then collect the values into a vector.\nFilename: src/main.rs\nuse std::env;\n\nfn main() {\n    let args: Vec&lt;String&gt; = env::args().collect();\n    dbg!(args);\n}\n\nListing 12-1: Collecting the command line arguments into a vector and printing them\nFirst, we bring the \"std::env\" module into scope with a \"use\" statement so we can use its \"args\" function. Notice that the \"std::env::args\" function is nested in two levels of modules. As we discussed in Chapter 7, in cases where the desired function is nested in more than one module, we’ve chosen to bring the parent module into scope rather than the function. By doing so, we can easily use other functions from \"std::env\". It’s also less ambiguous than adding \"use std::env::args\" and then calling the function with just \"args\", because \"args\" might easily be mistaken for a function that’s defined in the current module.\n\nThe \"args\" Function and Invalid Unicode\nNote that \"std::env::args\" will panic if any argument contains invalid Unicode. If your program needs to accept arguments containing invalid Unicode, use \"std::env::args_os\" instead. That function returns an iterator that produces \"OsString\" values instead of \"String\" values. We’ve chosen to use \"std::env::args\" here for simplicity, because \"OsString\" values differ per platform and are more complex to work with than \"String\" values.\n\nOn the first line of \"main\", we call \"env::args\", and we immediately use \"collect\" to turn the iterator into a vector containing all the values produced by the iterator. We can use the \"collect\" function to create many kinds of collections, so we explicitly annotate the type of \"args\" to specify that we want a vector of strings. Although we very rarely need to annotate types in Rust, \"collect\" is one function you do often need to annotate because Rust isn’t able to infer the kind of collection you want.\nFinally, we print the vector using the debug macro. Let’s try running the code first with no arguments and then with two arguments:\n$ cargo run\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.61s\n     Running \"target/debug/minigrep\"\n[src/main.rs:5] args = [\n    \"target/debug/minigrep\",\n]\n$ cargo run -- needle haystack\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished dev [unoptimized + debuginfo] target(s) in 1.57s\n     Running \"target/debug/minigrep needle haystack\"\n[src/main.rs:5] args = [\n    \"target/debug/minigrep\",\n    \"needle\",\n    \"haystack\",\n]\n\nNotice that the first value in the vector is \"\"target/debug/minigrep\"\", which is the name of our binary. This matches the behavior of the arguments list in C, letting programs use the name by which they were invoked in their execution. It’s often convenient to have access to the program name in case you want to print it in messages or change behavior of the program based on what command line alias was used to invoke the program. But for the purposes of this chapter, we’ll ignore it and save only the two arguments we need.\nSaving the Argument Values in Variables\nThe program is currently able to access the values specified as command line arguments. Now we need to save the values of the two arguments in variables so we can use the values throughout the rest of the program. We do that in Listing 12-2.\nFilename: src/main.rs\nuse std::env;\n\nfn main() {\n    let args: Vec&lt;String&gt; = env::args().collect();\n\n    let query = &amp;args[1];\n    let file_path = &amp;args[2];\n\n    println!(\"Searching for {}\", query);\n    println!(\"In file {}\", file_path);\n}\n\nListing 12-2: Creating variables to hold the query argument and file path argument\nAs we saw when we printed the vector, the program’s name takes up the first value in the vector at \"args[0]\", so we’re starting arguments at index \"1\". The first argument \"minigrep\" takes is the string we’re searching for, so we put a reference to the first argument in the variable \"query\". The second argument will be the file path, so we put a reference to the second argument in the variable \"file_path\".\nWe temporarily print the values of these variables to prove that the code is working as we intend. Let’s run this program again with the arguments \"test\" and \"sample.txt\":\n$ cargo run -- test sample.txt\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.0s\n     Running \"target/debug/minigrep test sample.txt\"\nSearching for test\nIn file sample.txt\n\nGreat, the program is working! The values of the arguments we need are being saved into the right variables. Later we’ll add some error handling to deal with certain potential erroneous situations, such as when the user provides no arguments; for now, we’ll ignore that situation and work on adding file-reading capabilities instead.\n\nReading a File\nNow we’ll add functionality to read the file specified in the \"file_path\" argument. First, we need a sample file to test it with: we’ll use a file with a small amount of text over multiple lines with some repeated words. Listing 12-3 has an Emily Dickinson poem that will work well! Create a file called poem.txt at the root level of your project, and enter the poem “I’m Nobody! Who are you?”\nFilename: poem.txt\nI\"m nobody! Who are you?\nAre you nobody, too?\nThen there\"s a pair of us - don\"t tell!\nThey\"d banish us, you know.\n\nHow dreary to be somebody!\nHow public, like a frog\nTo tell your name the livelong day\nTo an admiring bog!\n\nListing 12-3: A poem by Emily Dickinson makes a good test case\nWith the text in place, edit src/main.rs and add code to read the file, as shown in Listing 12-4.\nFilename: src/main.rs\nuse std::env;\nuse std::fs;\n\nfn main() {\n    // --snip--\n    println!(\"In file {}\", file_path);\n\n    let contents = fs::read_to_string(file_path)\n        .expect(\"Should have been able to read the file\");\n\n    println!(\"With text:\\n{contents}\");\n}\n\nListing 12-4: Reading the contents of the file specified by the second argument\nFirst, we bring in a relevant part of the standard library with a \"use\" statement: we need \"std::fs\" to handle files.\nIn \"main\", the new statement \"fs::read_to_string\" takes the \"file_path\", opens that file, and returns a \"std::io::Result\" of the file’s contents.\nAfter that, we again add a temporary \"println!\" statement that prints the value of \"contents\" after the file is read, so we can check that the program is working so far.\nLet’s run this code with any string as the first command line argument (because we haven’t implemented the searching part yet) and the poem.txt file as the second argument:\n$ cargo run -- the poem.txt\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.0s\n     Running \"target/debug/minigrep the poem.txt\"\nSearching for the\nIn file poem.txt\nWith text:\nI\"m nobody! Who are you?\nAre you nobody, too?\nThen there\"s a pair of us - don\"t tell!\nThey\"d banish us, you know.\n\nHow dreary to be somebody!\nHow public, like a frog\nTo tell your name the livelong day\nTo an admiring bog!\n\nGreat! The code read and then printed the contents of the file. But the code has a few flaws. At the moment, the \"main\" function has multiple responsibilities: generally, functions are clearer and easier to maintain if each function is responsible for only one idea. The other problem is that we’re not handling errors as well as we could. The program is still small, so these flaws aren’t a big problem, but as the program grows, it will be harder to fix them cleanly. It’s good practice to begin refactoring early on when developing a program, because it’s much easier to refactor smaller amounts of code. We’ll do that next.\n\nRefactoring to Improve Modularity and Error Handling\nTo improve our program, we’ll fix four problems that have to do with the program’s structure and how it’s handling potential errors. First, our \"main\" function now performs two tasks: it parses arguments and reads files. As our program grows, the number of separate tasks the \"main\" function handles will increase. As a function gains responsibilities, it becomes more difficult to reason about, harder to test, and harder to change without breaking one of its parts. It’s best to separate functionality so each function is responsible for one task.\nThis issue also ties into the second problem: although \"query\" and \"file_path\" are configuration variables to our program, variables like \"contents\" are used to perform the program’s logic. The longer \"main\" becomes, the more variables we’ll need to bring into scope; the more variables we have in scope, the harder it will be to keep track of the purpose of each. It’s best to group the configuration variables into one structure to make their purpose clear.\nThe third problem is that we’ve used \"expect\" to print an error message when reading the file fails, but the error message just prints \"Should have been able to read the file\". Reading a file can fail in a number of ways: for example, the file could be missing, or we might not have permission to open it. Right now, regardless of the situation, we’d print the same error message for everything, which wouldn’t give the user any information!\nFourth, we use \"expect\" repeatedly to handle different errors, and if the user runs our program without specifying enough arguments, they’ll get an \"index out of bounds\" error from Rust that doesn’t clearly explain the problem. It would be best if all the error-handling code were in one place so future maintainers had only one place to consult the code if the error-handling logic needed to change. Having all the error-handling code in one place will also ensure that we’re printing messages that will be meaningful to our end users.\nLet’s address these four problems by refactoring our project.\nSeparation of Concerns for Binary Projects\nThe organizational problem of allocating responsibility for multiple tasks to the \"main\" function is common to many binary projects. As a result, the Rust community has developed guidelines for splitting the separate concerns of a binary program when \"main\" starts getting large. This process has the following steps:\n\nSplit your program into a main.rs and a lib.rs and move your program’s logic to lib.rs.\nAs long as your command line parsing logic is small, it can remain in main.rs.\nWhen the command line parsing logic starts getting complicated, extract it from main.rs and move it to lib.rs.\n\nThe responsibilities that remain in the \"main\" function after this process should be limited to the following:\n\nCalling the command line parsing logic with the argument values\nSetting up any other configuration\nCalling a \"run\" function in lib.rs\nHandling the error if \"run\" returns an error\n\nThis pattern is about separating concerns: main.rs handles running the program, and lib.rs handles all the logic of the task at hand. Because you can’t test the \"main\" function directly, this structure lets you test all of your program’s logic by moving it into functions in lib.rs. The code that remains in main.rs will be small enough to verify its correctness by reading it. Let’s rework our program by following this process.\nExtracting the Argument Parser\nWe’ll extract the functionality for parsing arguments into a function that \"main\" will call to prepare for moving the command line parsing logic to src/lib.rs. Listing 12-5 shows the new start of \"main\" that calls a new function \"parse_config\", which we’ll define in src/main.rs for the moment.\nFilename: src/main.rs\nfn main() {\n    let args: Vec&lt;String&gt; = env::args().collect();\n\n    let (query, file_path) = parse_config(&amp;args);\n\n    // --snip--\n}\n\nfn parse_config(args: &amp;[String]) -&gt; (&amp;str, &amp;str) {\n    let query = &amp;args[1];\n    let file_path = &amp;args[2];\n\n    (query, file_path)\n}\n\nListing 12-5: Extracting a \"parse_config\" function from \"main\"\nWe’re still collecting the command line arguments into a vector, but instead of assigning the argument value at index 1 to the variable \"query\" and the argument value at index 2 to the variable \"file_path\" within the \"main\" function, we pass the whole vector to the \"parse_config\" function. The \"parse_config\" function then holds the logic that determines which argument goes in which variable and passes the values back to \"main\". We still create the \"query\" and \"file_path\" variables in \"main\", but \"main\" no longer has the responsibility of determining how the command line arguments and variables correspond.\nThis rework may seem like overkill for our small program, but we’re refactoring in small, incremental steps. After making this change, run the program again to verify that the argument parsing still works. It’s good to check your progress often, to help identify the cause of problems when they occur.\nGrouping Configuration Values\nWe can take another small step to improve the \"parse_config\" function further. At the moment, we’re returning a tuple, but then we immediately break that tuple into individual parts again. This is a sign that perhaps we don’t have the right abstraction yet.\nAnother indicator that shows there’s room for improvement is the \"config\" part of \"parse_config\", which implies that the two values we return are related and are both part of one configuration value. We’re not currently conveying this meaning in the structure of the data other than by grouping the two values into a tuple; we’ll instead put the two values into one struct and give each of the struct fields a meaningful name. Doing so will make it easier for future maintainers of this code to understand how the different values relate to each other and what their purpose is.\nListing 12-6 shows the improvements to the \"parse_config\" function.\nFilename: src/main.rs\nfn main() {\n    let args: Vec&lt;String&gt; = env::args().collect();\n\n    let config = parse_config(&amp;args);\n\n    println!(\"Searching for {}\", config.query);\n    println!(\"In file {}\", config.file_path);\n\n    let contents = fs::read_to_string(config.file_path)\n        .expect(\"Should have been able to read the file\");\n\n    // --snip--\n}\n\nstruct Config {\n    query: String,\n    file_path: String,\n}\n\nfn parse_config(args: &amp;[String]) -&gt; Config {\n    let query = args[1].clone();\n    let file_path = args[2].clone();\n\n    Config { query, file_path }\n}\n\nListing 12-6: Refactoring \"parse_config\" to return an instance of a \"Config\" struct\nWe’ve added a struct named \"Config\" defined to have fields named \"query\" and \"file_path\". The signature of \"parse_config\" now indicates that it returns a \"Config\" value. In the body of \"parse_config\", where we used to return string slices that reference \"String\" values in \"args\", we now define \"Config\" to contain owned \"String\" values. The \"args\" variable in \"main\" is the owner of the argument values and is only letting the \"parse_config\" function borrow them, which means we’d violate Rust’s borrowing rules if \"Config\" tried to take ownership of the values in \"args\".\nThere are a number of ways we could manage the \"String\" data; the easiest, though somewhat inefficient, route is to call the \"clone\" method on the values. This will make a full copy of the data for the \"Config\" instance to own, which takes more time and memory than storing a reference to the string data. However, cloning the data also makes our code very straightforward because we don’t have to manage the lifetimes of the references; in this circumstance, giving up a little performance to gain simplicity is a worthwhile trade-off.\n\nThe Trade-Offs of Using \"clone\"\nThere’s a tendency among many Rustaceans to avoid using \"clone\" to fix ownership problems because of its runtime cost. In Chapter 13, you’ll learn how to use more efficient methods in this type of situation. But for now, it’s okay to copy a few strings to continue making progress because you’ll make these copies only once and your file path and query string are very small. It’s better to have a working program that’s a bit inefficient than to try to hyperoptimize code on your first pass. As you become more experienced with Rust, it’ll be easier to start with the most efficient solution, but for now, it’s perfectly acceptable to call \"clone\".\n\nWe’ve updated \"main\" so it places the instance of \"Config\" returned by \"parse_config\" into a variable named \"config\", and we updated the code that previously used the separate \"query\" and \"file_path\" variables so it now uses the fields on the \"Config\" struct instead.\nNow our code more clearly conveys that \"query\" and \"file_path\" are related and that their purpose is to configure how the program will work. Any code that uses these values knows to find them in the \"config\" instance in the fields named for their purpose.\nCreating a Constructor for \"Config\"\nSo far, we’ve extracted the logic responsible for parsing the command line arguments from \"main\" and placed it in the \"parse_config\" function. Doing so helped us to see that the \"query\" and \"file_path\" values were related and that relationship should be conveyed in our code. We then added a \"Config\" struct to name the related purpose of \"query\" and \"file_path\" and to be able to return the values’ names as struct field names from the \"parse_config\" function.\nSo now that the purpose of the \"parse_config\" function is to create a \"Config\" instance, we can change \"parse_config\" from a plain function to a function named \"new\" that is associated with the \"Config\" struct. Making this change will make the code more idiomatic. We can create instances of types in the standard library, such as \"String\", by calling \"String::new\". Similarly, by changing \"parse_config\" into a \"new\" function associated with \"Config\", we’ll be able to create instances of \"Config\" by calling \"Config::new\". Listing 12-7 shows the changes we need to make.\nFilename: src/main.rs\nfn main() {\n    let args: Vec&lt;String&gt; = env::args().collect();\n\n    let config = Config::new(&amp;args);\n\n    // --snip--\n}\n\n// --snip--\n\nimpl Config {\n    fn new(args: &amp;[String]) -&gt; Config {\n        let query = args[1].clone();\n        let file_path = args[2].clone();\n\n        Config { query, file_path }\n    }\n}\n\nListing 12-7: Changing \"parse_config\" into \"Config::new\"\nWe’ve updated \"main\" where we were calling \"parse_config\" to instead call \"Config::new\". We’ve changed the name of \"parse_config\" to \"new\" and moved it within an \"impl\" block, which associates the \"new\" function with \"Config\". Try compiling this code again to make sure it works.\nFixing the Error Handling\nNow we’ll work on fixing our error handling. Recall that attempting to access the values in the \"args\" vector at index 1 or index 2 will cause the program to panic if the vector contains fewer than three items. Try running the program without any arguments; it will look like this:\n$ cargo run\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.0s\n     Running \"target/debug/minigrep\"\nthread \"main\" panicked at \"index out of bounds: the len is 1 but the index is 1\", src/main.rs:27:21\nnote: run with \"RUST_BACKTRACE=1\" environment variable to display a backtrace\n\nThe line \"index out of bounds: the len is 1 but the index is 1\" is an error message intended for programmers. It won’t help our end users understand what they should do instead. Let’s fix that now.\nImproving the Error Message\nIn Listing 12-8, we add a check in the \"new\" function that will verify that the slice is long enough before accessing index 1 and 2. If the slice isn’t long enough, the program panics and displays a better error message.\nFilename: src/main.rs\n    // --snip--\n    fn new(args: &amp;[String]) -&gt; Config {\n        if args.len() &lt; 3 {\n            panic!(\"not enough arguments\");\n        }\n        // --snip--\n\nListing 12-8: Adding a check for the number of arguments\nThis code is similar to the \"Guess::new\" function we wrote in Listing 9-13, where we called \"panic!\" when the \"value\" argument was out of the range of valid values. Instead of checking for a range of values here, we’re checking that the length of \"args\" is at least 3 and the rest of the function can operate under the assumption that this condition has been met. If \"args\" has fewer than three items, this condition will be true, and we call the \"panic!\" macro to end the program immediately.\nWith these extra few lines of code in \"new\", let’s run the program without any arguments again to see what the error looks like now:\n$ cargo run\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.0s\n     Running \"target/debug/minigrep\"\nthread \"main\" panicked at \"not enough arguments\", src/main.rs:26:13\nnote: run with \"RUST_BACKTRACE=1\" environment variable to display a backtrace\n\nThis output is better: we now have a reasonable error message. However, we also have extraneous information we don’t want to give to our users. Perhaps using the technique we used in Listing 9-13 isn’t the best to use here: a call to \"panic!\" is more appropriate for a programming problem than a usage problem, as discussed in Chapter 9. Instead, we’ll use the other technique you learned about in Chapter 9—returning a \"Result\" that indicates either success or an error.\nReturning a \"Result\" Instead of Calling \"panic!\"\nWe can instead return a \"Result\" value that will contain a \"Config\" instance in the successful case and will describe the problem in the error case. We’re also going to change the function name from \"new\" to \"build\" because many programmers expect \"new\" functions to never fail. When \"Config::build\" is communicating to \"main\", we can use the \"Result\" type to signal there was a problem. Then we can change \"main\" to convert an \"Err\" variant into a more practical error for our users without the surrounding text about \"thread \"main\"\" and \"RUST_BACKTRACE\" that a call to \"panic!\" causes.\nListing 12-9 shows the changes we need to make to the return value of the function we’re now calling \"Config::build\" and the body of the function needed to return a \"Result\". Note that this won’t compile until we update \"main\" as well, which we’ll do in the next listing.\nFilename: src/main.rs\nimpl Config {\n    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;\"static str&gt; {\n        if args.len() &lt; 3 {\n            return Err(\"not enough arguments\");\n        }\n\n        let query = args[1].clone();\n        let file_path = args[2].clone();\n\n        Ok(Config { query, file_path })\n    }\n}\n\nListing 12-9: Returning a \"Result\" from \"Config::build\"\nOur \"build\" function returns a \"Result\" with a \"Config\" instance in the success case and a \"&amp;\"static str\" in the error case. Our error values will always be string literals that have the \"\"static\" lifetime.\nWe’ve made two changes in the body of the function: instead of calling \"panic!\" when the user doesn’t pass enough arguments, we now return an \"Err\" value, and we’ve wrapped the \"Config\" return value in an \"Ok\". These changes make the function conform to its new type signature.\nReturning an \"Err\" value from \"Config::build\" allows the \"main\" function to handle the \"Result\" value returned from the \"build\" function and exit the process more cleanly in the error case.\nCalling \"Config::build\" and Handling Errors\nTo handle the error case and print a user-friendly message, we need to update \"main\" to handle the \"Result\" being returned by \"Config::build\", as shown in Listing 12-10. We’ll also take the responsibility of exiting the command line tool with a nonzero error code away from \"panic!\" and instead implement it by hand. A nonzero exit status is a convention to signal to the process that called our program that the program exited with an error state.\nFilename: src/main.rs\nuse std::process;\n\nfn main() {\n    let args: Vec&lt;String&gt; = env::args().collect();\n\n    let config = Config::build(&amp;args).unwrap_or_else(|err| {\n        println!(\"Problem parsing arguments: {err}\");\n        process::exit(1);\n    });\n\n    // --snip--\n\nListing 12-10: Exiting with an error code if building a \"Config\" fails\nIn this listing, we’ve used a method we haven’t covered in detail yet: \"unwrap_or_else\", which is defined on \"Result&lt;T, E&gt;\" by the standard library. Using \"unwrap_or_else\" allows us to define some custom, non-\"panic!\" error handling. If the \"Result\" is an \"Ok\" value, this method’s behavior is similar to \"unwrap\": it returns the inner value \"Ok\" is wrapping. However, if the value is an \"Err\" value, this method calls the code in the closure, which is an anonymous function we define and pass as an argument to \"unwrap_or_else\". We’ll cover closures in more detail in Chapter 13. For now, you just need to know that \"unwrap_or_else\" will pass the inner value of the \"Err\", which in this case is the static string \"\"not enough arguments\"\" that we added in Listing 12-9, to our closure in the argument \"err\" that appears between the vertical pipes. The code in the closure can then use the \"err\" value when it runs.\nWe’ve added a new \"use\" line to bring \"process\" from the standard library into scope. The code in the closure that will be run in the error case is only two lines: we print the \"err\" value and then call \"process::exit\". The \"process::exit\" function will stop the program immediately and return the number that was passed as the exit status code. This is similar to the \"panic!\"-based handling we used in Listing 12-8, but we no longer get all the extra output. Let’s try it:\n$ cargo run\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.48s\n     Running \"target/debug/minigrep\"\nProblem parsing arguments: not enough arguments\n\nGreat! This output is much friendlier for our users.\nExtracting Logic from \"main\"\nNow that we’ve finished refactoring the configuration parsing, let’s turn to the program’s logic. As we stated in “Separation of Concerns for Binary Projects”, we’ll extract a function named \"run\" that will hold all the logic currently in the \"main\" function that isn’t involved with setting up configuration or handling errors. When we’re done, \"main\" will be concise and easy to verify by inspection, and we’ll be able to write tests for all the other logic.\nListing 12-11 shows the extracted \"run\" function. For now, we’re just making the small, incremental improvement of extracting the function. We’re still defining the function in src/main.rs.\nFilename: src/main.rs\nfn main() {\n    // --snip--\n\n    println!(\"Searching for {}\", config.query);\n    println!(\"In file {}\", config.file_path);\n\n    run(config);\n}\n\nfn run(config: Config) {\n    let contents = fs::read_to_string(config.file_path)\n        .expect(\"Should have been able to read the file\");\n\n    println!(\"With text:\\n{contents}\");\n}\n\n// --snip--\n\nListing 12-11: Extracting a \"run\" function containing the rest of the program logic\nThe \"run\" function now contains all the remaining logic from \"main\", starting from reading the file. The \"run\" function takes the \"Config\" instance as an argument.\nReturning Errors from the \"run\" Function\nWith the remaining program logic separated into the \"run\" function, we can improve the error handling, as we did with \"Config::build\" in Listing 12-9. Instead of allowing the program to panic by calling \"expect\", the \"run\" function will return a \"Result&lt;T, E&gt;\" when something goes wrong. This will let us further consolidate the logic around handling errors into \"main\" in a user-friendly way. Listing 12-12 shows the changes we need to make to the signature and body of \"run\".\nFilename: src/main.rs\nuse std::error::Error;\n\n// --snip--\n\nfn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {\n    let contents = fs::read_to_string(config.file_path)?;\n\n    println!(\"With text:\\n{contents}\");\n\n    Ok(())\n}\n\nListing 12-12: Changing the \"run\" function to return \"Result\"\nWe’ve made three significant changes here. First, we changed the return type of the \"run\" function to \"Result&lt;(), Box&gt;\". This function previously returned the unit type, \"()\", and we keep that as the value returned in the \"Ok\" case.\nFor the error type, we used the trait object \"Box\" (and we’ve brought \"std::error::Error\" into scope with a \"use\" statement at the top). We’ll cover trait objects in Chapter 17. For now, just know that \"Box\" means the function will return a type that implements the \"Error\" trait, but we don’t have to specify what particular type the return value will be. This gives us flexibility to return error values that may be of different types in different error cases. The \"dyn\" keyword is short for “dynamic.”\nSecond, we’ve removed the call to \"expect\" in favor of the \"?\" operator, as we talked about in Chapter 9. Rather than \"panic!\" on an error, \"?\" will return the error value from the current function for the caller to handle.\nThird, the \"run\" function now returns an \"Ok\" value in the success case. We’ve declared the \"run\" function’s success type as \"()\" in the signature, which means we need to wrap the unit type value in the \"Ok\" value. This \"Ok(())\" syntax might look a bit strange at first, but using \"()\" like this is the idiomatic way to indicate that we’re calling \"run\" for its side effects only; it doesn’t return a value we need.\nWhen you run this code, it will compile but will display a warning:\n$ cargo run the poem.txt\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\nwarning: unused \"Result\" that must be used\n  --&gt; src/main.rs:19:5\n   |\n19 |     run(config);\n   |     ^^^^^^^^^^^\n   |\n   = note: this \"Result\" may be an \"Err\" variant, which should be handled\n   = note: \"#[warn(unused_must_use)]\" on by default\n\nwarning: \"minigrep\" (bin \"minigrep\") generated 1 warning\n    Finished dev [unoptimized + debuginfo] target(s) in 0.71s\n     Running \"target/debug/minigrep the poem.txt\"\nSearching for the\nIn file poem.txt\nWith text:\nI\"m nobody! Who are you?\nAre you nobody, too?\nThen there\"s a pair of us - don\"t tell!\nThey\"d banish us, you know.\n\nHow dreary to be somebody!\nHow public, like a frog\nTo tell your name the livelong day\nTo an admiring bog!\n\nRust tells us that our code ignored the \"Result\" value and the \"Result\" value might indicate that an error occurred. But we’re not checking to see whether or not there was an error, and the compiler reminds us that we probably meant to have some error-handling code here! Let’s rectify that problem now.\nHandling Errors Returned from \"run\" in \"main\"\nWe’ll check for errors and handle them using a technique similar to one we used with \"Config::build\" in Listing 12-10, but with a slight difference:\nFilename: src/main.rs\nfn main() {\n    // --snip--\n\n    println!(\"Searching for {}\", config.query);\n    println!(\"In file {}\", config.file_path);\n\n    if let Err(e) = run(config) {\n        println!(\"Application error: {e}\");\n        process::exit(1);\n    }\n}\n\nWe use \"if let\" rather than \"unwrap_or_else\" to check whether \"run\" returns an \"Err\" value and call \"process::exit(1)\" if it does. The \"run\" function doesn’t return a value that we want to \"unwrap\" in the same way that \"Config::build\" returns the \"Config\" instance. Because \"run\" returns \"()\" in the success case, we only care about detecting an error, so we don’t need \"unwrap_or_else\" to return the unwrapped value, which would only be \"()\".\nThe bodies of the \"if let\" and the \"unwrap_or_else\" functions are the same in both cases: we print the error and exit.\nSplitting Code into a Library Crate\nOur \"minigrep\" project is looking good so far! Now we’ll split the src/main.rs file and put some code into the src/lib.rs file. That way we can test the code and have a src/main.rs file with fewer responsibilities.\nLet’s move all the code that isn’t the \"main\" function from src/main.rs to src/lib.rs:\n\nThe \"run\" function definition\nThe relevant \"use\" statements\nThe definition of \"Config\"\nThe \"Config::build\" function definition\n\nThe contents of src/lib.rs should have the signatures shown in Listing 12-13 (we’ve omitted the bodies of the functions for brevity). Note that this won’t compile until we modify src/main.rs in Listing 12-14.\nFilename: src/lib.rs\nuse std::error::Error;\nuse std::fs;\n\npub struct Config {\n    pub query: String,\n    pub file_path: String,\n}\n\nimpl Config {\n    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;\"static str&gt; {\n        // --snip--\n    }\n}\n\npub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {\n    // --snip--\n}\n\nListing 12-13: Moving \"Config\" and \"run\" into src/lib.rs\nWe’ve made liberal use of the \"pub\" keyword: on \"Config\", on its fields and its \"build\" method, and on the \"run\" function. We now have a library crate that has a public API we can test!\nNow we need to bring the code we moved to src/lib.rs into the scope of the binary crate in src/main.rs, as shown in Listing 12-14.\nFilename: src/main.rs\nuse std::env;\nuse std::process;\n\nuse minigrep::Config;\n\nfn main() {\n    // --snip--\n    if let Err(e) = minigrep::run(config) {\n        // --snip--\n    }\n}\n\nListing 12-14: Using the \"minigrep\" library crate in src/main.rs\nWe add a \"use minigrep::Config\" line to bring the \"Config\" type from the library crate into the binary crate’s scope, and we prefix the \"run\" function with our crate name. Now all the functionality should be connected and should work. Run the program with \"cargo run\" and make sure everything works correctly.\nWhew! That was a lot of work, but we’ve set ourselves up for success in the future. Now it’s much easier to handle errors, and we’ve made the code more modular. Almost all of our work will be done in src/lib.rs from here on out.\nLet’s take advantage of this newfound modularity by doing something that would have been difficult with the old code but is easy with the new code: we’ll write some tests!\n\nDeveloping the Library’s Functionality with Test-Driven Development\nNow that we’ve extracted the logic into src/lib.rs and left the argument collecting and error handling in src/main.rs, it’s much easier to write tests for the core functionality of our code. We can call functions directly with various arguments and check return values without having to call our binary from the command line.\nIn this section, we’ll add the searching logic to the \"minigrep\" program using the test-driven development (TDD) process with the following steps:\n\nWrite a test that fails and run it to make sure it fails for the reason you expect.\nWrite or modify just enough code to make the new test pass.\nRefactor the code you just added or changed and make sure the tests continue to pass.\nRepeat from step 1!\n\nThough it’s just one of many ways to write software, TDD can help drive code design. Writing the test before you write the code that makes the test pass helps to maintain high test coverage throughout the process.\nWe’ll test drive the implementation of the functionality that will actually do the searching for the query string in the file contents and produce a list of lines that match the query. We’ll add this functionality in a function called \"search\".\nWriting a Failing Test\nBecause we don’t need them anymore, let’s remove the \"println!\" statements from src/lib.rs and src/main.rs that we used to check the program’s behavior. Then, in src/lib.rs, add a \"tests\" module with a test function, as we did in Chapter 11. The test function specifies the behavior we want the \"search\" function to have: it will take a query and the text to search, and it will return only the lines from the text that contain the query. Listing 12-15 shows this test, which won’t compile yet.\nFilename: src/lib.rs\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn one_result() {\n        let query = \"duct\";\n        let contents = \"\\\nRust:\nsafe, fast, productive.\nPick three.\";\n\n        assert_eq!(vec![\"safe, fast, productive.\"], search(query, contents));\n    }\n}\n\nListing 12-15: Creating a failing test for the \"search\" function we wish we had\nThis test searches for the string \"\"duct\"\". The text we’re searching is three lines, only one of which contains \"\"duct\"\" (Note that the backslash after the opening double quote tells Rust not to put a newline character at the beginning of the contents of this string literal). We assert that the value returned from the \"search\" function contains only the line we expect.\nWe aren’t yet able to run this test and watch it fail because the test doesn’t even compile: the \"search\" function doesn’t exist yet! In accordance with TDD principles, we’ll add just enough code to get the test to compile and run by adding a definition of the \"search\" function that always returns an empty vector, as shown in Listing 12-16. Then the test should compile and fail because an empty vector doesn’t match a vector containing the line \"\"safe, fast, productive.\"\"\nFilename: src/lib.rs\npub fn search&lt;\"a&gt;(query: &amp;str, contents: &amp;\"a str) -&gt; Vec&lt;&amp;\"a str&gt; {\n    vec![]\n}\n\nListing 12-16: Defining just enough of the \"search\" function so our test will compile\nNotice that we need to define an explicit lifetime \"\"a\" in the signature of \"search\" and use that lifetime with the \"contents\" argument and the return value. Recall in Chapter 10 that the lifetime parameters specify which argument lifetime is connected to the lifetime of the return value. In this case, we indicate that the returned vector should contain string slices that reference slices of the argument \"contents\" (rather than the argument \"query\").\nIn other words, we tell Rust that the data returned by the \"search\" function will live as long as the data passed into the \"search\" function in the \"contents\" argument. This is important! The data referenced by a slice needs to be valid for the reference to be valid; if the compiler assumes we’re making string slices of \"query\" rather than \"contents\", it will do its safety checking incorrectly.\nIf we forget the lifetime annotations and try to compile this function, we’ll get this error:\n$ cargo build\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\nerror[E0106]: missing lifetime specifier\n  --&gt; src/lib.rs:28:51\n   |\n28 | pub fn search(query: &amp;str, contents: &amp;str) -&gt; Vec&lt;&amp;str&gt; {\n   |                      ----            ----         ^ expected named lifetime parameter\n   |\n   = help: this function\"s return type contains a borrowed value, but the signature does not say whether it is borrowed from \"query\" or \"contents\"\nhelp: consider introducing a named lifetime parameter\n   |\n28 | pub fn search&lt;\"a&gt;(query: &amp;\"a str, contents: &amp;\"a str) -&gt; Vec&lt;&amp;\"a str&gt; {\n   |              ++++         ++                 ++              ++\n\nFor more information about this error, try \"rustc --explain E0106\".\nerror: could not compile \"minigrep\" due to previous error\n\nRust can’t possibly know which of the two arguments we need, so we need to tell it explicitly. Because \"contents\" is the argument that contains all of our text and we want to return the parts of that text that match, we know \"contents\" is the argument that should be connected to the return value using the lifetime syntax.\nOther programming languages don’t require you to connect arguments to return values in the signature, but this practice will get easier over time. You might want to compare this example with the “Validating References with Lifetimes” section in Chapter 10.\nNow let’s run the test:\n$ cargo test\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished test [unoptimized + debuginfo] target(s) in 0.97s\n     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)\n\nrunning 1 test\ntest tests::one_result ... FAILED\n\nfailures:\n\n---- tests::one_result stdout ----\nthread \"tests::one_result\" panicked at \"assertion failed: \"(left == right)\"\n  left: \"[\"safe, fast, productive.\"]\",\n right: \"[]\"\", src/lib.rs:44:9\nnote: run with \"RUST_BACKTRACE=1\" environment variable to display a backtrace\n\n\nfailures:\n    tests::one_result\n\ntest result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass \"--lib\"\n\nGreat, the test fails, exactly as we expected. Let’s get the test to pass!\nWriting Code to Pass the Test\nCurrently, our test is failing because we always return an empty vector. To fix that and implement \"search\", our program needs to follow these steps:\n\nIterate through each line of the contents.\nCheck whether the line contains our query string.\nIf it does, add it to the list of values we’re returning.\nIf it doesn’t, do nothing.\nReturn the list of results that match.\n\nLet’s work through each step, starting with iterating through lines.\nIterating Through Lines with the \"lines\" Method\nRust has a helpful method to handle line-by-line iteration of strings, conveniently named \"lines\", that works as shown in Listing 12-17. Note this won’t compile yet.\nFilename: src/lib.rs\npub fn search&lt;\"a&gt;(query: &amp;str, contents: &amp;\"a str) -&gt; Vec&lt;&amp;\"a str&gt; {\n    for line in contents.lines() {\n        // do something with line\n    }\n}\n\nListing 12-17: Iterating through each line in \"contents\"\nThe \"lines\" method returns an iterator. We’ll talk about iterators in depth in Chapter 13, but recall that you saw this way of using an iterator in Listing 3-5, where we used a \"for\" loop with an iterator to run some code on each item in a collection.\nSearching Each Line for the Query\nNext, we’ll check whether the current line contains our query string. Fortunately, strings have a helpful method named \"contains\" that does this for us! Add a call to the \"contains\" method in the \"search\" function, as shown in Listing 12-18. Note this still won’t compile yet.\nFilename: src/lib.rs\npub fn search&lt;\"a&gt;(query: &amp;str, contents: &amp;\"a str) -&gt; Vec&lt;&amp;\"a str&gt; {\n    for line in contents.lines() {\n        if line.contains(query) {\n            // do something with line\n        }\n    }\n}\n\nListing 12-18: Adding functionality to see whether the line contains the string in \"query\"\nAt the moment, we’re building up functionality. To get it to compile, we need to return a value from the body as we indicated we would in the function signature.\nStoring Matching Lines\nTo finish this function, we need a way to store the matching lines that we want to return. For that, we can make a mutable vector before the \"for\" loop and call the \"push\" method to store a \"line\" in the vector. After the \"for\" loop, we return the vector, as shown in Listing 12-19.\nFilename: src/lib.rs\npub fn search&lt;\"a&gt;(query: &amp;str, contents: &amp;\"a str) -&gt; Vec&lt;&amp;\"a str&gt; {\n    let mut results = Vec::new();\n\n    for line in contents.lines() {\n        if line.contains(query) {\n            results.push(line);\n        }\n    }\n\n    results\n}\n\nListing 12-19: Storing the lines that match so we can return them\nNow the \"search\" function should return only the lines that contain \"query\", and our test should pass. Let’s run the test:\n$ cargo test\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished test [unoptimized + debuginfo] target(s) in 1.22s\n     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)\n\nrunning 1 test\ntest tests::one_result ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n     Running unittests src/main.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests minigrep\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nOur test passed, so we know it works!\nAt this point, we could consider opportunities for refactoring the implementation of the search function while keeping the tests passing to maintain the same functionality. The code in the search function isn’t too bad, but it doesn’t take advantage of some useful features of iterators. We’ll return to this example in Chapter 13, where we’ll explore iterators in detail, and look at how to improve it.\nUsing the \"search\" Function in the \"run\" Function\nNow that the \"search\" function is working and tested, we need to call \"search\" from our \"run\" function. We need to pass the \"config.query\" value and the \"contents\" that \"run\" reads from the file to the \"search\" function. Then \"run\" will print each line returned from \"search\":\nFilename: src/lib.rs\npub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {\n    let contents = fs::read_to_string(config.file_path)?;\n\n    for line in search(&amp;config.query, &amp;contents) {\n        println!(\"{line}\");\n    }\n\n    Ok(())\n}\n\nWe’re still using a \"for\" loop to return each line from \"search\" and print it.\nNow the entire program should work! Let’s try it out, first with a word that should return exactly one line from the Emily Dickinson poem, “frog”:\n$ cargo run -- frog poem.txt\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.38s\n     Running \"target/debug/minigrep frog poem.txt\"\nHow public, like a frog\n\nCool! Now let’s try a word that will match multiple lines, like “body”:\n$ cargo run -- body poem.txt\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.0s\n     Running \"target/debug/minigrep body poem.txt\"\nI\"m nobody! Who are you?\nAre you nobody, too?\nHow dreary to be somebody!\n\nAnd finally, let’s make sure that we don’t get any lines when we search for a word that isn’t anywhere in the poem, such as “monomorphization”:\n$ cargo run -- monomorphization poem.txt\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.0s\n     Running \"target/debug/minigrep monomorphization poem.txt\"\n\nExcellent! We’ve built our own mini version of a classic tool and learned a lot about how to structure applications. We’ve also learned a bit about file input and output, lifetimes, testing, and command line parsing.\nTo round out this project, we’ll briefly demonstrate how to work with environment variables and how to print to standard error, both of which are useful when you’re writing command line programs.\n\nWorking with Environment Variables\nWe’ll improve \"minigrep\" by adding an extra feature: an option for case-insensitive searching that the user can turn on via an environment variable. We could make this feature a command line option and require that users enter it each time they want it to apply, but by instead making it an environment variable, we allow our users to set the environment variable once and have all their searches be case insensitive in that terminal session.\nWriting a Failing Test for the Case-Insensitive \"search\" Function\nWe first add a new \"search_case_insensitive\" function that will be called when the environment variable has a value. We’ll continue to follow the TDD process, so the first step is again to write a failing test. We’ll add a new test for the new \"search_case_insensitive\" function and rename our old test from \"one_result\" to \"case_sensitive\" to clarify the differences between the two tests, as shown in Listing 12-20.\nFilename: src/lib.rs\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn case_sensitive() {\n        let query = \"duct\";\n        let contents = \"\\\nRust:\nsafe, fast, productive.\nPick three.\nDuct tape.\";\n\n        assert_eq!(vec![\"safe, fast, productive.\"], search(query, contents));\n    }\n\n    #[test]\n    fn case_insensitive() {\n        let query = \"rUsT\";\n        let contents = \"\\\nRust:\nsafe, fast, productive.\nPick three.\nTrust me.\";\n\n        assert_eq!(\n            vec![\"Rust:\", \"Trust me.\"],\n            search_case_insensitive(query, contents)\n        );\n    }\n}\n\nListing 12-20: Adding a new failing test for the case-insensitive function we’re about to add\nNote that we’ve edited the old test’s \"contents\" too. We’ve added a new line with the text \"\"Duct tape.\"\" using a capital D that shouldn’t match the query \"\"duct\"\" when we’re searching in a case-sensitive manner. Changing the old test in this way helps ensure that we don’t accidentally break the case-sensitive search functionality that we’ve already implemented. This test should pass now and should continue to pass as we work on the case-insensitive search.\nThe new test for the case-insensitive search uses \"\"rUsT\"\" as its query. In the \"search_case_insensitive\" function we’re about to add, the query \"\"rUsT\"\" should match the line containing \"\"Rust:\"\" with a capital R and match the line \"\"Trust me.\"\" even though both have different casing from the query. This is our failing test, and it will fail to compile because we haven’t yet defined the \"search_case_insensitive\" function. Feel free to add a skeleton implementation that always returns an empty vector, similar to the way we did for the \"search\" function in Listing 12-16 to see the test compile and fail.\nImplementing the \"search_case_insensitive\" Function\nThe \"search_case_insensitive\" function, shown in Listing 12-21, will be almost the same as the \"search\" function. The only difference is that we’ll lowercase the \"query\" and each \"line\" so whatever the case of the input arguments, they’ll be the same case when we check whether the line contains the query.\nFilename: src/lib.rs\npub fn search_case_insensitive&lt;\"a&gt;(\n    query: &amp;str,\n    contents: &amp;\"a str,\n) -&gt; Vec&lt;&amp;\"a str&gt; {\n    let query = query.to_lowercase();\n    let mut results = Vec::new();\n\n    for line in contents.lines() {\n        if line.to_lowercase().contains(&amp;query) {\n            results.push(line);\n        }\n    }\n\n    results\n}\n\nListing 12-21: Defining the \"search_case_insensitive\" function to lowercase the query and the line before comparing them\nFirst, we lowercase the \"query\" string and store it in a shadowed variable with the same name. Calling \"to_lowercase\" on the query is necessary so no matter whether the user’s query is \"\"rust\"\", \"\"RUST\"\", \"\"Rust\"\", or \"\"rUsT\"\", we’ll treat the query as if it were \"\"rust\"\" and be insensitive to the case. While \"to_lowercase\" will handle basic Unicode, it won’t be 100% accurate. If we were writing a real application, we’d want to do a bit more work here, but this section is about environment variables, not Unicode, so we’ll leave it at that here.\nNote that \"query\" is now a \"String\" rather than a string slice, because calling \"to_lowercase\" creates new data rather than referencing existing data. Say the query is \"\"rUsT\"\", as an example: that string slice doesn’t contain a lowercase \"u\" or \"t\" for us to use, so we have to allocate a new \"String\" containing \"\"rust\"\". When we pass \"query\" as an argument to the \"contains\" method now, we need to add an ampersand because the signature of \"contains\" is defined to take a string slice.\nNext, we add a call to \"to_lowercase\" on each \"line\" to lowercase all characters. Now that we’ve converted \"line\" and \"query\" to lowercase, we’ll find matches no matter what the case of the query is.\nLet’s see if this implementation passes the tests:\n$ cargo test\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished test [unoptimized + debuginfo] target(s) in 1.33s\n     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)\n\nrunning 2 tests\ntest tests::case_insensitive ... ok\ntest tests::case_sensitive ... ok\n\ntest result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n     Running unittests src/main.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests minigrep\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nGreat! They passed. Now, let’s call the new \"search_case_insensitive\" function from the \"run\" function. First, we’ll add a configuration option to the \"Config\" struct to switch between case-sensitive and case-insensitive search. Adding this field will cause compiler errors because we aren’t initializing this field anywhere yet:\nFilename: src/lib.rs\npub struct Config {\n    pub query: String,\n    pub file_path: String,\n    pub ignore_case: bool,\n}\n\nWe added the \"ignore_case\" field that holds a Boolean. Next, we need the \"run\" function to check the \"ignore_case\" field’s value and use that to decide whether to call the \"search\" function or the \"search_case_insensitive\" function, as shown in Listing 12-22. This still won’t compile yet.\nFilename: src/lib.rs\npub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {\n    let contents = fs::read_to_string(config.file_path)?;\n\n    let results = if config.ignore_case {\n        search_case_insensitive(&amp;config.query, &amp;contents)\n    } else {\n        search(&amp;config.query, &amp;contents)\n    };\n\n    for line in results {\n        println!(\"{line}\");\n    }\n\n    Ok(())\n}\n\nListing 12-22: Calling either \"search\" or \"search_case_insensitive\" based on the value in \"config.ignore_case\"\nFinally, we need to check for the environment variable. The functions for working with environment variables are in the \"env\" module in the standard library, so we bring that module into scope at the top of src/lib.rs. Then we’ll use the \"var\" function from the \"env\" module to check to see if any value has been set for an environment variable named \"IGNORE_CASE\", as shown in Listing 12-23.\nFilename: src/lib.rs\nuse std::env;\n// --snip--\n\nimpl Config {\n    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;\"static str&gt; {\n        if args.len() &lt; 3 {\n            return Err(\"not enough arguments\");\n        }\n\n        let query = args[1].clone();\n        let file_path = args[2].clone();\n\n        let ignore_case = env::var(\"IGNORE_CASE\").is_ok();\n\n        Ok(Config {\n            query,\n            file_path,\n            ignore_case,\n        })\n    }\n}\n\nListing 12-23: Checking for any value in an environment variable named \"IGNORE_CASE\"\nHere, we create a new variable \"ignore_case\". To set its value, we call the \"env::var\" function and pass it the name of the \"IGNORE_CASE\" environment variable. The \"env::var\" function returns a \"Result\" that will be the successful \"Ok\" variant that contains the value of the environment variable if the environment variable is set to any value. It will return the \"Err\" variant if the environment variable is not set.\nWe’re using the \"is_ok\" method on the \"Result\" to check whether the environment variable is set, which means the program should do a case-insensitive search. If the \"IGNORE_CASE\" environment variable isn’t set to anything, \"is_ok\" will return false and the program will perform a case-sensitive search. We don’t care about the value of the environment variable, just whether it’s set or unset, so we’re checking \"is_ok\" rather than using \"unwrap\", \"expect\", or any of the other methods we’ve seen on \"Result\".\nWe pass the value in the \"ignore_case\" variable to the \"Config\" instance so the \"run\" function can read that value and decide whether to call \"search_case_insensitive\" or \"search\", as we implemented in Listing 12-22.\nLet’s give it a try! First, we’ll run our program without the environment variable set and with the query \"to\", which should match any line that contains the word “to” in all lowercase:\n$ cargo run -- to poem.txt\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.0s\n     Running \"target/debug/minigrep to poem.txt\"\nAre you nobody, too?\nHow dreary to be somebody!\n\nLooks like that still works! Now, let’s run the program with \"IGNORE_CASE\" set to \"1\" but with the same query \"to\".\n$ IGNORE_CASE=1 cargo run -- to poem.txt\n\nIf you’re using PowerShell, you will need to set the environment variable and run the program as separate commands:\nPS&gt; $Env:IGNORE_CASE=1; cargo run -- to poem.txt\n\nThis will make \"IGNORE_CASE\" persist for the remainder of your shell session. It can be unset with the \"Remove-Item\" cmdlet:\nPS&gt; Remove-Item Env:IGNORE_CASE\n\nWe should get lines that contain “to” that might have uppercase letters:\nAre you nobody, too?\nHow dreary to be somebody!\nTo tell your name the livelong day\nTo an admiring bog!\n\nExcellent, we also got lines containing “To”! Our \"minigrep\" program can now do case-insensitive searching controlled by an environment variable. Now you know how to manage options set using either command line arguments or environment variables.\nSome programs allow arguments and environment variables for the same configuration. In those cases, the programs decide that one or the other takes precedence. For another exercise on your own, try controlling case sensitivity through either a command line argument or an environment variable. Decide whether the command line argument or the environment variable should take precedence if the program is run with one set to case sensitive and one set to ignore case.\nThe \"std::env\" module contains many more useful features for dealing with environment variables: check out its documentation to see what is available.\n\nWriting Error Messages to Standard Error Instead of Standard Output\nAt the moment, we’re writing all of our output to the terminal using the \"println!\" macro. In most terminals, there are two kinds of output: standard output (\"stdout\") for general information and standard error (\"stderr\") for error messages. This distinction enables users to choose to direct the successful output of a program to a file but still print error messages to the screen.\nThe \"println!\" macro is only capable of printing to standard output, so we have to use something else to print to standard error.\nChecking Where Errors Are Written\nFirst, let’s observe how the content printed by \"minigrep\" is currently being written to standard output, including any error messages we want to write to standard error instead. We’ll do that by redirecting the standard output stream to a file while intentionally causing an error. We won’t redirect the standard error stream, so any content sent to standard error will continue to display on the screen.\nCommand line programs are expected to send error messages to the standard error stream so we can still see error messages on the screen even if we redirect the standard output stream to a file. Our program is not currently well-behaved: we’re about to see that it saves the error message output to a file instead!\nTo demonstrate this behavior, we’ll run the program with \"&gt;\" and the file path, output.txt, that we want to redirect the standard output stream to. We won’t pass any arguments, which should cause an error:\n$ cargo run &gt; output.txt\n\nThe \"&gt;\" syntax tells the shell to write the contents of standard output to output.txt instead of the screen. We didn’t see the error message we were expecting printed to the screen, so that means it must have ended up in the file. This is what output.txt contains:\nProblem parsing arguments: not enough arguments\n\nYup, our error message is being printed to standard output. It’s much more useful for error messages like this to be printed to standard error so only data from a successful run ends up in the file. We’ll change that.\nPrinting Errors to Standard Error\nWe’ll use the code in Listing 12-24 to change how error messages are printed. Because of the refactoring we did earlier in this chapter, all the code that prints error messages is in one function, \"main\". The standard library provides the \"eprintln!\" macro that prints to the standard error stream, so let’s change the two places we were calling \"println!\" to print errors to use \"eprintln!\" instead.\nFilename: src/main.rs\nfn main() {\n    let args: Vec&lt;String&gt; = env::args().collect();\n\n    let config = Config::build(&amp;args).unwrap_or_else(|err| {\n        eprintln!(\"Problem parsing arguments: {err}\");\n        process::exit(1);\n    });\n\n    if let Err(e) = minigrep::run(config) {\n        eprintln!(\"Application error: {e}\");\n        process::exit(1);\n    }\n}\n\nListing 12-24: Writing error messages to standard error instead of standard output using \"eprintln!\"\nLet’s now run the program again in the same way, without any arguments and redirecting standard output with \"&gt;\":\n$ cargo run &gt; output.txt\nProblem parsing arguments: not enough arguments\n\nNow we see the error onscreen and output.txt contains nothing, which is the behavior we expect of command line programs.\nLet’s run the program again with arguments that don’t cause an error but still redirect standard output to a file, like so:\n$ cargo run -- to poem.txt &gt; output.txt\n\nWe won’t see any output to the terminal, and output.txt will contain our results:\nFilename: output.txt\nAre you nobody, too?\nHow dreary to be somebody!\n\nThis demonstrates that we’re now using standard output for successful output and standard error for error output as appropriate.\nSummary\nThis chapter recapped some of the major concepts you’ve learned so far and covered how to perform common I/O operations in Rust. By using command line arguments, files, environment variables, and the \"eprintln!\" macro for printing errors, you’re now prepared to write command line applications. Combined with the concepts in previous chapters, your code will be well organized, store data effectively in the appropriate data structures, handle errors nicely, and be well tested.\nNext, we’ll explore some Rust features that were influenced by functional languages: closures and iterators.\n\n13\nFunctional Language Features: Iterators and Closures\nRust’s design has taken inspiration from many existing languages and techniques, and one significant influence is functional programming. Programming in a functional style often includes using functions as values by passing them in arguments, returning them from other functions, assigning them to variables for later execution, and so forth.\nIn this chapter, we won’t debate the issue of what functional programming is or isn’t but will instead discuss some features of Rust that are similar to features in many languages often referred to as functional.\nMore specifically, we’ll cover:\n\nClosures, a function-like construct you can store in a variable\nIterators, a way of processing a series of elements\nHow to use closures and iterators to improve the I/O project in Chapter 12\nThe performance of closures and iterators (Spoiler alert: they’re faster than you might think!)\n\nWe’ve already covered some other Rust features, such as pattern matching and enums, that are also influenced by the functional style. Because mastering closures and iterators is an important part of writing idiomatic, fast Rust code, we’ll devote this entire chapter to them.\n\nClosures: Anonymous Functions that Capture Their Environment\nRust’s closures are anonymous functions you can save in a variable or pass as arguments to other functions. You can create the closure in one place and then call the closure elsewhere to evaluate it in a different context. Unlike functions, closures can capture values from the scope in which they’re defined. We’ll demonstrate how these closure features allow for code reuse and behavior customization.\nCapturing the Environment with Closures\nWe’ll first examine how we can use closures to capture values from the environment they’re defined in for later use. Here’s the scenario: Every so often, our t-shirt company gives away an exclusive, limited-edition shirt to someone on our mailing list as a promotion. People on the mailing list can optionally add their favorite color to their profile. If the person chosen for a free shirt has their favorite color set, they get that color shirt. If the person hasn’t specified a favorite color, they get whatever color the company currently has the most of.\nThere are many ways to implement this. For this example, we’re going to use an enum called \"ShirtColor\" that has the variants \"Red\" and \"Blue\" (limiting the number of colors available for simplicity). We represent the company’s inventory with an \"Inventory\" struct that has a field named \"shirts\" that contains a \"Vec\" representing the shirt colors currently in stock. The method \"giveaway\" defined on \"Inventory\" gets the optional shirt color preference of the free shirt winner, and returns the shirt color the person will get. This setup is shown in Listing 13-1:\nFilename: src/main.rs\n#[derive(Debug, PartialEq, Copy, Clone)]\nenum ShirtColor {\n    Red,\n    Blue,\n}\n\nstruct Inventory {\n    shirts: Vec&lt;ShirtColor&gt;,\n}\n\nimpl Inventory {\n    fn giveaway(&amp;self, user_preference: Option&lt;ShirtColor&gt;) -&gt; ShirtColor {\n        user_preference.unwrap_or_else(|| self.most_stocked())\n    }\n\n    fn most_stocked(&amp;self) -&gt; ShirtColor {\n        let mut num_red = 0;\n        let mut num_blue = 0;\n\n        for color in &amp;self.shirts {\n            match color {\n                ShirtColor::Red =&gt; num_red += 1,\n                ShirtColor::Blue =&gt; num_blue += 1,\n            }\n        }\n        if num_red &gt; num_blue {\n            ShirtColor::Red\n        } else {\n            ShirtColor::Blue\n        }\n    }\n}\n\nfn main() {\n    let store = Inventory {\n        shirts: vec![ShirtColor::Blue, ShirtColor::Red, ShirtColor::Blue],\n    };\n\n    let user_pref1 = Some(ShirtColor::Red);\n    let giveaway1 = store.giveaway(user_pref1);\n    println!(\n        \"The user with preference {:?} gets {:?}\",\n        user_pref1, giveaway1\n    );\n\n    let user_pref2 = None;\n    let giveaway2 = store.giveaway(user_pref2);\n    println!(\n        \"The user with preference {:?} gets {:?}\",\n        user_pref2, giveaway2\n    );\n}\n\nListing 13-1: Shirt company giveaway situation\nThe \"store\" defined in \"main\" has two blue shirts and one red shirt remaining to distribute for this limited-edition promotion. We call the \"giveaway\" method for a user with a preference for a red shirt and a user without any preference.\nAgain, this code could be implemented in many ways, and here, to focus on closures, we’ve stuck to concepts you’ve already learned except for the body of the \"giveaway\" method that uses a closure. In the \"giveaway\" method, we get the user preference as a parameter of type \"Option\" and call the \"unwrap_or_else\" method on \"user_preference\". The \"unwrap_or_else\" method on \"Option\" is defined by the standard library. It takes one argument: a closure without any arguments that returns a value \"T\" (the same type stored in the \"Some\" variant of the \"Option\", in this case \"ShirtColor\"). If the \"Option\" is the \"Some\" variant, \"unwrap_or_else\" returns the value from within the \"Some\". If the \"Option\" is the \"None\" variant, \"unwrap_or_else\" calls the closure and returns the value returned by the closure.\nWe specify the closure expression \"|| self.most_stocked()\" as the argument to \"unwrap_or_else\". This is a closure that takes no parameters itself (if the closure had parameters, they would appear between the two vertical bars). The body of the closure calls \"self.most_stocked()\". We’re defining the closure here, and the implementation of \"unwrap_or_else\" will evaluate the closure later if the result is needed.\nRunning this code prints:\n$ cargo run\n   Compiling shirt-company v0.1.0 (file:///projects/shirt-company)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.27s\n     Running \"target/debug/shirt-company\"\nThe user with preference Some(Red) gets Red\nThe user with preference None gets Blue\n\nOne interesting aspect here is that we’ve passed a closure that calls \"self.most_stocked()\" on the current \"Inventory\" instance. The standard library didn’t need to know anything about the \"Inventory\" or \"ShirtColor\" types we defined, or the logic we want to use in this scenario. The closure captures an immutable reference to the \"self\" \"Inventory\" instance and passes it with the code we specify to the \"unwrap_or_else\" method. Functions, on the other hand, are not able to capture their environment in this way.\nClosure Type Inference and Annotation\nThere are more differences between functions and closures. Closures don’t usually require you to annotate the types of the parameters or the return value like \"fn\" functions do. Type annotations are required on functions because the types are part of an explicit interface exposed to your users. Defining this interface rigidly is important for ensuring that everyone agrees on what types of values a function uses and returns. Closures, on the other hand, aren’t used in an exposed interface like this: they’re stored in variables and used without naming them and exposing them to users of our library.\nClosures are typically short and relevant only within a narrow context rather than in any arbitrary scenario. Within these limited contexts, the compiler can infer the types of the parameters and the return type, similar to how it’s able to infer the types of most variables (there are rare cases where the compiler needs closure type annotations too).\nAs with variables, we can add type annotations if we want to increase explicitness and clarity at the cost of being more verbose than is strictly necessary. Annotating the types for a closure would look like the definition shown in Listing 13-2. In this example, we’re defining a closure and storing it in a variable rather than defining the closure in the spot we pass it as an argument as we did in Listing 13-1.\nFilename: src/main.rs\n    let expensive_closure = |num: u32| -&gt; u32 {\n        println!(\"calculating slowly...\");\n        thread::sleep(Duration::from_secs(2));\n        num\n    };\n\nListing 13-2: Adding optional type annotations of the parameter and return value types in the closure\nWith type annotations added, the syntax of closures looks more similar to the syntax of functions. Here we define a function that adds 1 to its parameter and a closure that has the same behavior, for comparison. We’ve added some spaces to line up the relevant parts. This illustrates how closure syntax is similar to function syntax except for the use of pipes and the amount of syntax that is optional:\nfn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }\nlet add_one_v2 = |x: u32| -&gt; u32 { x + 1 };\nlet add_one_v3 = |x|             { x + 1 };\nlet add_one_v4 = |x|               x + 1  ;\n\nThe first line shows a function definition, and the second line shows a fully annotated closure definition. In the third line, we remove the type annotations from the closure definition. In the fourth line, we remove the brackets, which are optional because the closure body has only one expression. These are all valid definitions that will produce the same behavior when they’re called. The \"add_one_v3\" and \"add_one_v4\" lines require the closures to be evaluated to be able to compile because the types will be inferred from their usage. This is similar to \"let v = Vec::new();\" needing either type annotations or values of some type to be inserted into the \"Vec\" for Rust to be able to infer the type.\nFor closure definitions, the compiler will infer one concrete type for each of their parameters and for their return value. For instance, Listing 13-3 shows the definition of a short closure that just returns the value it receives as a parameter. This closure isn’t very useful except for the purposes of this example. Note that we haven’t added any type annotations to the definition. Because there are no type annotations, we can call the closure with any type, which we’ve done here with \"String\" the first time. If we then try to call \"example_closure\" with an integer, we’ll get an error.\nFilename: src/main.rs\n    let example_closure = |x| x;\n\n    let s = example_closure(String::from(\"hello\"));\n    let n = example_closure(5);\n\nListing 13-3: Attempting to call a closure whose types are inferred with two different types\nThe compiler gives us this error:\n$ cargo run\n   Compiling closure-example v0.1.0 (file:///projects/closure-example)\nerror[E0308]: mismatched types\n --&gt; src/main.rs:5:29\n  |\n5 |     let n = example_closure(5);\n  |             --------------- ^- help: try using a conversion method: \".to_string()\"\n  |             |               |\n  |             |               expected struct \"String\", found integer\n  |             arguments to this function are incorrect\n  |\nnote: closure parameter defined here\n --&gt; src/main.rs:2:28\n  |\n2 |     let example_closure = |x| x;\n  |                            ^\n\nFor more information about this error, try \"rustc --explain E0308\".\nerror: could not compile \"closure-example\" due to previous error\n\nThe first time we call \"example_closure\" with the \"String\" value, the compiler infers the type of \"x\" and the return type of the closure to be \"String\". Those types are then locked into the closure in \"example_closure\", and we get a type error when we next try to use a different type with the same closure.\nCapturing References or Moving Ownership\nClosures can capture values from their environment in three ways, which directly map to the three ways a function can take a parameter: borrowing immutably, borrowing mutably, and taking ownership. The closure will decide which of these to use based on what the body of the function does with the captured values.\nIn Listing 13-4, we define a closure that captures an immutable reference to the vector named \"list\" because it only needs an immutable reference to print the value:\nFilename: src/main.rs\nfn main() {\n    let list = vec![1, 2, 3];\n    println!(\"Before defining closure: {:?}\", list);\n\n    let only_borrows = || println!(\"From closure: {:?}\", list);\n\n    println!(\"Before calling closure: {:?}\", list);\n    only_borrows();\n    println!(\"After calling closure: {:?}\", list);\n}\n\nListing 13-4: Defining and calling a closure that captures an immutable reference\nThis example also illustrates that a variable can bind to a closure definition, and we can later call the closure by using the variable name and parentheses as if the variable name were a function name.\nBecause we can have multiple immutable references to \"list\" at the same time, \"list\" is still accessible from the code before the closure definition, after the closure definition but before the closure is called, and after the closure is called. This code compiles, runs, and prints:\n$ cargo run\n   Compiling closure-example v0.1.0 (file:///projects/closure-example)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.43s\n     Running \"target/debug/closure-example\"\nBefore defining closure: [1, 2, 3]\nBefore calling closure: [1, 2, 3]\nFrom closure: [1, 2, 3]\nAfter calling closure: [1, 2, 3]\n\nNext, in Listing 13-5, we change the closure body so that it adds an element to the \"list\" vector. The closure now captures a mutable reference:\nFilename: src/main.rs\nfn main() {\n    let mut list = vec![1, 2, 3];\n    println!(\"Before defining closure: {:?}\", list);\n\n    let mut borrows_mutably = || list.push(7);\n\n    borrows_mutably();\n    println!(\"After calling closure: {:?}\", list);\n}\n\nListing 13-5: Defining and calling a closure that captures a mutable reference\nThis code compiles, runs, and prints:\n$ cargo run\n   Compiling closure-example v0.1.0 (file:///projects/closure-example)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.43s\n     Running \"target/debug/closure-example\"\nBefore defining closure: [1, 2, 3]\nAfter calling closure: [1, 2, 3, 7]\n\nNote that there’s no longer a \"println!\" between the definition and the call of the \"borrows_mutably\" closure: when \"borrows_mutably\" is defined, it captures a mutable reference to \"list\". We don’t use the closure again after the closure is called, so the mutable borrow ends. Between the closure definition and the closure call, an immutable borrow to print isn’t allowed because no other borrows are allowed when there’s a mutable borrow. Try adding a \"println!\" there to see what error message you get!\nIf you want to force the closure to take ownership of the values it uses in the environment even though the body of the closure doesn’t strictly need ownership, you can use the \"move\" keyword before the parameter list.\nThis technique is mostly useful when passing a closure to a new thread to move the data so that it’s owned by the new thread. We’ll discuss threads and why you would want to use them in detail in Chapter 16 when we talk about concurrency, but for now, let’s briefly explore spawning a new thread using a closure that needs the \"move\" keyword. Listing 13-6 shows Listing 13-4 modified to print the vector in a new thread rather than in the main thread:\nFilename: src/main.rs\nuse std::thread;\n\nfn main() {\n    let list = vec![1, 2, 3];\n    println!(\"Before defining closure: {:?}\", list);\n\n    thread::spawn(move || println!(\"From thread: {:?}\", list))\n        .join()\n        .unwrap();\n}\n\nListing 13-6: Using \"move\" to force the closure for the thread to take ownership of \"list\"\nWe spawn a new thread, giving the thread a closure to run as an argument. The closure body prints out the list. In Listing 13-4, the closure only captured \"list\" using an immutable reference because that\"s the least amount of access to \"list\" needed to print it. In this example, even though the closure body still only needs an immutable reference, we need to specify that \"list\" should be moved into the closure by putting the \"move\" keyword at the beginning of the closure definition. The new thread might finish before the rest of the main thread finishes, or the main thread might finish first. If the main thread maintained ownership of \"list\" but ended before the new thread did and dropped \"list\", the immutable reference in the thread would be invalid. Therefore, the compiler requires that \"list\" be moved into the closure given to the new thread so the reference will be valid. Try removing the \"move\" keyword or using \"list\" in the main thread after the closure is defined to see what compiler errors you get!\nMoving Captured Values Out of Closures and the \"Fn\" Traits\nOnce a closure has captured a reference or captured ownership of a value from the environment where the closure is defined (thus affecting what, if anything, is moved into the closure), the code in the body of the closure defines what happens to the references or values when the closure is evaluated later (thus affecting what, if anything, is moved out of the closure). A closure body can do any of the following: move a captured value out of the closure, mutate the captured value, neither move nor mutate the value, or capture nothing from the environment to begin with.\nThe way a closure captures and handles values from the environment affects which traits the closure implements, and traits are how functions and structs can specify what kinds of closures they can use. Closures will automatically implement one, two, or all three of these \"Fn\" traits, in an additive fashion, depending on how the closure’s body handles the values:\n\n\"FnOnce\" applies to closures that can be called once. All closures implement at least this trait, because all closures can be called. A closure that moves captured values out of its body will only implement \"FnOnce\" and none of the other \"Fn\" traits, because it can only be called once.\n\"FnMut\" applies to closures that don’t move captured values out of their body, but that might mutate the captured values. These closures can be called more than once.\n\"Fn\" applies to closures that don’t move captured values out of their body and that don’t mutate captured values, as well as closures that capture nothing from their environment. These closures can be called more than once without mutating their environment, which is important in cases such as calling a closure multiple times concurrently.\n\nLet’s look at the definition of the \"unwrap_or_else\" method on \"Option\" that we used in Listing 13-1:\nimpl&lt;T&gt; Option&lt;T&gt; {\n    pub fn unwrap_or_else&lt;F&gt;(self, f: F) -&gt; T\n    where\n        F: FnOnce() -&gt; T\n    {\n        match self {\n            Some(x) =&gt; x,\n            None =&gt; f(),\n        }\n    }\n}\n\nRecall that \"T\" is the generic type representing the type of the value in the \"Some\" variant of an \"Option\". That type \"T\" is also the return type of the \"unwrap_or_else\" function: code that calls \"unwrap_or_else\" on an \"Option\", for example, will get a \"String\".\nNext, notice that the \"unwrap_or_else\" function has the additional generic type parameter \"F\". The \"F\" type is the type of the parameter named \"f\", which is the closure we provide when calling \"unwrap_or_else\".\nThe trait bound specified on the generic type \"F\" is \"FnOnce() -&gt; T\", which means \"F\" must be able to be called once, take no arguments, and return a \"T\". Using \"FnOnce\" in the trait bound expresses the constraint that \"unwrap_or_else\" is only going to call \"f\" at most one time. In the body of \"unwrap_or_else\", we can see that if the \"Option\" is \"Some\", \"f\" won’t be called. If the \"Option\" is \"None\", \"f\" will be called once. Because all closures implement \"FnOnce\", \"unwrap_or_else\" accepts the most different kinds of closures and is as flexible as it can be.\n\nNote: Functions can implement all three of the \"Fn\" traits too. If what we want to do doesn’t require capturing a value from the environment, we can use the name of a function rather than a closure where we need something that implements one of the \"Fn\" traits. For example, on an \"Option&lt;Vec&gt;\" value, we could call \"unwrap_or_else(Vec::new)\" to get a new, empty vector if the value is \"None\".\n\nNow let’s look at the standard library method \"sort_by_key\" defined on slices, to see how that differs from \"unwrap_or_else\" and why \"sort_by_key\" uses \"FnMut\" instead of \"FnOnce\" for the trait bound. The closure gets one argument in the form of a reference to the current item in the slice being considered, and returns a value of type \"K\" that can be ordered. This function is useful when you want to sort a slice by a particular attribute of each item. In Listing 13-7, we have a list of \"Rectangle\" instances and we use \"sort_by_key\" to order them by their \"width\" attribute from low to high:\nFilename: src/main.rs\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let mut list = [\n        Rectangle { width: 10, height: 1 },\n        Rectangle { width: 3, height: 5 },\n        Rectangle { width: 7, height: 12 },\n    ];\n\n    list.sort_by_key(|r| r.width);\n    println!(\"{:#?}\", list);\n}\n\nListing 13-7: Using \"sort_by_key\" to order rectangles by width\nThis code prints:\n$ cargo run\n   Compiling rectangles v0.1.0 (file:///projects/rectangles)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.41s\n     Running \"target/debug/rectangles\"\n[\n    Rectangle {\n        width: 3,\n        height: 5,\n    },\n    Rectangle {\n        width: 7,\n        height: 12,\n    },\n    Rectangle {\n        width: 10,\n        height: 1,\n    },\n]\n\nThe reason \"sort_by_key\" is defined to take an \"FnMut\" closure is that it calls the closure multiple times: once for each item in the slice. The closure \"|r| r.width\" doesn’t capture, mutate, or move out anything from its environment, so it meets the trait bound requirements.\nIn contrast, Listing 13-8 shows an example of a closure that implements just the \"FnOnce\" trait, because it moves a value out of the environment. The compiler won’t let us use this closure with \"sort_by_key\":\nFilename: src/main.rs\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let mut list = [\n        Rectangle { width: 10, height: 1 },\n        Rectangle { width: 3, height: 5 },\n        Rectangle { width: 7, height: 12 },\n    ];\n\n    let mut sort_operations = vec![];\n    let value = String::from(\"by key called\");\n\n    list.sort_by_key(|r| {\n        sort_operations.push(value);\n        r.width\n    });\n    println!(\"{:#?}\", list);\n}\n\nListing 13-8: Attempting to use an \"FnOnce\" closure with \"sort_by_key\"\nThis is a contrived, convoluted way (that doesn’t work) to try and count the number of times \"sort_by_key\" gets called when sorting \"list\". This code attempts to do this counting by pushing \"value\"—a \"String\" from the closure’s environment—into the \"sort_operations\" vector. The closure captures \"value\" then moves \"value\" out of the closure by transferring ownership of \"value\" to the \"sort_operations\" vector. This closure can be called once; trying to call it a second time wouldn’t work because \"value\" would no longer be in the environment to be pushed into \"sort_operations\" again! Therefore, this closure only implements \"FnOnce\". When we try to compile this code, we get this error that \"value\" can’t be moved out of the closure because the closure must implement \"FnMut\":\n$ cargo run\n   Compiling rectangles v0.1.0 (file:///projects/rectangles)\nerror[E0507]: cannot move out of \"value\", a captured variable in an \"FnMut\" closure\n  --&gt; src/main.rs:18:30\n   |\n15 |     let value = String::from(\"by key called\");\n   |         ----- captured outer variable\n16 |\n17 |     list.sort_by_key(|r| {\n   |                      --- captured by this \"FnMut\" closure\n18 |         sort_operations.push(value);\n   |                              ^^^^^ move occurs because \"value\" has type \"String\", which does not implement the \"Copy\" trait\n\nFor more information about this error, try \"rustc --explain E0507\".\nerror: could not compile \"rectangles\" due to previous error\n\nThe error points to the line in the closure body that moves \"value\" out of the environment. To fix this, we need to change the closure body so that it doesn’t move values out of the environment. To count the number of times \"sort_by_key\" is called, keeping a counter in the environment and incrementing its value in the closure body is a more straightforward way to calculate that. The closure in Listing 13-9 works with \"sort_by_key\" because it is only capturing a mutable reference to the \"num_sort_operations\" counter and can therefore be called more than once:\nFilename: src/main.rs\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let mut list = [\n        Rectangle { width: 10, height: 1 },\n        Rectangle { width: 3, height: 5 },\n        Rectangle { width: 7, height: 12 },\n    ];\n\n    let mut num_sort_operations = 0;\n    list.sort_by_key(|r| {\n        num_sort_operations += 1;\n        r.width\n    });\n    println!(\"{:#?}, sorted in {num_sort_operations} operations\", list);\n}\n\nListing 13-9: Using an \"FnMut\" closure with \"sort_by_key\" is allowed\nThe \"Fn\" traits are important when defining or using functions or types that make use of closures. In the next section, we’ll discuss iterators. Many iterator methods take closure arguments, so keep these closure details in mind as we continue!\n\nProcessing a Series of Items with Iterators\nThe iterator pattern allows you to perform some task on a sequence of items in turn. An iterator is responsible for the logic of iterating over each item and determining when the sequence has finished. When you use iterators, you don’t have to reimplement that logic yourself.\nIn Rust, iterators are lazy, meaning they have no effect until you call methods that consume the iterator to use it up. For example, the code in Listing 13-10 creates an iterator over the items in the vector \"v1\" by calling the \"iter\" method defined on \"Vec\". This code by itself doesn’t do anything useful.\n    let v1 = vec![1, 2, 3];\n\n    let v1_iter = v1.iter();\n\nListing 13-10: Creating an iterator\nThe iterator is stored in the \"v1_iter\" variable. Once we’ve created an iterator, we can use it in a variety of ways. In Listing 3-5 in Chapter 3, we iterated over an array using a \"for\" loop to execute some code on each of its items. Under the hood this implicitly created and then consumed an iterator, but we glossed over how exactly that works until now.\nIn the example in Listing 13-11, we separate the creation of the iterator from the use of the iterator in the \"for\" loop. When the \"for\" loop is called using the iterator in \"v1_iter\", each element in the iterator is used in one iteration of the loop, which prints out each value.\n    let v1 = vec![1, 2, 3];\n\n    let v1_iter = v1.iter();\n\n    for val in v1_iter {\n        println!(\"Got: {}\", val);\n    }\n\nListing 13-11: Using an iterator in a \"for\" loop\nIn languages that don’t have iterators provided by their standard libraries, you would likely write this same functionality by starting a variable at index 0, using that variable to index into the vector to get a value, and incrementing the variable value in a loop until it reached the total number of items in the vector.\nIterators handle all that logic for you, cutting down on repetitive code you could potentially mess up. Iterators give you more flexibility to use the same logic with many different kinds of sequences, not just data structures you can index into, like vectors. Let’s examine how iterators do that.\nThe \"Iterator\" Trait and the \"next\" Method\nAll iterators implement a trait named \"Iterator\" that is defined in the standard library. The definition of the trait looks like this:\npub trait Iterator {\n    type Item;\n\n    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;\n\n    // methods with default implementations elided\n}\n\nNotice this definition uses some new syntax: \"type Item\" and \"Self::Item\", which are defining an associated type with this trait. We’ll talk about associated types in depth in Chapter 19. For now, all you need to know is that this code says implementing the \"Iterator\" trait requires that you also define an \"Item\" type, and this \"Item\" type is used in the return type of the \"next\" method. In other words, the \"Item\" type will be the type returned from the iterator.\nThe \"Iterator\" trait only requires implementors to define one method: the \"next\" method, which returns one item of the iterator at a time wrapped in \"Some\" and, when iteration is over, returns \"None\".\nWe can call the \"next\" method on iterators directly; Listing 13-12 demonstrates what values are returned from repeated calls to \"next\" on the iterator created from the vector.\nFilename: src/lib.rs\n    #[test]\n    fn iterator_demonstration() {\n        let v1 = vec![1, 2, 3];\n\n        let mut v1_iter = v1.iter();\n\n        assert_eq!(v1_iter.next(), Some(&amp;1));\n        assert_eq!(v1_iter.next(), Some(&amp;2));\n        assert_eq!(v1_iter.next(), Some(&amp;3));\n        assert_eq!(v1_iter.next(), None);\n    }\n\nListing 13-12: Calling the \"next\" method on an iterator\nNote that we needed to make \"v1_iter\" mutable: calling the \"next\" method on an iterator changes internal state that the iterator uses to keep track of where it is in the sequence. In other words, this code consumes, or uses up, the iterator. Each call to \"next\" eats up an item from the iterator. We didn’t need to make \"v1_iter\" mutable when we used a \"for\" loop because the loop took ownership of \"v1_iter\" and made it mutable behind the scenes.\nAlso note that the values we get from the calls to \"next\" are immutable references to the values in the vector. The \"iter\" method produces an iterator over immutable references. If we want to create an iterator that takes ownership of \"v1\" and returns owned values, we can call \"into_iter\" instead of \"iter\". Similarly, if we want to iterate over mutable references, we can call \"iter_mut\" instead of \"iter\".\nMethods that Consume the Iterator\nThe \"Iterator\" trait has a number of different methods with default implementations provided by the standard library; you can find out about these methods by looking in the standard library API documentation for the \"Iterator\" trait. Some of these methods call the \"next\" method in their definition, which is why you’re required to implement the \"next\" method when implementing the \"Iterator\" trait.\nMethods that call \"next\" are called consuming adaptors, because calling them uses up the iterator. One example is the \"sum\" method, which takes ownership of the iterator and iterates through the items by repeatedly calling \"next\", thus consuming the iterator. As it iterates through, it adds each item to a running total and returns the total when iteration is complete. Listing 13-13 has a test illustrating a use of the \"sum\" method:\nFilename: src/lib.rs\n    #[test]\n    fn iterator_sum() {\n        let v1 = vec![1, 2, 3];\n\n        let v1_iter = v1.iter();\n\n        let total: i32 = v1_iter.sum();\n\n        assert_eq!(total, 6);\n    }\n\nListing 13-13: Calling the \"sum\" method to get the total of all items in the iterator\nWe aren’t allowed to use \"v1_iter\" after the call to \"sum\" because \"sum\" takes ownership of the iterator we call it on.\nMethods that Produce Other Iterators\nIterator adaptors are methods defined on the \"Iterator\" trait that don’t consume the iterator. Instead, they produce different iterators by changing some aspect of the original iterator.\nListing 13-14 shows an example of calling the iterator adaptor method \"map\", which takes a closure to call on each item as the items are iterated through. The \"map\" method returns a new iterator that produces the modified items. The closure here creates a new iterator in which each item from the vector will be incremented by 1:\nFilename: src/main.rs\n    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];\n\n    v1.iter().map(|x| x + 1);\n\nListing 13-14: Calling the iterator adaptor \"map\" to create a new iterator\nHowever, this code produces a warning:\n$ cargo run\n   Compiling iterators v0.1.0 (file:///projects/iterators)\nwarning: unused \"Map\" that must be used\n --&gt; src/main.rs:4:5\n  |\n4 |     v1.iter().map(|x| x + 1);\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: iterators are lazy and do nothing unless consumed\n  = note: \"#[warn(unused_must_use)]\" on by default\n\nwarning: \"iterators\" (bin \"iterators\") generated 1 warning\n    Finished dev [unoptimized + debuginfo] target(s) in 0.47s\n     Running \"target/debug/iterators\"\n\nThe code in Listing 13-14 doesn’t do anything; the closure we’ve specified never gets called. The warning reminds us why: iterator adaptors are lazy, and we need to consume the iterator here.\nTo fix this warning and consume the iterator, we’ll use the \"collect\" method, which we used in Chapter 12 with \"env::args\" in Listing 12-1. This method consumes the iterator and collects the resulting values into a collection data type.\nIn Listing 13-15, we collect the results of iterating over the iterator that’s returned from the call to \"map\" into a vector. This vector will end up containing each item from the original vector incremented by 1.\nFilename: src/main.rs\n    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];\n\n    let v2: Vec&lt;_&gt; = v1.iter().map(|x| x + 1).collect();\n\n    assert_eq!(v2, vec![2, 3, 4]);\n\nListing 13-15: Calling the \"map\" method to create a new iterator and then calling the \"collect\" method to consume the new iterator and create a vector\nBecause \"map\" takes a closure, we can specify any operation we want to perform on each item. This is a great example of how closures let you customize some behavior while reusing the iteration behavior that the \"Iterator\" trait provides.\nYou can chain multiple calls to iterator adaptors to perform complex actions in a readable way. But because all iterators are lazy, you have to call one of the consuming adaptor methods to get results from calls to iterator adaptors.\nUsing Closures that Capture Their Environment\nMany iterator adapters take closures as arguments, and commonly the closures we’ll specify as arguments to iterator adapters will be closures that capture their environment.\nFor this example, we’ll use the \"filter\" method that takes a closure. The closure gets an item from the iterator and returns a \"bool\". If the closure returns \"true\", the value will be included in the iteration produced by \"filter\". If the closure returns \"false\", the value won’t be included.\nIn Listing 13-16, we use \"filter\" with a closure that captures the \"shoe_size\" variable from its environment to iterate over a collection of \"Shoe\" struct instances. It will return only shoes that are the specified size.\nFilename: src/lib.rs\n#[derive(PartialEq, Debug)]\nstruct Shoe {\n    size: u32,\n    style: String,\n}\n\nfn shoes_in_size(shoes: Vec&lt;Shoe&gt;, shoe_size: u32) -&gt; Vec&lt;Shoe&gt; {\n    shoes.into_iter().filter(|s| s.size == shoe_size).collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn filters_by_size() {\n        let shoes = vec![\n            Shoe {\n                size: 10,\n                style: String::from(\"sneaker\"),\n            },\n            Shoe {\n                size: 13,\n                style: String::from(\"sandal\"),\n            },\n            Shoe {\n                size: 10,\n                style: String::from(\"boot\"),\n            },\n        ];\n\n        let in_my_size = shoes_in_size(shoes, 10);\n\n        assert_eq!(\n            in_my_size,\n            vec![\n                Shoe {\n                    size: 10,\n                    style: String::from(\"sneaker\")\n                },\n                Shoe {\n                    size: 10,\n                    style: String::from(\"boot\")\n                },\n            ]\n        );\n    }\n}\n\nListing 13-16: Using the \"filter\" method with a closure that captures \"shoe_size\"\nThe \"shoes_in_size\" function takes ownership of a vector of shoes and a shoe size as parameters. It returns a vector containing only shoes of the specified size.\nIn the body of \"shoes_in_size\", we call \"into_iter\" to create an iterator that takes ownership of the vector. Then we call \"filter\" to adapt that iterator into a new iterator that only contains elements for which the closure returns \"true\".\nThe closure captures the \"shoe_size\" parameter from the environment and compares the value with each shoe’s size, keeping only shoes of the size specified. Finally, calling \"collect\" gathers the values returned by the adapted iterator into a vector that’s returned by the function.\nThe test shows that when we call \"shoes_in_size\", we get back only shoes that have the same size as the value we specified.\n\nImproving Our I/O Project\nWith this new knowledge about iterators, we can improve the I/O project in Chapter 12 by using iterators to make places in the code clearer and more concise. Let’s look at how iterators can improve our implementation of the \"Config::build\" function and the \"search\" function.\nRemoving a \"clone\" Using an Iterator\nIn Listing 12-6, we added code that took a slice of \"String\" values and created an instance of the \"Config\" struct by indexing into the slice and cloning the values, allowing the \"Config\" struct to own those values. In Listing 13-17, we’ve reproduced the implementation of the \"Config::build\" function as it was in Listing 12-23:\nFilename: src/lib.rs\nimpl Config {\n    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;\"static str&gt; {\n        if args.len() &lt; 3 {\n            return Err(\"not enough arguments\");\n        }\n\n        let query = args[1].clone();\n        let file_path = args[2].clone();\n\n        let ignore_case = env::var(\"IGNORE_CASE\").is_ok();\n\n        Ok(Config {\n            query,\n            file_path,\n            ignore_case,\n        })\n    }\n}\n\nListing 13-17: Reproduction of the \"Config::build\" function from Listing 12-23\nAt the time, we said not to worry about the inefficient \"clone\" calls because we would remove them in the future. Well, that time is now!\nWe needed \"clone\" here because we have a slice with \"String\" elements in the parameter \"args\", but the \"build\" function doesn’t own \"args\". To return ownership of a \"Config\" instance, we had to clone the values from the \"query\" and \"file_path\" fields of \"Config\" so the \"Config\" instance can own its values.\nWith our new knowledge about iterators, we can change the \"build\" function to take ownership of an iterator as its argument instead of borrowing a slice. We’ll use the iterator functionality instead of the code that checks the length of the slice and indexes into specific locations. This will clarify what the \"Config::build\" function is doing because the iterator will access the values.\nOnce \"Config::build\" takes ownership of the iterator and stops using indexing operations that borrow, we can move the \"String\" values from the iterator into \"Config\" rather than calling \"clone\" and making a new allocation.\nUsing the Returned Iterator Directly\nOpen your I/O project’s src/main.rs file, which should look like this:\nFilename: src/main.rs\nfn main() {\n    let args: Vec&lt;String&gt; = env::args().collect();\n\n    let config = Config::build(&amp;args).unwrap_or_else(|err| {\n        eprintln!(\"Problem parsing arguments: {err}\");\n        process::exit(1);\n    });\n\n    // --snip--\n}\n\nWe’ll first change the start of the \"main\" function that we had in Listing 12-24 to the code in Listing 13-18, which this time uses an iterator. This won’t compile until we update \"Config::build\" as well.\nFilename: src/main.rs\nfn main() {\n    let config = Config::build(env::args()).unwrap_or_else(|err| {\n        eprintln!(\"Problem parsing arguments: {err}\");\n        process::exit(1);\n    });\n\n    // --snip--\n}\n\nListing 13-18: Passing the return value of \"env::args\" to \"Config::build\"\nThe \"env::args\" function returns an iterator! Rather than collecting the iterator values into a vector and then passing a slice to \"Config::build\", now we’re passing ownership of the iterator returned from \"env::args\" to \"Config::build\" directly.\nNext, we need to update the definition of \"Config::build\". In your I/O project’s src/lib.rs file, let’s change the signature of \"Config::build\" to look like Listing 13-19. This still won’t compile because we need to update the function body.\nFilename: src/lib.rs\nimpl Config {\n    pub fn build(\n        mut args: impl Iterator&lt;Item = String&gt;,\n    ) -&gt; Result&lt;Config, &amp;\"static str&gt; {\n        // --snip--\n\nListing 13-19: Updating the signature of \"Config::build\" to expect an iterator\nThe standard library documentation for the \"env::args\" function shows that the type of the iterator it returns is \"std::env::Args\", and that type implements the \"Iterator\" trait and returns \"String\" values.\nWe’ve updated the signature of the \"Config::build\" function so the parameter \"args\" has a generic type with the trait bounds \"impl Iterator&lt;Item = String&gt;\" instead of \"&amp;[String]\". This usage of the \"impl Trait\" syntax we discussed in the “Traits as Parameters” section of Chapter 10 means that \"args\" can be any type that implements the \"Iterator\" type and returns \"String\" items.\nBecause we’re taking ownership of \"args\" and we’ll be mutating \"args\" by iterating over it, we can add the \"mut\" keyword into the specification of the \"args\" parameter to make it mutable.\nUsing \"Iterator\" Trait Methods Instead of Indexing\nNext, we’ll fix the body of \"Config::build\". Because \"args\" implements the \"Iterator\" trait, we know we can call the \"next\" method on it! Listing 13-20 updates the code from Listing 12-23 to use the \"next\" method:\nFilename: src/lib.rs\nimpl Config {\n    pub fn build(\n        mut args: impl Iterator&lt;Item = String&gt;,\n    ) -&gt; Result&lt;Config, &amp;\"static str&gt; {\n        args.next();\n\n        let query = match args.next() {\n            Some(arg) =&gt; arg,\n            None =&gt; return Err(\"Didn\"t get a query string\"),\n        };\n\n        let file_path = match args.next() {\n            Some(arg) =&gt; arg,\n            None =&gt; return Err(\"Didn\"t get a file path\"),\n        };\n\n        let ignore_case = env::var(\"IGNORE_CASE\").is_ok();\n\n        Ok(Config {\n            query,\n            file_path,\n            ignore_case,\n        })\n    }\n}\n\nListing 13-20: Changing the body of \"Config::build\" to use iterator methods\nRemember that the first value in the return value of \"env::args\" is the name of the program. We want to ignore that and get to the next value, so first we call \"next\" and do nothing with the return value. Second, we call \"next\" to get the value we want to put in the \"query\" field of \"Config\". If \"next\" returns a \"Some\", we use a \"match\" to extract the value. If it returns \"None\", it means not enough arguments were given and we return early with an \"Err\" value. We do the same thing for the \"file_path\" value.\nMaking Code Clearer with Iterator Adaptors\nWe can also take advantage of iterators in the \"search\" function in our I/O project, which is reproduced here in Listing 13-21 as it was in Listing 12-19:\nFilename: src/lib.rs\npub fn search&lt;\"a&gt;(query: &amp;str, contents: &amp;\"a str) -&gt; Vec&lt;&amp;\"a str&gt; {\n    let mut results = Vec::new();\n\n    for line in contents.lines() {\n        if line.contains(query) {\n            results.push(line);\n        }\n    }\n\n    results\n}\n\nListing 13-21: The implementation of the \"search\" function from Listing 12-19\nWe can write this code in a more concise way using iterator adaptor methods. Doing so also lets us avoid having a mutable intermediate \"results\" vector. The functional programming style prefers to minimize the amount of mutable state to make code clearer. Removing the mutable state might enable a future enhancement to make searching happen in parallel, because we wouldn’t have to manage concurrent access to the \"results\" vector. Listing 13-22 shows this change:\nFilename: src/lib.rs\npub fn search&lt;\"a&gt;(query: &amp;str, contents: &amp;\"a str) -&gt; Vec&lt;&amp;\"a str&gt; {\n    contents\n        .lines()\n        .filter(|line| line.contains(query))\n        .collect()\n}\n\nListing 13-22: Using iterator adaptor methods in the implementation of the \"search\" function\nRecall that the purpose of the \"search\" function is to return all lines in \"contents\" that contain the \"query\". Similar to the \"filter\" example in Listing 13-16, this code uses the \"filter\" adaptor to keep only the lines that \"line.contains(query)\" returns \"true\" for. We then collect the matching lines into another vector with \"collect\". Much simpler! Feel free to make the same change to use iterator methods in the \"search_case_insensitive\" function as well.\nChoosing Between Loops or Iterators\nThe next logical question is which style you should choose in your own code and why: the original implementation in Listing 13-21 or the version using iterators in Listing 13-22. Most Rust programmers prefer to use the iterator style. It’s a bit tougher to get the hang of at first, but once you get a feel for the various iterator adaptors and what they do, iterators can be easier to understand. Instead of fiddling with the various bits of looping and building new vectors, the code focuses on the high-level objective of the loop. This abstracts away some of the commonplace code so it’s easier to see the concepts that are unique to this code, such as the filtering condition each element in the iterator must pass.\nBut are the two implementations truly equivalent? The intuitive assumption might be that the more low-level loop will be faster. Let’s talk about performance.\n\nComparing Performance: Loops vs. Iterators\nTo determine whether to use loops or iterators, you need to know which implementation is faster: the version of the \"search\" function with an explicit \"for\" loop or the version with iterators.\nWe ran a benchmark by loading the entire contents of The Adventures of Sherlock Holmes by Sir Arthur Conan Doyle into a \"String\" and looking for the word the in the contents. Here are the results of the benchmark on the version of \"search\" using the \"for\" loop and the version using iterators:\ntest bench_search_for  ... bench:  19,620,300 ns/iter (+/- 915,700)\ntest bench_search_iter ... bench:  19,234,900 ns/iter (+/- 657,200)\n\nThe iterator version was slightly faster! We won’t explain the benchmark code here, because the point is not to prove that the two versions are equivalent but to get a general sense of how these two implementations compare performance-wise.\nFor a more comprehensive benchmark, you should check using various texts of various sizes as the \"contents\", different words and words of different lengths as the \"query\", and all kinds of other variations. The point is this: iterators, although a high-level abstraction, get compiled down to roughly the same code as if you’d written the lower-level code yourself. Iterators are one of Rust’s zero-cost abstractions, by which we mean using the abstraction imposes no additional runtime overhead. This is analogous to how Bjarne Stroustrup, the original designer and implementor of C++, defines zero-overhead in “Foundations of C++” (2012):\n\nIn general, C++ implementations obey the zero-overhead principle: What you don’t use, you don’t pay for. And further: What you do use, you couldn’t hand code any better.\n\nAs another example, the following code is taken from an audio decoder. The decoding algorithm uses the linear prediction mathematical operation to estimate future values based on a linear function of the previous samples. This code uses an iterator chain to do some math on three variables in scope: a \"buffer\" slice of data, an array of 12 \"coefficients\", and an amount by which to shift data in \"qlp_shift\". We’ve declared the variables within this example but not given them any values; although this code doesn’t have much meaning outside of its context, it’s still a concise, real-world example of how Rust translates high-level ideas to low-level code.\nlet buffer: &amp;mut [i32];\nlet coefficients: [i64; 12];\nlet qlp_shift: i16;\n\nfor i in 12..buffer.len() {\n    let prediction = coefficients.iter()\n                                 .zip(&amp;buffer[i - 12..i])\n                                 .map(|(&amp;c, &amp;s)| c * s as i64)\n                                 .sum::&lt;i64&gt;() &gt;&gt; qlp_shift;\n    let delta = buffer[i];\n    buffer[i] = prediction as i32 + delta;\n}\n\nTo calculate the value of \"prediction\", this code iterates through each of the 12 values in \"coefficients\" and uses the \"zip\" method to pair the coefficient values with the previous 12 values in \"buffer\". Then, for each pair, we multiply the values together, sum all the results, and shift the bits in the sum \"qlp_shift\" bits to the right.\nCalculations in applications like audio decoders often prioritize performance most highly. Here, we’re creating an iterator, using two adaptors, and then consuming the value. What assembly code would this Rust code compile to? Well, as of this writing, it compiles down to the same assembly you’d write by hand. There’s no loop at all corresponding to the iteration over the values in \"coefficients\": Rust knows that there are 12 iterations, so it “unrolls” the loop. Unrolling is an optimization that removes the overhead of the loop controlling code and instead generates repetitive code for each iteration of the loop.\nAll of the coefficients get stored in registers, which means accessing the values is very fast. There are no bounds checks on the array access at runtime. All these optimizations that Rust is able to apply make the resulting code extremely efficient. Now that you know this, you can use iterators and closures without fear! They make code seem like it’s higher level but don’t impose a runtime performance penalty for doing so.\nSummary\nClosures and iterators are Rust features inspired by functional programming language ideas. They contribute to Rust’s capability to clearly express high-level ideas at low-level performance. The implementations of closures and iterators are such that runtime performance is not affected. This is part of Rust’s goal to strive to provide zero-cost abstractions.\nNow that we’ve improved the expressiveness of our I/O project, let’s look at some more features of \"cargo\" that will help us share the project with the world.\n\n14\nMore About Cargo and Crates.io\nSo far we’ve used only the most basic features of Cargo to build, run, and test our code, but it can do a lot more. In this chapter, we’ll discuss some of its other, more advanced features to show you how to do the following:\n\nCustomize your build through release profiles\nPublish libraries on crates.io\nOrganize large projects with workspaces\nInstall binaries from crates.io\nExtend Cargo using custom commands\n\nCargo can do even more than the functionality we cover in this chapter, so for a full explanation of all its features, see its documentation.\n\nCustomizing Builds with Release Profiles\nIn Rust, release profiles are predefined and customizable profiles with different configurations that allow a programmer to have more control over various options for compiling code. Each profile is configured independently of the others.\nCargo has two main profiles: the \"dev\" profile Cargo uses when you run \"cargo build\" and the \"release\" profile Cargo uses when you run \"cargo build --release\". The \"dev\" profile is defined with good defaults for development, and the \"release\" profile has good defaults for release builds.\nThese profile names might be familiar from the output of your builds:\n$ cargo build\n    Finished dev [unoptimized + debuginfo] target(s) in 0.0s\n$ cargo build --release\n    Finished release [optimized] target(s) in 0.0s\n\nThe \"dev\" and \"release\" are these different profiles used by the compiler.\nCargo has default settings for each of the profiles that apply when you haven\"t explicitly added any \"[profile.]\" sections in the project’s Cargo.toml file. By adding \"[profile.]\" sections for any profile you want to customize, you override any subset of the default settings. For example, here are the default values for the \"opt-level\" setting for the \"dev\" and \"release\" profiles:\nFilename: Cargo.toml\n[profile.dev]\nopt-level = 0\n\n[profile.release]\nopt-level = 3\n\nThe \"opt-level\" setting controls the number of optimizations Rust will apply to your code, with a range of 0 to 3. Applying more optimizations extends compiling time, so if you’re in development and compiling your code often, you’ll want fewer optimizations to compile faster even if the resulting code runs slower. The default \"opt-level\" for \"dev\" is therefore \"0\". When you’re ready to release your code, it’s best to spend more time compiling. You’ll only compile in release mode once, but you’ll run the compiled program many times, so release mode trades longer compile time for code that runs faster. That is why the default \"opt-level\" for the \"release\" profile is \"3\".\nYou can override a default setting by adding a different value for it in Cargo.toml. For example, if we want to use optimization level 1 in the development profile, we can add these two lines to our project’s Cargo.toml file:\nFilename: Cargo.toml\n[profile.dev]\nopt-level = 1\n\nThis code overrides the default setting of \"0\". Now when we run \"cargo build\", Cargo will use the defaults for the \"dev\" profile plus our customization to \"opt-level\". Because we set \"opt-level\" to \"1\", Cargo will apply more optimizations than the default, but not as many as in a release build.\nFor the full list of configuration options and defaults for each profile, see Cargo’s documentation.\n\nPublishing a Crate to Crates.io\nWe’ve used packages from crates.io as dependencies of our project, but you can also share your code with other people by publishing your own packages. The crate registry at crates.io distributes the source code of your packages, so it primarily hosts code that is open source.\nRust and Cargo have features that make your published package easier for people to find and use. We’ll talk about some of these features next and then explain how to publish a package.\nMaking Useful Documentation Comments\nAccurately documenting your packages will help other users know how and when to use them, so it’s worth investing the time to write documentation. In Chapter 3, we discussed how to comment Rust code using two slashes, \"//\". Rust also has a particular kind of comment for documentation, known conveniently as a documentation comment, that will generate HTML documentation. The HTML displays the contents of documentation comments for public API items intended for programmers interested in knowing how to use your crate as opposed to how your crate is implemented.\nDocumentation comments use three slashes, \"///\", instead of two and support Markdown notation for formatting the text. Place documentation comments just before the item they’re documenting. Listing 14-1 shows documentation comments for an \"add_one\" function in a crate named \"my_crate\".\nFilename: src/lib.rs\n/// Adds one to the number given.\n///\n/// # Examples\n///\n/// ```\n/// let arg = 5;\n/// let answer = my_crate::add_one(arg);\n///\n/// assert_eq!(6, answer);\n/// ```\npub fn add_one(x: i32) -&gt; i32 {\n    x + 1\n}\n\nListing 14-1: A documentation comment for a function\nHere, we give a description of what the \"add_one\" function does, start a section with the heading \"Examples\", and then provide code that demonstrates how to use the \"add_one\" function. We can generate the HTML documentation from this documentation comment by running \"cargo doc\". This command runs the \"rustdoc\" tool distributed with Rust and puts the generated HTML documentation in the target/doc directory.\nFor convenience, running \"cargo doc --open\" will build the HTML for your current crate’s documentation (as well as the documentation for all of your crate’s dependencies) and open the result in a web browser. Navigate to the \"add_one\" function and you’ll see how the text in the documentation comments is rendered, as shown in Figure 14-1:\n\nFigure 14-1: HTML documentation for the \"add_one\" function\nCommonly Used Sections\nWe used the \"# Examples\" Markdown heading in Listing 14-1 to create a section in the HTML with the title “Examples.” Here are some other sections that crate authors commonly use in their documentation:\n\nPanics: The scenarios in which the function being documented could panic. Callers of the function who don’t want their programs to panic should make sure they don’t call the function in these situations.\nErrors: If the function returns a \"Result\", describing the kinds of errors that might occur and what conditions might cause those errors to be returned can be helpful to callers so they can write code to handle the different kinds of errors in different ways.\nSafety: If the function is \"unsafe\" to call (we discuss unsafety in Chapter 19), there should be a section explaining why the function is unsafe and covering the invariants that the function expects callers to uphold.\n\nMost documentation comments don’t need all of these sections, but this is a good checklist to remind you of the aspects of your code users will be interested in knowing about.\nDocumentation Comments as Tests\nAdding example code blocks in your documentation comments can help demonstrate how to use your library, and doing so has an additional bonus: running \"cargo test\" will run the code examples in your documentation as tests! Nothing is better than documentation with examples. But nothing is worse than examples that don’t work because the code has changed since the documentation was written. If we run \"cargo test\" with the documentation for the \"add_one\" function from Listing 14-1, we will see a section in the test results like this:\n   Doc-tests my_crate\n\nrunning 1 test\ntest src/lib.rs - add_one (line 5) ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.27s\n\nNow if we change either the function or the example so the \"assert_eq!\" in the example panics and run \"cargo test\" again, we’ll see that the doc tests catch that the example and the code are out of sync with each other!\nCommenting Contained Items\nThe style of doc comment \"//!\" adds documentation to the item that contains the comments rather than to the items following the comments. We typically use these doc comments inside the crate root file (src/lib.rs by convention) or inside a module to document the crate or the module as a whole.\nFor example, to add documentation that describes the purpose of the \"my_crate\" crate that contains the \"add_one\" function, we add documentation comments that start with \"//!\" to the beginning of the src/lib.rs file, as shown in Listing 14-2:\nFilename: src/lib.rs\n//! # My Crate\n//!\n//! \"my_crate\" is a collection of utilities to make performing certain\n//! calculations more convenient.\n\n/// Adds one to the number given.\n// --snip--\n\nListing 14-2: Documentation for the \"my_crate\" crate as a whole\nNotice there isn’t any code after the last line that begins with \"//!\". Because we started the comments with \"//!\" instead of \"///\", we’re documenting the item that contains this comment rather than an item that follows this comment. In this case, that item is the src/lib.rs file, which is the crate root. These comments describe the entire crate.\nWhen we run \"cargo doc --open\", these comments will display on the front page of the documentation for \"my_crate\" above the list of public items in the crate, as shown in Figure 14-2:\n\nFigure 14-2: Rendered documentation for \"my_crate\", including the comment describing the crate as a whole\nDocumentation comments within items are useful for describing crates and modules especially. Use them to explain the overall purpose of the container to help your users understand the crate’s organization.\nExporting a Convenient Public API with \"pub use\"\nThe structure of your public API is a major consideration when publishing a crate. People who use your crate are less familiar with the structure than you are and might have difficulty finding the pieces they want to use if your crate has a large module hierarchy.\nIn Chapter 7, we covered how to make items public using the \"pub\" keyword, and bring items into a scope with the \"use\" keyword. However, the structure that makes sense to you while you’re developing a crate might not be very convenient for your users. You might want to organize your structs in a hierarchy containing multiple levels, but then people who want to use a type you’ve defined deep in the hierarchy might have trouble finding out that type exists. They might also be annoyed at having to enter \"use\" \"my_crate::some_module::another_module::UsefulType;\" rather than \"use\" \"my_crate::UsefulType;\".\nThe good news is that if the structure isn’t convenient for others to use from another library, you don’t have to rearrange your internal organization: instead, you can re-export items to make a public structure that’s different from your private structure by using \"pub use\". Re-exporting takes a public item in one location and makes it public in another location, as if it were defined in the other location instead.\nFor example, say we made a library named \"art\" for modeling artistic concepts. Within this library are two modules: a \"kinds\" module containing two enums named \"PrimaryColor\" and \"SecondaryColor\" and a \"utils\" module containing a function named \"mix\", as shown in Listing 14-3:\nFilename: src/lib.rs\n//! # Art\n//!\n//! A library for modeling artistic concepts.\n\npub mod kinds {\n    /// The primary colors according to the RYB color model.\n    pub enum PrimaryColor {\n        Red,\n        Yellow,\n        Blue,\n    }\n\n    /// The secondary colors according to the RYB color model.\n    pub enum SecondaryColor {\n        Orange,\n        Green,\n        Purple,\n    }\n}\n\npub mod utils {\n    use crate::kinds::*;\n\n    /// Combines two primary colors in equal amounts to create\n    /// a secondary color.\n    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -&gt; SecondaryColor {\n        // --snip--\n    }\n}\n\nListing 14-3: An \"art\" library with items organized into \"kinds\" and \"utils\" modules\nFigure 14-3 shows what the front page of the documentation for this crate generated by \"cargo doc\" would look like:\n\nFigure 14-3: Front page of the documentation for \"art\" that lists the \"kinds\" and \"utils\" modules\nNote that the \"PrimaryColor\" and \"SecondaryColor\" types aren’t listed on the front page, nor is the \"mix\" function. We have to click \"kinds\" and \"utils\" to see them.\nAnother crate that depends on this library would need \"use\" statements that bring the items from \"art\" into scope, specifying the module structure that’s currently defined. Listing 14-4 shows an example of a crate that uses the \"PrimaryColor\" and \"mix\" items from the \"art\" crate:\nFilename: src/main.rs\nuse art::kinds::PrimaryColor;\nuse art::utils::mix;\n\nfn main() {\n    let red = PrimaryColor::Red;\n    let yellow = PrimaryColor::Yellow;\n    mix(red, yellow);\n}\n\nListing 14-4: A crate using the \"art\" crate’s items with its internal structure exported\nThe author of the code in Listing 14-4, which uses the \"art\" crate, had to figure out that \"PrimaryColor\" is in the \"kinds\" module and \"mix\" is in the \"utils\" module. The module structure of the \"art\" crate is more relevant to developers working on the \"art\" crate than to those using it. The internal structure doesn’t contain any useful information for someone trying to understand how to use the \"art\" crate, but rather causes confusion because developers who use it have to figure out where to look, and must specify the module names in the \"use\" statements.\nTo remove the internal organization from the public API, we can modify the \"art\" crate code in Listing 14-3 to add \"pub use\" statements to re-export the items at the top level, as shown in Listing 14-5:\nFilename: src/lib.rs\n//! # Art\n//!\n//! A library for modeling artistic concepts.\n\npub use self::kinds::PrimaryColor;\npub use self::kinds::SecondaryColor;\npub use self::utils::mix;\n\npub mod kinds {\n    // --snip--\n}\n\npub mod utils {\n    // --snip--\n}\n\nListing 14-5: Adding \"pub use\" statements to re-export items\nThe API documentation that \"cargo doc\" generates for this crate will now list and link re-exports on the front page, as shown in Figure 14-4, making the \"PrimaryColor\" and \"SecondaryColor\" types and the \"mix\" function easier to find.\n\nFigure 14-4: The front page of the documentation for \"art\" that lists the re-exports\nThe \"art\" crate users can still see and use the internal structure from Listing 14-3 as demonstrated in Listing 14-4, or they can use the more convenient structure in Listing 14-5, as shown in Listing 14-6:\nFilename: src/main.rs\nuse art::mix;\nuse art::PrimaryColor;\n\nfn main() {\n    // --snip--\n}\n\nListing 14-6: A program using the re-exported items from the \"art\" crate\nIn cases where there are many nested modules, re-exporting the types at the top level with \"pub use\" can make a significant difference in the experience of people who use the crate. Another common use of \"pub use\" is to re-export definitions of a dependency in the current crate to make that crate\"s definitions part of your crate’s public API.\nCreating a useful public API structure is more of an art than a science, and you can iterate to find the API that works best for your users. Choosing \"pub use\" gives you flexibility in how you structure your crate internally and decouples that internal structure from what you present to your users. Look at some of the code of crates you’ve installed to see if their internal structure differs from their public API.\nSetting Up a Crates.io Account\nBefore you can publish any crates, you need to create an account on crates.io and get an API token. To do so, visit the home page at crates.io and log in via a GitHub account. (The GitHub account is currently a requirement, but the site might support other ways of creating an account in the future.) Once you’re logged in, visit your account settings at https://crates.io/me/ and retrieve your API key. Then run the \"cargo login\" command with your API key, like this:\n$ cargo login abcdefghijklmnopqrstuvwxyz012345\n\nThis command will inform Cargo of your API token and store it locally in ~/.cargo/credentials. Note that this token is a secret: do not share it with anyone else. If you do share it with anyone for any reason, you should revoke it and generate a new token on crates.io.\nAdding Metadata to a New Crate\nLet’s say you have a crate you want to publish. Before publishing, you’ll need to add some metadata in the \"[package]\" section of the crate’s Cargo.toml file.\nYour crate will need a unique name. While you’re working on a crate locally, you can name a crate whatever you’d like. However, crate names on crates.io are allocated on a first-come, first-served basis. Once a crate name is taken, no one else can publish a crate with that name. Before attempting to publish a crate, search for the name you want to use. If the name has been used, you will need to find another name and edit the \"name\" field in the Cargo.toml file under the \"[package]\" section to use the new name for publishing, like so:\nFilename: Cargo.toml\n[package]\nname = \"guessing_game\"\n\nEven if you’ve chosen a unique name, when you run \"cargo publish\" to publish the crate at this point, you’ll get a warning and then an error:\n$ cargo publish\n    Updating crates.io index\nwarning: manifest has no description, license, license-file, documentation, homepage or repository.\nSee https://doc.rust-lang.org/cargo/reference/manifest.html#package-metadata for more info.\n--snip--\nerror: failed to publish to registry at https://crates.io\n\nCaused by:\n  the remote server responded with an error: missing or empty metadata fields: description, license. Please see https://doc.rust-lang.org/cargo/reference/manifest.html for how to upload metadata\n\nThis errors because you’re missing some crucial information: a description and license are required so people will know what your crate does and under what terms they can use it. In Cargo.toml, add a description that\"s just a sentence or two, because it will appear with your crate in search results. For the \"license\" field, you need to give a license identifier value. The Linux Foundation’s Software Package Data Exchange (SPDX) lists the identifiers you can use for this value. For example, to specify that you’ve licensed your crate using the MIT License, add the \"MIT\" identifier:\nFilename: Cargo.toml\n[package]\nname = \"guessing_game\"\nlicense = \"MIT\"\n\nIf you want to use a license that doesn’t appear in the SPDX, you need to place the text of that license in a file, include the file in your project, and then use \"license-file\" to specify the name of that file instead of using the \"license\" key.\nGuidance on which license is appropriate for your project is beyond the scope of this book. Many people in the Rust community license their projects in the same way as Rust by using a dual license of \"MIT OR Apache-2.0\". This practice demonstrates that you can also specify multiple license identifiers separated by \"OR\" to have multiple licenses for your project.\nWith a unique name, the version, your description, and a license added, the Cargo.toml file for a project that is ready to publish might look like this:\nFilename: Cargo.toml\n[package]\nname = \"guessing_game\"\nversion = \"0.1.0\"\nedition = \"2021\"\ndescription = \"A fun game where you guess what number the computer has chosen.\"\nlicense = \"MIT OR Apache-2.0\"\n\n[dependencies]\n\nCargo’s documentation describes other metadata you can specify to ensure others can discover and use your crate more easily.\nPublishing to Crates.io\nNow that you’ve created an account, saved your API token, chosen a name for your crate, and specified the required metadata, you’re ready to publish! Publishing a crate uploads a specific version to crates.io for others to use.\nBe careful, because a publish is permanent. The version can never be overwritten, and the code cannot be deleted. One major goal of crates.io is to act as a permanent archive of code so that builds of all projects that depend on crates from crates.io will continue to work. Allowing version deletions would make fulfilling that goal impossible. However, there is no limit to the number of crate versions you can publish.\nRun the \"cargo publish\" command again. It should succeed now:\n$ cargo publish\n    Updating crates.io index\n   Packaging guessing_game v0.1.0 (file:///projects/guessing_game)\n   Verifying guessing_game v0.1.0 (file:///projects/guessing_game)\n   Compiling guessing_game v0.1.0\n(file:///projects/guessing_game/target/package/guessing_game-0.1.0)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.19s\n   Uploading guessing_game v0.1.0 (file:///projects/guessing_game)\n\nCongratulations! You’ve now shared your code with the Rust community, and anyone can easily add your crate as a dependency of their project.\nPublishing a New Version of an Existing Crate\nWhen you’ve made changes to your crate and are ready to release a new version, you change the \"version\" value specified in your Cargo.toml file and republish. Use the Semantic Versioning rules to decide what an appropriate next version number is based on the kinds of changes you’ve made. Then run \"cargo publish\" to upload the new version.\nDeprecating Versions from Crates.io with \"cargo yank\"\nAlthough you can’t remove previous versions of a crate, you can prevent any future projects from adding them as a new dependency. This is useful when a crate version is broken for one reason or another. In such situations, Cargo supports yanking a crate version.\nYanking a version prevents new projects from depending on that version while allowing all existing projects that depend on it to continue. Essentially, a yank means that all projects with a Cargo.lock will not break, and any future Cargo.lock files generated will not use the yanked version.\nTo yank a version of a crate, in the directory of the crate that you’ve previously published, run \"cargo yank\" and specify which version you want to yank. For example, if we\"ve published a crate named \"guessing_game\" version 1.0.1 and we want to yank it, in the project directory for \"guessing_game\" we\"d run:\n$ cargo yank --vers 1.0.1\n    Updating crates.io index\n        Yank guessing_game@1.0.1\n\nBy adding \"--undo\" to the command, you can also undo a yank and allow projects to start depending on a version again:\n$ cargo yank --vers 1.0.1 --undo\n    Updating crates.io index\n      Unyank guessing_game@1.0.1\n\nA yank does not delete any code. It cannot, for example, delete accidentally uploaded secrets. If that happens, you must reset those secrets immediately.\n\nCargo Workspaces\nIn Chapter 12, we built a package that included a binary crate and a library crate. As your project develops, you might find that the library crate continues to get bigger and you want to split your package further into multiple library crates. Cargo offers a feature called workspaces that can help manage multiple related packages that are developed in tandem.\nCreating a Workspace\nA workspace is a set of packages that share the same Cargo.lock and output directory. Let’s make a project using a workspace—we’ll use trivial code so we can concentrate on the structure of the workspace. There are multiple ways to structure a workspace, so we\"ll just show one common way. We’ll have a workspace containing a binary and two libraries. The binary, which will provide the main functionality, will depend on the two libraries. One library will provide an \"add_one\" function, and a second library an \"add_two\" function. These three crates will be part of the same workspace. We’ll start by creating a new directory for the workspace:\n$ mkdir add\n$ cd add\n\nNext, in the add directory, we create the Cargo.toml file that will configure the entire workspace. This file won’t have a \"[package]\" section. Instead, it will start with a \"[workspace]\" section that will allow us to add members to the workspace by specifying the path to the package with our binary crate; in this case, that path is adder:\nFilename: Cargo.toml\n[workspace]\n\nmembers = [\n    \"adder\",\n]\n\nNext, we’ll create the \"adder\" binary crate by running \"cargo new\" within the add directory:\n$ cargo new adder\n     Created binary (application) \"adder\" package\n\nAt this point, we can build the workspace by running \"cargo build\". The files in your add directory should look like this:\n├── Cargo.lock\n├── Cargo.toml\n├── adder\n│   ├── Cargo.toml\n│   └── src\n│       └── main.rs\n└── target\n\nThe workspace has one target directory at the top level that the compiled artifacts will be placed into; the \"adder\" package doesn’t have its own target directory. Even if we were to run \"cargo build\" from inside the adder directory, the compiled artifacts would still end up in add/target rather than add/adder/target. Cargo structures the target directory in a workspace like this because the crates in a workspace are meant to depend on each other. If each crate had its own target directory, each crate would have to recompile each of the other crates in the workspace to place the artifacts in its own target directory. By sharing one target directory, the crates can avoid unnecessary rebuilding.\nCreating the Second Package in the Workspace\nNext, let’s create another member package in the workspace and call it \"add_one\". Change the top-level Cargo.toml to specify the add_one path in the \"members\" list:\nFilename: Cargo.toml\n[workspace]\n\nmembers = [\n    \"adder\",\n    \"add_one\",\n]\n\nThen generate a new library crate named \"add_one\":\n$ cargo new add_one --lib\n     Created library \"add_one\" package\n\nYour add directory should now have these directories and files:\n├── Cargo.lock\n├── Cargo.toml\n├── add_one\n│   ├── Cargo.toml\n│   └── src\n│       └── lib.rs\n├── adder\n│   ├── Cargo.toml\n│   └── src\n│       └── main.rs\n└── target\n\nIn the add_one/src/lib.rs file, let’s add an \"add_one\" function:\nFilename: add_one/src/lib.rs\npub fn add_one(x: i32) -&gt; i32 {\n    x + 1\n}\n\nNow we can have the \"adder\" package with our binary depend on the \"add_one\" package that has our library. First, we’ll need to add a path dependency on \"add_one\" to adder/Cargo.toml.\nFilename: adder/Cargo.toml\n[dependencies]\nadd_one = { path = \"../add_one\" }\n\nCargo doesn’t assume that crates in a workspace will depend on each other, so we need to be explicit about the dependency relationships.\nNext, let’s use the \"add_one\" function (from the \"add_one\" crate) in the \"adder\" crate. Open the adder/src/main.rs file and add a \"use\" line at the top to bring the new \"add_one\" library crate into scope. Then change the \"main\" function to call the \"add_one\" function, as in Listing 14-7.\nFilename: adder/src/main.rs\nuse add_one;\n\nfn main() {\n    let num = 10;\n    println!(\"Hello, world! {num} plus one is {}!\", add_one::add_one(num));\n}\n\nListing 14-7: Using the \"add_one\" library crate from the \"adder\" crate\nLet’s build the workspace by running \"cargo build\" in the top-level add directory!\n$ cargo build\n   Compiling add_one v0.1.0 (file:///projects/add/add_one)\n   Compiling adder v0.1.0 (file:///projects/add/adder)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.68s\n\nTo run the binary crate from the add directory, we can specify which package in the workspace we want to run by using the \"-p\" argument and the package name with \"cargo run\":\n$ cargo run -p adder\n    Finished dev [unoptimized + debuginfo] target(s) in 0.0s\n     Running \"target/debug/adder\"\nHello, world! 10 plus one is 11!\n\nThis runs the code in adder/src/main.rs, which depends on the \"add_one\" crate.\nDepending on an External Package in a Workspace\nNotice that the workspace has only one Cargo.lock file at the top level, rather than having a Cargo.lock in each crate’s directory. This ensures that all crates are using the same version of all dependencies. If we add the \"rand\" package to the adder/Cargo.toml and add_one/Cargo.toml files, Cargo will resolve both of those to one version of \"rand\" and record that in the one Cargo.lock. Making all crates in the workspace use the same dependencies means the crates will always be compatible with each other. Let’s add the \"rand\" crate to the \"[dependencies]\" section in the add_one/Cargo.toml file so we can use the \"rand\" crate in the \"add_one\" crate:\nFilename: add_one/Cargo.toml\n[dependencies]\nrand = \"0.8.5\"\n\nWe can now add \"use rand;\" to the add_one/src/lib.rs file, and building the whole workspace by running \"cargo build\" in the add directory will bring in and compile the \"rand\" crate. We will get one warning because we aren’t referring to the \"rand\" we brought into scope:\n$ cargo build\n    Updating crates.io index\n  Downloaded rand v0.8.5\n   --snip--\n   Compiling rand v0.8.5\n   Compiling add_one v0.1.0 (file:///projects/add/add_one)\nwarning: unused import: \"rand\"\n --&gt; add_one/src/lib.rs:1:5\n  |\n1 | use rand;\n  |     ^^^^\n  |\n  = note: \"#[warn(unused_imports)]\" on by default\n\nwarning: \"add_one\" (lib) generated 1 warning\n   Compiling adder v0.1.0 (file:///projects/add/adder)\n    Finished dev [unoptimized + debuginfo] target(s) in 10.18s\n\nThe top-level Cargo.lock now contains information about the dependency of \"add_one\" on \"rand\". However, even though \"rand\" is used somewhere in the workspace, we can’t use it in other crates in the workspace unless we add \"rand\" to their Cargo.toml files as well. For example, if we add \"use rand;\" to the adder/src/main.rs file for the \"adder\" package, we’ll get an error:\n$ cargo build\n  --snip--\n   Compiling adder v0.1.0 (file:///projects/add/adder)\nerror[E0432]: unresolved import \"rand\"\n --&gt; adder/src/main.rs:2:5\n  |\n2 | use rand;\n  |     ^^^^ no external crate \"rand\"\n\nTo fix this, edit the Cargo.toml file for the \"adder\" package and indicate that \"rand\" is a dependency for it as well. Building the \"adder\" package will add \"rand\" to the list of dependencies for \"adder\" in Cargo.lock, but no additional copies of \"rand\" will be downloaded. Cargo has ensured that every crate in every package in the workspace using the \"rand\" package will be using the same version, saving us space and ensuring that the crates in the workspace will be compatible with each other.\nAdding a Test to a Workspace\nFor another enhancement, let’s add a test of the \"add_one::add_one\" function within the \"add_one\" crate:\nFilename: add_one/src/lib.rs\npub fn add_one(x: i32) -&gt; i32 {\n    x + 1\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn it_works() {\n        assert_eq!(3, add_one(2));\n    }\n}\n\nNow run \"cargo test\" in the top-level add directory. Running \"cargo test\" in a workspace structured like this one will run the tests for all the crates in the workspace:\n$ cargo test\n   Compiling add_one v0.1.0 (file:///projects/add/add_one)\n   Compiling adder v0.1.0 (file:///projects/add/adder)\n    Finished test [unoptimized + debuginfo] target(s) in 0.27s\n     Running unittests src/lib.rs (target/debug/deps/add_one-f0253159197f7841)\n\nrunning 1 test\ntest tests::it_works ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n     Running unittests src/main.rs (target/debug/deps/adder-49979ff40686fa8e)\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests add_one\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nThe first section of the output shows that the \"it_works\" test in the \"add_one\" crate passed. The next section shows that zero tests were found in the \"adder\" crate, and then the last section shows zero documentation tests were found in the \"add_one\" crate.\nWe can also run tests for one particular crate in a workspace from the top-level directory by using the \"-p\" flag and specifying the name of the crate we want to test:\n$ cargo test -p add_one\n    Finished test [unoptimized + debuginfo] target(s) in 0.00s\n     Running unittests src/lib.rs (target/debug/deps/add_one-b3235fea9a156f74)\n\nrunning 1 test\ntest tests::it_works ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests add_one\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nThis output shows \"cargo test\" only ran the tests for the \"add_one\" crate and didn’t run the \"adder\" crate tests.\nIf you publish the crates in the workspace to crates.io, each crate in the workspace will need to be published separately. Like \"cargo test\", we can publish a particular crate in our workspace by using the \"-p\" flag and specifying the name of the crate we want to publish.\nFor additional practice, add an \"add_two\" crate to this workspace in a similar way as the \"add_one\" crate!\nAs your project grows, consider using a workspace: it’s easier to understand smaller, individual components than one big blob of code. Furthermore, keeping the crates in a workspace can make coordination between crates easier if they are often changed at the same time.\n\nInstalling Binaries with \"cargo install\"\nThe \"cargo install\" command allows you to install and use binary crates locally. This isn’t intended to replace system packages; it’s meant to be a convenient way for Rust developers to install tools that others have shared on crates.io. Note that you can only install packages that have binary targets. A binary target is the runnable program that is created if the crate has a src/main.rs file or another file specified as a binary, as opposed to a library target that isn’t runnable on its own but is suitable for including within other programs. Usually, crates have information in the README file about whether a crate is a library, has a binary target, or both.\nAll binaries installed with \"cargo install\" are stored in the installation root’s bin folder. If you installed Rust using rustup.rs and don’t have any custom configurations, this directory will be $HOME/.cargo/bin. Ensure that directory is in your \"$PATH\" to be able to run programs you’ve installed with \"cargo install\".\nFor example, in Chapter 12 we mentioned that there’s a Rust implementation of the \"grep\" tool called \"ripgrep\" for searching files. To install \"ripgrep\", we can run the following:\n$ cargo install ripgrep\n    Updating crates.io index\n  Downloaded ripgrep v13.0.0\n  Downloaded 1 crate (243.3 KB) in 0.88s\n  Installing ripgrep v13.0.0\n--snip--\n   Compiling ripgrep v13.0.0\n    Finished release [optimized + debuginfo] target(s) in 3m 10s\n  Installing ~/.cargo/bin/rg\n   Installed package \"ripgrep v13.0.0\" (executable \"rg\")\n\nThe second-to-last line of the output shows the location and the name of the installed binary, which in the case of \"ripgrep\" is \"rg\". As long as the installation directory is in your \"$PATH\", as mentioned previously, you can then run \"rg --help\" and start using a faster, rustier tool for searching files!\n\nExtending Cargo with Custom Commands\nCargo is designed so you can extend it with new subcommands without having to modify Cargo. If a binary in your \"$PATH\" is named \"cargo-something\", you can run it as if it was a Cargo subcommand by running \"cargo something\". Custom commands like this are also listed when you run \"cargo --list\". Being able to use \"cargo install\" to install extensions and then run them just like the built-in Cargo tools is a super convenient benefit of Cargo’s design!\nSummary\nSharing code with Cargo and crates.io is part of what makes the Rust ecosystem useful for many different tasks. Rust’s standard library is small and stable, but crates are easy to share, use, and improve on a timeline different from that of the language. Don’t be shy about sharing code that’s useful to you on crates.io; it’s likely that it will be useful to someone else as well!\n\n15\nSmart Pointers\nA pointer is a general concept for a variable that contains an address in memory. This address refers to, or “points at,” some other data. The most common kind of pointer in Rust is a reference, which you learned about in Chapter 4. References are indicated by the \"&amp;\" symbol and borrow the value they point to. They don’t have any special capabilities other than referring to data, and have no overhead.\nSmart pointers, on the other hand, are data structures that act like a pointer but also have additional metadata and capabilities. The concept of smart pointers isn’t unique to Rust: smart pointers originated in C++ and exist in other languages as well. Rust has a variety of smart pointers defined in the standard library that provide functionality beyond that provided by references. To explore the general concept, we’ll look at a couple of different examples of smart pointers, including a reference counting smart pointer type. This pointer enables you to allow data to have multiple owners by keeping track of the number of owners and, when no owners remain, cleaning up the data.\nRust, with its concept of ownership and borrowing, has an additional difference between references and smart pointers: while references only borrow data, in many cases, smart pointers own the data they point to.\nThough we didn’t call them as such at the time, we’ve already encountered a few smart pointers in this book, including \"String\" and \"Vec\" in Chapter 8. Both these types count as smart pointers because they own some memory and allow you to manipulate it. They also have metadata and extra capabilities or guarantees. \"String\", for example, stores its capacity as metadata and has the extra ability to ensure its data will always be valid UTF-8.\nSmart pointers are usually implemented using structs. Unlike an ordinary struct, smart pointers implement the \"Deref\" and \"Drop\" traits. The \"Deref\" trait allows an instance of the smart pointer struct to behave like a reference so you can write your code to work with either references or smart pointers. The \"Drop\" trait allows you to customize the code that’s run when an instance of the smart pointer goes out of scope. In this chapter, we’ll discuss both traits and demonstrate why they’re important to smart pointers.\nGiven that the smart pointer pattern is a general design pattern used frequently in Rust, this chapter won’t cover every existing smart pointer. Many libraries have their own smart pointers, and you can even write your own. We’ll cover the most common smart pointers in the standard library:\n\n\"Box\" for allocating values on the heap\n\"Rc\", a reference counting type that enables multiple ownership\n\"Ref\" and \"RefMut\", accessed through \"RefCell\", a type that enforces the borrowing rules at runtime instead of compile time\n\nIn addition, we’ll cover the interior mutability pattern where an immutable type exposes an API for mutating an interior value. We’ll also discuss reference cycles: how they can leak memory and how to prevent them.\nLet’s dive in!\n\nUsing \"Box\" to Point to Data on the Heap\nThe most straightforward smart pointer is a box, whose type is written \"Box\". Boxes allow you to store data on the heap rather than the stack. What remains on the stack is the pointer to the heap data. Refer to Chapter 4 to review the difference between the stack and the heap.\nBoxes don’t have performance overhead, other than storing their data on the heap instead of on the stack. But they don’t have many extra capabilities either. You’ll use them most often in these situations:\n\nWhen you have a type whose size can’t be known at compile time and you want to use a value of that type in a context that requires an exact size\nWhen you have a large amount of data and you want to transfer ownership but ensure the data won’t be copied when you do so\nWhen you want to own a value and you care only that it’s a type that implements a particular trait rather than being of a specific type\n\nWe’ll demonstrate the first situation in the “Enabling Recursive Types with Boxes” section. In the second case, transferring ownership of a large amount of data can take a long time because the data is copied around on the stack. To improve performance in this situation, we can store the large amount of data on the heap in a box. Then, only the small amount of pointer data is copied around on the stack, while the data it references stays in one place on the heap. The third case is known as a trait object, and Chapter 17 devotes an entire section, “Using Trait Objects That Allow for Values of Different Types,” just to that topic. So what you learn here you’ll apply again in Chapter 17!\nUsing a \"Box\" to Store Data on the Heap\nBefore we discuss the heap storage use case for \"Box\", we’ll cover the syntax and how to interact with values stored within a \"Box\".\nListing 15-1 shows how to use a box to store an \"i32\" value on the heap:\nFilename: src/main.rs\nfn main() {\n    let b = Box::new(5);\n    println!(\"b = {}\", b);\n}\n\nListing 15-1: Storing an \"i32\" value on the heap using a box\nWe define the variable \"b\" to have the value of a \"Box\" that points to the value \"5\", which is allocated on the heap. This program will print \"b = 5\"; in this case, we can access the data in the box similar to how we would if this data were on the stack. Just like any owned value, when a box goes out of scope, as \"b\" does at the end of \"main\", it will be deallocated. The deallocation happens both for the box (stored on the stack) and the data it points to (stored on the heap).\nPutting a single value on the heap isn’t very useful, so you won’t use boxes by themselves in this way very often. Having values like a single \"i32\" on the stack, where they’re stored by default, is more appropriate in the majority of situations. Let’s look at a case where boxes allow us to define types that we wouldn’t be allowed to if we didn’t have boxes.\nEnabling Recursive Types with Boxes\nA value of recursive type can have another value of the same type as part of itself. Recursive types pose an issue because at compile time Rust needs to know how much space a type takes up. However, the nesting of values of recursive types could theoretically continue infinitely, so Rust can’t know how much space the value needs. Because boxes have a known size, we can enable recursive types by inserting a box in the recursive type definition.\nAs an example of a recursive type, let’s explore the cons list. This is a data type commonly found in functional programming languages. The cons list type we’ll define is straightforward except for the recursion; therefore, the concepts in the example we’ll work with will be useful any time you get into more complex situations involving recursive types.\nMore Information About the Cons List\nA cons list is a data structure that comes from the Lisp programming language and its dialects and is made up of nested pairs, and is the Lisp version of a linked list. Its name comes from the \"cons\" function (short for “construct function”) in Lisp that constructs a new pair from its two arguments. By calling \"cons\" on a pair consisting of a value and another pair, we can construct cons lists made up of recursive pairs.\nFor example, here’s a pseudocode representation of a cons list containing the list 1, 2, 3 with each pair in parentheses:\n(1, (2, (3, Nil)))\n\nEach item in a cons list contains two elements: the value of the current item and the next item. The last item in the list contains only a value called \"Nil\" without a next item. A cons list is produced by recursively calling the \"cons\" function. The canonical name to denote the base case of the recursion is \"Nil\". Note that this is not the same as the “null” or “nil” concept in Chapter 6, which is an invalid or absent value.\nThe cons list isn’t a commonly used data structure in Rust. Most of the time when you have a list of items in Rust, \"Vec\" is a better choice to use. Other, more complex recursive data types are useful in various situations, but by starting with the cons list in this chapter, we can explore how boxes let us define a recursive data type without much distraction.\nListing 15-2 contains an enum definition for a cons list. Note that this code won’t compile yet because the \"List\" type doesn’t have a known size, which we’ll demonstrate.\nFilename: src/main.rs\nenum List {\n    Cons(i32, List),\n    Nil,\n}\n\nListing 15-2: The first attempt at defining an enum to represent a cons list data structure of \"i32\" values\n\nNote: We’re implementing a cons list that holds only \"i32\" values for the purposes of this example. We could have implemented it using generics, as we discussed in Chapter 10, to define a cons list type that could store values of any type.\n\nUsing the \"List\" type to store the list \"1, 2, 3\" would look like the code in Listing 15-3:\nFilename: src/main.rs\nuse crate::List::{Cons, Nil};\n\nfn main() {\n    let list = Cons(1, Cons(2, Cons(3, Nil)));\n}\n\nListing 15-3: Using the \"List\" enum to store the list \"1, 2, 3\"\nThe first \"Cons\" value holds \"1\" and another \"List\" value. This \"List\" value is another \"Cons\" value that holds \"2\" and another \"List\" value. This \"List\" value is one more \"Cons\" value that holds \"3\" and a \"List\" value, which is finally \"Nil\", the non-recursive variant that signals the end of the list.\nIf we try to compile the code in Listing 15-3, we get the error shown in Listing 15-4:\n$ cargo run\n   Compiling cons-list v0.1.0 (file:///projects/cons-list)\nerror[E0072]: recursive type \"List\" has infinite size\n --&gt; src/main.rs:1:1\n  |\n1 | enum List {\n  | ^^^^^^^^^\n2 |     Cons(i32, List),\n  |               ---- recursive without indirection\n  |\nhelp: insert some indirection (e.g., a \"Box\", \"Rc\", or \"&amp;\") to break the cycle\n  |\n2 |     Cons(i32, Box&lt;List&gt;),\n  |               ++++    +\n\nFor more information about this error, try \"rustc --explain E0072\".\nerror: could not compile \"cons-list\" due to previous error\n\nListing 15-4: The error we get when attempting to define a recursive enum\nThe error shows this type “has infinite size.” The reason is that we’ve defined \"List\" with a variant that is recursive: it holds another value of itself directly. As a result, Rust can’t figure out how much space it needs to store a \"List\" value. Let’s break down why we get this error. First, we’ll look at how Rust decides how much space it needs to store a value of a non-recursive type.\nComputing the Size of a Non-Recursive Type\nRecall the \"Message\" enum we defined in Listing 6-2 when we discussed enum definitions in Chapter 6:\nenum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n}\n\nTo determine how much space to allocate for a \"Message\" value, Rust goes through each of the variants to see which variant needs the most space. Rust sees that \"Message::Quit\" doesn’t need any space, \"Message::Move\" needs enough space to store two \"i32\" values, and so forth. Because only one variant will be used, the most space a \"Message\" value will need is the space it would take to store the largest of its variants.\nContrast this with what happens when Rust tries to determine how much space a recursive type like the \"List\" enum in Listing 15-2 needs. The compiler starts by looking at the \"Cons\" variant, which holds a value of type \"i32\" and a value of type \"List\". Therefore, \"Cons\" needs an amount of space equal to the size of an \"i32\" plus the size of a \"List\". To figure out how much memory the \"List\" type needs, the compiler looks at the variants, starting with the \"Cons\" variant. The \"Cons\" variant holds a value of type \"i32\" and a value of type \"List\", and this process continues infinitely, as shown in Figure 15-1.\n\nFigure 15-1: An infinite \"List\" consisting of infinite \"Cons\" variants\nUsing \"Box\" to Get a Recursive Type with a Known Size\nBecause Rust can’t figure out how much space to allocate for recursively defined types, the compiler gives an error with this helpful suggestion:\nhelp: insert some indirection (e.g., a \"Box\", \"Rc\", or \"&amp;\") to make \"List\" representable\n  |\n2 |     Cons(i32, Box&lt;List&gt;),\n  |               ++++    +\n\nIn this suggestion, “indirection” means that instead of storing a value directly, we should change the data structure to store the value indirectly by storing a pointer to the value instead.\nBecause a \"Box\" is a pointer, Rust always knows how much space a \"Box\" needs: a pointer’s size doesn’t change based on the amount of data it’s pointing to. This means we can put a \"Box\" inside the \"Cons\" variant instead of another \"List\" value directly. The \"Box\" will point to the next \"List\" value that will be on the heap rather than inside the \"Cons\" variant. Conceptually, we still have a list, created with lists holding other lists, but this implementation is now more like placing the items next to one another rather than inside one another.\nWe can change the definition of the \"List\" enum in Listing 15-2 and the usage of the \"List\" in Listing 15-3 to the code in Listing 15-5, which will compile:\nFilename: src/main.rs\nenum List {\n    Cons(i32, Box&lt;List&gt;),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\n\nfn main() {\n    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));\n}\n\nListing 15-5: Definition of \"List\" that uses \"Box\" in order to have a known size\nThe \"Cons\" variant needs the size of an \"i32\" plus the space to store the box’s pointer data. The \"Nil\" variant stores no values, so it needs less space than the \"Cons\" variant. We now know that any \"List\" value will take up the size of an \"i32\" plus the size of a box’s pointer data. By using a box, we’ve broken the infinite, recursive chain, so the compiler can figure out the size it needs to store a \"List\" value. Figure 15-2 shows what the \"Cons\" variant looks like now.\n\nFigure 15-2: A \"List\" that is not infinitely sized because \"Cons\" holds a \"Box\"\nBoxes provide only the indirection and heap allocation; they don’t have any other special capabilities, like those we’ll see with the other smart pointer types. They also don’t have the performance overhead that these special capabilities incur, so they can be useful in cases like the cons list where the indirection is the only feature we need. We’ll look at more use cases for boxes in Chapter 17, too.\nThe \"Box\" type is a smart pointer because it implements the \"Deref\" trait, which allows \"Box\" values to be treated like references. When a \"Box\" value goes out of scope, the heap data that the box is pointing to is cleaned up as well because of the \"Drop\" trait implementation. These two traits will be even more important to the functionality provided by the other smart pointer types we’ll discuss in the rest of this chapter. Let’s explore these two traits in more detail.\n\nTreating Smart Pointers Like Regular References with the \"Deref\" Trait\nImplementing the \"Deref\" trait allows you to customize the behavior of the dereference operator \"*\" (not to be confused with the multiplication or glob operator). By implementing \"Deref\" in such a way that a smart pointer can be treated like a regular reference, you can write code that operates on references and use that code with smart pointers too.\nLet’s first look at how the dereference operator works with regular references. Then we’ll try to define a custom type that behaves like \"Box\", and see why the dereference operator doesn’t work like a reference on our newly defined type. We’ll explore how implementing the \"Deref\" trait makes it possible for smart pointers to work in ways similar to references. Then we’ll look at Rust’s deref coercion feature and how it lets us work with either references or smart pointers.\n\nNote: there’s one big difference between the \"MyBox\" type we’re about to build and the real \"Box\": our version will not store its data on the heap. We are focusing this example on \"Deref\", so where the data is actually stored is less important than the pointer-like behavior.\n\nFollowing the Pointer to the Value\nA regular reference is a type of pointer, and one way to think of a pointer is as an arrow to a value stored somewhere else. In Listing 15-6, we create a reference to an \"i32\" value and then use the dereference operator to follow the reference to the value:\nFilename: src/main.rs\nfn main() {\n    let x = 5;\n    let y = &amp;x;\n\n    assert_eq!(5, x);\n    assert_eq!(5, *y);\n}\n\nListing 15-6: Using the dereference operator to follow a reference to an \"i32\" value\nThe variable \"x\" holds an \"i32\" value \"5\". We set \"y\" equal to a reference to \"x\". We can assert that \"x\" is equal to \"5\". However, if we want to make an assertion about the value in \"y\", we have to use \"*y\" to follow the reference to the value it’s pointing to (hence dereference) so the compiler can compare the actual value. Once we dereference \"y\", we have access to the integer value \"y\" is pointing to that we can compare with \"5\".\nIf we tried to write \"assert_eq!(5, y);\" instead, we would get this compilation error:\n$ cargo run\n   Compiling deref-example v0.1.0 (file:///projects/deref-example)\nerror[E0277]: can\"t compare \"{integer}\" with \"&amp;{integer}\"\n --&gt; src/main.rs:6:5\n  |\n6 |     assert_eq!(5, y);\n  |     ^^^^^^^^^^^^^^^^ no implementation for \"{integer} == &amp;{integer}\"\n  |\n  = help: the trait \"PartialEq&lt;&amp;{integer}&gt;\" is not implemented for \"{integer}\"\n  = help: the following other types implement trait \"PartialEq&lt;Rhs&gt;\":\n            f32\n            f64\n            i128\n            i16\n            i32\n            i64\n            i8\n            isize\n          and 6 others\n  = note: this error originates in the macro \"assert_eq\" (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try \"rustc --explain E0277\".\nerror: could not compile \"deref-example\" due to previous error\n\nComparing a number and a reference to a number isn’t allowed because they’re different types. We must use the dereference operator to follow the reference to the value it’s pointing to.\nUsing \"Box\" Like a Reference\nWe can rewrite the code in Listing 15-6 to use a \"Box\" instead of a reference; the dereference operator used on the \"Box\" in Listing 15-7 functions in the same way as the dereference operator used on the reference in Listing 15-6:\nFilename: src/main.rs\nfn main() {\n    let x = 5;\n    let y = Box::new(x);\n\n    assert_eq!(5, x);\n    assert_eq!(5, *y);\n}\n\nListing 15-7: Using the dereference operator on a \"Box\"\nThe main difference between Listing 15-7 and Listing 15-6 is that here we set \"y\" to be an instance of a \"Box\" pointing to a copied value of \"x\" rather than a reference pointing to the value of \"x\". In the last assertion, we can use the dereference operator to follow the pointer of the \"Box\" in the same way that we did when \"y\" was a reference. Next, we’ll explore what is special about \"Box\" that enables us to use the dereference operator by defining our own type.\nDefining Our Own Smart Pointer\nLet’s build a smart pointer similar to the \"Box\" type provided by the standard library to experience how smart pointers behave differently from references by default. Then we’ll look at how to add the ability to use the dereference operator.\nThe \"Box\" type is ultimately defined as a tuple struct with one element, so Listing 15-8 defines a \"MyBox\" type in the same way. We’ll also define a \"new\" function to match the \"new\" function defined on \"Box\".\nFilename: src/main.rs\nstruct MyBox&lt;T&gt;(T);\n\nimpl&lt;T&gt; MyBox&lt;T&gt; {\n    fn new(x: T) -&gt; MyBox&lt;T&gt; {\n        MyBox(x)\n    }\n}\n\nListing 15-8: Defining a \"MyBox\" type\nWe define a struct named \"MyBox\" and declare a generic parameter \"T\", because we want our type to hold values of any type. The \"MyBox\" type is a tuple struct with one element of type \"T\". The \"MyBox::new\" function takes one parameter of type \"T\" and returns a \"MyBox\" instance that holds the value passed in.\nLet’s try adding the \"main\" function in Listing 15-7 to Listing 15-8 and changing it to use the \"MyBox\" type we’ve defined instead of \"Box\". The code in Listing 15-9 won’t compile because Rust doesn’t know how to dereference \"MyBox\".\nFilename: src/main.rs\nfn main() {\n    let x = 5;\n    let y = MyBox::new(x);\n\n    assert_eq!(5, x);\n    assert_eq!(5, *y);\n}\n\nListing 15-9: Attempting to use \"MyBox\" in the same way we used references and \"Box\"\nHere’s the resulting compilation error:\n$ cargo run\n   Compiling deref-example v0.1.0 (file:///projects/deref-example)\nerror[E0614]: type \"MyBox&lt;{integer}&gt;\" cannot be dereferenced\n  --&gt; src/main.rs:14:19\n   |\n14 |     assert_eq!(5, *y);\n   |                   ^^\n\nFor more information about this error, try \"rustc --explain E0614\".\nerror: could not compile \"deref-example\" due to previous error\n\nOur \"MyBox\" type can’t be dereferenced because we haven’t implemented that ability on our type. To enable dereferencing with the \"*\" operator, we implement the \"Deref\" trait.\nTreating a Type Like a Reference by Implementing the \"Deref\" Trait\nAs discussed in the “Implementing a Trait on a Type” section of Chapter 10, to implement a trait, we need to provide implementations for the trait’s required methods. The \"Deref\" trait, provided by the standard library, requires us to implement one method named \"deref\" that borrows \"self\" and returns a reference to the inner data. Listing 15-10 contains an implementation of \"Deref\" to add to the definition of \"MyBox\":\nFilename: src/main.rs\nuse std::ops::Deref;\n\nimpl&lt;T&gt; Deref for MyBox&lt;T&gt; {\n    type Target = T;\n\n    fn deref(&amp;self) -&gt; &amp;Self::Target {\n        &amp;self.0\n    }\n}\n\nListing 15-10: Implementing \"Deref\" on \"MyBox\"\nThe \"type Target = T;\" syntax defines an associated type for the \"Deref\" trait to use. Associated types are a slightly different way of declaring a generic parameter, but you don’t need to worry about them for now; we’ll cover them in more detail in Chapter 19.\nWe fill in the body of the \"deref\" method with \"&amp;self.0\" so \"deref\" returns a reference to the value we want to access with the \"\" operator; recall from the “Using Tuple Structs without Named Fields to Create Different Types” section of Chapter 5 that \".0\" accesses the first value in a tuple struct. The \"main\" function in Listing 15-9 that calls \"\" on the \"MyBox\" value now compiles, and the assertions pass!\nWithout the \"Deref\" trait, the compiler can only dereference \"&amp;\" references. The \"deref\" method gives the compiler the ability to take a value of any type that implements \"Deref\" and call the \"deref\" method to get a \"&amp;\" reference that it knows how to dereference.\nWhen we entered \"*y\" in Listing 15-9, behind the scenes Rust actually ran this code:\n*(y.deref())\n\nRust substitutes the \"*\" operator with a call to the \"deref\" method and then a plain dereference so we don’t have to think about whether or not we need to call the \"deref\" method. This Rust feature lets us write code that functions identically whether we have a regular reference or a type that implements \"Deref\".\nThe reason the \"deref\" method returns a reference to a value, and that the plain dereference outside the parentheses in \"*(y.deref())\" is still necessary, is to do with the ownership system. If the \"deref\" method returned the value directly instead of a reference to the value, the value would be moved out of \"self\". We don’t want to take ownership of the inner value inside \"MyBox\" in this case or in most cases where we use the dereference operator.\nNote that the \"\" operator is replaced with a call to the \"deref\" method and then a call to the \"\" operator just once, each time we use a \"\" in our code. Because the substitution of the \"\" operator does not recurse infinitely, we end up with data of type \"i32\", which matches the \"5\" in \"assert_eq!\" in Listing 15-9.\nImplicit Deref Coercions with Functions and Methods\nDeref coercion converts a reference to a type that implements the \"Deref\" trait into a reference to another type. For example, deref coercion can convert \"&amp;String\" to \"&amp;str\" because \"String\" implements the \"Deref\" trait such that it returns \"&amp;str\". Deref coercion is a convenience Rust performs on arguments to functions and methods, and works only on types that implement the \"Deref\" trait. It happens automatically when we pass a reference to a particular type’s value as an argument to a function or method that doesn’t match the parameter type in the function or method definition. A sequence of calls to the \"deref\" method converts the type we provided into the type the parameter needs.\nDeref coercion was added to Rust so that programmers writing function and method calls don’t need to add as many explicit references and dereferences with \"&amp;\" and \"*\". The deref coercion feature also lets us write more code that can work for either references or smart pointers.\nTo see deref coercion in action, let’s use the \"MyBox\" type we defined in Listing 15-8 as well as the implementation of \"Deref\" that we added in Listing 15-10. Listing 15-11 shows the definition of a function that has a string slice parameter:\nFilename: src/main.rs\nfn hello(name: &amp;str) {\n    println!(\"Hello, {name}!\");\n}\n\nListing 15-11: A \"hello\" function that has the parameter \"name\" of type \"&amp;str\"\nWe can call the \"hello\" function with a string slice as an argument, such as \"hello(\"Rust\");\" for example. Deref coercion makes it possible to call \"hello\" with a reference to a value of type \"MyBox\", as shown in Listing 15-12:\nFilename: src/main.rs\nfn main() {\n    let m = MyBox::new(String::from(\"Rust\"));\n    hello(&amp;m);\n}\n\nListing 15-12: Calling \"hello\" with a reference to a \"MyBox\" value, which works because of deref coercion\nHere we’re calling the \"hello\" function with the argument \"&amp;m\", which is a reference to a \"MyBox\" value. Because we implemented the \"Deref\" trait on \"MyBox\" in Listing 15-10, Rust can turn \"&amp;MyBox\" into \"&amp;String\" by calling \"deref\". The standard library provides an implementation of \"Deref\" on \"String\" that returns a string slice, and this is in the API documentation for \"Deref\". Rust calls \"deref\" again to turn the \"&amp;String\" into \"&amp;str\", which matches the \"hello\" function’s definition.\nIf Rust didn’t implement deref coercion, we would have to write the code in Listing 15-13 instead of the code in Listing 15-12 to call \"hello\" with a value of type \"&amp;MyBox\".\nFilename: src/main.rs\nfn main() {\n    let m = MyBox::new(String::from(\"Rust\"));\n    hello(&amp;(*m)[..]);\n}\n\nListing 15-13: The code we would have to write if Rust didn’t have deref coercion\nThe \"(*m)\" dereferences the \"MyBox\" into a \"String\". Then the \"&amp;\" and \"[..]\" take a string slice of the \"String\" that is equal to the whole string to match the signature of \"hello\". This code without deref coercions is harder to read, write, and understand with all of these symbols involved. Deref coercion allows Rust to handle these conversions for us automatically.\nWhen the \"Deref\" trait is defined for the types involved, Rust will analyze the types and use \"Deref::deref\" as many times as necessary to get a reference to match the parameter’s type. The number of times that \"Deref::deref\" needs to be inserted is resolved at compile time, so there is no runtime penalty for taking advantage of deref coercion!\nHow Deref Coercion Interacts with Mutability\nSimilar to how you use the \"Deref\" trait to override the \"\" operator on immutable references, you can use the \"DerefMut\" trait to override the \"\" operator on mutable references.\nRust does deref coercion when it finds types and trait implementations in three cases:\n\nFrom \"&amp;T\" to \"&amp;U\" when \"T: Deref&lt;Target=U&gt;\"\nFrom \"&amp;mut T\" to \"&amp;mut U\" when \"T: DerefMut&lt;Target=U&gt;\"\nFrom \"&amp;mut T\" to \"&amp;U\" when \"T: Deref&lt;Target=U&gt;\"\n\nThe first two cases are the same as each other except that the second implements mutability. The first case states that if you have a \"&amp;T\", and \"T\" implements \"Deref\" to some type \"U\", you can get a \"&amp;U\" transparently. The second case states that the same deref coercion happens for mutable references.\nThe third case is trickier: Rust will also coerce a mutable reference to an immutable one. But the reverse is not possible: immutable references will never coerce to mutable references. Because of the borrowing rules, if you have a mutable reference, that mutable reference must be the only reference to that data (otherwise, the program wouldn’t compile). Converting one mutable reference to one immutable reference will never break the borrowing rules. Converting an immutable reference to a mutable reference would require that the initial immutable reference is the only immutable reference to that data, but the borrowing rules don’t guarantee that. Therefore, Rust can’t make the assumption that converting an immutable reference to a mutable reference is possible.\n\nRunning Code on Cleanup with the \"Drop\" Trait\nThe second trait important to the smart pointer pattern is \"Drop\", which lets you customize what happens when a value is about to go out of scope. You can provide an implementation for the \"Drop\" trait on any type, and that code can be used to release resources like files or network connections.\nWe’re introducing \"Drop\" in the context of smart pointers because the functionality of the \"Drop\" trait is almost always used when implementing a smart pointer. For example, when a \"Box\" is dropped it will deallocate the space on the heap that the box points to.\nIn some languages, for some types, the programmer must call code to free memory or resources every time they finish using an instance of those types. Examples include file handles, sockets, or locks. If they forget, the system might become overloaded and crash. In Rust, you can specify that a particular bit of code be run whenever a value goes out of scope, and the compiler will insert this code automatically. As a result, you don’t need to be careful about placing cleanup code everywhere in a program that an instance of a particular type is finished with—you still won’t leak resources!\nYou specify the code to run when a value goes out of scope by implementing the \"Drop\" trait. The \"Drop\" trait requires you to implement one method named \"drop\" that takes a mutable reference to \"self\". To see when Rust calls \"drop\", let’s implement \"drop\" with \"println!\" statements for now.\nListing 15-14 shows a \"CustomSmartPointer\" struct whose only custom functionality is that it will print \"Dropping CustomSmartPointer!\" when the instance goes out of scope, to show when Rust runs the \"drop\" function.\nFilename: src/main.rs\nstruct CustomSmartPointer {\n    data: String,\n}\n\nimpl Drop for CustomSmartPointer {\n    fn drop(&amp;mut self) {\n        println!(\"Dropping CustomSmartPointer with data \"{}\"!\", self.data);\n    }\n}\n\nfn main() {\n    let c = CustomSmartPointer {\n        data: String::from(\"my stuff\"),\n    };\n    let d = CustomSmartPointer {\n        data: String::from(\"other stuff\"),\n    };\n    println!(\"CustomSmartPointers created.\");\n}\n\nListing 15-14: A \"CustomSmartPointer\" struct that implements the \"Drop\" trait where we would put our cleanup code\nThe \"Drop\" trait is included in the prelude, so we don’t need to bring it into scope. We implement the \"Drop\" trait on \"CustomSmartPointer\" and provide an implementation for the \"drop\" method that calls \"println!\". The body of the \"drop\" function is where you would place any logic that you wanted to run when an instance of your type goes out of scope. We’re printing some text here to demonstrate visually when Rust will call \"drop\".\nIn \"main\", we create two instances of \"CustomSmartPointer\" and then print \"CustomSmartPointers created\". At the end of \"main\", our instances of \"CustomSmartPointer\" will go out of scope, and Rust will call the code we put in the \"drop\" method, printing our final message. Note that we didn’t need to call the \"drop\" method explicitly.\nWhen we run this program, we’ll see the following output:\n$ cargo run\n   Compiling drop-example v0.1.0 (file:///projects/drop-example)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.60s\n     Running \"target/debug/drop-example\"\nCustomSmartPointers created.\nDropping CustomSmartPointer with data \"other stuff\"!\nDropping CustomSmartPointer with data \"my stuff\"!\n\nRust automatically called \"drop\" for us when our instances went out of scope, calling the code we specified. Variables are dropped in the reverse order of their creation, so \"d\" was dropped before \"c\". This example’s purpose is to give you a visual guide to how the \"drop\" method works; usually you would specify the cleanup code that your type needs to run rather than a print message.\nDropping a Value Early with \"std::mem::drop\"\nUnfortunately, it’s not straightforward to disable the automatic \"drop\" functionality. Disabling \"drop\" isn’t usually necessary; the whole point of the \"Drop\" trait is that it’s taken care of automatically. Occasionally, however, you might want to clean up a value early. One example is when using smart pointers that manage locks: you might want to force the \"drop\" method that releases the lock so that other code in the same scope can acquire the lock. Rust doesn’t let you call the \"Drop\" trait’s \"drop\" method manually; instead you have to call the \"std::mem::drop\" function provided by the standard library if you want to force a value to be dropped before the end of its scope.\nIf we try to call the \"Drop\" trait’s \"drop\" method manually by modifying the \"main\" function from Listing 15-14, as shown in Listing 15-15, we’ll get a compiler error:\nFilename: src/main.rs\nfn main() {\n    let c = CustomSmartPointer {\n        data: String::from(\"some data\"),\n    };\n    println!(\"CustomSmartPointer created.\");\n    c.drop();\n    println!(\"CustomSmartPointer dropped before the end of main.\");\n}\n\nListing 15-15: Attempting to call the \"drop\" method from the \"Drop\" trait manually to clean up early\nWhen we try to compile this code, we’ll get this error:\n$ cargo run\n   Compiling drop-example v0.1.0 (file:///projects/drop-example)\nerror[E0040]: explicit use of destructor method\n  --&gt; src/main.rs:16:7\n   |\n16 |     c.drop();\n   |     --^^^^--\n   |     | |\n   |     | explicit destructor calls not allowed\n   |     help: consider using \"drop\" function: \"drop(c)\"\n\nFor more information about this error, try \"rustc --explain E0040\".\nerror: could not compile \"drop-example\" due to previous error\n\nThis error message states that we’re not allowed to explicitly call \"drop\". The error message uses the term destructor, which is the general programming term for a function that cleans up an instance. A destructor is analogous to a constructor, which creates an instance. The \"drop\" function in Rust is one particular destructor.\nRust doesn’t let us call \"drop\" explicitly because Rust would still automatically call \"drop\" on the value at the end of \"main\". This would cause a double free error because Rust would be trying to clean up the same value twice.\nWe can’t disable the automatic insertion of \"drop\" when a value goes out of scope, and we can’t call the \"drop\" method explicitly. So, if we need to force a value to be cleaned up early, we use the \"std::mem::drop\" function.\nThe \"std::mem::drop\" function is different from the \"drop\" method in the \"Drop\" trait. We call it by passing as an argument the value we want to force drop. The function is in the prelude, so we can modify \"main\" in Listing 15-15 to call the \"drop\" function, as shown in Listing 15-16:\nFilename: src/main.rs\nfn main() {\n    let c = CustomSmartPointer {\n        data: String::from(\"some data\"),\n    };\n    println!(\"CustomSmartPointer created.\");\n    drop(c);\n    println!(\"CustomSmartPointer dropped before the end of main.\");\n}\n\nListing 15-16: Calling \"std::mem::drop\" to explicitly drop a value before it goes out of scope\nRunning this code will print the following:\n$ cargo run\n   Compiling drop-example v0.1.0 (file:///projects/drop-example)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.73s\n     Running \"target/debug/drop-example\"\nCustomSmartPointer created.\nDropping CustomSmartPointer with data \"some data\"!\nCustomSmartPointer dropped before the end of main.\n\nThe text \"Dropping CustomSmartPointer with data \"some data\"!\" is printed between the \"CustomSmartPointer created.\" and \"CustomSmartPointer dropped before the end of main.\" text, showing that the \"drop\" method code is called to drop \"c\" at that point.\nYou can use code specified in a \"Drop\" trait implementation in many ways to make cleanup convenient and safe: for instance, you could use it to create your own memory allocator! With the \"Drop\" trait and Rust’s ownership system, you don’t have to remember to clean up because Rust does it automatically.\nYou also don’t have to worry about problems resulting from accidentally cleaning up values still in use: the ownership system that makes sure references are always valid also ensures that \"drop\" gets called only once when the value is no longer being used.\nNow that we’ve examined \"Box\" and some of the characteristics of smart pointers, let’s look at a few other smart pointers defined in the standard library.\n\n\"Rc\", the Reference Counted Smart Pointer\nIn the majority of cases, ownership is clear: you know exactly which variable owns a given value. However, there are cases when a single value might have multiple owners. For example, in graph data structures, multiple edges might point to the same node, and that node is conceptually owned by all of the edges that point to it. A node shouldn’t be cleaned up unless it doesn’t have any edges pointing to it and so has no owners.\nYou have to enable multiple ownership explicitly by using the Rust type \"Rc\", which is an abbreviation for reference counting. The \"Rc\" type keeps track of the number of references to a value to determine whether or not the value is still in use. If there are zero references to a value, the value can be cleaned up without any references becoming invalid.\nImagine \"Rc\" as a TV in a family room. When one person enters to watch TV, they turn it on. Others can come into the room and watch the TV. When the last person leaves the room, they turn off the TV because it’s no longer being used. If someone turns off the TV while others are still watching it, there would be uproar from the remaining TV watchers!\nWe use the \"Rc\" type when we want to allocate some data on the heap for multiple parts of our program to read and we can’t determine at compile time which part will finish using the data last. If we knew which part would finish last, we could just make that part the data’s owner, and the normal ownership rules enforced at compile time would take effect.\nNote that \"Rc\" is only for use in single-threaded scenarios. When we discuss concurrency in Chapter 16, we’ll cover how to do reference counting in multithreaded programs.\nUsing \"Rc\" to Share Data\nLet’s return to our cons list example in Listing 15-5. Recall that we defined it using \"Box\". This time, we’ll create two lists that both share ownership of a third list. Conceptually, this looks similar to Figure 15-3:\n\nFigure 15-3: Two lists, \"b\" and \"c\", sharing ownership of a third list, \"a\"\nWe’ll create list \"a\" that contains 5 and then 10. Then we’ll make two more lists: \"b\" that starts with 3 and \"c\" that starts with 4. Both \"b\" and \"c\" lists will then continue on to the first \"a\" list containing 5 and 10. In other words, both lists will share the first list containing 5 and 10.\nTrying to implement this scenario using our definition of \"List\" with \"Box\" won’t work, as shown in Listing 15-17:\nFilename: src/main.rs\nenum List {\n    Cons(i32, Box&lt;List&gt;),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\n\nfn main() {\n    let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));\n    let b = Cons(3, Box::new(a));\n    let c = Cons(4, Box::new(a));\n}\n\nListing 15-17: Demonstrating we’re not allowed to have two lists using \"Box\" that try to share ownership of a third list\nWhen we compile this code, we get this error:\n$ cargo run\n   Compiling cons-list v0.1.0 (file:///projects/cons-list)\nerror[E0382]: use of moved value: \"a\"\n  --&gt; src/main.rs:11:30\n   |\n9  |     let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));\n   |         - move occurs because \"a\" has type \"List\", which does not implement the \"Copy\" trait\n10 |     let b = Cons(3, Box::new(a));\n   |                              - value moved here\n11 |     let c = Cons(4, Box::new(a));\n   |                              ^ value used here after move\n\nFor more information about this error, try \"rustc --explain E0382\".\nerror: could not compile \"cons-list\" due to previous error\n\nThe \"Cons\" variants own the data they hold, so when we create the \"b\" list, \"a\" is moved into \"b\" and \"b\" owns \"a\". Then, when we try to use \"a\" again when creating \"c\", we’re not allowed to because \"a\" has been moved.\nWe could change the definition of \"Cons\" to hold references instead, but then we would have to specify lifetime parameters. By specifying lifetime parameters, we would be specifying that every element in the list will live at least as long as the entire list. This is the case for the elements and lists in Listing 15-17, but not in every scenario.\nInstead, we’ll change our definition of \"List\" to use \"Rc\" in place of \"Box\", as shown in Listing 15-18. Each \"Cons\" variant will now hold a value and an \"Rc\" pointing to a \"List\". When we create \"b\", instead of taking ownership of \"a\", we’ll clone the \"Rc\" that \"a\" is holding, thereby increasing the number of references from one to two and letting \"a\" and \"b\" share ownership of the data in that \"Rc\". We’ll also clone \"a\" when creating \"c\", increasing the number of references from two to three. Every time we call \"Rc::clone\", the reference count to the data within the \"Rc\" will increase, and the data won’t be cleaned up unless there are zero references to it.\nFilename: src/main.rs\nenum List {\n    Cons(i32, Rc&lt;List&gt;),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\nuse std::rc::Rc;\n\nfn main() {\n    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));\n    let b = Cons(3, Rc::clone(&amp;a));\n    let c = Cons(4, Rc::clone(&amp;a));\n}\n\nListing 15-18: A definition of \"List\" that uses \"Rc\"\nWe need to add a \"use\" statement to bring \"Rc\" into scope because it’s not in the prelude. In \"main\", we create the list holding 5 and 10 and store it in a new \"Rc\" in \"a\". Then when we create \"b\" and \"c\", we call the \"Rc::clone\" function and pass a reference to the \"Rc\" in \"a\" as an argument.\nWe could have called \"a.clone()\" rather than \"Rc::clone(&amp;a)\", but Rust’s convention is to use \"Rc::clone\" in this case. The implementation of \"Rc::clone\" doesn’t make a deep copy of all the data like most types’ implementations of \"clone\" do. The call to \"Rc::clone\" only increments the reference count, which doesn’t take much time. Deep copies of data can take a lot of time. By using \"Rc::clone\" for reference counting, we can visually distinguish between the deep-copy kinds of clones and the kinds of clones that increase the reference count. When looking for performance problems in the code, we only need to consider the deep-copy clones and can disregard calls to \"Rc::clone\".\nCloning an \"Rc\" Increases the Reference Count\nLet’s change our working example in Listing 15-18 so we can see the reference counts changing as we create and drop references to the \"Rc\" in \"a\".\nIn Listing 15-19, we’ll change \"main\" so it has an inner scope around list \"c\"; then we can see how the reference count changes when \"c\" goes out of scope.\nFilename: src/main.rs\nfn main() {\n    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));\n    println!(\"count after creating a = {}\", Rc::strong_count(&amp;a));\n    let b = Cons(3, Rc::clone(&amp;a));\n    println!(\"count after creating b = {}\", Rc::strong_count(&amp;a));\n    {\n        let c = Cons(4, Rc::clone(&amp;a));\n        println!(\"count after creating c = {}\", Rc::strong_count(&amp;a));\n    }\n    println!(\"count after c goes out of scope = {}\", Rc::strong_count(&amp;a));\n}\n\nListing 15-19: Printing the reference count\nAt each point in the program where the reference count changes, we print the reference count, which we get by calling the \"Rc::strong_count\" function. This function is named \"strong_count\" rather than \"count\" because the \"Rc\" type also has a \"weak_count\"; we’ll see what \"weak_count\" is used for in the “Preventing Reference Cycles: Turning an \"Rc\" into a \"Weak\"” section.\nThis code prints the following:\n$ cargo run\n   Compiling cons-list v0.1.0 (file:///projects/cons-list)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.45s\n     Running \"target/debug/cons-list\"\ncount after creating a = 1\ncount after creating b = 2\ncount after creating c = 3\ncount after c goes out of scope = 2\n\nWe can see that the \"Rc\" in \"a\" has an initial reference count of 1; then each time we call \"clone\", the count goes up by 1. When \"c\" goes out of scope, the count goes down by 1. We don’t have to call a function to decrease the reference count like we have to call \"Rc::clone\" to increase the reference count: the implementation of the \"Drop\" trait decreases the reference count automatically when an \"Rc\" value goes out of scope.\nWhat we can’t see in this example is that when \"b\" and then \"a\" go out of scope at the end of \"main\", the count is then 0, and the \"Rc\" is cleaned up completely. Using \"Rc\" allows a single value to have multiple owners, and the count ensures that the value remains valid as long as any of the owners still exist.\nVia immutable references, \"Rc\" allows you to share data between multiple parts of your program for reading only. If \"Rc\" allowed you to have multiple mutable references too, you might violate one of the borrowing rules discussed in Chapter 4: multiple mutable borrows to the same place can cause data races and inconsistencies. But being able to mutate data is very useful! In the next section, we’ll discuss the interior mutability pattern and the \"RefCell\" type that you can use in conjunction with an \"Rc\" to work with this immutability restriction.\n\n\"RefCell\" and the Interior Mutability Pattern\nInterior mutability is a design pattern in Rust that allows you to mutate data even when there are immutable references to that data; normally, this action is disallowed by the borrowing rules. To mutate data, the pattern uses \"unsafe\" code inside a data structure to bend Rust’s usual rules that govern mutation and borrowing. Unsafe code indicates to the compiler that we’re checking the rules manually instead of relying on the compiler to check them for us; we will discuss unsafe code more in Chapter 19.\nWe can use types that use the interior mutability pattern only when we can ensure that the borrowing rules will be followed at runtime, even though the compiler can’t guarantee that. The \"unsafe\" code involved is then wrapped in a safe API, and the outer type is still immutable.\nLet’s explore this concept by looking at the \"RefCell\" type that follows the interior mutability pattern.\nEnforcing Borrowing Rules at Runtime with \"RefCell\"\nUnlike \"Rc\", the \"RefCell\" type represents single ownership over the data it holds. So, what makes \"RefCell\" different from a type like \"Box\"? Recall the borrowing rules you learned in Chapter 4:\n\nAt any given time, you can have either (but not both) one mutable reference or any number of immutable references.\nReferences must always be valid.\n\nWith references and \"Box\", the borrowing rules’ invariants are enforced at compile time. With \"RefCell\", these invariants are enforced at runtime. With references, if you break these rules, you’ll get a compiler error. With \"RefCell\", if you break these rules, your program will panic and exit.\nThe advantages of checking the borrowing rules at compile time are that errors will be caught sooner in the development process, and there is no impact on runtime performance because all the analysis is completed beforehand. For those reasons, checking the borrowing rules at compile time is the best choice in the majority of cases, which is why this is Rust’s default.\nThe advantage of checking the borrowing rules at runtime instead is that certain memory-safe scenarios are then allowed, where they would’ve been disallowed by the compile-time checks. Static analysis, like the Rust compiler, is inherently conservative. Some properties of code are impossible to detect by analyzing the code: the most famous example is the Halting Problem, which is beyond the scope of this book but is an interesting topic to research.\nBecause some analysis is impossible, if the Rust compiler can’t be sure the code complies with the ownership rules, it might reject a correct program; in this way, it’s conservative. If Rust accepted an incorrect program, users wouldn’t be able to trust in the guarantees Rust makes. However, if Rust rejects a correct program, the programmer will be inconvenienced, but nothing catastrophic can occur. The \"RefCell\" type is useful when you’re sure your code follows the borrowing rules but the compiler is unable to understand and guarantee that.\nSimilar to \"Rc\", \"RefCell\" is only for use in single-threaded scenarios and will give you a compile-time error if you try using it in a multithreaded context. We’ll talk about how to get the functionality of \"RefCell\" in a multithreaded program in Chapter 16.\nHere is a recap of the reasons to choose \"Box\", \"Rc\", or \"RefCell\":\n\n\"Rc\" enables multiple owners of the same data; \"Box\" and \"RefCell\" have single owners.\n\"Box\" allows immutable or mutable borrows checked at compile time; \"Rc\" allows only immutable borrows checked at compile time; \"RefCell\" allows immutable or mutable borrows checked at runtime.\nBecause \"RefCell\" allows mutable borrows checked at runtime, you can mutate the value inside the \"RefCell\" even when the \"RefCell\" is immutable.\n\nMutating the value inside an immutable value is the interior mutability pattern. Let’s look at a situation in which interior mutability is useful and examine how it’s possible.\nInterior Mutability: A Mutable Borrow to an Immutable Value\nA consequence of the borrowing rules is that when you have an immutable value, you can’t borrow it mutably. For example, this code won’t compile:\nfn main() {\n    let x = 5;\n    let y = &amp;mut x;\n}\n\nIf you tried to compile this code, you’d get the following error:\n$ cargo run\n   Compiling borrowing v0.1.0 (file:///projects/borrowing)\nerror[E0596]: cannot borrow \"x\" as mutable, as it is not declared as mutable\n --&gt; src/main.rs:3:13\n  |\n2 |     let x = 5;\n  |         - help: consider changing this to be mutable: \"mut x\"\n3 |     let y = &amp;mut x;\n  |             ^^^^^^ cannot borrow as mutable\n\nFor more information about this error, try \"rustc --explain E0596\".\nerror: could not compile \"borrowing\" due to previous error\n\nHowever, there are situations in which it would be useful for a value to mutate itself in its methods but appear immutable to other code. Code outside the value’s methods would not be able to mutate the value. Using \"RefCell\" is one way to get the ability to have interior mutability, but \"RefCell\" doesn’t get around the borrowing rules completely: the borrow checker in the compiler allows this interior mutability, and the borrowing rules are checked at runtime instead. If you violate the rules, you’ll get a \"panic!\" instead of a compiler error.\nLet’s work through a practical example where we can use \"RefCell\" to mutate an immutable value and see why that is useful.\nA Use Case for Interior Mutability: Mock Objects\nSometimes during testing a programmer will use a type in place of another type, in order to observe particular behavior and assert it’s implemented correctly. This placeholder type is called a test double. Think of it in the sense of a “stunt double” in filmmaking, where a person steps in and substitutes for an actor to do a particular tricky scene. Test doubles stand in for other types when we’re running tests. Mock objects are specific types of test doubles that record what happens during a test so you can assert that the correct actions took place.\nRust doesn’t have objects in the same sense as other languages have objects, and Rust doesn’t have mock object functionality built into the standard library as some other languages do. However, you can definitely create a struct that will serve the same purposes as a mock object.\nHere’s the scenario we’ll test: we’ll create a library that tracks a value against a maximum value and sends messages based on how close to the maximum value the current value is. This library could be used to keep track of a user’s quota for the number of API calls they’re allowed to make, for example.\nOur library will only provide the functionality of tracking how close to the maximum a value is and what the messages should be at what times. Applications that use our library will be expected to provide the mechanism for sending the messages: the application could put a message in the application, send an email, send a text message, or something else. The library doesn’t need to know that detail. All it needs is something that implements a trait we’ll provide called \"Messenger\". Listing 15-20 shows the library code:\nFilename: src/lib.rs\npub trait Messenger {\n    fn send(&amp;self, msg: &amp;str);\n}\n\npub struct LimitTracker&lt;\"a, T: Messenger&gt; {\n    messenger: &amp;\"a T,\n    value: usize,\n    max: usize,\n}\n\nimpl&lt;\"a, T&gt; LimitTracker&lt;\"a, T&gt;\nwhere\n    T: Messenger,\n{\n    pub fn new(messenger: &amp;\"a T, max: usize) -&gt; LimitTracker&lt;\"a, T&gt; {\n        LimitTracker {\n            messenger,\n            value: 0,\n            max,\n        }\n    }\n\n    pub fn set_value(&amp;mut self, value: usize) {\n        self.value = value;\n\n        let percentage_of_max = self.value as f64 / self.max as f64;\n\n        if percentage_of_max &gt;= 1.0 {\n            self.messenger.send(\"Error: You are over your quota!\");\n        } else if percentage_of_max &gt;= 0.9 {\n            self.messenger\n                .send(\"Urgent warning: You\"ve used up over 90% of your quota!\");\n        } else if percentage_of_max &gt;= 0.75 {\n            self.messenger\n                .send(\"Warning: You\"ve used up over 75% of your quota!\");\n        }\n    }\n}\n\nListing 15-20: A library to keep track of how close a value is to a maximum value and warn when the value is at certain levels\nOne important part of this code is that the \"Messenger\" trait has one method called \"send\" that takes an immutable reference to \"self\" and the text of the message. This trait is the interface our mock object needs to implement so that the mock can be used in the same way a real object is. The other important part is that we want to test the behavior of the \"set_value\" method on the \"LimitTracker\". We can change what we pass in for the \"value\" parameter, but \"set_value\" doesn’t return anything for us to make assertions on. We want to be able to say that if we create a \"LimitTracker\" with something that implements the \"Messenger\" trait and a particular value for \"max\", when we pass different numbers for \"value\", the messenger is told to send the appropriate messages.\nWe need a mock object that, instead of sending an email or text message when we call \"send\", will only keep track of the messages it’s told to send. We can create a new instance of the mock object, create a \"LimitTracker\" that uses the mock object, call the \"set_value\" method on \"LimitTracker\", and then check that the mock object has the messages we expect. Listing 15-21 shows an attempt to implement a mock object to do just that, but the borrow checker won’t allow it:\nFilename: src/lib.rs\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    struct MockMessenger {\n        sent_messages: Vec&lt;String&gt;,\n    }\n\n    impl MockMessenger {\n        fn new() -&gt; MockMessenger {\n            MockMessenger {\n                sent_messages: vec![],\n            }\n        }\n    }\n\n    impl Messenger for MockMessenger {\n        fn send(&amp;self, message: &amp;str) {\n            self.sent_messages.push(String::from(message));\n        }\n    }\n\n    #[test]\n    fn it_sends_an_over_75_percent_warning_message() {\n        let mock_messenger = MockMessenger::new();\n        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);\n\n        limit_tracker.set_value(80);\n\n        assert_eq!(mock_messenger.sent_messages.len(), 1);\n    }\n}\n\nListing 15-21: An attempt to implement a \"MockMessenger\" that isn’t allowed by the borrow checker\nThis test code defines a \"MockMessenger\" struct that has a \"sent_messages\" field with a \"Vec\" of \"String\" values to keep track of the messages it’s told to send. We also define an associated function \"new\" to make it convenient to create new \"MockMessenger\" values that start with an empty list of messages. We then implement the \"Messenger\" trait for \"MockMessenger\" so we can give a \"MockMessenger\" to a \"LimitTracker\". In the definition of the \"send\" method, we take the message passed in as a parameter and store it in the \"MockMessenger\" list of \"sent_messages\".\nIn the test, we’re testing what happens when the \"LimitTracker\" is told to set \"value\" to something that is more than 75 percent of the \"max\" value. First, we create a new \"MockMessenger\", which will start with an empty list of messages. Then we create a new \"LimitTracker\" and give it a reference to the new \"MockMessenger\" and a \"max\" value of 100. We call the \"set_value\" method on the \"LimitTracker\" with a value of 80, which is more than 75 percent of 100. Then we assert that the list of messages that the \"MockMessenger\" is keeping track of should now have one message in it.\nHowever, there’s one problem with this test, as shown here:\n$ cargo test\n   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)\nerror[E0596]: cannot borrow \"self.sent_messages\" as mutable, as it is behind a \"&amp;\" reference\n  --&gt; src/lib.rs:58:13\n   |\n2  |     fn send(&amp;self, msg: &amp;str);\n   |             ----- help: consider changing that to be a mutable reference: \"&amp;mut self\"\n...\n58 |             self.sent_messages.push(String::from(message));\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ \"self\" is a \"&amp;\" reference, so the data it refers to cannot be borrowed as mutable\n\nFor more information about this error, try \"rustc --explain E0596\".\nerror: could not compile \"limit-tracker\" due to previous error\nwarning: build failed, waiting for other jobs to finish...\n\nWe can’t modify the \"MockMessenger\" to keep track of the messages, because the \"send\" method takes an immutable reference to \"self\". We also can’t take the suggestion from the error text to use \"&amp;mut self\" instead, because then the signature of \"send\" wouldn’t match the signature in the \"Messenger\" trait definition (feel free to try and see what error message you get).\nThis is a situation in which interior mutability can help! We’ll store the \"sent_messages\" within a \"RefCell\", and then the \"send\" method will be able to modify \"sent_messages\" to store the messages we’ve seen. Listing 15-22 shows what that looks like:\nFilename: src/lib.rs\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::cell::RefCell;\n\n    struct MockMessenger {\n        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,\n    }\n\n    impl MockMessenger {\n        fn new() -&gt; MockMessenger {\n            MockMessenger {\n                sent_messages: RefCell::new(vec![]),\n            }\n        }\n    }\n\n    impl Messenger for MockMessenger {\n        fn send(&amp;self, message: &amp;str) {\n            self.sent_messages.borrow_mut().push(String::from(message));\n        }\n    }\n\n    #[test]\n    fn it_sends_an_over_75_percent_warning_message() {\n        // --snip--\n\n        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);\n    }\n}\n\nListing 15-22: Using \"RefCell\" to mutate an inner value while the outer value is considered immutable\nThe \"sent_messages\" field is now of type \"RefCell&lt;Vec&gt;\" instead of \"Vec\". In the \"new\" function, we create a new \"RefCell&lt;Vec&gt;\" instance around the empty vector.\nFor the implementation of the \"send\" method, the first parameter is still an immutable borrow of \"self\", which matches the trait definition. We call \"borrow_mut\" on the \"RefCell&lt;Vec&gt;\" in \"self.sent_messages\" to get a mutable reference to the value inside the \"RefCell&lt;Vec&gt;\", which is the vector. Then we can call \"push\" on the mutable reference to the vector to keep track of the messages sent during the test.\nThe last change we have to make is in the assertion: to see how many items are in the inner vector, we call \"borrow\" on the \"RefCell&lt;Vec&gt;\" to get an immutable reference to the vector.\nNow that you’ve seen how to use \"RefCell\", let’s dig into how it works!\nKeeping Track of Borrows at Runtime with \"RefCell\"\nWhen creating immutable and mutable references, we use the \"&amp;\" and \"&amp;mut\" syntax, respectively. With \"RefCell\", we use the \"borrow\" and \"borrow_mut\" methods, which are part of the safe API that belongs to \"RefCell\". The \"borrow\" method returns the smart pointer type \"Ref\", and \"borrow_mut\" returns the smart pointer type \"RefMut\". Both types implement \"Deref\", so we can treat them like regular references.\nThe \"RefCell\" keeps track of how many \"Ref\" and \"RefMut\" smart pointers are currently active. Every time we call \"borrow\", the \"RefCell\" increases its count of how many immutable borrows are active. When a \"Ref\" value goes out of scope, the count of immutable borrows goes down by one. Just like the compile-time borrowing rules, \"RefCell\" lets us have many immutable borrows or one mutable borrow at any point in time.\nIf we try to violate these rules, rather than getting a compiler error as we would with references, the implementation of \"RefCell\" will panic at runtime. Listing 15-23 shows a modification of the implementation of \"send\" in Listing 15-22. We’re deliberately trying to create two mutable borrows active for the same scope to illustrate that \"RefCell\" prevents us from doing this at runtime.\nFilename: src/lib.rs\n    impl Messenger for MockMessenger {\n        fn send(&amp;self, message: &amp;str) {\n            let mut one_borrow = self.sent_messages.borrow_mut();\n            let mut two_borrow = self.sent_messages.borrow_mut();\n\n            one_borrow.push(String::from(message));\n            two_borrow.push(String::from(message));\n        }\n    }\n\nListing 15-23: Creating two mutable references in the same scope to see that \"RefCell\" will panic\nWe create a variable \"one_borrow\" for the \"RefMut\" smart pointer returned from \"borrow_mut\". Then we create another mutable borrow in the same way in the variable \"two_borrow\". This makes two mutable references in the same scope, which isn’t allowed. When we run the tests for our library, the code in Listing 15-23 will compile without any errors, but the test will fail:\n$ cargo test\n   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)\n    Finished test [unoptimized + debuginfo] target(s) in 0.91s\n     Running unittests src/lib.rs (target/debug/deps/limit_tracker-e599811fa246dbde)\n\nrunning 1 test\ntest tests::it_sends_an_over_75_percent_warning_message ... FAILED\n\nfailures:\n\n---- tests::it_sends_an_over_75_percent_warning_message stdout ----\nthread \"tests::it_sends_an_over_75_percent_warning_message\" panicked at \"already borrowed: BorrowMutError\", src/lib.rs:60:53\nnote: run with \"RUST_BACKTRACE=1\" environment variable to display a backtrace\n\n\nfailures:\n    tests::it_sends_an_over_75_percent_warning_message\n\ntest result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass \"--lib\"\n\nNotice that the code panicked with the message \"already borrowed: BorrowMutError\". This is how \"RefCell\" handles violations of the borrowing rules at runtime.\nChoosing to catch borrowing errors at runtime rather than compile time, as we’ve done here, means you’d potentially be finding mistakes in your code later in the development process: possibly not until your code was deployed to production. Also, your code would incur a small runtime performance penalty as a result of keeping track of the borrows at runtime rather than compile time. However, using \"RefCell\" makes it possible to write a mock object that can modify itself to keep track of the messages it has seen while you’re using it in a context where only immutable values are allowed. You can use \"RefCell\" despite its trade-offs to get more functionality than regular references provide.\nHaving Multiple Owners of Mutable Data by Combining \"Rc\" and \"RefCell\"\nA common way to use \"RefCell\" is in combination with \"Rc\". Recall that \"Rc\" lets you have multiple owners of some data, but it only gives immutable access to that data. If you have an \"Rc\" that holds a \"RefCell\", you can get a value that can have multiple owners and that you can mutate!\nFor example, recall the cons list example in Listing 15-18 where we used \"Rc\" to allow multiple lists to share ownership of another list. Because \"Rc\" holds only immutable values, we can’t change any of the values in the list once we’ve created them. Let’s add in \"RefCell\" to gain the ability to change the values in the lists. Listing 15-24 shows that by using a \"RefCell\" in the \"Cons\" definition, we can modify the value stored in all the lists:\nFilename: src/main.rs\n#[derive(Debug)]\nenum List {\n    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\nfn main() {\n    let value = Rc::new(RefCell::new(5));\n\n    let a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));\n\n    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&amp;a));\n    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&amp;a));\n\n    *value.borrow_mut() += 10;\n\n    println!(\"a after = {:?}\", a);\n    println!(\"b after = {:?}\", b);\n    println!(\"c after = {:?}\", c);\n}\n\nListing 15-24: Using \"Rc&lt;RefCell&gt;\" to create a \"List\" that we can mutate\nWe create a value that is an instance of \"Rc&lt;RefCell&gt;\" and store it in a variable named \"value\" so we can access it directly later. Then we create a \"List\" in \"a\" with a \"Cons\" variant that holds \"value\". We need to clone \"value\" so both \"a\" and \"value\" have ownership of the inner \"5\" value rather than transferring ownership from \"value\" to \"a\" or having \"a\" borrow from \"value\".\nWe wrap the list \"a\" in an \"Rc\" so when we create lists \"b\" and \"c\", they can both refer to \"a\", which is what we did in Listing 15-18.\nAfter we’ve created the lists in \"a\", \"b\", and \"c\", we want to add 10 to the value in \"value\". We do this by calling \"borrow_mut\" on \"value\", which uses the automatic dereferencing feature we discussed in Chapter 5 (see the section “Where’s the \"-&gt;\" Operator?”) to dereference the \"Rc\" to the inner \"RefCell\" value. The \"borrow_mut\" method returns a \"RefMut\" smart pointer, and we use the dereference operator on it and change the inner value.\nWhen we print \"a\", \"b\", and \"c\", we can see that they all have the modified value of 15 rather than 5:\n$ cargo run\n   Compiling cons-list v0.1.0 (file:///projects/cons-list)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.63s\n     Running \"target/debug/cons-list\"\na after = Cons(RefCell { value: 15 }, Nil)\nb after = Cons(RefCell { value: 3 }, Cons(RefCell { value: 15 }, Nil))\nc after = Cons(RefCell { value: 4 }, Cons(RefCell { value: 15 }, Nil))\n\nThis technique is pretty neat! By using \"RefCell\", we have an outwardly immutable \"List\" value. But we can use the methods on \"RefCell\" that provide access to its interior mutability so we can modify our data when we need to. The runtime checks of the borrowing rules protect us from data races, and it’s sometimes worth trading a bit of speed for this flexibility in our data structures. Note that \"RefCell\" does not work for multithreaded code! \"Mutex\" is the thread-safe version of \"RefCell\" and we’ll discuss \"Mutex\" in Chapter 16.\n\nReference Cycles Can Leak Memory\nRust’s memory safety guarantees make it difficult, but not impossible, to accidentally create memory that is never cleaned up (known as a memory leak). Preventing memory leaks entirely is not one of Rust’s guarantees, meaning memory leaks are memory safe in Rust. We can see that Rust allows memory leaks by using \"Rc\" and \"RefCell\": it’s possible to create references where items refer to each other in a cycle. This creates memory leaks because the reference count of each item in the cycle will never reach 0, and the values will never be dropped.\nCreating a Reference Cycle\nLet’s look at how a reference cycle might happen and how to prevent it, starting with the definition of the \"List\" enum and a \"tail\" method in Listing 15-25:\nFilename: src/main.rs\nuse crate::List::{Cons, Nil};\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\n#[derive(Debug)]\nenum List {\n    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),\n    Nil,\n}\n\nimpl List {\n    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {\n        match self {\n            Cons(_, item) =&gt; Some(item),\n            Nil =&gt; None,\n        }\n    }\n}\n\nfn main() {}\n\nListing 15-25: A cons list definition that holds a \"RefCell\" so we can modify what a \"Cons\" variant is referring to\nWe’re using another variation of the \"List\" definition from Listing 15-5. The second element in the \"Cons\" variant is now \"RefCell&lt;Rc&gt;\", meaning that instead of having the ability to modify the \"i32\" value as we did in Listing 15-24, we want to modify the \"List\" value a \"Cons\" variant is pointing to. We’re also adding a \"tail\" method to make it convenient for us to access the second item if we have a \"Cons\" variant.\nIn Listing 15-26, we’re adding a \"main\" function that uses the definitions in Listing 15-25. This code creates a list in \"a\" and a list in \"b\" that points to the list in \"a\". Then it modifies the list in \"a\" to point to \"b\", creating a reference cycle. There are \"println!\" statements along the way to show what the reference counts are at various points in this process.\nFilename: src/main.rs\nfn main() {\n    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));\n\n    println!(\"a initial rc count = {}\", Rc::strong_count(&amp;a));\n    println!(\"a next item = {:?}\", a.tail());\n\n    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&amp;a))));\n\n    println!(\"a rc count after b creation = {}\", Rc::strong_count(&amp;a));\n    println!(\"b initial rc count = {}\", Rc::strong_count(&amp;b));\n    println!(\"b next item = {:?}\", b.tail());\n\n    if let Some(link) = a.tail() {\n        *link.borrow_mut() = Rc::clone(&amp;b);\n    }\n\n    println!(\"b rc count after changing a = {}\", Rc::strong_count(&amp;b));\n    println!(\"a rc count after changing a = {}\", Rc::strong_count(&amp;a));\n\n    // Uncomment the next line to see that we have a cycle;\n    // it will overflow the stack\n    // println!(\"a next item = {:?}\", a.tail());\n}\n\nListing 15-26: Creating a reference cycle of two \"List\" values pointing to each other\nWe create an \"Rc\" instance holding a \"List\" value in the variable \"a\" with an initial list of \"5, Nil\". We then create an \"Rc\" instance holding another \"List\" value in the variable \"b\" that contains the value 10 and points to the list in \"a\".\nWe modify \"a\" so it points to \"b\" instead of \"Nil\", creating a cycle. We do that by using the \"tail\" method to get a reference to the \"RefCell&lt;Rc&gt;\" in \"a\", which we put in the variable \"link\". Then we use the \"borrow_mut\" method on the \"RefCell&lt;Rc&gt;\" to change the value inside from an \"Rc\" that holds a \"Nil\" value to the \"Rc\" in \"b\".\nWhen we run this code, keeping the last \"println!\" commented out for the moment, we’ll get this output:\n$ cargo run\n   Compiling cons-list v0.1.0 (file:///projects/cons-list)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.53s\n     Running \"target/debug/cons-list\"\na initial rc count = 1\na next item = Some(RefCell { value: Nil })\na rc count after b creation = 2\nb initial rc count = 1\nb next item = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })\nb rc count after changing a = 2\na rc count after changing a = 2\n\nThe reference count of the \"Rc\" instances in both \"a\" and \"b\" are 2 after we change the list in \"a\" to point to \"b\". At the end of \"main\", Rust drops the variable \"b\", which decreases the reference count of the \"b\" \"Rc\" instance from 2 to 1. The memory that \"Rc\" has on the heap won’t be dropped at this point, because its reference count is 1, not 0. Then Rust drops \"a\", which decreases the reference count of the \"a\" \"Rc\" instance from 2 to 1 as well. This instance’s memory can’t be dropped either, because the other \"Rc\" instance still refers to it. The memory allocated to the list will remain uncollected forever. To visualize this reference cycle, we’ve created a diagram in Figure 15-4.\n\nFigure 15-4: A reference cycle of lists \"a\" and \"b\" pointing to each other\nIf you uncomment the last \"println!\" and run the program, Rust will try to print this cycle with \"a\" pointing to \"b\" pointing to \"a\" and so forth until it overflows the stack.\nCompared to a real-world program, the consequences creating a reference cycle in this example aren’t very dire: right after we create the reference cycle, the program ends. However, if a more complex program allocated lots of memory in a cycle and held onto it for a long time, the program would use more memory than it needed and might overwhelm the system, causing it to run out of available memory.\nCreating reference cycles is not easily done, but it’s not impossible either. If you have \"RefCell\" values that contain \"Rc\" values or similar nested combinations of types with interior mutability and reference counting, you must ensure that you don’t create cycles; you can’t rely on Rust to catch them. Creating a reference cycle would be a logic bug in your program that you should use automated tests, code reviews, and other software development practices to minimize.\nAnother solution for avoiding reference cycles is reorganizing your data structures so that some references express ownership and some references don’t. As a result, you can have cycles made up of some ownership relationships and some non-ownership relationships, and only the ownership relationships affect whether or not a value can be dropped. In Listing 15-25, we always want \"Cons\" variants to own their list, so reorganizing the data structure isn’t possible. Let’s look at an example using graphs made up of parent nodes and child nodes to see when non-ownership relationships are an appropriate way to prevent reference cycles.\nPreventing Reference Cycles: Turning an \"Rc\" into a \"Weak\"\nSo far, we’ve demonstrated that calling \"Rc::clone\" increases the \"strong_count\" of an \"Rc\" instance, and an \"Rc\" instance is only cleaned up if its \"strong_count\" is 0. You can also create a weak reference to the value within an \"Rc\" instance by calling \"Rc::downgrade\" and passing a reference to the \"Rc\". Strong references are how you can share ownership of an \"Rc\" instance. Weak references don’t express an ownership relationship, and their count doesn’t affect when an \"Rc\" instance is cleaned up. They won’t cause a reference cycle because any cycle involving some weak references will be broken once the strong reference count of values involved is 0.\nWhen you call \"Rc::downgrade\", you get a smart pointer of type \"Weak\". Instead of increasing the \"strong_count\" in the \"Rc\" instance by 1, calling \"Rc::downgrade\" increases the \"weak_count\" by 1. The \"Rc\" type uses \"weak_count\" to keep track of how many \"Weak\" references exist, similar to \"strong_count\". The difference is the \"weak_count\" doesn’t need to be 0 for the \"Rc\" instance to be cleaned up.\nBecause the value that \"Weak\" references might have been dropped, to do anything with the value that a \"Weak\" is pointing to, you must make sure the value still exists. Do this by calling the \"upgrade\" method on a \"Weak\" instance, which will return an \"Option&lt;Rc&gt;\". You’ll get a result of \"Some\" if the \"Rc\" value has not been dropped yet and a result of \"None\" if the \"Rc\" value has been dropped. Because \"upgrade\" returns an \"Option&lt;Rc&gt;\", Rust will ensure that the \"Some\" case and the \"None\" case are handled, and there won’t be an invalid pointer.\nAs an example, rather than using a list whose items know only about the next item, we’ll create a tree whose items know about their children items and their parent items.\nCreating a Tree Data Structure: a \"Node\" with Child Nodes\nTo start, we’ll build a tree with nodes that know about their child nodes. We’ll create a struct named \"Node\" that holds its own \"i32\" value as well as references to its children \"Node\" values:\nFilename: src/main.rs\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\n#[derive(Debug)]\nstruct Node {\n    value: i32,\n    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,\n}\n\nWe want a \"Node\" to own its children, and we want to share that ownership with variables so we can access each \"Node\" in the tree directly. To do this, we define the \"Vec\" items to be values of type \"Rc\". We also want to modify which nodes are children of another node, so we have a \"RefCell\" in \"children\" around the \"Vec&lt;Rc&gt;\".\nNext, we’ll use our struct definition and create one \"Node\" instance named \"leaf\" with the value 3 and no children, and another instance named \"branch\" with the value 5 and \"leaf\" as one of its children, as shown in Listing 15-27:\nFilename: src/main.rs\nfn main() {\n    let leaf = Rc::new(Node {\n        value: 3,\n        children: RefCell::new(vec![]),\n    });\n\n    let branch = Rc::new(Node {\n        value: 5,\n        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),\n    });\n}\n\nListing 15-27: Creating a \"leaf\" node with no children and a \"branch\" node with \"leaf\" as one of its children\nWe clone the \"Rc\" in \"leaf\" and store that in \"branch\", meaning the \"Node\" in \"leaf\" now has two owners: \"leaf\" and \"branch\". We can get from \"branch\" to \"leaf\" through \"branch.children\", but there’s no way to get from \"leaf\" to \"branch\". The reason is that \"leaf\" has no reference to \"branch\" and doesn’t know they’re related. We want \"leaf\" to know that \"branch\" is its parent. We’ll do that next.\nAdding a Reference from a Child to Its Parent\nTo make the child node aware of its parent, we need to add a \"parent\" field to our \"Node\" struct definition. The trouble is in deciding what the type of \"parent\" should be. We know it can’t contain an \"Rc\", because that would create a reference cycle with \"leaf.parent\" pointing to \"branch\" and \"branch.children\" pointing to \"leaf\", which would cause their \"strong_count\" values to never be 0.\nThinking about the relationships another way, a parent node should own its children: if a parent node is dropped, its child nodes should be dropped as well. However, a child should not own its parent: if we drop a child node, the parent should still exist. This is a case for weak references!\nSo instead of \"Rc\", we’ll make the type of \"parent\" use \"Weak\", specifically a \"RefCell&lt;Weak&gt;\". Now our \"Node\" struct definition looks like this:\nFilename: src/main.rs\nuse std::cell::RefCell;\nuse std::rc::{Rc, Weak};\n\n#[derive(Debug)]\nstruct Node {\n    value: i32,\n    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,\n    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,\n}\n\nA node will be able to refer to its parent node but doesn’t own its parent. In Listing 15-28, we update \"main\" to use this new definition so the \"leaf\" node will have a way to refer to its parent, \"branch\":\nFilename: src/main.rs\nfn main() {\n    let leaf = Rc::new(Node {\n        value: 3,\n        parent: RefCell::new(Weak::new()),\n        children: RefCell::new(vec![]),\n    });\n\n    println!(\"leaf parent = {:?}\", leaf.parent.borrow().upgrade());\n\n    let branch = Rc::new(Node {\n        value: 5,\n        parent: RefCell::new(Weak::new()),\n        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),\n    });\n\n    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);\n\n    println!(\"leaf parent = {:?}\", leaf.parent.borrow().upgrade());\n}\n\nListing 15-28: A \"leaf\" node with a weak reference to its parent node \"branch\"\nCreating the \"leaf\" node looks similar to Listing 15-27 with the exception of the \"parent\" field: \"leaf\" starts out without a parent, so we create a new, empty \"Weak\" reference instance.\nAt this point, when we try to get a reference to the parent of \"leaf\" by using the \"upgrade\" method, we get a \"None\" value. We see this in the output from the first \"println!\" statement:\nleaf parent = None\n\nWhen we create the \"branch\" node, it will also have a new \"Weak\" reference in the \"parent\" field, because \"branch\" doesn’t have a parent node. We still have \"leaf\" as one of the children of \"branch\". Once we have the \"Node\" instance in \"branch\", we can modify \"leaf\" to give it a \"Weak\" reference to its parent. We use the \"borrow_mut\" method on the \"RefCell&lt;Weak&gt;\" in the \"parent\" field of \"leaf\", and then we use the \"Rc::downgrade\" function to create a \"Weak\" reference to \"branch\" from the \"Rc\" in \"branch.\"\nWhen we print the parent of \"leaf\" again, this time we’ll get a \"Some\" variant holding \"branch\": now \"leaf\" can access its parent! When we print \"leaf\", we also avoid the cycle that eventually ended in a stack overflow like we had in Listing 15-26; the \"Weak\" references are printed as \"(Weak)\":\nleaf parent = Some(Node { value: 5, parent: RefCell { value: (Weak) },\nchildren: RefCell { value: [Node { value: 3, parent: RefCell { value: (Weak) },\nchildren: RefCell { value: [] } }] } })\n\nThe lack of infinite output indicates that this code didn’t create a reference cycle. We can also tell this by looking at the values we get from calling \"Rc::strong_count\" and \"Rc::weak_count\".\nVisualizing Changes to \"strong_count\" and \"weak_count\"\nLet’s look at how the \"strong_count\" and \"weak_count\" values of the \"Rc\" instances change by creating a new inner scope and moving the creation of \"branch\" into that scope. By doing so, we can see what happens when \"branch\" is created and then dropped when it goes out of scope. The modifications are shown in Listing 15-29:\nFilename: src/main.rs\nfn main() {\n    let leaf = Rc::new(Node {\n        value: 3,\n        parent: RefCell::new(Weak::new()),\n        children: RefCell::new(vec![]),\n    });\n\n    println!(\n        \"leaf strong = {}, weak = {}\",\n        Rc::strong_count(&amp;leaf),\n        Rc::weak_count(&amp;leaf),\n    );\n\n    {\n        let branch = Rc::new(Node {\n            value: 5,\n            parent: RefCell::new(Weak::new()),\n            children: RefCell::new(vec![Rc::clone(&amp;leaf)]),\n        });\n\n        *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);\n\n        println!(\n            \"branch strong = {}, weak = {}\",\n            Rc::strong_count(&amp;branch),\n            Rc::weak_count(&amp;branch),\n        );\n\n        println!(\n            \"leaf strong = {}, weak = {}\",\n            Rc::strong_count(&amp;leaf),\n            Rc::weak_count(&amp;leaf),\n        );\n    }\n\n    println!(\"leaf parent = {:?}\", leaf.parent.borrow().upgrade());\n    println!(\n        \"leaf strong = {}, weak = {}\",\n        Rc::strong_count(&amp;leaf),\n        Rc::weak_count(&amp;leaf),\n    );\n}\n\nListing 15-29: Creating \"branch\" in an inner scope and examining strong and weak reference counts\nAfter \"leaf\" is created, its \"Rc\" has a strong count of 1 and a weak count of 0. In the inner scope, we create \"branch\" and associate it with \"leaf\", at which point when we print the counts, the \"Rc\" in \"branch\" will have a strong count of 1 and a weak count of 1 (for \"leaf.parent\" pointing to \"branch\" with a \"Weak\"). When we print the counts in \"leaf\", we’ll see it will have a strong count of 2, because \"branch\" now has a clone of the \"Rc\" of \"leaf\" stored in \"branch.children\", but will still have a weak count of 0.\nWhen the inner scope ends, \"branch\" goes out of scope and the strong count of the \"Rc\" decreases to 0, so its \"Node\" is dropped. The weak count of 1 from \"leaf.parent\" has no bearing on whether or not \"Node\" is dropped, so we don’t get any memory leaks!\nIf we try to access the parent of \"leaf\" after the end of the scope, we’ll get \"None\" again. At the end of the program, the \"Rc\" in \"leaf\" has a strong count of 1 and a weak count of 0, because the variable \"leaf\" is now the only reference to the \"Rc\" again.\nAll of the logic that manages the counts and value dropping is built into \"Rc\" and \"Weak\" and their implementations of the \"Drop\" trait. By specifying that the relationship from a child to its parent should be a \"Weak\" reference in the definition of \"Node\", you’re able to have parent nodes point to child nodes and vice versa without creating a reference cycle and memory leaks.\nSummary\nThis chapter covered how to use smart pointers to make different guarantees and trade-offs from those Rust makes by default with regular references. The \"Box\" type has a known size and points to data allocated on the heap. The \"Rc\" type keeps track of the number of references to data on the heap so that data can have multiple owners. The \"RefCell\" type with its interior mutability gives us a type that we can use when we need an immutable type but need to change an inner value of that type; it also enforces the borrowing rules at runtime instead of at compile time.\nAlso discussed were the \"Deref\" and \"Drop\" traits, which enable a lot of the functionality of smart pointers. We explored reference cycles that can cause memory leaks and how to prevent them using \"Weak\".\nIf this chapter has piqued your interest and you want to implement your own smart pointers, check out “The Rustonomicon” for more useful information.\nNext, we’ll talk about concurrency in Rust. You’ll even learn about a few new smart pointers.\n\n16\nFearless Concurrency\nHandling concurrent programming safely and efficiently is another of Rust’s major goals. Concurrent programming, where different parts of a program execute independently, and parallel programming, where different parts of a program execute at the same time, are becoming increasingly important as more computers take advantage of their multiple processors. Historically, programming in these contexts has been difficult and error prone: Rust hopes to change that.\nInitially, the Rust team thought that ensuring memory safety and preventing concurrency problems were two separate challenges to be solved with different methods. Over time, the team discovered that the ownership and type systems are a powerful set of tools to help manage memory safety and concurrency problems! By leveraging ownership and type checking, many concurrency errors are compile-time errors in Rust rather than runtime errors. Therefore, rather than making you spend lots of time trying to reproduce the exact circumstances under which a runtime concurrency bug occurs, incorrect code will refuse to compile and present an error explaining the problem. As a result, you can fix your code while you’re working on it rather than potentially after it has been shipped to production. We’ve nicknamed this aspect of Rust fearless concurrency. Fearless concurrency allows you to write code that is free of subtle bugs and is easy to refactor without introducing new bugs.\n\nNote: For simplicity’s sake, we’ll refer to many of the problems as concurrent rather than being more precise by saying concurrent and/or parallel. If this book were about concurrency and/or parallelism, we’d be more specific. For this chapter, please mentally substitute concurrent and/or parallel whenever we use concurrent.\n\nMany languages are dogmatic about the solutions they offer for handling concurrent problems. For example, Erlang has elegant functionality for message-passing concurrency but has only obscure ways to share state between threads. Supporting only a subset of possible solutions is a reasonable strategy for higher-level languages, because a higher-level language promises benefits from giving up some control to gain abstractions. However, lower-level languages are expected to provide the solution with the best performance in any given situation and have fewer abstractions over the hardware. Therefore, Rust offers a variety of tools for modeling problems in whatever way is appropriate for your situation and requirements.\nHere are the topics we’ll cover in this chapter:\n\nHow to create threads to run multiple pieces of code at the same time\nMessage-passing concurrency, where channels send messages between threads\nShared-state concurrency, where multiple threads have access to some piece of data\nThe \"Sync\" and \"Send\" traits, which extend Rust’s concurrency guarantees to user-defined types as well as types provided by the standard library\n\n\nUsing Threads to Run Code Simultaneously\nIn most current operating systems, an executed program’s code is run in a process, and the operating system will manage multiple processes at once. Within a program, you can also have independent parts that run simultaneously. The features that run these independent parts are called threads. For example, a web server could have multiple threads so that it could respond to more than one request at the same time.\nSplitting the computation in your program into multiple threads to run multiple tasks at the same time can improve performance, but it also adds complexity. Because threads can run simultaneously, there’s no inherent guarantee about the order in which parts of your code on different threads will run. This can lead to problems, such as:\n\nRace conditions, where threads are accessing data or resources in an inconsistent order\nDeadlocks, where two threads are waiting for each other, preventing both threads from continuing\nBugs that happen only in certain situations and are hard to reproduce and fix reliably\n\nRust attempts to mitigate the negative effects of using threads, but programming in a multithreaded context still takes careful thought and requires a code structure that is different from that in programs running in a single thread.\nProgramming languages implement threads in a few different ways, and many operating systems provide an API the language can call for creating new threads. The Rust standard library uses a 1:1 model of thread implementation, whereby a program uses one operating system thread per one language thread. There are crates that implement other models of threading that make different tradeoffs to the 1:1 model.\nCreating a New Thread with \"spawn\"\nTo create a new thread, we call the \"thread::spawn\" function and pass it a closure (we talked about closures in Chapter 13) containing the code we want to run in the new thread. The example in Listing 16-1 prints some text from a main thread and other text from a new thread:\nFilename: src/main.rs\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    thread::spawn(|| {\n        for i in 1..10 {\n            println!(\"hi number {} from the spawned thread!\", i);\n            thread::sleep(Duration::from_millis(1));\n        }\n    });\n\n    for i in 1..5 {\n        println!(\"hi number {} from the main thread!\", i);\n        thread::sleep(Duration::from_millis(1));\n    }\n}\n\nListing 16-1: Creating a new thread to print one thing while the main thread prints something else\nNote that when the main thread of a Rust program completes, all spawned threads are shut down, whether or not they have finished running. The output from this program might be a little different every time, but it will look similar to the following:\nhi number 1 from the main thread!\nhi number 1 from the spawned thread!\nhi number 2 from the main thread!\nhi number 2 from the spawned thread!\nhi number 3 from the main thread!\nhi number 3 from the spawned thread!\nhi number 4 from the main thread!\nhi number 4 from the spawned thread!\nhi number 5 from the spawned thread!\n\nThe calls to \"thread::sleep\" force a thread to stop its execution for a short duration, allowing a different thread to run. The threads will probably take turns, but that isn’t guaranteed: it depends on how your operating system schedules the threads. In this run, the main thread printed first, even though the print statement from the spawned thread appears first in the code. And even though we told the spawned thread to print until \"i\" is 9, it only got to 5 before the main thread shut down.\nIf you run this code and only see output from the main thread, or don’t see any overlap, try increasing the numbers in the ranges to create more opportunities for the operating system to switch between the threads.\nWaiting for All Threads to Finish Using \"join\" Handles\nThe code in Listing 16-1 not only stops the spawned thread prematurely most of the time due to the main thread ending, but because there is no guarantee on the order in which threads run, we also can’t guarantee that the spawned thread will get to run at all!\nWe can fix the problem of the spawned thread not running or ending prematurely by saving the return value of \"thread::spawn\" in a variable. The return type of \"thread::spawn\" is \"JoinHandle\". A \"JoinHandle\" is an owned value that, when we call the \"join\" method on it, will wait for its thread to finish. Listing 16-2 shows how to use the \"JoinHandle\" of the thread we created in Listing 16-1 and call \"join\" to make sure the spawned thread finishes before \"main\" exits:\nFilename: src/main.rs\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    let handle = thread::spawn(|| {\n        for i in 1..10 {\n            println!(\"hi number {} from the spawned thread!\", i);\n            thread::sleep(Duration::from_millis(1));\n        }\n    });\n\n    for i in 1..5 {\n        println!(\"hi number {} from the main thread!\", i);\n        thread::sleep(Duration::from_millis(1));\n    }\n\n    handle.join().unwrap();\n}\n\nListing 16-2: Saving a \"JoinHandle\" from \"thread::spawn\" to guarantee the thread is run to completion\nCalling \"join\" on the handle blocks the thread currently running until the thread represented by the handle terminates. Blocking a thread means that thread is prevented from performing work or exiting. Because we’ve put the call to \"join\" after the main thread’s \"for\" loop, running Listing 16-2 should produce output similar to this:\nhi number 1 from the main thread!\nhi number 2 from the main thread!\nhi number 1 from the spawned thread!\nhi number 3 from the main thread!\nhi number 2 from the spawned thread!\nhi number 4 from the main thread!\nhi number 3 from the spawned thread!\nhi number 4 from the spawned thread!\nhi number 5 from the spawned thread!\nhi number 6 from the spawned thread!\nhi number 7 from the spawned thread!\nhi number 8 from the spawned thread!\nhi number 9 from the spawned thread!\n\nThe two threads continue alternating, but the main thread waits because of the call to \"handle.join()\" and does not end until the spawned thread is finished.\nBut let’s see what happens when we instead move \"handle.join()\" before the \"for\" loop in \"main\", like this:\nFilename: src/main.rs\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    let handle = thread::spawn(|| {\n        for i in 1..10 {\n            println!(\"hi number {} from the spawned thread!\", i);\n            thread::sleep(Duration::from_millis(1));\n        }\n    });\n\n    handle.join().unwrap();\n\n    for i in 1..5 {\n        println!(\"hi number {} from the main thread!\", i);\n        thread::sleep(Duration::from_millis(1));\n    }\n}\n\nThe main thread will wait for the spawned thread to finish and then run its \"for\" loop, so the output won’t be interleaved anymore, as shown here:\nhi number 1 from the spawned thread!\nhi number 2 from the spawned thread!\nhi number 3 from the spawned thread!\nhi number 4 from the spawned thread!\nhi number 5 from the spawned thread!\nhi number 6 from the spawned thread!\nhi number 7 from the spawned thread!\nhi number 8 from the spawned thread!\nhi number 9 from the spawned thread!\nhi number 1 from the main thread!\nhi number 2 from the main thread!\nhi number 3 from the main thread!\nhi number 4 from the main thread!\n\nSmall details, such as where \"join\" is called, can affect whether or not your threads run at the same time.\nUsing \"move\" Closures with Threads\nWe\"ll often use the \"move\" keyword with closures passed to \"thread::spawn\" because the closure will then take ownership of the values it uses from the environment, thus transferring ownership of those values from one thread to another. In the “Capturing References or Moving Ownership” section of Chapter 13, we discussed \"move\" in the context of closures. Now, we’ll concentrate more on the interaction between \"move\" and \"thread::spawn\".\nNotice in Listing 16-1 that the closure we pass to \"thread::spawn\" takes no arguments: we’re not using any data from the main thread in the spawned thread’s code. To use data from the main thread in the spawned thread, the spawned thread’s closure must capture the values it needs. Listing 16-3 shows an attempt to create a vector in the main thread and use it in the spawned thread. However, this won’t yet work, as you’ll see in a moment.\nFilename: src/main.rs\nuse std::thread;\n\nfn main() {\n    let v = vec![1, 2, 3];\n\n    let handle = thread::spawn(|| {\n        println!(\"Here\"s a vector: {:?}\", v);\n    });\n\n    handle.join().unwrap();\n}\n\nListing 16-3: Attempting to use a vector created by the main thread in another thread\nThe closure uses \"v\", so it will capture \"v\" and make it part of the closure’s environment. Because \"thread::spawn\" runs this closure in a new thread, we should be able to access \"v\" inside that new thread. But when we compile this example, we get the following error:\n$ cargo run\n   Compiling threads v0.1.0 (file:///projects/threads)\nerror[E0373]: closure may outlive the current function, but it borrows \"v\", which is owned by the current function\n --&gt; src/main.rs:6:32\n  |\n6 |     let handle = thread::spawn(|| {\n  |                                ^^ may outlive borrowed value \"v\"\n7 |         println!(\"Here\"s a vector: {:?}\", v);\n  |                                           - \"v\" is borrowed here\n  |\nnote: function requires argument type to outlive \"\"static\"\n --&gt; src/main.rs:6:18\n  |\n6 |       let handle = thread::spawn(|| {\n  |  __________________^\n7 | |         println!(\"Here\"s a vector: {:?}\", v);\n8 | |     });\n  | |______^\nhelp: to force the closure to take ownership of \"v\" (and any other referenced variables), use the \"move\" keyword\n  |\n6 |     let handle = thread::spawn(move || {\n  |                                ++++\n\nFor more information about this error, try \"rustc --explain E0373\".\nerror: could not compile \"threads\" due to previous error\n\nRust infers how to capture \"v\", and because \"println!\" only needs a reference to \"v\", the closure tries to borrow \"v\". However, there’s a problem: Rust can’t tell how long the spawned thread will run, so it doesn’t know if the reference to \"v\" will always be valid.\nListing 16-4 provides a scenario that’s more likely to have a reference to \"v\" that won’t be valid:\nFilename: src/main.rs\nuse std::thread;\n\nfn main() {\n    let v = vec![1, 2, 3];\n\n    let handle = thread::spawn(|| {\n        println!(\"Here\"s a vector: {:?}\", v);\n    });\n\n    drop(v); // oh no!\n\n    handle.join().unwrap();\n}\n\nListing 16-4: A thread with a closure that attempts to capture a reference to \"v\" from a main thread that drops \"v\"\nIf Rust allowed us to run this code, there’s a possibility the spawned thread would be immediately put in the background without running at all. The spawned thread has a reference to \"v\" inside, but the main thread immediately drops \"v\", using the \"drop\" function we discussed in Chapter 15. Then, when the spawned thread starts to execute, \"v\" is no longer valid, so a reference to it is also invalid. Oh no!\nTo fix the compiler error in Listing 16-3, we can use the error message’s advice:\nhelp: to force the closure to take ownership of \"v\" (and any other referenced variables), use the \"move\" keyword\n  |\n6 |     let handle = thread::spawn(move || {\n  |                                ++++\n\nBy adding the \"move\" keyword before the closure, we force the closure to take ownership of the values it’s using rather than allowing Rust to infer that it should borrow the values. The modification to Listing 16-3 shown in Listing 16-5 will compile and run as we intend:\nFilename: src/main.rs\nuse std::thread;\n\nfn main() {\n    let v = vec![1, 2, 3];\n\n    let handle = thread::spawn(move || {\n        println!(\"Here\"s a vector: {:?}\", v);\n    });\n\n    handle.join().unwrap();\n}\n\nListing 16-5: Using the \"move\" keyword to force a closure to take ownership of the values it uses\nWe might be tempted to try the same thing to fix the code in Listing 16-4 where the main thread called \"drop\" by using a \"move\" closure. However, this fix will not work because what Listing 16-4 is trying to do is disallowed for a different reason. If we added \"move\" to the closure, we would move \"v\" into the closure’s environment, and we could no longer call \"drop\" on it in the main thread. We would get this compiler error instead:\n$ cargo run\n   Compiling threads v0.1.0 (file:///projects/threads)\nerror[E0382]: use of moved value: \"v\"\n  --&gt; src/main.rs:10:10\n   |\n4  |     let v = vec![1, 2, 3];\n   |         - move occurs because \"v\" has type \"Vec&lt;i32&gt;\", which does not implement the \"Copy\" trait\n5  |\n6  |     let handle = thread::spawn(move || {\n   |                                ------- value moved into closure here\n7  |         println!(\"Here\"s a vector: {:?}\", v);\n   |                                           - variable moved due to use in closure\n...\n10 |     drop(v); // oh no!\n   |          ^ value used here after move\n\nFor more information about this error, try \"rustc --explain E0382\".\nerror: could not compile \"threads\" due to previous error\n\nRust’s ownership rules have saved us again! We got an error from the code in Listing 16-3 because Rust was being conservative and only borrowing \"v\" for the thread, which meant the main thread could theoretically invalidate the spawned thread’s reference. By telling Rust to move ownership of \"v\" to the spawned thread, we’re guaranteeing Rust that the main thread won’t use \"v\" anymore. If we change Listing 16-4 in the same way, we’re then violating the ownership rules when we try to use \"v\" in the main thread. The \"move\" keyword overrides Rust’s conservative default of borrowing; it doesn’t let us violate the ownership rules.\nWith a basic understanding of threads and the thread API, let’s look at what we can do with threads.\n\nUsing Message Passing to Transfer Data Between Threads\nOne increasingly popular approach to ensuring safe concurrency is message passing, where threads or actors communicate by sending each other messages containing data. Here’s the idea in a slogan from the Go language documentation: “Do not communicate by sharing memory; instead, share memory by communicating.”\nTo accomplish message-sending concurrency, Rust\"s standard library provides an implementation of channels. A channel is a general programming concept by which data is sent from one thread to another.\nYou can imagine a channel in programming as being like a directional channel of water, such as a stream or a river. If you put something like a rubber duck into a river, it will travel downstream to the end of the waterway.\nA channel has two halves: a transmitter and a receiver. The transmitter half is the upstream location where you put rubber ducks into the river, and the receiver half is where the rubber duck ends up downstream. One part of your code calls methods on the transmitter with the data you want to send, and another part checks the receiving end for arriving messages. A channel is said to be closed if either the transmitter or receiver half is dropped.\nHere, we’ll work up to a program that has one thread to generate values and send them down a channel, and another thread that will receive the values and print them out. We’ll be sending simple values between threads using a channel to illustrate the feature. Once you’re familiar with the technique, you could use channels for any threads that need to communicate between each other, such as a chat system or a system where many threads perform parts of a calculation and send the parts to one thread that aggregates the results.\nFirst, in Listing 16-6, we’ll create a channel but not do anything with it. Note that this won’t compile yet because Rust can’t tell what type of values we want to send over the channel.\nFilename: src/main.rs\nuse std::sync::mpsc;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n}\n\nListing 16-6: Creating a channel and assigning the two halves to \"tx\" and \"rx\"\nWe create a new channel using the \"mpsc::channel\" function; \"mpsc\" stands for multiple producer, single consumer. In short, the way Rust’s standard library implements channels means a channel can have multiple sending ends that produce values but only one receiving end that consumes those values. Imagine multiple streams flowing together into one big river: everything sent down any of the streams will end up in one river at the end. We’ll start with a single producer for now, but we’ll add multiple producers when we get this example working.\nThe \"mpsc::channel\" function returns a tuple, the first element of which is the sending end--the transmitter--and the second element is the receiving end--the receiver. The abbreviations \"tx\" and \"rx\" are traditionally used in many fields for transmitter and receiver respectively, so we name our variables as such to indicate each end. We’re using a \"let\" statement with a pattern that destructures the tuples; we’ll discuss the use of patterns in \"let\" statements and destructuring in Chapter 18. For now, know that using a \"let\" statement this way is a convenient approach to extract the pieces of the tuple returned by \"mpsc::channel\".\nLet’s move the transmitting end into a spawned thread and have it send one string so the spawned thread is communicating with the main thread, as shown in Listing 16-7. This is like putting a rubber duck in the river upstream or sending a chat message from one thread to another.\nFilename: src/main.rs\nuse std::sync::mpsc;\nuse std::thread;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n\n    thread::spawn(move || {\n        let val = String::from(\"hi\");\n        tx.send(val).unwrap();\n    });\n}\n\nListing 16-7: Moving \"tx\" to a spawned thread and sending “hi”\nAgain, we’re using \"thread::spawn\" to create a new thread and then using \"move\" to move \"tx\" into the closure so the spawned thread owns \"tx\". The spawned thread needs to own the transmitter to be able to send messages through the channel. The transmitter has a \"send\" method that takes the value we want to send. The \"send\" method returns a \"Result&lt;T, E&gt;\" type, so if the receiver has already been dropped and there’s nowhere to send a value, the send operation will return an error. In this example, we’re calling \"unwrap\" to panic in case of an error. But in a real application, we would handle it properly: return to Chapter 9 to review strategies for proper error handling.\nIn Listing 16-8, we’ll get the value from the receiver in the main thread. This is like retrieving the rubber duck from the water at the end of the river or receiving a chat message.\nFilename: src/main.rs\nuse std::sync::mpsc;\nuse std::thread;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n\n    thread::spawn(move || {\n        let val = String::from(\"hi\");\n        tx.send(val).unwrap();\n    });\n\n    let received = rx.recv().unwrap();\n    println!(\"Got: {}\", received);\n}\n\nListing 16-8: Receiving the value “hi” in the main thread and printing it\nThe receiver has two useful methods: \"recv\" and \"try_recv\". We’re using \"recv\", short for receive, which will block the main thread’s execution and wait until a value is sent down the channel. Once a value is sent, \"recv\" will return it in a \"Result&lt;T, E&gt;\". When the transmitter closes, \"recv\" will return an error to signal that no more values will be coming.\nThe \"try_recv\" method doesn’t block, but will instead return a \"Result&lt;T, E&gt;\" immediately: an \"Ok\" value holding a message if one is available and an \"Err\" value if there aren’t any messages this time. Using \"try_recv\" is useful if this thread has other work to do while waiting for messages: we could write a loop that calls \"try_recv\" every so often, handles a message if one is available, and otherwise does other work for a little while until checking again.\nWe’ve used \"recv\" in this example for simplicity; we don’t have any other work for the main thread to do other than wait for messages, so blocking the main thread is appropriate.\nWhen we run the code in Listing 16-8, we’ll see the value printed from the main thread:\nGot: hi\n\nPerfect!\nChannels and Ownership Transference\nThe ownership rules play a vital role in message sending because they help you write safe, concurrent code. Preventing errors in concurrent programming is the advantage of thinking about ownership throughout your Rust programs. Let’s do an experiment to show how channels and ownership work together to prevent problems: we’ll try to use a \"val\" value in the spawned thread after we’ve sent it down the channel. Try compiling the code in Listing 16-9 to see why this code isn’t allowed:\nFilename: src/main.rs\nuse std::sync::mpsc;\nuse std::thread;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n\n    thread::spawn(move || {\n        let val = String::from(\"hi\");\n        tx.send(val).unwrap();\n        println!(\"val is {}\", val);\n    });\n\n    let received = rx.recv().unwrap();\n    println!(\"Got: {}\", received);\n}\n\nListing 16-9: Attempting to use \"val\" after we’ve sent it down the channel\nHere, we try to print \"val\" after we’ve sent it down the channel via \"tx.send\". Allowing this would be a bad idea: once the value has been sent to another thread, that thread could modify or drop it before we try to use the value again. Potentially, the other thread’s modifications could cause errors or unexpected results due to inconsistent or nonexistent data. However, Rust gives us an error if we try to compile the code in Listing 16-9:\n$ cargo run\n   Compiling message-passing v0.1.0 (file:///projects/message-passing)\nerror[E0382]: borrow of moved value: \"val\"\n  --&gt; src/main.rs:10:31\n   |\n8  |         let val = String::from(\"hi\");\n   |             --- move occurs because \"val\" has type \"String\", which does not implement the \"Copy\" trait\n9  |         tx.send(val).unwrap();\n   |                 --- value moved here\n10 |         println!(\"val is {}\", val);\n   |                               ^^^ value borrowed here after move\n   |\n   = note: this error originates in the macro \"$crate::format_args_nl\" which comes from the expansion of the macro \"println\" (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try \"rustc --explain E0382\".\nerror: could not compile \"message-passing\" due to previous error\n\nOur concurrency mistake has caused a compile time error. The \"send\" function takes ownership of its parameter, and when the value is moved, the receiver takes ownership of it. This stops us from accidentally using the value again after sending it; the ownership system checks that everything is okay.\nSending Multiple Values and Seeing the Receiver Waiting\nThe code in Listing 16-8 compiled and ran, but it didn’t clearly show us that two separate threads were talking to each other over the channel. In Listing 16-10 we’ve made some modifications that will prove the code in Listing 16-8 is running concurrently: the spawned thread will now send multiple messages and pause for a second between each message.\nFilename: src/main.rs\nuse std::sync::mpsc;\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n\n    thread::spawn(move || {\n        let vals = vec![\n            String::from(\"hi\"),\n            String::from(\"from\"),\n            String::from(\"the\"),\n            String::from(\"thread\"),\n        ];\n\n        for val in vals {\n            tx.send(val).unwrap();\n            thread::sleep(Duration::from_secs(1));\n        }\n    });\n\n    for received in rx {\n        println!(\"Got: {}\", received);\n    }\n}\n\nListing 16-10: Sending multiple messages and pausing between each\nThis time, the spawned thread has a vector of strings that we want to send to the main thread. We iterate over them, sending each individually, and pause between each by calling the \"thread::sleep\" function with a \"Duration\" value of 1 second.\nIn the main thread, we’re not calling the \"recv\" function explicitly anymore: instead, we’re treating \"rx\" as an iterator. For each value received, we’re printing it. When the channel is closed, iteration will end.\nWhen running the code in Listing 16-10, you should see the following output with a 1-second pause in between each line:\nGot: hi\nGot: from\nGot: the\nGot: thread\n\nBecause we don’t have any code that pauses or delays in the \"for\" loop in the main thread, we can tell that the main thread is waiting to receive values from the spawned thread.\nCreating Multiple Producers by Cloning the Transmitter\nEarlier we mentioned that \"mpsc\" was an acronym for multiple producer, single consumer. Let’s put \"mpsc\" to use and expand the code in Listing 16-10 to create multiple threads that all send values to the same receiver. We can do so by cloning the transmitter, as shown in Listing 16-11:\nFilename: src/main.rs\n    // --snip--\n\n    let (tx, rx) = mpsc::channel();\n\n    let tx1 = tx.clone();\n    thread::spawn(move || {\n        let vals = vec![\n            String::from(\"hi\"),\n            String::from(\"from\"),\n            String::from(\"the\"),\n            String::from(\"thread\"),\n        ];\n\n        for val in vals {\n            tx1.send(val).unwrap();\n            thread::sleep(Duration::from_secs(1));\n        }\n    });\n\n    thread::spawn(move || {\n        let vals = vec![\n            String::from(\"more\"),\n            String::from(\"messages\"),\n            String::from(\"for\"),\n            String::from(\"you\"),\n        ];\n\n        for val in vals {\n            tx.send(val).unwrap();\n            thread::sleep(Duration::from_secs(1));\n        }\n    });\n\n    for received in rx {\n        println!(\"Got: {}\", received);\n    }\n\n    // --snip--\n\nListing 16-11: Sending multiple messages from multiple producers\nThis time, before we create the first spawned thread, we call \"clone\" on the transmitter. This will give us a new transmitter we can pass to the first spawned thread. We pass the original transmitter to a second spawned thread. This gives us two threads, each sending different messages to the one receiver.\nWhen you run the code, your output should look something like this:\nGot: hi\nGot: more\nGot: from\nGot: messages\nGot: for\nGot: the\nGot: thread\nGot: you\n\nYou might see the values in another order, depending on your system. This is what makes concurrency interesting as well as difficult. If you experiment with \"thread::sleep\", giving it various values in the different threads, each run will be more nondeterministic and create different output each time.\nNow that we’ve looked at how channels work, let’s look at a different method of concurrency.\n\nShared-State Concurrency\nMessage passing is a fine way of handling concurrency, but it’s not the only one. Another method would be for multiple threads to access the same shared data. Consider this part of the slogan from the Go language documentation again: “do not communicate by sharing memory.”\nWhat would communicating by sharing memory look like? In addition, why would message-passing enthusiasts caution not to use memory sharing?\nIn a way, channels in any programming language are similar to single ownership, because once you transfer a value down a channel, you should no longer use that value. Shared memory concurrency is like multiple ownership: multiple threads can access the same memory location at the same time. As you saw in Chapter 15, where smart pointers made multiple ownership possible, multiple ownership can add complexity because these different owners need managing. Rust’s type system and ownership rules greatly assist in getting this management correct. For an example, let’s look at mutexes, one of the more common concurrency primitives for shared memory.\nUsing Mutexes to Allow Access to Data from One Thread at a Time\nMutex is an abbreviation for mutual exclusion, as in, a mutex allows only one thread to access some data at any given time. To access the data in a mutex, a thread must first signal that it wants access by asking to acquire the mutex’s lock. The lock is a data structure that is part of the mutex that keeps track of who currently has exclusive access to the data. Therefore, the mutex is described as guarding the data it holds via the locking system.\nMutexes have a reputation for being difficult to use because you have to remember two rules:\n\nYou must attempt to acquire the lock before using the data.\nWhen you’re done with the data that the mutex guards, you must unlock the data so other threads can acquire the lock.\n\nFor a real-world metaphor for a mutex, imagine a panel discussion at a conference with only one microphone. Before a panelist can speak, they have to ask or signal that they want to use the microphone. When they get the microphone, they can talk for as long as they want to and then hand the microphone to the next panelist who requests to speak. If a panelist forgets to hand the microphone off when they’re finished with it, no one else is able to speak. If management of the shared microphone goes wrong, the panel won’t work as planned!\nManagement of mutexes can be incredibly tricky to get right, which is why so many people are enthusiastic about channels. However, thanks to Rust’s type system and ownership rules, you can’t get locking and unlocking wrong.\nThe API of \"Mutex\"\nAs an example of how to use a mutex, let’s start by using a mutex in a single-threaded context, as shown in Listing 16-12:\nFilename: src/main.rs\nuse std::sync::Mutex;\n\nfn main() {\n    let m = Mutex::new(5);\n\n    {\n        let mut num = m.lock().unwrap();\n        *num = 6;\n    }\n\n    println!(\"m = {:?}\", m);\n}\n\nListing 16-12: Exploring the API of \"Mutex\" in a single-threaded context for simplicity\nAs with many types, we create a \"Mutex\" using the associated function \"new\". To access the data inside the mutex, we use the \"lock\" method to acquire the lock. This call will block the current thread so it can’t do any work until it’s our turn to have the lock.\nThe call to \"lock\" would fail if another thread holding the lock panicked. In that case, no one would ever be able to get the lock, so we’ve chosen to \"unwrap\" and have this thread panic if we’re in that situation.\nAfter we’ve acquired the lock, we can treat the return value, named \"num\" in this case, as a mutable reference to the data inside. The type system ensures that we acquire a lock before using the value in \"m\". The type of \"m\" is \"Mutex\", not \"i32\", so we must call \"lock\" to be able to use the \"i32\" value. We can’t forget; the type system won’t let us access the inner \"i32\" otherwise.\nAs you might suspect, \"Mutex\" is a smart pointer. More accurately, the call to \"lock\" returns a smart pointer called \"MutexGuard\", wrapped in a \"LockResult\" that we handled with the call to \"unwrap\". The \"MutexGuard\" smart pointer implements \"Deref\" to point at our inner data; the smart pointer also has a \"Drop\" implementation that releases the lock automatically when a \"MutexGuard\" goes out of scope, which happens at the end of the inner scope. As a result, we don’t risk forgetting to release the lock and blocking the mutex from being used by other threads, because the lock release happens automatically.\nAfter dropping the lock, we can print the mutex value and see that we were able to change the inner \"i32\" to 6.\nSharing a \"Mutex\" Between Multiple Threads\nNow, let’s try to share a value between multiple threads using \"Mutex\". We’ll spin up 10 threads and have them each increment a counter value by 1, so the counter goes from 0 to 10. The next example in Listing 16-13 will have a compiler error, and we’ll use that error to learn more about using \"Mutex\" and how Rust helps us use it correctly.\nFilename: src/main.rs\nuse std::sync::Mutex;\nuse std::thread;\n\nfn main() {\n    let counter = Mutex::new(0);\n    let mut handles = vec![];\n\n    for _ in 0..10 {\n        let handle = thread::spawn(move || {\n            let mut num = counter.lock().unwrap();\n\n            *num += 1;\n        });\n        handles.push(handle);\n    }\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n\n    println!(\"Result: {}\", *counter.lock().unwrap());\n}\n\nListing 16-13: Ten threads each increment a counter guarded by a \"Mutex\"\nWe create a \"counter\" variable to hold an \"i32\" inside a \"Mutex\", as we did in Listing 16-12. Next, we create 10 threads by iterating over a range of numbers. We use \"thread::spawn\" and give all the threads the same closure: one that moves the counter into the thread, acquires a lock on the \"Mutex\" by calling the \"lock\" method, and then adds 1 to the value in the mutex. When a thread finishes running its closure, \"num\" will go out of scope and release the lock so another thread can acquire it.\nIn the main thread, we collect all the join handles. Then, as we did in Listing 16-2, we call \"join\" on each handle to make sure all the threads finish. At that point, the main thread will acquire the lock and print the result of this program.\nWe hinted that this example wouldn’t compile. Now let’s find out why!\n$ cargo run\n   Compiling shared-state v0.1.0 (file:///projects/shared-state)\nerror[E0382]: use of moved value: \"counter\"\n  --&gt; src/main.rs:9:36\n   |\n5  |     let counter = Mutex::new(0);\n   |         ------- move occurs because \"counter\" has type \"Mutex&lt;i32&gt;\", which does not implement the \"Copy\" trait\n...\n9  |         let handle = thread::spawn(move || {\n   |                                    ^^^^^^^ value moved into closure here, in previous iteration of loop\n10 |             let mut num = counter.lock().unwrap();\n   |                           ------- use occurs due to use in closure\n\nFor more information about this error, try \"rustc --explain E0382\".\nerror: could not compile \"shared-state\" due to previous error\n\nThe error message states that the \"counter\" value was moved in the previous iteration of the loop. Rust is telling us that we can’t move the ownership of lock \"counter\" into multiple threads. Let’s fix the compiler error with a multiple-ownership method we discussed in Chapter 15.\nMultiple Ownership with Multiple Threads\nIn Chapter 15, we gave a value multiple owners by using the smart pointer \"Rc\" to create a reference counted value. Let’s do the same here and see what happens. We’ll wrap the \"Mutex\" in \"Rc\" in Listing 16-14 and clone the \"Rc\" before moving ownership to the thread.\nFilename: src/main.rs\nuse std::rc::Rc;\nuse std::sync::Mutex;\nuse std::thread;\n\nfn main() {\n    let counter = Rc::new(Mutex::new(0));\n    let mut handles = vec![];\n\n    for _ in 0..10 {\n        let counter = Rc::clone(&amp;counter);\n        let handle = thread::spawn(move || {\n            let mut num = counter.lock().unwrap();\n\n            *num += 1;\n        });\n        handles.push(handle);\n    }\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n\n    println!(\"Result: {}\", *counter.lock().unwrap());\n}\n\nListing 16-14: Attempting to use \"Rc\" to allow multiple threads to own the \"Mutex\"\nOnce again, we compile and get... different errors! The compiler is teaching us a lot.\n$ cargo run\n   Compiling shared-state v0.1.0 (file:///projects/shared-state)\nerror[E0277]: \"Rc&lt;Mutex&lt;i32&gt;&gt;\" cannot be sent between threads safely\n  --&gt; src/main.rs:11:36\n   |\n11 |           let handle = thread::spawn(move || {\n   |                        ------------- ^------\n   |                        |             |\n   |  ______________________|_____________within this \"[closure@src/main.rs:11:36: 11:43]\"\n   | |                      |\n   | |                      required by a bound introduced by this call\n12 | |             let mut num = counter.lock().unwrap();\n13 | |\n14 | |             *num += 1;\n15 | |         });\n   | |_________^ \"Rc&lt;Mutex&lt;i32&gt;&gt;\" cannot be sent between threads safely\n   |\n   = help: within \"[closure@src/main.rs:11:36: 11:43]\", the trait \"Send\" is not implemented for \"Rc&lt;Mutex&lt;i32&gt;&gt;\"\nnote: required because it\"s used within this closure\n  --&gt; src/main.rs:11:36\n   |\n11 |         let handle = thread::spawn(move || {\n   |                                    ^^^^^^^\nnote: required by a bound in \"spawn\"\n  --&gt; /rustc/d5a82bbd26e1ad8b7401f6a718a9c57c96905483/library/std/src/thread/mod.rs:704:8\n   |\n   = note: required by this bound in \"spawn\"\n\nFor more information about this error, try \"rustc --explain E0277\".\nerror: could not compile \"shared-state\" due to previous error\n\nWow, that error message is very wordy! Here’s the important part to focus on: \"\"Rc&lt;Mutex&gt;\" cannot be sent between threads safely\". The compiler is also telling us the reason why: \"the trait \"Send\" is not implemented for \"Rc&lt;Mutex&gt;\" \". We’ll talk about \"Send\" in the next section: it’s one of the traits that ensures the types we use with threads are meant for use in concurrent situations.\nUnfortunately, \"Rc\" is not safe to share across threads. When \"Rc\" manages the reference count, it adds to the count for each call to \"clone\" and subtracts from the count when each clone is dropped. But it doesn’t use any concurrency primitives to make sure that changes to the count can’t be interrupted by another thread. This could lead to wrong counts—subtle bugs that could in turn lead to memory leaks or a value being dropped before we’re done with it. What we need is a type exactly like \"Rc\" but one that makes changes to the reference count in a thread-safe way.\nAtomic Reference Counting with \"Arc\"\nFortunately, \"Arc\" is a type like \"Rc\" that is safe to use in concurrent situations. The a stands for atomic, meaning it’s an atomically reference counted type. Atomics are an additional kind of concurrency primitive that we won’t cover in detail here: see the standard library documentation for \"std::sync::atomic\" for more details. At this point, you just need to know that atomics work like primitive types but are safe to share across threads.\nYou might then wonder why all primitive types aren’t atomic and why standard library types aren’t implemented to use \"Arc\" by default. The reason is that thread safety comes with a performance penalty that you only want to pay when you really need to. If you’re just performing operations on values within a single thread, your code can run faster if it doesn’t have to enforce the guarantees atomics provide.\nLet’s return to our example: \"Arc\" and \"Rc\" have the same API, so we fix our program by changing the \"use\" line, the call to \"new\", and the call to \"clone\". The code in Listing 16-15 will finally compile and run:\nFilename: src/main.rs\nuse std::sync::{Arc, Mutex};\nuse std::thread;\n\nfn main() {\n    let counter = Arc::new(Mutex::new(0));\n    let mut handles = vec![];\n\n    for _ in 0..10 {\n        let counter = Arc::clone(&amp;counter);\n        let handle = thread::spawn(move || {\n            let mut num = counter.lock().unwrap();\n\n            *num += 1;\n        });\n        handles.push(handle);\n    }\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n\n    println!(\"Result: {}\", *counter.lock().unwrap());\n}\n\nListing 16-15: Using an \"Arc\" to wrap the \"Mutex\" to be able to share ownership across multiple threads\nThis code will print the following:\nResult: 10\n\nWe did it! We counted from 0 to 10, which may not seem very impressive, but it did teach us a lot about \"Mutex\" and thread safety. You could also use this program’s structure to do more complicated operations than just incrementing a counter. Using this strategy, you can divide a calculation into independent parts, split those parts across threads, and then use a \"Mutex\" to have each thread update the final result with its part.\nNote that if you are doing simple numerical operations, there are types simpler than \"Mutex\" types provided by the \"std::sync::atomic\" module of the standard library. These types provide safe, concurrent, atomic access to primitive types. We chose to use \"Mutex\" with a primitive type for this example so we could concentrate on how \"Mutex\" works.\nSimilarities Between \"RefCell\"/\"Rc\" and \"Mutex\"/\"Arc\"\nYou might have noticed that \"counter\" is immutable but we could get a mutable reference to the value inside it; this means \"Mutex\" provides interior mutability, as the \"Cell\" family does. In the same way we used \"RefCell\" in Chapter 15 to allow us to mutate contents inside an \"Rc\", we use \"Mutex\" to mutate contents inside an \"Arc\".\nAnother detail to note is that Rust can’t protect you from all kinds of logic errors when you use \"Mutex\". Recall in Chapter 15 that using \"Rc\" came with the risk of creating reference cycles, where two \"Rc\" values refer to each other, causing memory leaks. Similarly, \"Mutex\" comes with the risk of creating deadlocks. These occur when an operation needs to lock two resources and two threads have each acquired one of the locks, causing them to wait for each other forever. If you’re interested in deadlocks, try creating a Rust program that has a deadlock; then research deadlock mitigation strategies for mutexes in any language and have a go at implementing them in Rust. The standard library API documentation for \"Mutex\" and \"MutexGuard\" offers useful information.\nWe’ll round out this chapter by talking about the \"Send\" and \"Sync\" traits and how we can use them with custom types.\n\nExtensible Concurrency with the \"Sync\" and \"Send\" Traits\nInterestingly, the Rust language has very few concurrency features. Almost every concurrency feature we’ve talked about so far in this chapter has been part of the standard library, not the language. Your options for handling concurrency are not limited to the language or the standard library; you can write your own concurrency features or use those written by others.\nHowever, two concurrency concepts are embedded in the language: the \"std::marker\" traits \"Sync\" and \"Send\".\nAllowing Transference of Ownership Between Threads with \"Send\"\nThe \"Send\" marker trait indicates that ownership of values of the type implementing \"Send\" can be transferred between threads. Almost every Rust type is \"Send\", but there are some exceptions, including \"Rc\": this cannot be \"Send\" because if you cloned an \"Rc\" value and tried to transfer ownership of the clone to another thread, both threads might update the reference count at the same time. For this reason, \"Rc\" is implemented for use in single-threaded situations where you don’t want to pay the thread-safe performance penalty.\nTherefore, Rust’s type system and trait bounds ensure that you can never accidentally send an \"Rc\" value across threads unsafely. When we tried to do this in Listing 16-14, we got the error \"the trait Send is not implemented for Rc&lt;Mutex&gt;\". When we switched to \"Arc\", which is \"Send\", the code compiled.\nAny type composed entirely of \"Send\" types is automatically marked as \"Send\" as well. Almost all primitive types are \"Send\", aside from raw pointers, which we’ll discuss in Chapter 19.\nAllowing Access from Multiple Threads with \"Sync\"\nThe \"Sync\" marker trait indicates that it is safe for the type implementing \"Sync\" to be referenced from multiple threads. In other words, any type \"T\" is \"Sync\" if \"&amp;T\" (an immutable reference to \"T\") is \"Send\", meaning the reference can be sent safely to another thread. Similar to \"Send\", primitive types are \"Sync\", and types composed entirely of types that are \"Sync\" are also \"Sync\".\nThe smart pointer \"Rc\" is also not \"Sync\" for the same reasons that it’s not \"Send\". The \"RefCell\" type (which we talked about in Chapter 15) and the family of related \"Cell\" types are not \"Sync\". The implementation of borrow checking that \"RefCell\" does at runtime is not thread-safe. The smart pointer \"Mutex\" is \"Sync\" and can be used to share access with multiple threads as you saw in the “Sharing a \"Mutex\" Between Multiple Threads” section.\nImplementing \"Send\" and \"Sync\" Manually Is Unsafe\nBecause types that are made up of \"Send\" and \"Sync\" traits are automatically also \"Send\" and \"Sync\", we don’t have to implement those traits manually. As marker traits, they don’t even have any methods to implement. They’re just useful for enforcing invariants related to concurrency.\nManually implementing these traits involves implementing unsafe Rust code. We’ll talk about using unsafe Rust code in Chapter 19; for now, the important information is that building new concurrent types not made up of \"Send\" and \"Sync\" parts requires careful thought to uphold the safety guarantees. “The Rustonomicon” has more information about these guarantees and how to uphold them.\nSummary\nThis isn’t the last you’ll see of concurrency in this book: the project in Chapter 20 will use the concepts in this chapter in a more realistic situation than the smaller examples discussed here.\nAs mentioned earlier, because very little of how Rust handles concurrency is part of the language, many concurrency solutions are implemented as crates. These evolve more quickly than the standard library, so be sure to search online for the current, state-of-the-art crates to use in multithreaded situations.\nThe Rust standard library provides channels for message passing and smart pointer types, such as \"Mutex\" and \"Arc\", that are safe to use in concurrent contexts. The type system and the borrow checker ensure that the code using these solutions won’t end up with data races or invalid references. Once you get your code to compile, you can rest assured that it will happily run on multiple threads without the kinds of hard-to-track-down bugs common in other languages. Concurrent programming is no longer a concept to be afraid of: go forth and make your programs concurrent, fearlessly!\nNext, we’ll talk about idiomatic ways to model problems and structure solutions as your Rust programs get bigger. In addition, we’ll discuss how Rust’s idioms relate to those you might be familiar with from object-oriented programming.\n","id":"http://127.0.0.1:1111/rust/chapter11-17/","title":"11-17"},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"body":"자동화된 테스트 작성\nEdsger W. Dijkstra는 1972년 에세이 The Humble Programmer에서 프로그램 테스트는 버그의 존재를 보여주는 매우 효과적인 방법이 될 수 있지만, 버그의 부재를 보여주기에는 절망적으로 부적절합니다.라고 말했습니다. 그것은 우리가 할 수 있는 한 많이 테스트하려고 하지 말아야 한다는 것을 의미하지는 않습니다!\n프로그램의 정확성은 코드가 의도한 바를 수행하는 정도입니다. Rust는 프로그램의 정확성에 대해 높은 수준의 관심을 가지고 설계되었지만 정확성은 복잡하고 증명하기 쉽지 않습니다. Rust의 유형 시스템은 이러한 부담의 상당 부분을 짊어지고 있지만 유형 시스템이 모든 것을 처리할 수는 없습니다. 따라서 Rust에는 자동화된 소프트웨어 테스트 작성 지원이 포함되어 있습니다.\n전달되는 숫자에 2를 더하는 add_two 함수를 작성한다고 가정해 보겠습니다. 이 함수의 시그니처는 매개변수로 정수를 받아들이고 결과로 정수를 반환합니다. 우리가 그 함수를 구현하고 컴파일할 때 Rust는 예를 들어 이 함수에 문자열 값이나 유효하지 않은 참조를 전달하지 않도록 하기 위해 여러분이 지금까지 배운 모든 유형 검사와 차용 검사를 수행합니다. 그러나 러스트는 이 함수가 정확히 우리가 의도한 바를 수행하는지 확인할 수 없습니다 . 예를 들어 매개변수에 10을 더하거나 매개변수에서 50을 뺀 것이 아니라 매개변수에 2를 더한 값을 반환하는 것입니다! 그것이 테스트가 들어오는 곳입니다.\n예를 들어 add_two 함수에 3을 전달할 때 반환 값이 5라고 주장하는 테스트를 작성할 수 있습니다. 기존의 올바른 동작이 변경되지 않았는지 확인하기 위해 코드를 변경할 때마다 이러한 테스트를 실행할 수 있습니다.\n테스트는 복잡한 기술입니다. 한 장에서 좋은 테스트를 작성하는 방법에 대한 모든 세부 사항을 다룰 수는 없지만 Rust의 테스트 기능의 메커니즘에 대해 논의할 것입니다. 테스트를 작성할 때 사용할 수 있는 주석 및 매크로, 테스트 실행을 위해 제공되는 기본 동작 및 옵션, 테스트를 단위 테스트 및 통합 테스트로 구성하는 방법에 대해 설명합니다.\n\n테스트 작성 방법\n테스트는 테스트가 아닌 코드가 예상대로 작동하는지 확인하는 Rust 기능입니다. 테스트 함수 본문은 일반적으로 다음 세 가지 작업을 수행합니다.\n\n필요한 데이터 또는 상태를 설정합니다.\n테스트하려는 코드를 실행합니다.\n결과가 당신이 기대하는 것이라고 주장하십시오.\n\ntest 속성, 몇 가지 매크로 및 should_panic 속성을 포함하여 Rust가 이러한 작업을 수행하는 테스트 작성을 위해 특별히 제공하는 기능을 살펴보겠습니다.\n테스트 함수 분석\n가장 간단하게 Rust의 테스트는 test 속성으로 주석이 달린 함수입니다. 속성은 Rust 코드 조각에 대한 메타데이터입니다. 한 가지 예는 5장에서 구조체와 함께 사용한 derive 특성입니다. 함수를 테스트 함수로 변경하려면 fn 앞 줄에 #[test]를 추가합니다. cargo test 명령으로 테스트를 실행할 때 Rust는 주석이 달린 함수를 실행하고 각 테스트 함수의 통과 여부를 보고하는 테스트 실행기 바이너리를 빌드합니다.\nCargo로 새 라이브러리 프로젝트를 만들 때마다 테스트 기능이 포함된 테스트 모듈이 자동으로 생성됩니다. 이 모듈은 테스트 작성을 위한 템플릿을 제공하므로 새 프로젝트를 시작할 때마다 정확한 구조와 구문을 조회할 필요가 없습니다. 추가 테스트 기능과 테스트 모듈을 원하는 만큼 추가할 수 있습니다!\n실제로 코드를 테스트하기 전에 템플릿 테스트를 실험하여 테스트 작동 방식의 몇 가지 측면을 살펴보겠습니다. 그런 다음 우리가 작성한 일부 코드를 호출하고 해당 동작이 올바른지 확인하는 실제 테스트를 작성합니다.\n두 개의 숫자를 더할 adder라는 새 라이브러리 프로젝트를 만들어 보겠습니다.\n$ cargo new adder --lib\n     Created library `adder` project\n$ cd adder\n\n가산기 라이브러리에 있는 src/lib.rs 파일 의 내용은 목록 11-1과 같아야 합니다.\n파일 이름: src/lib.rs\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn it_works() {\n        let result = 2 + 2;\n        assert_eq!(result, 4);\n    }\n}\n\n목록 11-1: cargo new에 의해 자동으로 생성된 테스트 모듈 및 함수\n지금은 맨 위 두 줄을 무시하고 함수에 집중하겠습니다. #[test] 주석: 이 속성은 이것이 테스트 함수임을 나타내므로 테스트 러너는 이 함수를 테스트로 취급해야 함을 알고 있습니다. 일반적인 시나리오를 설정하거나 일반적인 작업을 수행하는 데 도움이 되도록 테스트 모듈에 테스트가 아닌 기능이 있을 수 있으므로 항상 어떤 기능이 테스트인지 표시해야 합니다.\n예제 함수 본문은 assert_eq! 매크로는 2와 2를 더한 결과가 포함된 result가 4와 같다고 주장합니다. 이 주장은 일반적인 테스트 형식의 예입니다. 이 테스트가 통과하는지 확인하기 위해 실행해 봅시다.\ncargo test 명령은 목록 11-2와 같이 프로젝트의 모든 테스트를 실행합니다.\n$ cargo test\n   Compiling adder v0.1.0 (file:///projects/adder)\n    Finished test [unoptimized + debuginfo] target(s) in 0.57s\n     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)\n\nrunning 1 test\ntest tests::it_works ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests adder\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nListing 11-2: 자동으로 생성된 테스트 실행 결과\nCargo는 테스트를 컴파일하고 실행했습니다. running 1 test라는 줄이 보입니다. 다음 줄은 it_works라는 생성된 테스트 함수의 이름과 해당 테스트를 실행한 결과가 ok임을 보여줍니다. 전체 요약 테스트 결과: ok. 모든 테스트가 통과되었음을 의미하며 1 통과, 0 실패라고 표시된 부분은 통과 또는 실패한 테스트의 총 수입니다.\n특정 인스턴스에서 실행되지 않도록 테스트를 무시됨으로 표시할 수 있습니다. 이 장 뒷부분의 특별히 요청하지 않는 한 일부 테스트 무시 섹션 에서 이에 대해 다룰 것입니다. 여기에서 수행하지 않았기 때문에 요약에는 0 무시됨이 표시됩니다. 또한 cargo test 명령에 인수를 전달하여 이름이 문자열과 일치하는 테스트만 실행할 수 있습니다. 이것을 필터링 이라고 하며 이름으로 테스트 하위 집합 실행 섹션 에서 다룰 것입니다. 또한 실행 중인 테스트를 필터링하지 않았으므로 요약 끝에 0 필터링됨이 표시됩니다.\n0개 측정됨 통계는 성능을 측정하는 벤치마크 테스트용입니다. 벤치마크 테스트는 이 글을 쓰는 시점에서 nightly Rust에서만 사용할 수 있습니다. 자세한 내용은 벤치마크 테스트에 대한 설명서를 참조하십시오 .\nDoc-tests adder에서 시작하는 테스트 출력의 다음 부분은 모든 문서 테스트의 결과입니다. 아직 문서 테스트가 없지만 Rust는 API 문서에 나타나는 모든 코드 예제를 컴파일할 수 있습니다. 이 기능은 문서와 코드를 동기화하는 데 도움이 됩니다! 14장의 테스트로서의 문서 주석 섹션 에서 문서 테스트를 작성하는 방법에 대해 논의할 것입니다. 지금은 Doc-tests 출력을 무시합니다.\n우리의 필요에 맞게 테스트를 사용자 지정해 보겠습니다. 먼저 it_works 함수의 이름을 exploration과 같은 다른 이름으로 다음과 같이 변경합니다.\n파일 이름: src/lib.rs\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn exploration() {\n        assert_eq!(2 + 2, 4);\n    }\n}\n\n그런 다음 화물 테스트를 다시 실행하십시오. 이제 출력에 it_works 대신 exploration이 표시됩니다.\n$ cargo test\n   Compiling adder v0.1.0 (file:///projects/adder)\n    Finished test [unoptimized + debuginfo] target(s) in 0.59s\n     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)\n\nrunning 1 test\ntest tests::exploration ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests adder\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n이제 우리는 다른 테스트를 추가할 것이지만 이번에는 실패하는 테스트를 만들 것입니다! 테스트 기능에 패닉이 발생하면 테스트가 실패합니다. 각 테스트는 새 스레드에서 실행되며 기본 스레드에서 테스트 스레드가 종료된 것을 확인하면 테스트가 실패로 표시됩니다. 9장에서 패닉에 빠지는 가장 간단한 방법은 패닉! 매크로. 새 테스트를 another라는 이름의 함수로 입력하면 src/lib.rs 파일이 목록 11-3처럼 보입니다.\n파일 이름: src/lib.rs\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn exploration() {\n        assert_eq!(2 + 2, 4);\n    }\n\n    #[test]\n    fn another() {\n        panic!(`Make this test fail`);\n    }\n}\n\nListing 11-3: 패닉! 매크로\n화물 테스트를 사용하여 테스트를 다시 실행하십시오. 출력은 목록 11-4와 같아야 합니다. 탐색 테스트는 통과했고 다른 테스트는 실패했음을 보여줍니다.\n$ cargo test\n   Compiling adder v0.1.0 (file:///projects/adder)\n    Finished test [unoptimized + debuginfo] target(s) in 0.72s\n     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)\n\nrunning 2 tests\ntest tests::another ... FAILED\ntest tests::exploration ... ok\n\nfailures:\n\n---- tests::another stdout ----\nthread `tests::another` panicked at `Make this test fail`, src/lib.rs:10:9\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\n\nfailures:\n    tests::another\n\ntest result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass `--lib`\n\nListing 11-4: 하나의 테스트는 통과하고 하나는 실패했을 때의 테스트 결과\nok 대신 test tests::another 줄에 FAILED가 표시됩니다. 개별 결과와 요약 사이에 두 개의 새 섹션이 나타납니다. 첫 번째 섹션에는 각 테스트 실패에 대한 자세한 이유가 표시됩니다. 이 경우 another가 src/lib.rs 파일의 10행에서 ``Make this test fail에서 당황했기 때문에 실패했다는 세부 정보를 얻습니다. 다음 섹션에는 실패한 모든 테스트의 이름만 나열되어 있습니다. 이는 많은 테스트와 자세한 실패한 테스트 출력이 많은 경우에 유용합니다. 실패한 테스트의 이름을 사용하여 해당 테스트만 실행하면 더 쉽게 디버그할 수 있습니다. 테스트 실행 방법 제어 섹션 에서 테스트를 실행하는 방법에 대해 자세히 설명합니다.\n요약 줄은 마지막에 표시됩니다. 전반적으로 테스트 결과는 FAILED입니다. 한 번의 테스트 통과와 한 번의 테스트 실패가 있었습니다.\n다양한 시나리오에서 테스트 결과가 어떻게 보이는지 확인했으므로 이제 panic! 이외의 일부 매크로를 살펴보겠습니다. 테스트에 유용합니다.\nassert!로 결과 확인 매크로\n주장! 표준 라이브러리에서 제공하는 매크로는 테스트의 일부 조건이 true로 평가되도록 하려는 경우에 유용합니다. 우리는 주장! 매크로는 부울로 평가되는 인수입니다. 값이 true이면 아무 일도 일어나지 않고 테스트가 통과됩니다. 값이 false이면 assert! 매크로 호출 패닉! 테스트가 실패하도록 합니다. 어설션! 매크로는 코드가 의도한 대로 작동하는지 확인하는 데 도움이 됩니다.\n5장, Listing 5-15에서 우리는 Rectangle 구조체와 can_hold 메서드를 사용했고, 여기 Listing 11-5에서 반복됩니다. 이 코드를 src/lib.rs 파일 에 넣고 assert! 매크로.\n파일 이름: src/lib.rs\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nimpl Rectangle {\n    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {\n        self.width &gt; other.width &amp;&amp; self.height &gt; other.height\n    }\n}\n\nListing 11-5: 5장의 Rectangle 구조체와 can_hold 메서드 사용\ncan_hold 메서드는 부울을 반환합니다. 즉, assert!에 대한 완벽한 사용 사례입니다. 매크로. Listing 11-6에서 너비가 8이고 높이가 7인 Rectangle 인스턴스를 생성하고 너비가 7인 다른 Rectangle 인스턴스를 보유할 수 있다고 주장하여 can_hold 메서드를 실행하는 테스트를 작성합니다. 5의 높이와 1의 높이.\n파일 이름: src/lib.rs\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn larger_can_hold_smaller() {\n        let larger = Rectangle {\n            width: 8,\n            height: 7,\n        };\n        let smaller = Rectangle {\n            width: 5,\n            height: 1,\n        };\n\n        assert!(larger.can_hold(&amp;smaller));\n    }\n}\n\nListing 11-6: 더 큰 사각형이 실제로 더 작은 사각형을 담을 수 있는지 확인하는 can_hold 테스트\ntests 모듈 내부에 use super::*;라는 새 줄을 추가했습니다. tests 모듈은 7장 모듈 트리에서 항목을 참조하기 위한 경로 섹션 에서 다룬 일반적인 가시성 규칙을 따르는 일반 모듈입니다. tests 모듈은 내부 모듈이기 때문에 외부 모듈의 테스트 중인 코드를 내부 모듈의 범위로 가져와야 합니다. 우리는 외부 모듈에서 정의한 모든 것을 이 테스트 모듈에서 사용할 수 있도록 여기에서 glob을 사용합니다.\n테스트 이름을 larger_can_hold_smaller로 지정하고 필요한 두 개의 Rectangle 인스턴스를 만들었습니다. 그런 다음 assert!라고 불렀습니다. 매크로를 호출하고 larger.can_hold(&amp;smaller)를 호출한 결과를 전달했습니다. 이 식은 true를 반환해야 하므로 테스트를 통과해야 합니다. 알아 보자!\n$ cargo test\n   Compiling rectangle v0.1.0 (file:///projects/rectangle)\n    Finished test [unoptimized + debuginfo] target(s) in 0.66s\n     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)\n\nrunning 1 test\ntest tests::larger_can_hold_smaller ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests rectangle\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n통과합니다! 이번에는 더 작은 직사각형이 더 큰 직사각형을 수용할 수 없다고 주장하는 또 다른 테스트를 추가해 보겠습니다.\n파일 이름: src/lib.rs\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn larger_can_hold_smaller() {\n        // --snip--\n    }\n\n    #[test]\n    fn smaller_cannot_hold_larger() {\n        let larger = Rectangle {\n            width: 8,\n            height: 7,\n        };\n        let smaller = Rectangle {\n            width: 5,\n            height: 1,\n        };\n\n        assert!(!smaller.can_hold(&amp;larger));\n    }\n}\n\n이 경우 can_hold 함수의 올바른 결과는 거짓이므로 assert! 매크로. 결과적으로 can_hold가 false를 반환하면 테스트가 통과됩니다.\n$ cargo test\n   Compiling rectangle v0.1.0 (file:///projects/rectangle)\n    Finished test [unoptimized + debuginfo] target(s) in 0.66s\n     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)\n\nrunning 2 tests\ntest tests::larger_can_hold_smaller ... ok\ntest tests::smaller_cannot_hold_larger ... ok\n\ntest result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests rectangle\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n통과하는 두 가지 테스트! 이제 우리 코드에 버그가 생겼을 때 테스트 결과에 어떤 일이 일어나는지 봅시다. 너비를 비교할 때 보다 큼 기호를 보다 작음 기호로 대체하여 can_hold 메서드의 구현을 변경합니다.\n// --snip--\nimpl Rectangle {\n    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {\n        self.width &lt; other.width &amp;&amp; self.height &gt; other.height\n    }\n}\n\n이제 테스트를 실행하면 다음이 생성됩니다.\n$ cargo test\n   Compiling rectangle v0.1.0 (file:///projects/rectangle)\n    Finished test [unoptimized + debuginfo] target(s) in 0.66s\n     Running unittests src/lib.rs (target/debug/deps/rectangle-6584c4561e48942e)\n\nrunning 2 tests\ntest tests::larger_can_hold_smaller ... FAILED\ntest tests::smaller_cannot_hold_larger ... ok\n\nfailures:\n\n---- tests::larger_can_hold_smaller stdout ----\nthread `tests::larger_can_hold_smaller` panicked at `assertion failed: larger.can_hold(&amp;smaller)`, src/lib.rs:28:9\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\n\nfailures:\n    tests::larger_can_hold_smaller\n\ntest result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass `--lib`\n\n테스트에서 버그를 잡았습니다! larger.width는 8이고 smaller.width는 5이므로 can_hold의 너비 비교는 이제 false를 반환합니다. 8은 5보다 작지 않습니다.\nassert_eq!로 평등 테스트하기 그리고 assert_ne! 매크로\n기능을 확인하는 일반적인 방법은 테스트 중인 코드의 결과와 코드가 반환할 것으로 예상하는 값이 같은지 테스트하는 것입니다. assert!를 사용하여 이를 수행할 수 있습니다. 매크로를 만들고 == 연산자를 사용하여 식을 전달합니다. 그러나 이것은 표준 라이브러리가 한 쌍의 매크로(assert_eq!)를 제공하는 일반적인 테스트입니다. 및 assert_ne! - 이 테스트를 보다 편리하게 수행합니다. 이러한 매크로는 각각 같음 또는 같지 않음에 대한 두 인수를 비교합니다. 또한 어설션이 실패하면 두 값을 인쇄하므로 테스트가 실패한 이유를 쉽게 확인할 수 있습니다. 반대로 assert! 매크로는 false 값으로 이어진 값을 인쇄하지 않고 == 표현식에 대해 false 값을 얻었음을 나타냅니다.\n목록 11-7에서 매개변수에 2를 추가하는 add_two라는 함수를 작성한 다음 assert_eq! 매크로.\n파일 이름: src/lib.rs\npub fn add_two(a: i32) -&gt; i32 {\n    a + 2\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn it_adds_two() {\n        assert_eq!(4, add_two(2));\n    }\n}\n\n목록 11-7: assert_eq!를 사용하여 add_two 함수 테스트 매크로\n통과했는지 확인해보자!\n$ cargo test\n   Compiling adder v0.1.0 (file:///projects/adder)\n    Finished test [unoptimized + debuginfo] target(s) in 0.58s\n     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)\n\nrunning 1 test\ntest tests::it_adds_two ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests adder\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nadd_two(2)를 호출한 결과와 동일한 assert_eq!에 4를 인수로 전달합니다. 이 테스트의 줄은 test tests::it_adds_two ... ok이고 ok 텍스트는 테스트가 통과되었음을 나타냅니다!\n코드에 버그를 도입하여 assert_eq! 실패했을 때의 모습입니다. 대신 3을 추가하도록 add_two 함수의 구현을 변경합니다.\npub fn add_two(a: i32) -&gt; i32 {\n    a + 3\n}\n\n테스트를 다시 실행합니다.\n$ cargo test\n   Compiling adder v0.1.0 (file:///projects/adder)\n    Finished test [unoptimized + debuginfo] target(s) in 0.61s\n     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)\n\nrunning 1 test\ntest tests::it_adds_two ... FAILED\n\nfailures:\n\n---- tests::it_adds_two stdout ----\nthread `tests::it_adds_two` panicked at `assertion failed: `(left == right)`\n  left: `4`,\n right: `5``, src/lib.rs:11:9\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\n\nfailures:\n    tests::it_adds_two\n\ntest result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass `--lib`\n\n테스트에서 버그를 잡았습니다! it_adds_two 테스트가 실패했으며 메시지는 실패한 어설션이 assertion failed: (left == right)``이고 left 및 right 값이 무엇인지 알려줍니다. 이 메시지는 디버깅을 시작하는 데 도움이 됩니다. 왼쪽 인수는 4였지만 add_two(2)가 있는 오른쪽 인수는 5였습니다. 많은 테스트가 진행될 때 이것이 특히 도움이 될 것이라고 상상할 수 있습니다.\n일부 언어 및 테스트 프레임워크에서는 동등 주장 함수에 대한 매개변수를 예상 및 실제라고 하며 인수를 지정하는 순서가 중요합니다. 그러나 Rust에서는 left와 right라고 부르며 우리가 기대하는 값과 코드가 생성하는 값을 지정하는 순서는 중요하지 않습니다. 이 테스트에서 어설션을 assert_eq!(add_two(2), 4)로 작성할 수 있습니다. 그러면 어설션 실패: (left == right)``를 표시하는 동일한 실패 메시지가 표시됩니다.\nassert_ne! 매크로는 우리가 제공한 두 값이 같지 않으면 통과하고 같으면 실패합니다. 이 매크로는 값이 무엇인지 확신할 수 없지만 값이 절대 아니어야 할 값을 알고 있는 경우에 가장 유용 합니다 . 예를 들어, 어떤 식으로든 입력을 변경하는 것이 보장되는 함수를 테스트하고 있지만 입력이 변경되는 방식은 테스트를 실행하는 요일에 따라 달라지는 경우 가장 좋은 주장은 다음과 같습니다. 함수의 출력이 입력과 같지 않다는 것.\n표면 아래에서 assert_eq! 그리고 assert_ne! 매크로는 각각 == 및 != 연산자를 사용합니다. 어설션이 실패하면 이러한 매크로는 디버그 형식을 사용하여 인수를 인쇄합니다. 즉, 비교되는 값은 PartialEq 및 Debug 특성을 구현해야 합니다. 모든 기본 유형과 대부분의 표준 라이브러리 유형은 이러한 특성을 구현합니다. 직접 정의하는 구조체 및 열거형의 경우 이러한 유형의 동등성을 주장하려면 PartialEq를 구현해야 합니다. 또한 어설션이 실패할 때 값을 인쇄하려면 디버그를 구현해야 합니다. 5장의 Listing 5-12에서 언급한 것처럼 두 특성 모두 파생 가능한 특성이기 때문에 이것은 일반적으로 #[derive(PartialEq, Debug)]를 추가하는 것만큼 간단합니다. 구조체 또는 열거형 정의에 대한 주석입니다. 부록 C, 파생 가능한 특성을 참조하십시오.이러한 특성 및 기타 파생 특성에 대한 자세한 내용은\n사용자 지정 실패 메시지 추가\nassert!, assert_eq! 및 assert_ne! 매크로. 필수 인수 뒤에 지정된 모든 인수는 형식! 매크로( + 연산자 또는 형식! 매크로를 사용한 연결 섹션의 8장에서 설명 )를 사용하여 {} 자리 표시자와 해당 자리 표시자에 들어갈 값을 포함하는 형식 문자열을 전달할 수 있습니다. 사용자 지정 메시지는 어설션의 의미를 문서화하는 데 유용합니다. 테스트가 실패하면 코드의 문제가 무엇인지 더 잘 알 수 있습니다.\n예를 들어 이름으로 인사하는 함수가 있고 함수에 전달한 이름이 출력에 나타나는지 테스트하고 싶다고 가정해 보겠습니다.\n파일 이름: src/lib.rs\npub fn greeting(name: &amp;str) -&gt; String {\n    format!(`Hello {}!`, name)\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn greeting_contains_name() {\n        let result = greeting(`Carol`);\n        assert!(result.contains(`Carol`));\n    }\n}\n\n이 프로그램에 대한 요구 사항은 아직 합의되지 않았으며 인사말 시작 부분의 Hello 텍스트가 변경될 것이라고 확신합니다. 우리는 요구 사항이 변경될 때 테스트를 업데이트하고 싶지 않기 때문에 인사말 함수에서 반환된 값과 정확히 같은지 확인하는 대신 출력에 입력 텍스트가 포함되어 있다고 주장할 것입니다. 매개변수.\n이제 인사말을 이름을 제외하도록 변경하여 이 코드에 버그를 도입하여 기본 테스트 실패가 어떻게 보이는지 확인합니다.\npub fn greeting(name: &amp;str) -&gt; String {\n    String::from(`Hello!`)\n}\n\n이 테스트를 실행하면 다음이 생성됩니다.\n$ cargo test\n   Compiling greeter v0.1.0 (file:///projects/greeter)\n    Finished test [unoptimized + debuginfo] target(s) in 0.91s\n     Running unittests src/lib.rs (target/debug/deps/greeter-170b942eb5bf5e3a)\n\nrunning 1 test\ntest tests::greeting_contains_name ... FAILED\n\nfailures:\n\n---- tests::greeting_contains_name stdout ----\nthread `tests::greeting_contains_name` panicked at `assertion failed: result.contains(\\`Carol\\`)`, src/lib.rs:12:9\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\n\nfailures:\n    tests::greeting_contains_name\n\ntest result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass `--lib`\n\n이 결과는 어설션이 실패했으며 어설션이 있는 라인을 나타냅니다. 보다 유용한 실패 메시지는 인사 기능의 값을 인쇄합니다. greeting 함수에서 얻은 실제 값으로 채워진 자리 표시자가 있는 형식 문자열로 구성된 사용자 지정 실패 메시지를 추가해 보겠습니다.\n    #[test]\n    fn greeting_contains_name() {\n        let result = greeting(`Carol`);\n        assert!(\n            result.contains(`Carol`),\n            `Greeting did not contain name, value was `{}``,\n            result\n        );\n    }\n\n이제 테스트를 실행하면 더 많은 정보를 제공하는 오류 메시지가 표시됩니다.\n$ cargo test\n   Compiling greeter v0.1.0 (file:///projects/greeter)\n    Finished test [unoptimized + debuginfo] target(s) in 0.93s\n     Running unittests src/lib.rs (target/debug/deps/greeter-170b942eb5bf5e3a)\n\nrunning 1 test\ntest tests::greeting_contains_name ... FAILED\n\nfailures:\n\n---- tests::greeting_contains_name stdout ----\nthread `tests::greeting_contains_name` panicked at `Greeting did not contain name, value was `Hello!``, src/lib.rs:12:9\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\n\nfailures:\n    tests::greeting_contains_name\n\ntest result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass `--lib`\n\n우리는 테스트 출력에서 실제로 얻은 값을 볼 수 있으며, 이는 우리가 예상했던 일 대신 발생한 일을 디버깅하는 데 도움이 됩니다.\nshould_panic으로 패닉 확인\n반환 값을 확인하는 것 외에도 코드가 예상대로 오류 조건을 처리하는지 확인하는 것이 중요합니다. 예를 들어, 9장, 목록 9-13에서 생성한 Guess 유형을 고려하십시오. Guess를 사용하는 다른 코드는 Guess 인스턴스가 1에서 100 사이의 값만 포함한다는 보장에 따라 달라집니다. 해당 범위 밖의 값으로 Guess 인스턴스를 만들려고 시도하면 패닉이 발생하는지 확인하는 테스트를 작성할 수 있습니다.\n테스트 기능에 should_panic 속성을 추가하여 이를 수행합니다. 함수 내부의 코드가 패닉 상태이면 테스트에 통과합니다. 함수 내부의 코드가 패닉하지 않으면 테스트가 실패합니다.\n목록 11-8은 Guess::new의 오류 조건이 우리가 예상할 때 발생하는지 확인하는 테스트를 보여줍니다.\n파일 이름: src/lib.rs\npub struct Guess {\n    value: i32,\n}\n\nimpl Guess {\n    pub fn new(value: i32) -&gt; Guess {\n        if value &lt; 1 || value &gt; 100 {\n            panic!(`Guess value must be between 1 and 100, got {}.`, value);\n        }\n\n        Guess { value }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic]\n    fn greater_than_100() {\n        Guess::new(200);\n    }\n}\n\n목록 11-8: 조건이 패닉!을 유발하는지 테스트\n우리는 #[should_panic] 속성을 #[test] 속성 뒤와 그것이 적용되는 테스트 함수 앞에 배치합니다. 이 테스트가 통과되면 결과를 살펴보겠습니다.\n$ cargo test\n   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n    Finished test [unoptimized + debuginfo] target(s) in 0.58s\n     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)\n\nrunning 1 test\ntest tests::greater_than_100 - should panic ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests guessing_game\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n좋아 보인다! 이제 값이 100보다 크면 new 함수가 패닉이 되는 조건을 제거하여 코드에 버그를 도입해 보겠습니다.\n// --snip--\nimpl Guess {\n    pub fn new(value: i32) -&gt; Guess {\n        if value &lt; 1 {\n            panic!(`Guess value must be between 1 and 100, got {}.`, value);\n        }\n\n        Guess { value }\n    }\n}\n\n목록 11-8의 테스트를 실행하면 실패합니다.\n$ cargo test\n   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n    Finished test [unoptimized + debuginfo] target(s) in 0.62s\n     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)\n\nrunning 1 test\ntest tests::greater_than_100 - should panic ... FAILED\n\nfailures:\n\n---- tests::greater_than_100 stdout ----\nnote: test did not panic as expected\n\nfailures:\n    tests::greater_than_100\n\ntest result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass `--lib`\n\n이 경우 매우 유용한 메시지를 얻지는 못하지만 테스트 기능을 보면 #[should_panic] 주석이 달린 것을 볼 수 있습니다. 우리가 얻은 실패는 테스트 기능의 코드가 패닉을 일으키지 않았음을 의미합니다.\nshould_panic을 사용하는 테스트는 부정확할 수 있습니다. should_panic 테스트는 우리가 예상했던 것과 다른 이유로 테스트 패닉이 발생하더라도 통과합니다. should_panic 테스트를 더 정확하게 만들기 위해 should_panic 속성에 선택적 expected 매개변수를 추가할 수 있습니다. 테스트 도구는 실패 메시지에 제공된 텍스트가 포함되어 있는지 확인합니다. 예를 들어, 값이 너무 작거나 큰지에 따라 다른 메시지와 함께 new 함수 패닉이 발생하는 Listing 11-9의 Guess에 대한 수정된 코드를 고려하십시오.\n파일 이름: src/lib.rs\n// --snip--\n\nimpl Guess {\n    pub fn new(value: i32) -&gt; Guess {\n        if value &lt; 1 {\n            panic!(\n                `Guess value must be greater than or equal to 1, got {}.`,\n                value\n            );\n        } else if value &gt; 100 {\n            panic!(\n                `Guess value must be less than or equal to 100, got {}.`,\n                value\n            );\n        }\n\n        Guess { value }\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    #[should_panic(expected = `less than or equal to 100`)]\n    fn greater_than_100() {\n        Guess::new(200);\n    }\n}\n\nListing 11-9: panic! 테스트 지정된 하위 문자열을 포함하는 패닉 메시지와 함께\nshould_panic 속성의 expected 매개변수에 넣은 값이 Guess::new 함수가 패닉 상태가 되는 메시지의 하위 문자열이기 때문에 이 테스트는 통과할 것입니다. 예상되는 전체 패닉 메시지를 지정할 수 있습니다. 이 경우 Guess value must be less or equal to 100, got 200.이 됩니다. 지정하기 위해 선택하는 항목은 패닉 메시지가 고유하거나 동적인 정도와 원하는 테스트의 정확도에 따라 다릅니다. 이 경우 패닉 메시지의 하위 문자열은 테스트 함수의 코드가 else if value &gt; 100 사례를 실행하는 데 충분합니다.\nexpected 메시지가 있는 should_panic 테스트가 실패할 때 어떤 일이 발생하는지 확인하기 위해 if value &lt; 1 블록과 else if value &gt; 100 블록의 본문을 교체하여 코드에 버그를 다시 도입해 보겠습니다.\n        if value &lt; 1 {\n            panic!(\n                `Guess value must be less than or equal to 100, got {}.`,\n                value\n            );\n        } else if value &gt; 100 {\n            panic!(\n                `Guess value must be greater than or equal to 1, got {}.`,\n                value\n            );\n        }\n\n이번에는 should_panic 테스트를 실행하면 실패합니다.\n$ cargo test\n   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n    Finished test [unoptimized + debuginfo] target(s) in 0.66s\n     Running unittests src/lib.rs (target/debug/deps/guessing_game-57d70c3acb738f4d)\n\nrunning 1 test\ntest tests::greater_than_100 - should panic ... FAILED\n\nfailures:\n\n---- tests::greater_than_100 stdout ----\nthread `tests::greater_than_100` panicked at `Guess value must be greater than or equal to 1, got 200.`, src/lib.rs:13:13\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\nnote: panic did not contain expected string\n      panic message: ``Guess value must be greater than or equal to 1, got 200.``,\n expected substring: ``less than or equal to 100``\n\nfailures:\n    tests::greater_than_100\n\ntest result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass `--lib`\n\n실패 메시지는 이 테스트가 실제로 우리가 예상한 대로 패닉이 발생했음을 나타내지만 패닉 메시지에는 예상 문자열 Guess value must be less than or equal to 100이 포함되지 않았습니다. 이 경우에 우리가 받은 패닉 메시지는 Guess value must be greater or equal to 1, got 200.이었습니다. 이제 버그가 어디에 있는지 알아낼 수 있습니다!\n테스트에서 결과 사용\n지금까지 우리의 테스트는 실패하면 모두 당황합니다. Result&lt;T, E&gt;를 사용하는 테스트를 작성할 수도 있습니다! 다음은 Listing 11-1의 테스트입니다. Result&lt;T, E&gt;를 사용하고 당황하지 않고 Err를 반환하도록 재작성했습니다.\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn it_works() -&gt; Result&lt;(), String&gt; {\n        if 2 + 2 == 4 {\n            Ok(())\n        } else {\n            Err(String::from(`two plus two does not equal four`))\n        }\n    }\n}\n\nit_works 함수에는 이제 Result&lt;(), String&gt; 반환 유형이 있습니다. 함수 본문에서 assert_eq! 매크로에서 테스트가 통과하면 Ok(())를 반환하고 테스트가 실패하면 내부에 String이 있는 Err를 반환합니다.\nResult&lt;T, E&gt;를 반환하도록 테스트를 작성하면 테스트 본문에서 물음표 연산자를 사용할 수 있습니다. 이는 테스트 내의 작업이 Err를 반환하는 경우 실패해야 하는 테스트를 작성하는 편리한 방법이 될 수 있습니다. 변종.\nResult&lt;T, E&gt;를 사용하는 테스트에는 #[should_panic] 주석을 사용할 수 없습니다. 작업이 Err 변형을 반환한다고 주장하려면 Result&lt;T, E&gt; 값에 물음표 연산자를 사용 하지 마세요 . 대신 assert!(value.is_err())를 사용하십시오.\n테스트를 작성하는 여러 가지 방법을 알았으니 이제 테스트를 실행할 때 어떤 일이 발생하는지 살펴보고 화물 테스트와 함께 사용할 수 있는 다양한 옵션을 살펴보겠습니다.\n\n테스트 실행 방법 제어\ncargo run이 코드를 컴파일한 다음 결과 바이너리를 실행하는 것처럼 cargo test는 테스트 모드에서 코드를 컴파일하고 결과 테스트 바이너리를 실행합니다. cargo test에 의해 생성된 바이너리의 기본 동작은 모든 테스트를 병렬로 실행하고 테스트 실행 중에 생성된 출력을 캡처하여 출력이 표시되지 않도록 하고 테스트 결과와 관련된 출력을 쉽게 읽을 수 있도록 합니다. 그러나 명령줄 옵션을 지정하여 이 기본 동작을 변경할 수 있습니다.\n일부 명령줄 옵션은 cargo test로 이동하고 일부는 결과 테스트 바이너리로 이동합니다. 이 두 가지 유형의 인수를 구분하려면 cargo test로 이동하는 인수를 나열하고 그 뒤에 구분 기호 --를 추가한 다음 테스트 바이너리로 이동하는 인수를 나열합니다. cargo test --help를 실행하면 cargo test와 함께 사용할 수 있는 옵션이 표시되고 cargo test -- --help를 실행하면 구분 기호 뒤에 사용할 수 있는 옵션이 표시됩니다.\n병렬 또는 연속으로 테스트 실행\n여러 테스트를 실행할 때 기본적으로 스레드를 사용하여 병렬로 실행됩니다. 즉, 실행이 더 빨리 완료되고 피드백을 더 빨리 받습니다. 테스트가 동시에 실행되기 때문에 테스트가 서로 또는 현재 작업 디렉터리 또는 환경 변수와 같은 공유 환경을 포함한 공유 상태에 의존하지 않는지 확인해야 합니다.\n예를 들어 각 테스트 에서 test-output.txt 라는 디스크에 파일을 생성 하고 해당 파일에 일부 데이터를 쓰는 일부 코드를 실행한다고 가정합니다. 그런 다음 각 테스트는 해당 파일의 데이터를 읽고 파일에 각 테스트마다 다른 특정 값이 포함되어 있다고 주장합니다. 테스트가 동시에 실행되기 때문에 다른 테스트가 파일을 쓰고 읽는 사이에 한 테스트가 파일을 덮어쓸 수 있습니다. 두 번째 테스트는 코드가 잘못되어서가 아니라 테스트가 병렬로 실행되는 동안 서로 간섭했기 때문에 실패합니다. 한 가지 해결책은 각 테스트가 다른 파일에 기록되는지 확인하는 것입니다. 또 다른 해결책은 테스트를 한 번에 하나씩 실행하는 것입니다.\n테스트를 병렬로 실행하고 싶지 않거나 사용되는 스레드 수를 보다 세밀하게 제어하려면 --test-threads 플래그와 사용하려는 스레드 수를 보낼 수 있습니다. 테스트 바이너리. 다음 예를 살펴보십시오.\n$ cargo test -- --test-threads=1\n\n테스트 스레드 수를 1로 설정하여 프로그램에 병렬 처리를 사용하지 않도록 지시합니다. 하나의 스레드를 사용하여 테스트를 실행하면 병렬로 실행하는 것보다 시간이 더 오래 걸리지만 테스트가 상태를 공유하는 경우 서로 간섭하지 않습니다.\n함수 출력 표시\n기본적으로 테스트가 통과하면 Rust의 테스트 라이브러리는 표준 출력으로 인쇄된 모든 것을 캡처합니다. 예를 들어 println! 테스트에서 테스트에 통과하면 println! 터미널에서 출력; 테스트 통과를 나타내는 줄만 표시됩니다. 테스트가 실패하면 나머지 실패 메시지와 함께 표준 출력으로 출력된 내용을 볼 수 있습니다.\n예를 들어 Listing 11-10에는 매개변수 값을 인쇄하고 10을 반환하는 어리석은 함수와 테스트에 통과한 테스트와 실패한 테스트가 있습니다.\n파일 이름: src/lib.rs\nfn prints_and_returns_10(a: i32) -&gt; i32 {\n    println!(`I got the value {}`, a);\n    10\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn this_test_will_pass() {\n        let value = prints_and_returns_10(4);\n        assert_eq!(10, value);\n    }\n\n    #[test]\n    fn this_test_will_fail() {\n        let value = prints_and_returns_10(8);\n        assert_eq!(5, value);\n    }\n}\n\nListing 11-10: println!을 호출하는 함수를 테스트합니다.\ncargo test로 이러한 테스트를 실행하면 다음과 같은 결과가 표시됩니다.\n$ cargo test\n   Compiling silly-function v0.1.0 (file:///projects/silly-function)\n    Finished test [unoptimized + debuginfo] target(s) in 0.58s\n     Running unittests src/lib.rs (target/debug/deps/silly_function-160869f38cff9166)\n\nrunning 2 tests\ntest tests::this_test_will_fail ... FAILED\ntest tests::this_test_will_pass ... ok\n\nfailures:\n\n---- tests::this_test_will_fail stdout ----\nI got the value 8\nthread `tests::this_test_will_fail` panicked at `assertion failed: `(left == right)`\n  left: `5`,\n right: `10``, src/lib.rs:19:9\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\n\nfailures:\n    tests::this_test_will_fail\n\ntest result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass `--lib`\n\n이 출력의 어디에도 I got the value 4가 표시되지 않는다는 점에 유의하십시오. 통과한 테스트가 실행될 때 출력되는 값입니다. 해당 출력이 캡처되었습니다. 실패한 테스트의 출력 I got the value 8이 테스트 요약 출력의 섹션에 나타나며 테스트 실패의 원인도 보여줍니다.\n테스트 통과에 대한 인쇄된 값도 보려면 --show-output을 사용하여 성공적인 테스트의 출력도 표시하도록 Rust에 지시할 수 있습니다.\n$ cargo test -- --show-output\n\n--show-output 플래그를 사용하여 Listing 11-10의 테스트를 다시 실행하면 다음과 같은 출력이 표시됩니다.\n$ cargo test -- --show-output\n   Compiling silly-function v0.1.0 (file:///projects/silly-function)\n    Finished test [unoptimized + debuginfo] target(s) in 0.60s\n     Running unittests src/lib.rs (target/debug/deps/silly_function-160869f38cff9166)\n\nrunning 2 tests\ntest tests::this_test_will_fail ... FAILED\ntest tests::this_test_will_pass ... ok\n\nsuccesses:\n\n---- tests::this_test_will_pass stdout ----\nI got the value 4\n\n\nsuccesses:\n    tests::this_test_will_pass\n\nfailures:\n\n---- tests::this_test_will_fail stdout ----\nI got the value 8\nthread `tests::this_test_will_fail` panicked at `assertion failed: `(left == right)`\n  left: `5`,\n right: `10``, src/lib.rs:19:9\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\n\nfailures:\n    tests::this_test_will_fail\n\ntest result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass `--lib`\n\n이름으로 테스트 하위 집합 실행\n경우에 따라 전체 테스트 스위트를 실행하는 데 시간이 오래 걸릴 수 있습니다. 특정 영역에서 코드 작업을 하는 경우 해당 코드와 관련된 테스트만 실행하려고 할 수 있습니다. cargo test에 실행하려는 테스트의 이름을 인수로 전달하여 실행할 테스트를 선택할 수 있습니다.\n테스트의 하위 집합을 실행하는 방법을 보여주기 위해 목록 11-11에 표시된 것처럼 먼저 add_two 함수에 대한 세 가지 테스트를 만들고 실행할 항목을 선택합니다.\n파일 이름: src/lib.rs\npub fn add_two(a: i32) -&gt; i32 {\n    a + 2\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn add_two_and_two() {\n        assert_eq!(4, add_two(2));\n    }\n\n    #[test]\n    fn add_three_and_two() {\n        assert_eq!(5, add_two(3));\n    }\n\n    #[test]\n    fn one_hundred() {\n        assert_eq!(102, add_two(100));\n    }\n}\n\nListing 11-11: 세 가지 다른 이름을 가진 세 가지 테스트\n이전에 본 것처럼 인수를 전달하지 않고 테스트를 실행하면 모든 테스트가 병렬로 실행됩니다.\n$ cargo test\n   Compiling adder v0.1.0 (file:///projects/adder)\n    Finished test [unoptimized + debuginfo] target(s) in 0.62s\n     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)\n\nrunning 3 tests\ntest tests::add_three_and_two ... ok\ntest tests::add_two_and_two ... ok\ntest tests::one_hundred ... ok\n\ntest result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests adder\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n단일 테스트 실행\n테스트 함수의 이름을 cargo test에 전달하여 해당 테스트만 실행할 수 있습니다.\n$ cargo test one_hundred\n   Compiling adder v0.1.0 (file:///projects/adder)\n    Finished test [unoptimized + debuginfo] target(s) in 0.69s\n     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)\n\nrunning 1 test\ntest tests::one_hundred ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out; finished in 0.00s\n\none_hundred라는 이름의 테스트만 실행되었습니다. 다른 두 테스트는 해당 이름과 일치하지 않았습니다. 테스트 출력은 마지막에 2 필터링 아웃을 표시하여 실행되지 않은 테스트가 더 있음을 알려줍니다.\n이런 방식으로 여러 테스트의 이름을 지정할 수 없습니다. cargo test에 주어진 첫 번째 값만 사용됩니다. 그러나 여러 테스트를 실행하는 방법이 있습니다.\n여러 테스트를 실행하기 위한 필터링\n테스트 이름의 일부를 지정할 수 있으며 이름이 해당 값과 일치하는 모든 테스트가 실행됩니다. 예를 들어 테스트 이름 중 두 개에 add가 포함되어 있으므로 cargo test add를 실행하여 이 두 개를 실행할 수 있습니다.\n$ cargo test add\n   Compiling adder v0.1.0 (file:///projects/adder)\n    Finished test [unoptimized + debuginfo] target(s) in 0.61s\n     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)\n\nrunning 2 tests\ntest tests::add_three_and_two ... ok\ntest tests::add_two_and_two ... ok\n\ntest result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s\n\n이 명령은 이름에 add가 포함된 모든 테스트를 실행하고 one_hundred라는 테스트를 필터링했습니다. 또한 테스트가 나타나는 모듈은 테스트 이름의 일부가 되므로 모듈 이름을 필터링하여 모듈의 모든 테스트를 실행할 수 있습니다.\n특별히 요청하지 않는 한 일부 테스트 무시\n때로는 몇 가지 특정 테스트를 실행하는 데 시간이 많이 걸릴 수 있으므로 대부분의 화물 테스트 실행 중에 테스트를 제외하고 싶을 수 있습니다. 실행하려는 모든 테스트를 인수로 나열하는 대신 다음과 같이 제외하기 위해 ignore 속성을 사용하여 시간이 많이 걸리는 테스트에 주석을 달 수 있습니다.\n파일 이름: src/lib.rs\n#[test]\nfn it_works() {\n    assert_eq!(2 + 2, 4);\n}\n\n#[test]\n#[ignore]\nfn expensive_test() {\n    // code that takes an hour to run\n}\n\n#[test] 뒤에 제외하려는 테스트에 #[ignore] 줄을 추가합니다. 이제 테스트를 실행할 때 it_works는 실행되지만 expensive_test는 실행되지 않습니다.\n$ cargo test\n   Compiling adder v0.1.0 (file:///projects/adder)\n    Finished test [unoptimized + debuginfo] target(s) in 0.60s\n     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)\n\nrunning 2 tests\ntest expensive_test ... ignored\ntest it_works ... ok\n\ntest result: ok. 1 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests adder\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nexpensive_test 함수는 ignored로 나열됩니다. 무시된 테스트만 실행하려면 cargo test -- --ignored를 사용할 수 있습니다.\n$ cargo test -- --ignored\n   Compiling adder v0.1.0 (file:///projects/adder)\n    Finished test [unoptimized + debuginfo] target(s) in 0.61s\n     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)\n\nrunning 1 test\ntest expensive_test ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out; finished in 0.00s\n\n   Doc-tests adder\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n실행되는 테스트를 제어하여 화물 테스트 결과를 빠르게 얻을 수 있습니다. 무시된 테스트의 결과를 확인하는 것이 합리적이고 결과를 기다릴 시간이 있는 경우 대신 cargo test -- --ignored를 실행할 수 있습니다. 무시 여부에 관계없이 모든 테스트를 실행하려면 cargo test -- --include-ignored를 실행할 수 있습니다.\n\n테스트 조직\n이 장의 시작 부분에서 언급했듯이 테스트는 복잡한 규율이며 서로 다른 사람들이 서로 다른 용어와 조직을 사용합니다. Rust 커뮤니티는 단위 테스트와 통합 테스트라는 두 가지 주요 범주 측면에서 테스트에 대해 생각합니다. 단위 테스트 는 작고 집중적이며 한 번에 하나의 모듈을 격리하여 테스트하고 개인 인터페이스를 테스트할 수 있습니다. 통합 테스트는 완전히 라이브러리 외부에 있으며 공개 인터페이스만 사용하고 잠재적으로 테스트당 여러 모듈을 실행하는 다른 외부 코드와 동일한 방식으로 코드를 사용합니다.\n두 종류의 테스트를 모두 작성하는 것은 라이브러리의 일부가 개별적으로 그리고 함께 기대하는 대로 작동하는지 확인하는 데 중요합니다.\n단위 테스트\n단위 테스트의 목적은 나머지 코드와 격리된 각 코드 단위를 테스트하여 코드가 예상대로 작동하는 위치와 작동하지 않는 위치를 신속하게 찾아내는 것입니다. 테스트 중인 코드가 있는 각 파일의 src 디렉터리 에 단위 테스트를 배치합니다. 관례는 테스트 기능을 포함하고 cfg(test)로 모듈에 주석을 달기 위해 각 파일에 tests라는 모듈을 만드는 것입니다.\n테스트 모듈 및 # [cfg(테스트)\\]\n테스트 모듈의 #[cfg(test)] 주석은 러스트에게 cargo build를 실행할 때가 아니라 cargo test를 실행할 때만 테스트 코드를 컴파일하고 실행하도록 지시합니다. 이렇게 하면 테스트가 포함되지 않기 때문에 라이브러리만 빌드하려는 경우 컴파일 시간이 절약되고 결과 컴파일된 아티팩트의 공간이 절약됩니다. 통합 테스트는 다른 디렉토리로 이동하기 때문에 #[cfg(test)] 주석이 필요하지 않습니다. 그러나 단위 테스트는 코드와 동일한 파일에 있기 때문에 #[cfg(test)]를 사용하여 컴파일된 결과에 포함되지 않아야 함을 지정합니다.\n이 장의 첫 번째 섹션에서 새로운 가산기 프로젝트를 생성했을 때 Cargo가 우리를 위해 다음 코드를 생성했음을 기억하십시오.\n파일 이름: src/lib.rs\n#[cfg(test)]\nmod tests {\n    #[test]\n    fn it_works() {\n        let result = 2 + 2;\n        assert_eq!(result, 4);\n    }\n}\n\n이 코드는 자동으로 생성된 테스트 모듈입니다. 속성 cfg는 구성을 의미하며 다음 항목은 특정 구성 옵션이 주어질 때만 포함되어야 함을 Rust에 알려줍니다. 이 경우 구성 옵션은 테스트를 컴파일하고 실행하기 위해 Rust에서 제공하는 테스트입니다. Cargo는 cfg 속성을 사용하여 cargo test로 테스트를 적극적으로 실행하는 경우에만 테스트 코드를 컴파일합니다. 여기에는 #[test] 주석이 달린 함수 외에도 이 모듈 내에 있을 수 있는 모든 도우미 함수가 포함됩니다.\n비공개 기능 테스트\n개인 기능을 직접 테스트해야 하는지 여부에 대해 테스트 커뮤니티 내에서 논쟁이 있으며 다른 언어는 개인 기능을 테스트하기 어렵거나 불가능합니다. 당신이 고수하는 테스트 이데올로기에 관계없이 Rust의 개인 정보 보호 규칙은 개인 기능을 테스트할 수 있도록 허용합니다. 비공개 함수 internal_adder가 있는 Listing 11-12의 코드를 고려하십시오.\n파일 이름: src/lib.rs\npub fn add_two(a: i32) -&gt; i32 {\n    internal_adder(a, 2)\n}\n\nfn internal_adder(a: i32, b: i32) -&gt; i32 {\n    a + b\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn internal() {\n        assert_eq!(4, internal_adder(2, 2));\n    }\n}\n\nListing 11-12: 프라이빗 함수 테스트\ninternal_adder 함수는 pub로 표시되지 않습니다. 테스트는 Rust 코드일 뿐이고 tests 모듈은 또 다른 모듈일 뿐입니다. 모듈 트리에서 항목을 참조하기 위한 경로 섹션 에서 논의한 것처럼 자식 모듈의 항목은 상위 모듈의 항목을 사용할 수 있습니다. 이 테스트에서는 use super::*를 사용하여 모든 테스트 모듈의 상위 항목을 범위로 가져온 다음 테스트에서 internal_adder를 호출할 수 있습니다. 개인 함수를 테스트해야 한다고 생각하지 않는다면 Rust에는 그렇게 하도록 강요하는 것이 없습니다.\n통합 테스트\nRust에서 통합 테스트는 완전히 라이브러리 외부에 있습니다. 그들은 다른 코드와 같은 방식으로 라이브러리를 사용합니다. 즉, 라이브러리의 공개 API의 일부인 함수만 호출할 수 있습니다. 그들의 목적은 라이브러리의 많은 부분이 올바르게 함께 작동하는지 여부를 테스트하는 것입니다. 자체적으로 올바르게 작동하는 코드 단위는 통합 시 문제가 발생할 수 있으므로 통합 코드의 테스트 범위도 중요합니다. 통합 테스트를 만들려면 먼저 테스트 디렉터리가 필요합니다.\n테스트 디렉토리 _\nsrc 옆에 있는 프로젝트 디렉토리의 최상위 레벨에 테스트 디렉토리를 만듭니다. Cargo는 이 디렉토리에서 통합 테스트 파일을 찾는 것을 알고 있습니다. 그런 다음 원하는 만큼 많은 테스트 파일을 만들 수 있으며 Cargo는 각 파일을 개별 크레이트로 컴파일합니다.\n통합 테스트를 만들어 봅시다. 목록 11-12의 코드가 src/lib.rs 파일에 있는 상태에서 테스트 디렉토리를 만들고 tests/integration_test.rs 라는 새 파일을 만듭니다. 디렉토리 구조는 다음과 같아야 합니다.\nadder\n├── Cargo.lock\n├── Cargo.toml\n├── src\n│   └── lib.rs\n└── tests\n    └── integration_test.rs\n\n목록 11-13의 코드를 tests/integration_test.rs 파일에 입력하십시오:\n파일 이름: 테스트/integration_test.rs\nuse adder;\n\n#[test]\nfn it_adds_two() {\n    assert_eq!(4, adder::add_two(2));\n}\n\nListing 11-13: adder 크레이트에 있는 함수의 통합 테스트\ntests 디렉토리의 각 파일은 별도의 크레이트이므로 라이브러리를 각 테스트 크레이트의 범위로 가져와야 합니다. 그런 이유로 우리는 단위 테스트에서 필요하지 않은 use adder를 코드 상단에 추가합니다.\ntests/integration_test.rs 의 코드에 #[cfg(test)]로 주석을 달 필요가 없습니다. Cargo는 tests 디렉토리를 특별히 취급하고 cargo test를 실행할 때만 이 디렉토리의 파일을 컴파일합니다. 지금 화물 테스트 실행:\n$ cargo test\n   Compiling adder v0.1.0 (file:///projects/adder)\n    Finished test [unoptimized + debuginfo] target(s) in 1.31s\n     Running unittests src/lib.rs (target/debug/deps/adder-1082c4b063a8fbe6)\n\nrunning 1 test\ntest tests::internal ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n     Running tests/integration_test.rs (target/debug/deps/integration_test-1082c4b063a8fbe6)\n\nrunning 1 test\ntest it_adds_two ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests adder\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n출력의 세 섹션에는 단위 테스트, 통합 테스트 및 문서 테스트가 포함됩니다. 섹션의 테스트가 실패하면 다음 섹션이 실행되지 않습니다. 예를 들어 단위 테스트가 실패하면 모든 단위 테스트가 통과하는 경우에만 테스트가 실행되기 때문에 통합 및 문서 테스트에 대한 출력이 없습니다.\n단위 테스트의 첫 번째 섹션은 우리가 본 것과 동일합니다. 각 단위 테스트에 대한 한 줄(목록 11-12에서 추가한 internal이라는 이름의 한 줄)과 단위 테스트에 대한 요약 줄입니다.\n통합 테스트 섹션은 Running tests/integration_test.rs 줄로 시작합니다. 다음으로, 해당 통합 테스트의 각 테스트 기능에 대한 라인과 Doc-tests adder 섹션이 시작되기 직전에 통합 테스트 결과에 대한 요약 라인이 있습니다.\n각 통합 테스트 파일에는 자체 섹션이 있으므로 테스트 디렉토리 에 더 많은 파일을 추가하면 통합 테스트 섹션이 더 많아집니다.\ncargo test에 대한 인수로 테스트 함수의 이름을 지정하여 특정 통합 테스트 함수를 계속 실행할 수 있습니다. 특정 통합 테스트 파일에서 모든 테스트를 실행하려면 cargo test의 --test 인수 뒤에 파일 이름을 사용하십시오.\n$ cargo test --test integration_test\n   Compiling adder v0.1.0 (file:///projects/adder)\n    Finished test [unoptimized + debuginfo] target(s) in 0.64s\n     Running tests/integration_test.rs (target/debug/deps/integration_test-82e7799c1bc62298)\n\nrunning 1 test\ntest it_adds_two ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n이 명령은 tests/integration_test.rs 파일 의 테스트만 실행합니다.\n통합 테스트의 하위 모듈\n더 많은 통합 테스트를 추가함에 따라 테스트 를 구성하는 데 도움이 되도록 테스트 디렉터리 에 더 많은 파일을 만들 수 있습니다. 예를 들어 테스트 중인 기능별로 테스트 기능을 그룹화할 수 있습니다. 앞서 언급했듯이 테스트 디렉토리의 각 파일은 별도의 크레이트로 컴파일되며, 이는 최종 사용자가 크레이트를 사용하는 방식을 더 가깝게 모방하기 위해 별도의 범위를 만드는 데 유용합니다. 그러나 이것은 코드를 모듈과 파일로 분리하는 방법에 대해 7장에서 배운 것처럼 tests 디렉토리의 파일이 src 의 파일과 동일한 동작을 공유하지 않는다는 것을 의미합니다.\n테스트 디렉토리 파일 의 다른 동작은 여러 통합 테스트 파일에서 사용할 헬퍼 함수 집합이 있고 7장의 모듈을 다른 파일로 분리 섹션의 단계에 따라 압축을 풀려고 할 때 가장 눈에 띕니다. 공통 모듈. 예를 들어, tests/common.rs를 생성 하고 그 안에 setup이라는 함수를 배치하면 여러 테스트 파일의 여러 테스트 함수에서 호출하려는 setup에 일부 코드를 추가할 수 있습니다.\n파일 이름: tests/common.rs\npub fn setup() {\n    // setup code specific to your library`s tests would go here\n}\n\n테스트를 다시 실행하면 common.rs 파일에 대한 테스트 출력에 새 섹션이 표시됩니다. 이 파일에는 테스트 기능이 포함되어 있지 않으며 어디에서나 setup 기능을 호출하지도 않았습니다.\n$ cargo test\n   Compiling adder v0.1.0 (file:///projects/adder)\n    Finished test [unoptimized + debuginfo] target(s) in 0.89s\n     Running unittests src/lib.rs (target/debug/deps/adder-92948b65e88960b4)\n\nrunning 1 test\ntest tests::internal ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n     Running tests/common.rs (target/debug/deps/common-92948b65e88960b4)\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n     Running tests/integration_test.rs (target/debug/deps/integration_test-92948b65e88960b4)\n\nrunning 1 test\ntest it_adds_two ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests adder\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n테스트 결과에 common이 표시되고 running 0 tests가 표시되는 것은 우리가 원하는 것이 아닙니다. 다른 통합 테스트 파일과 일부 코드를 공유하고 싶었습니다.\n테스트 출력에 common이 표시되지 않도록 하려면 tests/common.rs 를 생성하는 대신 tests/common/mod.rs 를 생성합니다. 이제 프로젝트 디렉토리는 다음과 같습니다.\n├── Cargo.lock\n├── Cargo.toml\n├── src\n│   └── lib.rs\n└── tests\n    ├── common\n    │   └── mod.rs\n    └── integration_test.rs\n\n이것은 우리가 7장의 대체 파일 경로 섹션 에서 언급한 Rust가 이해하는 오래된 명명 규칙이기도 합니다. 이러한 방식으로 파일 이름을 지정하면 Rust는 공통 모듈을 통합 테스트 파일로 취급하지 않습니다. setup 기능 코드를 tests/common/mod.rs 로 이동 하고 tests/common.rs 파일을 삭제하면 테스트 출력의 섹션이 더 이상 나타나지 않습니다. 테스트 디렉토리 의 하위 디렉토리에 있는 파일은 별도의 크레이트로 컴파일되지 않거나 테스트 출력에 섹션이 없습니다.\ntests/common/mod.rs 를 만든 후에는 모든 통합 테스트 파일에서 모듈로 사용할 수 있습니다. 다음은 tests/integration_test.rs 의 it_adds_two 테스트에서 setup 함수를 호출하는 예입니다.\n파일 이름: 테스트/integration_test.rs\nuse adder;\n\nmod common;\n\n#[test]\nfn it_adds_two() {\n    common::setup();\n    assert_eq!(4, adder::add_two(2));\n}\n\nmod common; 선언은 Listing 7-21에서 보여준 모듈 선언과 동일합니다. 그런 다음 테스트 함수에서 common::setup() 함수를 호출할 수 있습니다.\n바이너리 크레이트에 대한 통합 테스트\n프로젝트가 src/main.rs 파일만 포함하고 src/lib.rs 파일이 없는 바이너리 크레이트인 경우 테스트 디렉토리에서 통합 테스트를 생성하고 src/main 에 정의된 함수를 가져올 수 없습니다. .rs 파일을 use 문으로 범위에 넣습니다. 라이브러리 크레이트만이 다른 크레이트가 사용할 수 있는 기능을 노출합니다. 바이너리 크레이트는 자체적으로 실행되도록 되어 있습니다.\n이것은 바이너리를 제공하는 Rust 프로젝트가 src/ lib.rs 파일 에 있는 논리를 호출하는 간단한 src/main.rs 파일을 갖는 이유 중 하나입니다. 이 구조를 사용하여 통합 테스트는 중요한 기능을 사용할 수 있도록 사용으로 라이브러리 크레이트를 테스트 할 수 있습니다. 중요한 기능이 작동하면 src/main.rs 파일 에 있는 소량의 코드 도 작동하고 그 소량의 코드는 테스트할 필요가 없습니다.\n요약\nRust의 테스트 기능은 코드를 변경하더라도 예상대로 계속 작동하도록 코드가 작동하는 방법을 지정하는 방법을 제공합니다. 단위 테스트는 라이브러리의 다른 부분을 개별적으로 실행하고 개인 구현 세부 정보를 테스트할 수 있습니다. 통합 테스트는 라이브러리의 많은 부분이 올바르게 함께 작동하는지 확인하고 라이브러리의 공개 API를 사용하여 외부 코드에서 사용하는 것과 동일한 방식으로 코드를 테스트합니다. Rust의 타입 시스템과 소유권 규칙이 일부 종류의 버그를 방지하는 데 도움이 되지만 테스트는 코드의 동작 방식과 관련된 논리 버그를 줄이는 데 여전히 중요합니다.\n이 장과 이전 장에서 배운 지식을 결합하여 프로젝트를 진행해 봅시다!\n\n12\nI/O 프로젝트: 명령줄 프로그램 구축\n이 장은 지금까지 배운 많은 기술을 요약하고 몇 가지 추가 표준 라이브러리 기능을 탐색합니다. 우리는 파일 및 명령줄 입력/출력과 상호 작용하는 명령줄 도구를 구축하여 현재 가지고 있는 일부 Rust 개념을 연습할 것입니다.\nRust의 속도, 안전성, 단일 바이너리 출력 및 크로스 플랫폼 지원은 명령줄 도구를 만들기 위한 이상적인 언어로 만들어 주므로 프로젝트를 위해 고전적인 명령줄 검색 도구 grep( g lobally) 의 자체 버전을 만들 것입니다. 정규식 검색 및 인쇄 ) . _ 가장 간단한 사용 사례에서 grep은 지정된 문자열에 대해 지정된 파일을 검색합니다. 이를 위해 grep은 파일 경로와 문자열을 인수로 사용합니다. 그런 다음 파일을 읽고 해당 파일에서 문자열 인수를 포함하는 줄을 찾은 다음 해당 줄을 인쇄합니다.\n그 과정에서 명령줄 도구가 다른 많은 명령줄 도구에서 사용하는 터미널 기능을 사용하도록 만드는 방법을 보여줍니다. 사용자가 도구의 동작을 구성할 수 있도록 환경 변수의 값을 읽습니다. 또한 표준 출력(stdout) 대신 표준 오류 bash 스트림(stderr)에 오류 메시지를 인쇄하므로 예를 들어 사용자는 화면에 오류 메시지가 계속 표시되는 동안 성공적인 출력을 파일로 리디렉션할 수 있습니다.\n한 Rust 커뮤니티 회원인 Andrew Gallant는 ripgrep이라는 완전한 기능을 갖춘 매우 빠른 grep 버전을 이미 만들었습니다. 이에 비해 우리 버전은 상당히 단순하지만 이 장에서는 ripgrep과 같은 실제 프로젝트를 이해하는 데 필요한 일부 배경 지식을 제공합니다.\ngrep 프로젝트는 지금까지 배운 여러 개념을 결합합니다.\n\n코드 구성( 7장 에서 모듈에 대해 배운 내용 사용 )\n벡터 및 문자열 사용(컬렉션, 8장 )\n오류 처리( 9장 )\n적절한 경우 특성 및 수명 사용( 10장 )\n테스트 작성( 11장 )\n\n또한 13 장 과 17 장 에서 자세히 다룰 클로저, 반복자 및 특성 개체를 간략하게 소개합니다.\n\n명령줄 인수 수락\n언제나처럼 cargo new로 새 프로젝트를 만들어 봅시다. 시스템에 이미 있을 수 있는 grep 도구와 구별하기 위해 프로젝트를 minigrep이라고 합니다.\n$ cargo new minigrep\n     Created binary (application) `minigrep` project\n$ cd minigrep\n\n첫 번째 작업은 minigrep이 파일 경로와 검색할 문자열이라는 두 개의 명령줄 인수를 받아들이도록 만드는 것입니다. 즉, 우리는 cargo run으로 프로그램을 실행할 수 있기를 원합니다. 다음 인수를 나타내는 두 개의 하이픈은 cargo가 아닌 프로그램, 검색할 문자열, 검색할 파일의 경로를 나타냅니다. 다음과 같이\n$ cargo run -- searchstring example-filename.txt\n\n현재 cargo new에 의해 생성된 프로그램은 우리가 제공한 인수를 처리할 수 없습니다. crates.io 의 일부 기존 라이브러리는 명령줄 인수를 허용하는 프로그램을 작성하는 데 도움이 될 수 있지만 이 개념을 배우는 중이므로 이 기능을 직접 구현해 보겠습니다.\n인수 값 읽기\nminigrep이 전달하는 명령줄 인수의 값을 읽을 수 있도록 하려면 Rust의 표준 라이브러리에서 제공되는 std::env::args 함수가 필요합니다. 이 함수는 minigrep에 전달된 명령줄 인수의 반복자를 반환합니다. 13장 에서 반복자를 완전히 다룰 것입니다. 지금은 반복자에 대한 두 가지 세부 정보만 알면 됩니다. 반복자는 일련의 값을 생성하고 반복자에서 collect 메서드를 호출하여 모든 요소를 포함하는 벡터와 같은 컬렉션으로 전환할 수 있습니다. 반복자가 생성합니다.\n목록 12-1의 코드를 사용하면 minigrep 프로그램이 전달된 명령줄 인수를 읽고 값을 벡터로 수집할 수 있습니다.\n파일 이름: src/main.rs\nuse std::env;\n\nfn main() {\n    let args: Vec&lt;String&gt; = env::args().collect();\n    dbg!(args);\n}\n\nListing 12-1: 명령줄 인수를 벡터로 수집하고 인쇄하기\n먼저 use 문을 사용하여 std::env 모듈을 범위로 가져오면 args 기능을 사용할 수 있습니다. std::env::args 함수는 두 수준의 모듈에 중첩되어 있습니다. 7장 에서 논의한 것처럼 원하는 함수가 둘 이상의 모듈에 중첩된 경우 함수가 아닌 상위 모듈을 범위로 가져오도록 선택했습니다. 이렇게 하면 std::env의 다른 기능을 쉽게 사용할 수 있습니다. 또한 use std::env::args를 추가한 다음 args만으로 함수를 호출하는 것보다 모호하지 않습니다. args는 현재 모듈에 정의된 함수로 쉽게 오인될 수 있기 때문입니다.\n\nargs 함수와 유효하지 않은 유니코드\n인수에 유효하지 않은 유니코드가 포함된 경우 std::env::args가 패닉 상태가 됩니다. 프로그램이 잘못된 유니코드를 포함하는 인수를 수락해야 하는 경우 std::env::args_os를 대신 사용하세요. 이 함수는 String 값 대신 OsString 값을 생성하는 반복자를 반환합니다. 여기에서는 단순화를 위해 std::env::args를 사용하기로 했습니다. OsString 값은 플랫폼마다 다르고 String 값보다 작업하기가 더 복잡하기 때문입니다.\n\nmain의 첫 번째 줄에서 env::args를 호출하고 즉시 collect를 사용하여 반복자를 반복자가 생성한 모든 값을 포함하는 벡터로 바꿉니다. collect 함수를 사용하여 많은 종류의 컬렉션을 만들 수 있으므로 args 유형에 명시적으로 주석을 달아 문자열 벡터를 원한다고 지정합니다. Rust에서는 유형에 주석을 달 필요가 거의 없지만 Rust는 원하는 컬렉션 종류를 추론할 수 없기 때문에 collect는 자주 주석을 달아야 하는 함수 중 하나입니다.\n마지막으로 디버그 매크로를 사용하여 벡터를 인쇄합니다. 먼저 인수 없이 코드를 실행한 다음 두 개의 인수를 사용하여 코드를 실행해 보겠습니다.\n$ cargo run\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.61s\n     Running `target/debug/minigrep`\n[src/main.rs:5] args = [\n    `target/debug/minigrep`,\n]\n$ cargo run -- needle haystack\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished dev [unoptimized + debuginfo] target(s) in 1.57s\n     Running `target/debug/minigrep needle haystack`\n[src/main.rs:5] args = [\n    `target/debug/minigrep`,\n    `needle`,\n    `haystack`,\n]\n\n벡터의 첫 번째 값은 바이너리의 이름인 target/debug/minigrep입니다. 이는 프로그램이 실행 시 호출된 이름을 사용하도록 하는 C의 인수 목록 동작과 일치합니다. 메시지에 인쇄하거나 프로그램을 호출하는 데 사용된 명령줄 별칭에 따라 프로그램의 동작을 변경하려는 경우 프로그램 이름에 액세스하는 것이 편리한 경우가 많습니다. 그러나 이 장의 목적을 위해 이를 무시하고 필요한 두 인수만 저장합니다.\n인수 값을 변수에 저장\n프로그램은 현재 명령줄 인수로 지정된 값에 액세스할 수 있습니다. 이제 프로그램의 나머지 부분에서 값을 사용할 수 있도록 두 인수의 값을 변수에 저장해야 합니다. 목록 12-2에서 그렇게 합니다.\n파일 이름: src/main.rs\nuse std::env;\n\nfn main() {\n    let args: Vec&lt;String&gt; = env::args().collect();\n\n    let query = &amp;args[1];\n    let file_path = &amp;args[2];\n\n    println!(`Searching for {}`, query);\n    println!(`In file {}`, file_path);\n}\n\n목록 12-2: 쿼리 인수와 파일 경로 인수를 담을 변수 만들기\n벡터를 인쇄할 때 보았듯이 프로그램 이름은 args[0]에서 벡터의 첫 번째 값을 차지하므로 인덱스 1에서 인수를 시작합니다. minigrep이 취하는 첫 번째 인수는 우리가 검색하는 문자열이므로 변수 query에 첫 번째 인수에 대한 참조를 넣습니다. 두 번째 인수는 파일 경로이므로 file_path 변수에 두 번째 인수에 대한 참조를 넣습니다.\n코드가 의도한 대로 작동하는지 확인하기 위해 이러한 변수의 값을 일시적으로 인쇄합니다. test 및 sample.txt 인수를 사용하여 이 프로그램을 다시 실행해 보겠습니다.\n$ cargo run -- test sample.txt\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.0s\n     Running `target/debug/minigrep test sample.txt`\nSearching for test\nIn file sample.txt\n\n좋습니다. 프로그램이 작동 중입니다! 필요한 인수 값이 올바른 변수에 저장되고 있습니다. 나중에 사용자가 인수를 제공하지 않는 경우와 같은 잠재적인 오류 상황을 처리하기 위해 몇 가지 오류 처리를 추가할 것입니다. 지금은 이러한 상황을 무시하고 대신 파일 읽기 기능을 추가하는 작업을 할 것입니다.\n\n파일 읽기\n이제 file_path 인수에 지정된 파일을 읽는 기능을 추가합니다. 먼저 테스트할 샘플 파일이 필요합니다. 반복되는 단어가 포함된 여러 줄에 걸쳐 적은 양의 텍스트가 있는 파일을 사용합니다. 목록 12-3에는 잘 작동할 Emily Dickinson 시가 있습니다! 프로젝트의 루트 수준에서 poem.txt 라는 파일을 만들고 I'm Nobody!라는 시를 입력합니다. 누구세요?`\n파일명: 시.txt\nI`m nobody! Who are you?\nAre you nobody, too?\nThen there`s a pair of us - don`t tell!\nThey`d banish us, you know.\n\nHow dreary to be somebody!\nHow public, like a frog\nTo tell your name the livelong day\nTo an admiring bog!\n\nListing 12-3: Emily Dickinson의 시는 좋은 테스트 케이스를 만듭니다.\n텍스트가 있는 상태에서 목록 12-4와 같이 src/main.rs를 편집하고 파일을 읽는 코드를 추가합니다.\n파일 이름: src/main.rs\nuse std::env;\nuse std::fs;\n\nfn main() {\n    // --snip--\n    println!(`In file {}`, file_path);\n\n    let contents = fs::read_to_string(file_path)\n        .expect(`Should have been able to read the file`);\n\n    println!(`With text:\\n{contents}`);\n}\n\n목록 12-4: 두 번째 인수로 지정된 파일의 내용 읽기\n먼저 use 문을 사용하여 표준 라이브러리의 관련 부분을 가져옵니다. 파일을 처리하려면 std::fs가 필요합니다.\nmain에서 새 문 fs::read_to_string은 file_path를 가져와 해당 파일을 열고 std::io::Result를 반환합니다. 파일 내용입니다.\n그런 다음 임시 println!을 다시 추가합니다. 파일을 읽은 후 contents 값을 출력하는 문으로 프로그램이 지금까지 작동하는지 확인할 수 있습니다.\n첫 번째 명령줄 인수로 임의의 문자열을 사용하고(아직 검색 부분을 구현하지 않았기 때문에) 두 번째 인수로 poem.txt 파일을 사용하여 이 코드를 실행해 보겠습니다.\n$ cargo run -- the poem.txt\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.0s\n     Running `target/debug/minigrep the poem.txt`\nSearching for the\nIn file poem.txt\nWith text:\nI`m nobody! Who are you?\nAre you nobody, too?\nThen there`s a pair of us - don`t tell!\nThey`d banish us, you know.\n\nHow dreary to be somebody!\nHow public, like a frog\nTo tell your name the livelong day\nTo an admiring bog!\n\n엄청난! 코드는 파일의 내용을 읽고 인쇄했습니다. 그러나 코드에는 몇 가지 결함이 있습니다. 현재 main 기능에는 여러 가지 책임이 있습니다. 일반적으로 각 기능이 하나의 아이디어만 담당하는 경우 기능이 더 명확하고 유지 관리하기 쉽습니다. 다른 문제는 우리가 할 수 있는 만큼 오류를 처리하지 못한다는 것입니다. 프로그램이 아직 작기 때문에 이러한 결함은 큰 문제가 아니지만 프로그램이 커질수록 깔끔하게 수정하기가 더 어려워질 것입니다. 적은 양의 코드를 리팩토링하는 것이 훨씬 쉽기 때문에 프로그램을 개발할 때 초기에 리팩토링을 시작하는 것이 좋습니다. 다음에 그렇게 하겠습니다.\n\n모듈성 및 오류 처리 개선을 위한 리팩토링\n프로그램을 개선하기 위해 프로그램의 구조 및 잠재적 오류를 처리하는 방법과 관련된 네 가지 문제를 수정할 것입니다. 먼저 main 함수는 이제 두 가지 작업을 수행합니다. 인수를 구문 분석하고 파일을 읽습니다. 프로그램이 커짐에 따라 main 함수가 처리하는 개별 작업의 수가 증가할 것입니다. 함수에 책임이 부여됨에 따라 추론하기, 테스트하기, 부분 중 하나를 손상시키지 않고 변경하기가 더 어려워집니다. 각 기능이 하나의 작업을 담당하도록 기능을 분리하는 것이 가장 좋습니다.\n이 문제는 두 번째 문제와도 관련이 있습니다. query 및 file_path는 우리 프로그램의 구성 변수이지만 contents와 같은 변수는 프로그램의 논리를 수행하는 데 사용됩니다. main이 길어질수록 더 많은 변수를 범위로 가져와야 합니다. 범위에 변수가 많을수록 각각의 목적을 추적하기가 더 어려워집니다. 목적을 명확히 하기 위해 구성 변수를 하나의 구조로 그룹화하는 것이 가장 좋습니다.\n세 번째 문제는 파일 읽기에 실패했을 때 오류 메시지를 인쇄하기 위해 예상을 사용했지만 오류 메시지는 파일을 읽을 수 있어야 했습니다만 인쇄한다는 것입니다. 파일 읽기는 여러 가지 방법으로 실패할 수 있습니다. 예를 들어 파일이 없거나 파일을 열 수 있는 권한이 없을 수 있습니다. 바로 지금 상황에 관계없이 우리는 모든 것에 대해 동일한 오류 메시지를 인쇄할 것이므로 사용자에게 어떤 정보도 제공하지 않을 것입니다!\n넷째, 우리는 expect를 반복적으로 사용하여 다른 오류를 처리합니다. 사용자가 충분한 인수를 지정하지 않고 프로그램을 실행하면 문제를 명확하게 설명하지 않는 Rust에서 인덱스가 범위를 벗어났습니다 오류가 발생합니다. 모든 오류 처리 코드가 한 곳에 있어서 오류 처리 논리를 변경해야 하는 경우 미래의 관리자가 코드를 참조할 수 있는 곳은 한 곳뿐이면 가장 좋을 것입니다. 모든 오류 처리 코드를 한 곳에 보관하면 최종 사용자에게 의미 있는 메시지를 인쇄할 수 있습니다.\n프로젝트를 리팩토링하여 이 네 가지 문제를 해결해 보겠습니다.\n바이너리 프로젝트에 대한 관심사 분리\n여러 작업에 대한 책임을 주요 기능에 할당하는 조직적 문제는 많은 바이너리 프로젝트에 공통적입니다. 결과적으로 Rust 커뮤니티는 main이 커지기 시작할 때 바이너리 프로그램의 개별 관심사를 분할하기 위한 지침을 개발했습니다. 이 프로세스에는 다음 단계가 있습니다.\n\n프로그램을 main.rs 및 lib.rs 로 분할하고 프로그램의 논리를 lib.rs 로 이동합니다.\n명령줄 구문 분석 로직이 작은 한 main.rs 에 남아 있을 수 있습니다.\n명령줄 구문 분석 논리가 복잡해지기 시작하면 main.rs 에서 추출하여 lib.rs 로 이동합니다.\n\n이 프로세스 후에 main 기능에 남아 있는 책임은 다음으로 제한되어야 합니다.\n\n인수 값을 사용하여 명령줄 구문 분석 논리 호출\n기타 구성 설정\nlib.rs 에서 실행 함수 호출\n실행이 오류를 반환하는 경우 오류 처리\n\n이 패턴은 관심사 분리에 관한 것입니다. main.rs 는 프로그램 실행을 처리하고 lib.rs는 당면한 작업의 모든 논리를 처리합니다. main 함수를 직접 테스트할 수 없기 때문에 이 구조를 사용하면 lib.rs 의 함수로 이동하여 프로그램의 모든 논리를 테스트할 수 있습니다. main.rs 에 남아 있는 코드는 읽어서 정확성을 확인할 수 있을 만큼 작을 것입니다. 이 프로세스를 따라 프로그램을 다시 작성해 보겠습니다.\n인수 파서 추출\n명령줄 구문 분석 논리를 src/lib.rs 로 이동하기 위해 준비하기 위해 main이 호출하는 함수로 인수를 구문 분석하는 기능을 추출합니다. 목록 12-5는 새 함수 parse_config를 호출하는 main의 새로운 시작을 보여줍니다. 이 함수는 잠시 동안 src/main.rs 에서 정의할 것입니다.\n파일 이름: src/main.rs\nfn main() {\n    let args: Vec&lt;String&gt; = env::args().collect();\n\n    let (query, file_path) = parse_config(&amp;args);\n\n    // --snip--\n}\n\nfn parse_config(args: &amp;[String]) -&gt; (&amp;str, &amp;str) {\n    let query = &amp;args[1];\n    let file_path = &amp;args[2];\n\n    (query, file_path)\n}\n\n목록 12-5: main에서 parse_config 함수 추출하기\n우리는 여전히 명령줄 인수를 벡터로 수집하고 있지만 인덱스 1의 인수 값을 변수 query에 할당하고 인덱스 2의 인수 값을 main 함수 내의 변수 file_path에 할당하는 대신 전체 벡터를 parse_config 함수에 전달합니다. 그런 다음 parse_config 함수는 어떤 인수가 어떤 변수에 들어가고 값을 다시 main으로 전달하는지 결정하는 논리를 보유합니다. 여전히 main에서 query 및 file_path 변수를 생성하지만 main은 더 이상 명령줄 인수와 변수가 일치하는 방법을 결정할 책임이 없습니다.\n이 재작업은 우리의 작은 프로그램에 대해 과잉처럼 보일 수 있지만 우리는 작고 점진적인 단계로 리팩토링하고 있습니다. 이렇게 변경한 후 프로그램을 다시 실행하여 인수 구문 분석이 여전히 작동하는지 확인하십시오. 진행 상황을 자주 확인하여 문제가 발생할 때 원인을 파악하는 것이 좋습니다.\n구성 값 그룹화\nparse_config 기능을 더 개선하기 위해 또 다른 작은 조치를 취할 수 있습니다. 현재 우리는 튜플을 반환하고 있지만 즉시 해당 튜플을 개별 부분으로 다시 나눕니다. 이는 아직 올바른 추상화가 없다는 신호입니다.\n개선의 여지가 있음을 보여주는 또 다른 지표는 parse_config의 config 부분입니다. 이는 우리가 반환하는 두 값이 관련되어 있고 둘 다 하나의 구성 값의 일부임을 의미합니다. 우리는 현재 두 값을 튜플로 그룹화하는 것 외에는 데이터 구조에서 이 의미를 전달하지 않습니다. 대신 두 값을 하나의 구조체에 넣고 각 구조체 필드에 의미 있는 이름을 지정합니다. 이렇게 하면 이 코드의 향후 관리자가 서로 다른 값이 서로 어떻게 관련되어 있고 그 목적이 무엇인지 더 쉽게 이해할 수 있습니다.\n목록 12-6은 parse_config 기능의 개선 사항을 보여줍니다.\n파일 이름: src/main.rs\nfn main() {\n    let args: Vec&lt;String&gt; = env::args().collect();\n\n    let config = parse_config(&amp;args);\n\n    println!(`Searching for {}`, config.query);\n    println!(`In file {}`, config.file_path);\n\n    let contents = fs::read_to_string(config.file_path)\n        .expect(`Should have been able to read the file`);\n\n    // --snip--\n}\n\nstruct Config {\n    query: String,\n    file_path: String,\n}\n\nfn parse_config(args: &amp;[String]) -&gt; Config {\n    let query = args[1].clone();\n    let file_path = args[2].clone();\n\n    Config { query, file_path }\n}\n\n목록 12-6: Config 구조체의 인스턴스를 반환하도록 parse_config 리팩터링\nquery 및 file_path라는 필드를 갖도록 정의된 Config라는 구조체를 추가했습니다. 이제 parse_config의 서명은 Config 값을 반환함을 나타냅니다. args의 문자열 값을 참조하는 문자열 조각을 반환하는 데 사용했던 parse_config 본문에서 이제 소유한 문자열 값을 포함하도록 구성을 정의합니다. main의 args 변수는 인수 값의 소유자이며 parse_config 함수가 값을 차용하도록 허용하고 있습니다. 즉, Config가 에서 값의 소유권을 가져오려고 하면 Rust의 차용 규칙을 위반하게 됩니다. 인수.\n문자열 데이터를 관리할 수 있는 방법에는 여러 가지가 있습니다. 다소 비효율적이지만 가장 쉬운 방법은 값에 대해 복제 메서드를 호출하는 것입니다. 이렇게 하면 구성 인스턴스가 소유할 데이터의 전체 복사본이 만들어지며 문자열 데이터에 대한 참조를 저장하는 것보다 더 많은 시간과 메모리가 필요합니다. 그러나 데이터를 복제하면 참조의 수명을 관리할 필요가 없기 때문에 코드가 매우 간단해집니다. 이러한 상황에서 단순성을 얻기 위해 약간의 성능을 포기하는 것은 가치 있는 절충안입니다.\n\n클론 사용의 장단점\n런타임 비용 때문에 소유권 문제를 해결하기 위해 복제를 사용하는 것을 피하는 경향이 많은 Rustacean 사이에 있습니다. 13장 에서는 이러한 유형의 상황에서 보다 효율적인 방법을 사용하는 방법을 배웁니다. 그러나 지금은 이러한 복사본을 한 번만 만들고 파일 경로와 쿼리 문자열이 매우 작기 때문에 진행을 계속하기 위해 몇 개의 문자열을 복사해도 괜찮습니다. 첫 단계에서 코드를 과도하게 최적화하려고 시도하는 것보다 약간 비효율적으로 작동하는 프로그램을 사용하는 것이 좋습니다. Rust에 대한 경험이 많아지면 가장 효율적인 솔루션으로 시작하는 것이 더 쉬울 것이지만 지금은 복제라고 부르는 것이 완벽하게 허용됩니다.\n\nmain을 업데이트하여 parse_config에 의해 반환된 Config 인스턴스를 config라는 변수에 배치하고 이전에 별도의 query 및 file_path 변수를 사용했던 코드를 업데이트했습니다. 대신 Config 구조체의 필드를 사용합니다.\n이제 우리의 코드는 query와 file_path가 서로 관련되어 있고 이들의 목적이 프로그램 작동 방식을 구성하는 것임을 보다 명확하게 전달합니다. 이러한 값을 사용하는 모든 코드는 목적에 맞게 명명된 필드의 config 인스턴스에서 값을 찾을 수 있음을 알고 있습니다.\n구성에 대한 생성자 만들기\n지금까지 main에서 명령줄 인수 구문 분석을 담당하는 논리를 추출하여 parse_config 함수에 배치했습니다. 이렇게 하면 query 및 file_path 값이 관련되어 있고 해당 관계가 코드에 전달되어야 한다는 것을 알 수 있습니다. 그런 다음 query 및 file_path의 관련 목적을 명명하고 parse_config 함수에서 값의 이름을 구조체 필드 이름으로 반환할 수 있도록 Config 구조체를 추가했습니다.\n이제 parse_config 함수의 목적은 Config 인스턴스를 만드는 것이므로 parse_config를 일반 함수에서 Config 구조체와 연결된 new라는 함수로 변경할 수 있습니다. 이렇게 변경하면 코드가 더 직관적이 됩니다. String::new를 호출하여 String과 같은 표준 라이브러리 유형의 인스턴스를 만들 수 있습니다. 마찬가지로 parse_config를 Config와 연결된 new 함수로 변경하면 Config::new를 호출하여 Config의 인스턴스를 만들 수 있습니다. 목록 12-7은 우리가 만들어야 하는 변경 사항을 보여줍니다.\n파일 이름: src/main.rs\nfn main() {\n    let args: Vec&lt;String&gt; = env::args().collect();\n\n    let config = Config::new(&amp;args);\n\n    // --snip--\n}\n\n// --snip--\n\nimpl Config {\n    fn new(args: &amp;[String]) -&gt; Config {\n        let query = args[1].clone();\n        let file_path = args[2].clone();\n\n        Config { query, file_path }\n    }\n}\n\n목록 12-7: parse_config를 Config::new로 변경\n대신 Config::new를 호출하도록 parse_config를 호출하던 main을 업데이트했습니다. parse_config의 이름을 new로 변경하고 new 기능을 Config와 연결하는 impl 블록 내로 이동했습니다. 이 코드를 다시 컴파일하여 제대로 작동하는지 확인하십시오.\n오류 처리 수정\n이제 우리는 오류 처리를 수정하기 위해 노력할 것입니다. 인덱스 1 또는 인덱스 2에서 args 벡터의 값에 액세스하려고 하면 벡터에 세 개 미만의 항목이 포함된 경우 프로그램이 패닉 상태가 됩니다. 인수 없이 프로그램을 실행해 보십시오. 다음과 같이 표시됩니다.\n$ cargo run\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.0s\n     Running `target/debug/minigrep`\nthread `main` panicked at `index out of bounds: the len is 1 but the index is 1`, src/main.rs:27:21\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\nindex out of bounds: the len is 1 but the index is 1 줄은 프로그래머를 위한 오류 메시지입니다. 최종 사용자가 대신 수행해야 하는 작업을 이해하는 데 도움이 되지 않습니다. 지금 수정하겠습니다.\n오류 메시지 개선\nListing 12-8에서 인덱스 1과 2에 액세스하기 전에 슬라이스가 충분히 긴지 확인하는 new 함수에 검사를 추가합니다. 슬라이스가 충분히 길지 않으면 프로그램이 패닉 상태가 되고 더 나은 오류 메시지를 표시합니다. .\n파일 이름: src/main.rs\n    // --snip--\n    fn new(args: &amp;[String]) -&gt; Config {\n        if args.len() &lt; 3 {\n            panic!(`not enough arguments`);\n        }\n        // --snip--\n\nListing 12-8: 인수 개수 확인 추가\n이 코드는 Listing 9-13에서 작성한 Guess::new 함수 와 유사합니다. panic! value 인수가 유효한 값의 범위를 벗어난 경우. 여기에서 값의 범위를 확인하는 대신 args의 길이가 3 이상이고 함수의 나머지 부분이 이 조건이 충족되었다는 가정하에 작동할 수 있는지 확인하고 있습니다. args 항목이 3개 미만이면 이 조건이 참이 되며 패닉! 프로그램을 즉시 종료하는 매크로입니다.\nnew에 추가된 몇 줄의 코드를 사용하여 인수 없이 프로그램을 다시 실행하여 이제 오류가 어떻게 보이는지 확인합니다.\n$ cargo run\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.0s\n     Running `target/debug/minigrep`\nthread `main` panicked at `not enough arguments`, src/main.rs:26:13\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\n이 출력이 더 좋습니다. 이제 합리적인 오류 메시지가 표시됩니다. 그러나 사용자에게 제공하고 싶지 않은 외부 정보도 있습니다. Listing 9-13에서 사용한 기법을 여기서 사용하는 것이 최선이 아닐 수도 있습니다. 패닉! 9장에서 논의한 것처럼 사용 문제보다 프로그래밍 문제에 더 적합합니다. 대신 9장에서 배운 다른 기술인 성공 또는 오류를 나타내는 결과 반환을 사용합니다.\n패닉!을 호출하는 대신 결과 반환\n대신 성공한 경우 구성 인스턴스를 포함하고 오류 경우 문제를 설명하는 결과 값을 반환할 수 있습니다. 또한 많은 프로그래머가 새로운 함수는 절대 실패하지 않을 것으로 기대하기 때문에 함수 이름을 new에서 build로 변경할 것입니다. Config::build가 main과 통신할 때 Result 유형을 사용하여 문제가 있음을 알릴 수 있습니다. 그런 다음 메인을 변경하여 패닉!을 호출하는 스레드 메인`` 및 RUST_BACKTRACE에 대한 주변 텍스트 없이 Err 변형을 사용자를 위한 보다 실용적인 오류로 변환할 수 있습니다. 원인.\n목록 12-9는 Config::build라고 부르는 함수의 반환 값과 결과를 반환하는 데 필요한 함수 본문에 필요한 변경 사항을 보여줍니다. 다음 목록에서 수행할 main도 업데이트할 때까지 컴파일되지 않습니다.\n파일 이름: src/main.rs\nimpl Config {\n    fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;`static str&gt; {\n        if args.len() &lt; 3 {\n            return Err(`not enough arguments`);\n        }\n\n        let query = args[1].clone();\n        let file_path = args[2].clone();\n\n        Ok(Config { query, file_path })\n    }\n}\n\n목록 12-9: Config::build에서 결과 반환\nbuild 함수는 성공 사례의 Config 인스턴스와 오류 사례의 &amp;static str이 있는 Result를 반환합니다. 오류 값은 항상 ``정적 수명을 갖는 문자열 리터럴입니다.\n함수 본문에서 패닉!을 호출하는 대신 두 가지를 변경했습니다. 사용자가 충분한 인수를 전달하지 않으면 Err 값을 반환하고 Config 반환 값을 Ok로 래핑했습니다. 이러한 변경으로 인해 함수는 새로운 유형 서명을 준수합니다.\nConfig::build에서 Err 값을 반환하면 main 함수가 build 함수에서 반환된 Result 값을 처리하고 오류 사례에서 보다 깔끔하게 프로세스를 종료할 수 있습니다.\nConfig::build 호출 및 오류 처리\n오류 사례를 처리하고 사용자에게 친숙한 메시지를 인쇄하려면 Listing 12-10과 같이 Config::build에서 반환되는 결과를 처리하도록 main을 업데이트해야 합니다. 또한 panic!에서 벗어나 0이 아닌 오류 코드로 명령줄 도구를 종료하는 책임을 집니다. 대신 손으로 구현하십시오. 0이 아닌 종료 상태는 프로그램이 오류 상태로 종료되었음을 프로그램을 호출한 프로세스에 알리는 규칙입니다.\n파일 이름: src/main.rs\nuse std::process;\n\nfn main() {\n    let args: Vec&lt;String&gt; = env::args().collect();\n\n    let config = Config::build(&amp;args).unwrap_or_else(|err| {\n        println!(`Problem parsing arguments: {err}`);\n        process::exit(1);\n    });\n\n    // --snip--\n\nListing 12-10: Config 빌드에 실패하면 오류 코드와 함께 종료\n이 목록에서는 아직 자세히 다루지 않은 방법인 unwrap_or_else를 사용했는데, 이는 표준 라이브러리에 의해 Result&lt;T, E&gt;에 정의되어 있습니다. unwrap_or_else를 사용하면 panic!이 아닌 사용자 정의를 정의할 수 있습니다. 오류 처리. Result가 Ok 값인 경우 이 메서드의 동작은 unwrap과 유사합니다. Ok가 래핑되는 내부 값을 반환합니다. 그러나 값이 Err 값이면 이 메서드 는 우리가 정의하고 unwrap_or_else에 인수로 전달하는 익명 함수인 클로저 의 코드를 호출합니다. 클로저에 대해서는 13장 에서 자세히 다룰 것입니다.. 지금은 unwrap_or_else가 Err의 내부 값을 전달한다는 사실만 알면 됩니다. 이 경우 Listing 12-9에서 추가한 정적 문자열 인수가 충분하지 않음이 클로저에 전달됩니다. 수직 파이프 사이에 나타나는 인수 err에서. 클로저의 코드는 실행될 때 err 값을 사용할 수 있습니다.\n표준 라이브러리의 프로세스를 범위로 가져오기 위해 새로운 use 줄을 추가했습니다. 오류 케이스에서 실행될 클로저의 코드는 단 두 줄입니다. err 값을 인쇄한 다음 process::exit를 호출합니다. process::exit 함수는 프로그램을 즉시 중지하고 종료 상태 코드로 전달된 번호를 반환합니다. 이것은 목록 12-8에서 사용한 패닉! 기반 처리와 유사하지만 더 이상 모든 추가 출력을 얻지 못합니다. 해 보자:\n$ cargo run\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.48s\n     Running `target/debug/minigrep`\nProblem parsing arguments: not enough arguments\n\n엄청난! 이 출력은 사용자에게 훨씬 친숙합니다.\nmain에서 논리 추출\n이제 구성 구문 분석 리팩터링을 마쳤으므로 프로그램의 논리로 전환해 보겠습니다. 바이너리 프로젝트에 대한 관심사 분리 에서 언급한 것처럼 구성 설정 또는 오류 처리와 관련되지 않은 현재 main 함수에 있는 모든 논리를 보유할 run이라는 함수를 추출합니다. 완료되면 main은 간결하고 검사를 통해 쉽게 확인할 수 있으며 다른 모든 논리에 대한 테스트를 작성할 수 있습니다.\nListing 12-11은 추출된 run 함수를 보여줍니다. 지금은 함수 추출을 조금씩 점진적으로 개선하고 있습니다. 우리는 여전히 src/main.rs 에서 함수를 정의하고 있습니다.\n파일 이름: src/main.rs\nfn main() {\n    // --snip--\n\n    println!(`Searching for {}`, config.query);\n    println!(`In file {}`, config.file_path);\n\n    run(config);\n}\n\nfn run(config: Config) {\n    let contents = fs::read_to_string(config.file_path)\n        .expect(`Should have been able to read the file`);\n\n    println!(`With text:\\n{contents}`);\n}\n\n// --snip--\n\nListing 12-11: 나머지 프로그램 로직을 포함하는 run 함수 추출\n이제 run 함수에는 파일 읽기부터 시작하여 main의 나머지 모든 논리가 포함됩니다. run 함수는 Config 인스턴스를 인수로 사용합니다.\nrun 함수에서 오류 반환\nrun 함수로 분리된 나머지 프로그램 로직으로 목록 12-9의 Config::build에서 했던 것처럼 오류 처리를 개선할 수 있습니다. expect를 호출하여 프로그램이 패닉 상태가 되도록 하는 대신 run 함수는 무언가 잘못되었을 때 Result&lt;T, E&gt;를 반환합니다. 이렇게 하면 사용자에게 친숙한 방식으로 오류를 처리하는 논리를 기본으로 더욱 통합할 수 있습니다. 목록 12-12는 run의 서명과 본문에 필요한 변경 사항을 보여줍니다.\n파일 이름: src/main.rs\nuse std::error::Error;\n\n// --snip--\n\nfn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {\n    let contents = fs::read_to_string(config.file_path)?;\n\n    println!(`With text:\\n{contents}`);\n\n    Ok(())\n}\n\n목록 12-12: 결과를 반환하도록 실행 함수 변경\n여기에 세 가지 중요한 변경 사항이 있습니다. 먼저 run 함수의 리턴 타입을 Result&lt;(), Box로 변경했습니다.&gt;. 이 함수는 이전에 단위 유형 ()을 반환했으며 Ok`의 경우 반환된 값으로 유지합니다.\n오류 유형의 경우 특성 개체 Box를 사용했습니다.(그리고 우리는std::error::Error를 use문이 맨 위에 있는 범위로 가져왔습니다.) 우리는 [17장](https://doc.rust-lang.org/book/ch17-00-oop.html) 에서 특성 개체를 다룰 것입니다. 지금은Box는 함수가오류특성을 구현하는 유형을 반환하지만 반환 값이 어떤 특정 유형인지 지정할 필요가 없음을 의미합니다. 이는 다른 오류에서 다른 유형일 수 있는 오류 값을 반환할 수 있는 유연성을 제공합니다.dyn키워드는dynamic`의 줄임말입니다.\n둘째, ? 대신 expect 호출을 제거했습니다. 9장 에서 언급한 연산자입니다. 패닉! 오류 시 ? 호출자가 처리할 현재 함수의 오류 값을 반환합니다.\n셋째, run 함수는 이제 성공 사례에서 Ok 값을 반환합니다. 서명에서 run 함수의 성공 유형을 ()로 선언했습니다. 즉, 단위 유형 값을 Ok 값으로 래핑해야 합니다. 이 Ok(()) 구문은 처음에는 약간 이상하게 보일 수 있지만 이와 같이 ()를 사용하는 것은 우리가 부작용 때문에 run을 호출하고 있음을 나타내는 관용적인 방법입니다. 필요한 값을 반환하지 않습니다.\n이 코드를 실행하면 컴파일되지만 경고가 표시됩니다.\n$ cargo run the poem.txt\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\nwarning: unused `Result` that must be used\n  --&gt; src/main.rs:19:5\n   |\n19 |     run(config);\n   |     ^^^^^^^^^^^\n   |\n   = note: this `Result` may be an `Err` variant, which should be handled\n   = note: `#[warn(unused_must_use)]` on by default\n\nwarning: `minigrep` (bin `minigrep`) generated 1 warning\n    Finished dev [unoptimized + debuginfo] target(s) in 0.71s\n     Running `target/debug/minigrep the poem.txt`\nSearching for the\nIn file poem.txt\nWith text:\nI`m nobody! Who are you?\nAre you nobody, too?\nThen there`s a pair of us - don`t tell!\nThey`d banish us, you know.\n\nHow dreary to be somebody!\nHow public, like a frog\nTo tell your name the livelong day\nTo an admiring bog!\n\n러스트는 코드가 결과 값을 무시하고 결과 값이 오류가 발생했음을 나타낼 수 있다고 알려줍니다. 그러나 우리는 오류가 있는지 여부를 확인하지 않으며 컴파일러는 아마도 여기에 오류 처리 코드가 있어야 한다고 상기시켜줍니다! 이제 그 문제를 바로잡자.\nmain의 run에서 반환된 오류 처리\nListing 12-10에서 Config::build에 사용한 것과 비슷한 기술을 사용하여 오류를 확인하고 처리하지만 약간의 차이가 있습니다.\n파일 이름: src/main.rs\nfn main() {\n    // --snip--\n\n    println!(`Searching for {}`, config.query);\n    println!(`In file {}`, config.file_path);\n\n    if let Err(e) = run(config) {\n        println!(`Application error: {e}`);\n        process::exit(1);\n    }\n}\n\n우리는 unwrap_or_else가 아닌 if let을 사용하여 run이 Err 값을 반환하는지 여부를 확인하고 반환하는 경우 process::exit(1)을 호출합니다. run 함수는 Config::build가 Config 인스턴스를 반환하는 것과 같은 방식으로 언래핑하려는 값을 반환하지 않습니다. 성공 사례에서 run은 ()를 반환하기 때문에 우리는 오류 감지에만 관심이 있으므로 래핑되지 않은 값을 반환하기 위해 unwrap_or_else가 필요하지 않으며 ()만 반환됩니다.\nif let 및 unwrap_or_else 함수의 본문은 두 경우 모두 동일합니다. 오류를 인쇄하고 종료합니다.\n코드를 라이브러리 크레이트로 분할\n우리의 minigrep 프로젝트는 지금까지 괜찮아 보입니다! 이제 src/main.rs 파일을 분할 하고 일부 코드를 src/lib.rs 파일에 넣습니다. 그렇게 하면 코드를 테스트하고 더 적은 책임으로 src/main.rs 파일을 가질 수 있습니다.\nmain 함수가 아닌 모든 코드를 src/main.rs 에서 src/lib.rs 로 이동해 보겠습니다.\n\n실행 함수 정의\n관련 사용 진술\n구성의 정의\nConfig::build 함수 정의\n\nsrc/lib.rs 의 내용은 목록 12-13에 표시된 서명을 가져야 합니다(간결성을 위해 함수 본문을 생략했습니다). Listing 12-14에서 src/main.rs를 수정할 때까지는 컴파일되지 않습니다.\n파일 이름: src/lib.rs\nuse std::error::Error;\nuse std::fs;\n\npub struct Config {\n    pub query: String,\n    pub file_path: String,\n}\n\nimpl Config {\n    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;`static str&gt; {\n        // --snip--\n    }\n}\n\npub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {\n    // --snip--\n}\n\n목록 12-13: Config 및 run을 src/lib.rs 로 이동\n우리는 pub 키워드를 Config, 해당 필드 및 build 메서드, run 함수에 자유롭게 사용했습니다. 이제 테스트할 수 있는 공개 API가 있는 라이브러리 크레이트가 생겼습니다!\n이제 목록 12-14에 표시된 것처럼 src/lib.rs 로 이동한 코드를 src/main.rs 의 바이너리 크레이트 범위로 가져와야 합니다.\n파일 이름: src/main.rs\nuse std::env;\nuse std::process;\n\nuse minigrep::Config;\n\nfn main() {\n    // --snip--\n    if let Err(e) = minigrep::run(config) {\n        // --snip--\n    }\n}\n\n목록 12-14: src/main.rs 에서 minigrep 라이브러리 크레이트 사용하기\nuse minigrep::Config 행을 추가하여 라이브러리 크레이트의 Config 유형을 바이너리 크레이트의 범위로 가져오고 run 함수 앞에 크레이트 이름을 붙입니다. 이제 모든 기능이 연결되고 작동해야 합니다. cargo run으로 프로그램을 실행하고 모든 것이 올바르게 작동하는지 확인하십시오.\n아휴! 그것은 많은 일이었지만 우리는 미래의 성공을 위해 스스로를 준비했습니다. 이제 오류를 처리하기가 훨씬 더 쉬워졌으며 코드를 더 모듈화했습니다. 거의 모든 작업은 여기서부터 src/lib.rs 에서 수행됩니다.\n이전 코드로는 어려웠지만 새 코드로는 쉬운 작업을 수행하여 이 새로 발견된 모듈성을 활용해 보겠습니다. 몇 가지 테스트를 작성하겠습니다!\n\n테스트 주도 개발로 라이브러리의 기능 개발\n이제 논리를 src/lib.rs 로 추출 하고 인수 수집 및 오류 처리를 src/main.rs 에 남겨두었 으므로 코드의 핵심 기능에 대한 테스트를 작성하는 것이 훨씬 쉬워졌습니다. 명령줄에서 바이너리를 호출하지 않고도 다양한 인수로 함수를 직접 호출하고 반환 값을 확인할 수 있습니다.\n이 섹션에서는 다음 단계에 따라 TDD(테스트 기반 개발) 프로세스를 사용하여 minigrep 프로그램에 검색 논리를 추가합니다.\n\n실패하는 테스트를 작성하고 실행하여 예상한 이유로 실패하는지 확인하십시오.\n새 테스트를 통과하기에 충분한 코드만 작성하거나 수정하십시오.\n방금 추가하거나 변경한 코드를 리팩터링하고 테스트가 계속 통과하는지 확인하십시오.\n1단계부터 반복!\n\nTDD는 소프트웨어를 작성하는 여러 방법 중 하나일 뿐이지만 코드 설계를 추진하는 데 도움이 될 수 있습니다. 테스트를 통과하는 코드를 작성하기 전에 테스트를 작성하면 프로세스 전체에서 높은 테스트 범위를 유지하는 데 도움이 됩니다.\n파일 내용에서 쿼리 문자열을 실제로 검색하고 쿼리와 일치하는 줄 목록을 생성하는 기능의 구현을 테스트 드라이브할 것입니다. 검색이라는 기능에 이 기능을 추가할 것입니다.\n실패한 테스트 작성\n더 이상 필요하지 않으므로 println! 프로그램의 동작을 확인하는 데 사용한 src/lib.rs 및 src/main.rs 의 명령문 . 그런 다음 src/lib.rs 에서 11장 에서 했던 것처럼 테스트 기능이 있는 tests 모듈을 추가합니다. 테스트 기능은 검색 기능에 원하는 동작을 지정합니다. 검색할 쿼리와 텍스트를 사용하고 쿼리를 포함하는 텍스트의 줄만 반환합니다. Listing 12-15는 아직 컴파일되지 않은 이 테스트를 보여줍니다.\n파일 이름: src/lib.rs\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn one_result() {\n        let query = `duct`;\n        let contents = `\\\nRust:\nsafe, fast, productive.\nPick three.`;\n\n        assert_eq!(vec![`safe, fast, productive.`], search(query, contents));\n    }\n}\n\n목록 12-15: 검색 기능에 대한 실패한 테스트 만들기\n이 테스트는 문자열 duct를 검색합니다. 우리가 찾고 있는 텍스트는 세 줄이며, 그 중 하나만 duct를 포함합니다(여는 큰따옴표 뒤의 백슬래시가 Rust에게 이 문자열 리터럴의 내용 시작 부분에 개행 문자를 넣지 말라고 지시한다는 점에 유의하십시오). 우리는 검색 함수에서 반환된 값에 우리가 기대하는 줄만 포함되어 있다고 주장합니다.\n우리는 아직 이 테스트를 실행할 수 없으며 테스트가 컴파일되지도 않았기 때문에 테스트가 실패하는 것을 볼 수 없습니다. 검색 기능은 아직 존재하지 않습니다! TDD 원칙에 따라 목록 12-16과 같이 항상 빈 벡터를 반환하는 검색 함수의 정의를 추가하여 테스트를 컴파일하고 실행하는 데 충분한 코드를 추가할 것입니다. 그러면 빈 벡터가 안전하고 빠르며 생산적이라는 줄을 포함하는 벡터와 일치하지 않기 때문에 테스트가 컴파일되고 실패해야 합니다.\n파일 이름: src/lib.rs\npub fn search&lt;`a&gt;(query: &amp;str, contents: &amp;`a str) -&gt; Vec&lt;&amp;`a str&gt; {\n    vec![]\n}\n\nListing 12-16: 테스트가 컴파일되도록 검색 기능을 충분히 정의하기\nsearch의 서명에서 명시적인 수명 ``a를 정의하고 contents인수 및 반환 값과 함께 해당 수명을 사용해야 한다는 점에 유의하십시오. 10장에서 수명 매개변수가 연결된 인수 수명을 지정한다는 것을 기억 [하십시오](https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html) . 반환 값의 수명 이 경우 반환된 벡터에는query인수가 아니라contents` 인수의 슬라이스를 참조하는 문자열 슬라이스가 포함되어야 함을 나타냅니다.\n즉, contents 인수에서 search 함수로 데이터가 전달되는 한 search 함수에 의해 반환된 데이터가 계속 유지될 것이라고 Rust에 알립니다. 이건 중요하다! 참조가 유효하려면 슬라이스 에서 참조하는 데이터가 유효해야 합니다. 컴파일러가 콘텐츠가 아닌 쿼리의 문자열 조각을 만들고 있다고 가정하면 안전 검사를 잘못 수행합니다.\n수명 주석을 잊어버리고 이 함수를 컴파일하려고 하면 다음 오류가 발생합니다.\n$ cargo build\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\nerror[E0106]: missing lifetime specifier\n  --&gt; src/lib.rs:28:51\n   |\n28 | pub fn search(query: &amp;str, contents: &amp;str) -&gt; Vec&lt;&amp;str&gt; {\n   |                      ----            ----         ^ expected named lifetime parameter\n   |\n   = help: this function`s return type contains a borrowed value, but the signature does not say whether it is borrowed from `query` or `contents`\nhelp: consider introducing a named lifetime parameter\n   |\n28 | pub fn search&lt;`a&gt;(query: &amp;`a str, contents: &amp;`a str) -&gt; Vec&lt;&amp;`a str&gt; {\n   |              ++++         ++                 ++              ++\n\nFor more information about this error, try `rustc --explain E0106`.\nerror: could not compile `minigrep` due to previous error\n\nRust는 우리에게 필요한 두 인수 중 어느 것이 필요한지 알 수 없으므로 명시적으로 알려줄 필요가 있습니다. contents는 모든 텍스트를 포함하는 인수이고 일치하는 해당 텍스트의 일부를 반환하기를 원하기 때문에 contents가 수명 구문을 사용하여 반환 값에 연결되어야 하는 인수임을 알고 있습니다.\n다른 프로그래밍 언어에서는 서명에서 값을 반환하기 위해 인수를 연결할 필요가 없지만 이 방법은 시간이 지나면서 더 쉬워질 것입니다. 이 예제를 10장의 수명이 있는 참조 유효성 검사 섹션 과 비교할 수 있습니다.\n이제 테스트를 실행해 보겠습니다.\n$ cargo test\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished test [unoptimized + debuginfo] target(s) in 0.97s\n     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)\n\nrunning 1 test\ntest tests::one_result ... FAILED\n\nfailures:\n\n---- tests::one_result stdout ----\nthread `tests::one_result` panicked at `assertion failed: `(left == right)`\n  left: `[`safe, fast, productive.`]`,\n right: `[]``, src/lib.rs:44:9\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\n\nfailures:\n    tests::one_result\n\ntest result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass `--lib`\n\n좋습니다. 예상한 대로 테스트가 실패했습니다. 시험을 통과하자!\n테스트 통과를 위한 코드 작성\n현재 테스트는 항상 빈 벡터를 반환하기 때문에 실패하고 있습니다. 이를 수정하고 검색을 구현하려면 프로그램에서 다음 단계를 따라야 합니다.\n\n내용의 각 행을 반복합니다.\n행에 쿼리 문자열이 포함되어 있는지 확인하십시오.\n그렇다면 반환하는 값 목록에 추가하십시오.\n그렇지 않으면 아무것도 하지 마십시오.\n일치하는 결과 목록을 반환합니다.\n\n줄을 반복하는 것부터 시작하여 각 단계를 살펴보겠습니다.\nlines 메서드를 사용하여 줄 반복\nRust는 목록 12-17에 표시된 대로 작동하는 편리한 lines라는 문자열의 라인별 반복을 처리하는 유용한 방법을 가지고 있습니다. 이것은 아직 컴파일되지 않습니다.\n파일 이름: src/lib.rs\npub fn search&lt;`a&gt;(query: &amp;str, contents: &amp;`a str) -&gt; Vec&lt;&amp;`a str&gt; {\n    for line in contents.lines() {\n        // do something with line\n    }\n}\n\nListing 12-17: contents의 각 줄 반복\nlines 메서드는 반복자를 반환합니다. 13장 에서 이터레이터에 대해 자세히 이야기하겠지만 목록 3-5 에서 이터레이터를 사용하는 방법을 보았던 것을 기억하십시오. 여기서 우리는 컬렉션의 각 항목에 대해 일부 코드를 실행하기 위해 이터레이터와 함께 for 루프를 사용했습니다. .\n쿼리에 대한 각 줄 검색\n다음으로 현재 줄에 쿼리 문자열이 포함되어 있는지 확인합니다. 다행스럽게도 문자열에는 이 작업을 수행하는 contains라는 유용한 메서드가 있습니다! Listing 12-18에 표시된 것처럼 search 함수의 contains 메서드에 대한 호출을 추가합니다. 이것은 아직 컴파일되지 않습니다.\n파일 이름: src/lib.rs\npub fn search&lt;`a&gt;(query: &amp;str, contents: &amp;`a str) -&gt; Vec&lt;&amp;`a str&gt; {\n    for line in contents.lines() {\n        if line.contains(query) {\n            // do something with line\n        }\n    }\n}\n\nListing 12-18: 줄에 query의 문자열이 포함되어 있는지 확인하는 기능 추가\n현재 우리는 기능을 구축하고 있습니다. 컴파일하려면 함수 서명에서 지시한 대로 본문에서 값을 반환해야 합니다.\n일치하는 줄 저장\n이 기능을 완료하려면 반환하려는 일치하는 줄을 저장할 방법이 필요합니다. 이를 위해 for 루프 전에 가변 벡터를 만들고 push 메서드를 호출하여 벡터에 선을 저장할 수 있습니다. for 루프 다음에 목록 12-19에 표시된 것처럼 벡터를 반환합니다.\n파일 이름: src/lib.rs\npub fn search&lt;`a&gt;(query: &amp;str, contents: &amp;`a str) -&gt; Vec&lt;&amp;`a str&gt; {\n    let mut results = Vec::new();\n\n    for line in contents.lines() {\n        if line.contains(query) {\n            results.push(line);\n        }\n    }\n\n    results\n}\n\nListing 12-19: 반환할 수 있도록 일치하는 줄 저장\n이제 search 함수는 query를 포함하는 줄만 반환해야 하며 테스트는 통과해야 합니다. 테스트를 실행해 보겠습니다.\n$ cargo test\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished test [unoptimized + debuginfo] target(s) in 1.22s\n     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)\n\nrunning 1 test\ntest tests::one_result ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n     Running unittests src/main.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests minigrep\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n우리의 테스트는 통과되었으므로 작동한다는 것을 알고 있습니다!\n이 시점에서 동일한 기능을 유지하기 위해 테스트 통과를 유지하면서 검색 기능 구현을 리팩토링할 수 있는 기회를 고려할 수 있습니다. 검색 기능의 코드는 그리 나쁘지는 않지만 반복자의 몇 가지 유용한 기능을 활용하지 않습니다. 13장 에서 이 예제로 돌아가 반복자를 자세히 살펴보고 이를 개선하는 방법을 살펴보겠습니다.\n실행 기능에서 검색 기능 사용\n이제 검색 기능이 작동하고 테스트되었으므로 실행 기능에서 검색을 호출해야 합니다. config.query 값과 run이 파일에서 읽는 contents를 search 기능에 전달해야 합니다. 그런 다음 run은 search에서 반환된 각 줄을 인쇄합니다.\n파일 이름: src/lib.rs\npub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {\n    let contents = fs::read_to_string(config.file_path)?;\n\n    for line in search(&amp;config.query, &amp;contents) {\n        println!(`{line}`);\n    }\n\n    Ok(())\n}\n\n우리는 여전히 for 루프를 사용하여 검색에서 각 줄을 반환하고 인쇄합니다.\n이제 전체 프로그램이 작동해야 합니다! 먼저 Emily Dickinson의 시 개구리에서 정확히 한 줄을 반환해야 하는 단어로 시도해 봅시다.\n$ cargo run -- frog poem.txt\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.38s\n     Running `target/debug/minigrep frog poem.txt`\nHow public, like a frog\n\n시원한! 이제 body와 같이 여러 줄과 일치하는 단어를 사용해 보겠습니다.\n$ cargo run -- body poem.txt\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.0s\n     Running `target/debug/minigrep body poem.txt`\nI`m nobody! Who are you?\nAre you nobody, too?\nHow dreary to be somebody!\n\n그리고 마지막으로 monomorphization과 같이 시 어디에도 없는 단어를 검색할 때 어떤 행도 얻지 않도록 합시다.\n$ cargo run -- monomorphization poem.txt\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.0s\n     Running `target/debug/minigrep monomorphization poem.txt`\n\n훌륭한! 우리는 고전적인 도구의 자체 미니 버전을 구축했으며 응용 프로그램을 구성하는 방법에 대해 많은 것을 배웠습니다. 또한 파일 입력 및 출력, 수명, 테스트 및 명령줄 구문 분석에 대해 조금 배웠습니다.\n이 프로젝트를 마무리하기 위해 명령줄 프로그램을 작성할 때 유용한 환경 변수로 작업하는 방법과 표준 오류로 인쇄하는 방법을 간략하게 설명합니다.\n\n환경 변수 작업\n사용자가 환경 변수를 통해 설정할 수 있는 대소문자를 구분하지 않는 검색 옵션을 추가하여 minigrep을 개선할 것입니다. 이 기능을 명령줄 옵션으로 만들고 사용자가 적용하기를 원할 때마다 입력하도록 요구할 수 있지만 대신 환경 변수로 만들어 사용자가 환경 변수를 한 번 설정하고 모든 검색에서 대소문자를 구분하지 않도록 할 수 있습니다. 해당 터미널 세션에서.\n대소문자를 구분하지 않는 검색 기능에 대한 실패한 테스트 작성\n먼저 환경 변수에 값이 있을 때 호출되는 새로운 search_case_insensitive 함수를 추가합니다. 계속해서 TDD 프로세스를 따를 것이므로 첫 번째 단계는 실패한 테스트를 다시 작성하는 것입니다. 새로운 search_case_insensitive 함수에 대한 새 테스트를 추가하고 이전 테스트의 이름을 one_result에서 case_sensitive로 변경하여 Listing 12-20과 같이 두 테스트 간의 차이점을 명확히 할 것입니다.\n파일 이름: src/lib.rs\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn case_sensitive() {\n        let query = `duct`;\n        let contents = `\\\nRust:\nsafe, fast, productive.\nPick three.\nDuct tape.`;\n\n        assert_eq!(vec![`safe, fast, productive.`], search(query, contents));\n    }\n\n    #[test]\n    fn case_insensitive() {\n        let query = `rUsT`;\n        let contents = `\\\nRust:\nsafe, fast, productive.\nPick three.\nTrust me.`;\n\n        assert_eq!(\n            vec![`Rust:`, `Trust me.`],\n            search_case_insensitive(query, contents)\n        );\n    }\n}\n\n목록 12-20: 추가하려는 대소문자를 구분하지 않는 함수에 대한 새로운 실패 테스트 추가\n이전 테스트의 내용도 편집했습니다. 대소문자 구분 방식으로 검색할 때 duct 검색어와 일치하지 않아야 하는 대문자 D를 사용하여 Duct tape.이라는 텍스트가 포함된 새 줄을 추가했습니다. 이러한 방식으로 기존 테스트를 변경하면 이미 구현한 대소문자 구분 검색 기능이 실수로 중단되지 않도록 할 수 있습니다. 이 테스트는 지금 통과해야 하며 대소문자를 구분하지 않는 검색 작업을 진행하는 동안 계속 통과해야 합니다.\n대소문자를 구분하지 않는 검색 에 대한 새 테스트는 rUsT를 쿼리로 사용합니다. 추가하려는 search_case_insensitive 함수에서 쿼리 rUsT는 대문자 R이 있는 Rust:를 포함하는 줄과 일치하고 Trust me. 줄과 일치해야 합니다. 쿼리와 대소문자가 다릅니다. 이것은 실패한 테스트이며 아직 search_case_insensitive 함수를 정의하지 않았기 때문에 컴파일에 실패합니다. 테스트 컴파일 및 실패를 확인하기 위해 Listing 12-16의 search 함수에 대해 수행한 방식과 유사하게 항상 빈 벡터를 반환하는 스켈레톤 구현을 자유롭게 추가하십시오.\nsearch_case_insensitive 기능 구현\n목록 12-21에 표시된 search_case_insensitive 기능은 search 기능과 거의 동일합니다. 유일한 차이점은 query와 각 line을 소문자로 사용하여 입력 인수의 대소문자가 무엇이든 라인에 쿼리가 포함되어 있는지 여부를 확인할 때 대소문자가 동일하다는 것입니다.\n파일 이름: src/lib.rs\npub fn search_case_insensitive&lt;`a&gt;(\n    query: &amp;str,\n    contents: &amp;`a str,\n) -&gt; Vec&lt;&amp;`a str&gt; {\n    let query = query.to_lowercase();\n    let mut results = Vec::new();\n\n    for line in contents.lines() {\n        if line.to_lowercase().contains(&amp;query) {\n            results.push(line);\n        }\n    }\n\n    results\n}\n\n목록 12-21: search_case_insensitive 함수를 정의하여 쿼리와 줄을 비교하기 전에 소문자로 만들기\n먼저 query 문자열을 소문자로 만들고 같은 이름의 숨겨진 변수에 저장합니다. 쿼리에서 to_lowercase를 호출하는 것이 필요하므로 사용자의 쿼리가 rust, RUST, Rust 또는 rUsT인지 여부에 관계없이 쿼리를 다음과 같이 처리합니다. 그것은 녹이었고 케이스에 둔감했습니다. to_lowercase는 기본 유니코드를 처리하지만 100% 정확하지는 않습니다. 실제 응용 프로그램을 작성하고 있다면 여기에서 좀 더 많은 작업을 수행하고 싶지만 이 섹션은 유니코드가 아닌 환경 변수에 관한 것이므로 여기에서 그대로 두겠습니다.\nto_lowercase를 호출하면 기존 데이터를 참조하는 대신 새 데이터가 생성되기 때문에 query는 이제 문자열 조각이 아니라 문자열입니다. 예를 들어 쿼리가 rUsT라고 가정해 보겠습니다. 해당 문자열 조각에는 소문자 u 또는 t가 포함되어 있지 않으므로 ``rust를 포함하는 새 문자열을 할당해야 합니다. . 이제 contains 메서드에 query를 인수로 전달할 때 contains의 서명이 문자열 슬라이스를 취하도록 정의되어 있으므로 앰퍼샌드를 추가해야 합니다.\n다음으로 각 줄에 to_lowercase에 대한 호출을 추가하여 모든 문자를 소문자로 만듭니다. 이제 line과 query를 소문자로 변환했으므로 쿼리의 대소문자에 상관없이 일치하는 항목을 찾을 수 있습니다.\n이 구현이 테스트를 통과하는지 봅시다:\n$ cargo test\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished test [unoptimized + debuginfo] target(s) in 1.33s\n     Running unittests src/lib.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)\n\nrunning 2 tests\ntest tests::case_insensitive ... ok\ntest tests::case_sensitive ... ok\n\ntest result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n     Running unittests src/main.rs (target/debug/deps/minigrep-9cd200e5fac0fc94)\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests minigrep\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n엄청난! 통과했습니다. 이제 run 함수에서 새로운 search_case_insensitive 함수를 호출해 보겠습니다. 먼저 Config 구조체에 구성 옵션을 추가하여 대소문자 구분 검색과 대소문자 구분 안 함 검색 간에 전환합니다. 이 필드를 추가하면 아직 이 필드를 초기화하지 않았기 때문에 컴파일러 오류가 발생합니다.\n파일 이름: src/lib.rs\npub struct Config {\n    pub query: String,\n    pub file_path: String,\n    pub ignore_case: bool,\n}\n\n부울을 포함하는 ignore_case 필드를 추가했습니다. 다음으로 ignore_case 필드의 값을 확인하고 search 함수를 호출할지 search_case_insensitive 함수를 호출할지 결정하는 데 사용하는 run 함수가 필요합니다. Listing 12-22에서 볼 수 있습니다. 아직 컴파일되지 않습니다.\n파일 이름: src/lib.rs\npub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {\n    let contents = fs::read_to_string(config.file_path)?;\n\n    let results = if config.ignore_case {\n        search_case_insensitive(&amp;config.query, &amp;contents)\n    } else {\n        search(&amp;config.query, &amp;contents)\n    };\n\n    for line in results {\n        println!(`{line}`);\n    }\n\n    Ok(())\n}\n\n목록 12-22: config.ignore_case의 값을 기반으로 search 또는 search_case_insensitive 호출\n마지막으로 환경 변수를 확인해야 합니다. 환경 변수 작업을 위한 함수는 표준 라이브러리의 env 모듈에 있으므로 해당 모듈을 src/lib.rs 맨 위에 있는 범위로 가져옵니다. 그런 다음 목록 12-23과 같이 IGNORE_CASE라는 환경 변수에 대해 값이 설정되었는지 확인하기 위해 env 모듈의 var 함수를 사용할 것입니다.\n파일 이름: src/lib.rs\nuse std::env;\n// --snip--\n\nimpl Config {\n    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;`static str&gt; {\n        if args.len() &lt; 3 {\n            return Err(`not enough arguments`);\n        }\n\n        let query = args[1].clone();\n        let file_path = args[2].clone();\n\n        let ignore_case = env::var(`IGNORE_CASE`).is_ok();\n\n        Ok(Config {\n            query,\n            file_path,\n            ignore_case,\n        })\n    }\n}\n\n목록 12-23: IGNORE_CASE라는 이름의 환경 변수에서 값 확인하기\n여기에서 새 변수 ignore_case를 만듭니다. 값을 설정하기 위해 env::var 함수를 호출하고 IGNORE_CASE 환경 변수의 이름을 전달합니다. env::var 함수는 환경 변수가 임의의 값으로 설정된 경우 환경 변수의 값을 포함하는 성공적인 Ok 변형이 될 결과를 반환합니다. 환경 변수가 설정되지 않은 경우 Err 변형을 반환합니다.\n환경 변수가 설정되었는지 확인하기 위해 결과에서 is_ok 메서드를 사용하고 있습니다. 이는 프로그램이 대소문자를 구분하지 않고 검색해야 함을 의미합니다. IGNORE_CASE 환경 변수가 아무 것도 설정되지 않은 경우 is_ok는 false를 반환하고 프로그램은 대소문자 구분 검색을 수행합니다. 우리는 환경 변수의 값이 설정되었는지 여부에 대해 신경 쓰지 않으므로 unwrap, expect 또는 우리가 본 다른 방법을 사용하는 대신 is_ok를 확인합니다. 결과.\nListing 12-22에서 구현한 것처럼 ignore_case 변수의 값을 Config 인스턴스로 전달하여 run 함수가 해당 값을 읽고 search_case_insensitive 또는 search를 호출할지 여부를 결정할 수 있습니다.\n한번 해보자! 먼저 환경 변수를 설정하지 않고 to라는 쿼리를 사용하여 프로그램을 실행합니다. 이 쿼리는 모두 소문자로 to라는 단어가 포함된 줄과 일치해야 합니다.\n$ cargo run -- to poem.txt\n   Compiling minigrep v0.1.0 (file:///projects/minigrep)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.0s\n     Running `target/debug/minigrep to poem.txt`\nAre you nobody, too?\nHow dreary to be somebody!\n\n여전히 작동하는 것 같습니다! 이제 IGNORE_CASE를 1로 설정하고 동일한 쿼리 to를 사용하여 프로그램을 실행해 보겠습니다.\n$ IGNORE_CASE=1 cargo run -- to poem.txt\n\nPowerShell을 사용하는 경우 환경 변수를 설정하고 별도의 명령으로 프로그램을 실행해야 합니다.\nPS&gt; $Env:IGNORE_CASE=1; cargo run -- to poem.txt\n\n이렇게 하면 나머지 셸 세션 동안 IGNORE_CASE가 지속됩니다. Remove-Item cmdlet을 사용하여 설정을 해제할 수 있습니다.\nPS&gt; Remove-Item Env:IGNORE_CASE\n\n대문자를 가질 수 있는 to를 포함하는 줄을 가져와야 합니다.\nAre you nobody, too?\nHow dreary to be somebody!\nTo tell your name the livelong day\nTo an admiring bog!\n\n훌륭합니다. To가 포함된 대사도 있습니다! minigrep 프로그램은 이제 환경 변수에 의해 제어되는 대소문자를 구분하지 않는 검색을 수행할 수 있습니다. 이제 명령줄 인수 또는 환경 변수를 사용하여 옵션 세트를 관리하는 방법을 알게 되었습니다.\n일부 프로그램은 동일한 구성에 대해 인수 와 환경 변수를 허용합니다. 이러한 경우 프로그램은 둘 중 하나가 우선적으로 적용되도록 결정합니다. 다른 실습을 위해 명령줄 인수 또는 환경 변수를 통해 대소문자 구분을 제어해 보십시오. 하나는 대소문자를 구분하도록 설정하고 다른 하나는 대소문자를 무시하도록 설정된 상태로 프로그램을 실행하는 경우 명령줄 인수 또는 환경 변수가 우선적으로 적용되어야 하는지 여부를 결정합니다.\nstd::env 모듈에는 환경 변수를 처리하기 위한 더 많은 유용한 기능이 포함되어 있습니다. 사용 가능한 기능을 보려면 설명서를 확인하십시오.\n\n표준 출력 대신 표준 오류에 오류 메시지 쓰기\n지금은 println!을 사용하여 모든 출력을 터미널에 쓰고 있습니다. 매크로. 대부분의 터미널에는 일반 정보에 대한 표준 출력 (stdout)과 오류 메시지에 대한 표준 오류 (stderr) 의 두 가지 종류의 출력이 있습니다. 이러한 구별을 통해 사용자는 프로그램의 성공적인 출력을 파일로 지정하지만 여전히 오류 메시지를 화면에 인쇄하도록 선택할 수 있습니다.\nprintln! 매크로는 표준 출력으로만 인쇄할 수 있으므로 표준 오류로 인쇄하려면 다른 것을 사용해야 합니다.\n오류가 기록된 위치 확인\n먼저 minigrep에 의해 인쇄된 내용이 현재 어떻게 표준 출력에 기록되는지 살펴보겠습니다. 여기에는 표준 오류에 기록하려는 오류 메시지도 포함됩니다. 의도적으로 오류를 발생시키면서 표준 출력 스트림을 파일로 리디렉션하여 이를 수행합니다. 표준 오류 스트림을 리디렉션하지 않으므로 표준 오류로 전송된 모든 콘텐츠가 화면에 계속 표시됩니다.\n명령줄 프로그램은 오류 메시지를 표준 오류 스트림으로 보낼 것으로 예상되므로 표준 출력 스트림을 파일로 리디렉션하더라도 화면에서 여전히 오류 메시지를 볼 수 있습니다. 우리 프로그램은 현재 제대로 작동하지 않습니다. 대신 오류 메시지 출력을 파일에 저장하는 것을 보게 될 것입니다!\n이 동작을 시연하기 위해 &gt; 및 표준 출력 스트림을 리디렉션할 파일 경로 output.txt 를 사용하여 프로그램을 실행합니다. 오류가 발생하는 인수를 전달하지 않습니다.\n$ cargo run &gt; output.txt\n\n&gt; 구문은 표준 출력의 내용을 화면 대신 output.txt 에 쓰도록 쉘에 지시합니다. 예상했던 오류 메시지가 화면에 표시되지 않았으므로 파일에 오류가 있음을 의미합니다. 이것이 output.txt 에 포함된 내용입니다.\nProblem parsing arguments: not enough arguments\n\n예, 오류 메시지가 표준 출력으로 출력되고 있습니다. 이와 같은 오류 메시지가 표준 오류로 인쇄되어 성공적인 실행의 데이터만 파일에 저장되는 것이 훨씬 더 유용합니다. 우리는 그것을 바꿀 것입니다.\n오류를 표준 오류로 인쇄\nListing 12-24의 코드를 사용하여 오류 메시지가 인쇄되는 방식을 변경할 것입니다. 이 장의 앞부분에서 수행한 리팩토링으로 인해 오류 메시지를 인쇄하는 모든 코드는 main이라는 하나의 함수에 있습니다. 표준 라이브러리는 eprintln! 표준 오류 스트림으로 인쇄하는 매크로이므로 println!이라고 부르던 두 위치를 변경하겠습니다. 오류를 인쇄하려면 eprintln!을 사용하십시오. 대신에.\n파일 이름: src/main.rs\nfn main() {\n    let args: Vec&lt;String&gt; = env::args().collect();\n\n    let config = Config::build(&amp;args).unwrap_or_else(|err| {\n        eprintln!(`Problem parsing arguments: {err}`);\n        process::exit(1);\n    });\n\n    if let Err(e) = minigrep::run(config) {\n        eprintln!(`Application error: {e}`);\n        process::exit(1);\n    }\n}\n\n목록 12-24: eprintln!을 사용하여 표준 출력 대신 표준 오류에 오류 메시지 쓰기\n이제 인수 없이 &gt;를 사용하여 표준 출력을 리디렉션하는 동일한 방식으로 프로그램을 다시 실행해 보겠습니다.\n$ cargo run &gt; output.txt\nProblem parsing arguments: not enough arguments\n\n이제 화면에 오류가 표시되고 output.txt 에 아무것도 포함되지 않습니다. 이는 명령줄 프로그램에서 예상되는 동작입니다.\n다음과 같이 오류를 일으키지 않지만 여전히 표준 출력을 파일로 리디렉션하는 인수를 사용하여 프로그램을 다시 실행해 보겠습니다.\n$ cargo run -- to poem.txt &gt; output.txt\n\n터미널에 대한 출력이 표시되지 않으며 output.txt에 결과가 포함됩니다.\n파일 이름: output.txt\nAre you nobody, too?\nHow dreary to be somebody!\n\n이것은 성공적인 출력을 위해 표준 출력을 사용하고 오류 출력을 위해 표준 오류를 적절하게 사용하고 있음을 보여줍니다.\n요약\n이 장에서는 지금까지 배운 몇 가지 주요 개념을 요약하고 Rust에서 일반적인 I/O 작업을 수행하는 방법을 다루었습니다. 명령줄 인수, 파일, 환경 변수 및 eprintln! 인쇄 오류에 대한 매크로, 이제 명령줄 응용 프로그램을 작성할 준비가 된 것입니다. 이전 장의 개념과 결합하면 코드가 잘 구성되고 데이터를 적절한 데이터 구조에 효과적으로 저장하며 오류를 잘 처리하고 잘 테스트됩니다.\n다음으로 함수형 언어의 영향을 받은 일부 Rust 기능인 클로저와 이터레이터를 살펴보겠습니다.\n\n13\n함수형 언어 기능: 반복자와 클로저\nRust의 디자인은 기존의 많은 언어와 기술에서 영감을 얻었으며 한 가지 중요한 영향은 함수형 프로그래밍 입니다. 기능적 스타일의 프로그래밍에는 종종 함수를 인수로 전달하고, 다른 함수에서 반환하고, 나중에 실행하기 위해 변수에 할당하는 등 함수를 값으로 사용하는 것이 포함됩니다.\n이 장에서 우리는 함수형 프로그래밍이 무엇인지 아닌지에 대한 문제에 대해 토론하지 않을 것입니다. 대신 종종 함수형이라고 하는 많은 언어의 기능과 유사한 Rust의 일부 기능에 대해 논의할 것입니다.\n보다 구체적으로 다음 내용을 다룹니다.\n\nClosures , 변수에 저장할 수 있는 함수와 유사한 구조\n일련의 요소를 처리하는 방법인 반복자\n12장에서 클로저와 반복자를 사용하여 I/O 프로젝트를 개선하는 방법\n클로저와 이터레이터의 성능(스포일러 경고: 생각보다 빠릅니다!)\n\n우리는 함수형 스타일의 영향을 받는 패턴 일치 및 열거형과 같은 일부 다른 Rust 기능을 이미 다루었습니다. 클로저와 이터레이터를 마스터하는 것은 관용적이고 빠른 Rust 코드를 작성하는 데 중요한 부분이기 때문에 이 장 전체를 여기에 할애할 것입니다.\n\n클로저: 환경을 캡처하는 익명 함수\nRust의 클로저는 변수에 저장하거나 다른 함수에 인수로 전달할 수 있는 익명 함수입니다. 한 곳에서 클로저를 생성한 다음 다른 곳에서 클로저를 호출하여 다른 컨텍스트에서 평가할 수 있습니다. 함수와 달리 클로저는 정의된 범위에서 값을 캡처할 수 있습니다. 이러한 클로저 기능이 코드 재사용 및 동작 사용자 정의를 허용하는 방법을 보여줍니다.\n폐쇄로 환경 캡처\n나중에 사용하기 위해 클로저가 정의된 환경에서 값을 캡처하기 위해 클로저를 사용하는 방법을 먼저 살펴보겠습니다. 시나리오는 다음과 같습니다. 우리 티셔츠 회사는 메일링 리스트에 있는 누군가에게 판촉 행사로 독점적인 한정판 셔츠를 무료로 제공합니다. 메일링 리스트에 있는 사람들은 원하는 색상을 프로필에 추가할 수 있습니다. 무료 셔츠로 선택된 사람이 좋아하는 색상 세트를 가지고 있으면 그 색상 셔츠를 받게 됩니다. 선호하는 색상을 지정하지 않은 경우 회사에서 현재 가장 많이 사용하는 색상이 지정됩니다.\n이를 구현하는 방법에는 여러 가지가 있습니다. 이 예에서는 Red 및 Blue 변형이 있는 ShirtColor라는 열거형을 사용합니다(단순화를 위해 사용 가능한 색상 수 제한). Vec을 포함하는 shirts라는 필드가 있는 Inventory 구조로 회사의 인벤토리를 나타냅니다.는 현재 재고가 있는 셔츠 색상을 나타냅니다. Inventory에 정의된 giveaway` 메서드는 무료 셔츠 당첨자의 셔츠 색상 기본 설정(옵션)을 가져오고 그 사람이 받게 될 셔츠 색상을 반환합니다. 이 설정은 목록 13-1에 나와 있습니다. :\n파일 이름: src/main.rs\n#[derive(Debug, PartialEq, Copy, Clone)]\nenum ShirtColor {\n    Red,\n    Blue,\n}\n\nstruct Inventory {\n    shirts: Vec&lt;ShirtColor&gt;,\n}\n\nimpl Inventory {\n    fn giveaway(&amp;self, user_preference: Option&lt;ShirtColor&gt;) -&gt; ShirtColor {\n        user_preference.unwrap_or_else(|| self.most_stocked())\n    }\n\n    fn most_stocked(&amp;self) -&gt; ShirtColor {\n        let mut num_red = 0;\n        let mut num_blue = 0;\n\n        for color in &amp;self.shirts {\n            match color {\n                ShirtColor::Red =&gt; num_red += 1,\n                ShirtColor::Blue =&gt; num_blue += 1,\n            }\n        }\n        if num_red &gt; num_blue {\n            ShirtColor::Red\n        } else {\n            ShirtColor::Blue\n        }\n    }\n}\n\nfn main() {\n    let store = Inventory {\n        shirts: vec![ShirtColor::Blue, ShirtColor::Red, ShirtColor::Blue],\n    };\n\n    let user_pref1 = Some(ShirtColor::Red);\n    let giveaway1 = store.giveaway(user_pref1);\n    println!(\n        `The user with preference {:?} gets {:?}`,\n        user_pref1, giveaway1\n    );\n\n    let user_pref2 = None;\n    let giveaway2 = store.giveaway(user_pref2);\n    println!(\n        `The user with preference {:?} gets {:?}`,\n        user_pref2, giveaway2\n    );\n}\n\n목록 13-1: 셔츠 회사 증정품 상황\n메인에 정의된 상점에는 이 한정판 프로모션을 위해 배포할 파란색 셔츠 2개와 빨간색 셔츠 1개가 남아 있습니다. 빨간색 셔츠를 선호하는 사용자와 선호하지 않는 사용자를 giveaway 방식이라고 합니다.\n다시 말하지만, 이 코드는 여러 가지 방법으로 구현될 수 있으며 여기서는 클로저에 초점을 맞추기 위해 클로저를 사용하는 giveaway 메서드의 본문을 제외하고 이미 배운 개념을 고수했습니다. giveaway 방식에서는 사용자 선호도를 Option 유형의 매개변수로 가져옵니다.그리고user_preference에서 unwrap_or_else 메서드를 호출합니다. [Option에서 unwrap_or_else메서드는](https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or_else) 표준 라이브러리에 의해 정의됩니다. 하나의 인수를 취합니다: 값T를 반환하는 인수 없는 클로저(동일한 유형 옵션의 일부 변형에 저장됨, 이 경우 ShirtColor). 옵션는 Some 변형이고, unwrap_or_else는 Some 내에서 값을 반환합니다. Option는 없음 변형이고 unwrap_or_else는 클로저를 호출하고 클로저에서 반환된 값을 반환합니다.\n클로저 표현식 || self.most_stocked()를 unwrap_or_else의 인수로 지정합니다. 이것은 자체적으로 매개변수를 받지 않는 클로저입니다(클로저에 매개변수가 있는 경우 두 개의 수직 막대 사이에 나타납니다). 클로저의 본문은 self.most_stocked()를 호출합니다. 우리는 여기에서 클로저를 정의하고 있으며 unwrap_or_else 구현은 나중에 결과가 필요한 경우 클로저를 평가합니다.\n이 코드를 실행하면 다음이 인쇄됩니다.\n$ cargo run\n   Compiling shirt-company v0.1.0 (file:///projects/shirt-company)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.27s\n     Running `target/debug/shirt-company`\nThe user with preference Some(Red) gets Red\nThe user with preference None gets Blue\n\n여기서 한 가지 흥미로운 측면은 현재 Inventory 인스턴스에서 self.most_stocked()를 호출하는 클로저를 전달했다는 것입니다. 표준 라이브러리는 우리가 정의한 Inventory 또는 ShirtColor 유형이나 이 시나리오에서 사용하려는 논리에 대해 알 필요가 없습니다. 클로저는 self Inventory 인스턴스에 대한 불변 참조를 캡처하고 unwrap_or_else 메서드에 지정한 코드와 함께 전달합니다. 반면에 함수는 이러한 방식으로 환경을 캡처할 수 없습니다.\n클로저 유형 추론 및 주석\n함수와 클로저 사이에는 더 많은 차이점이 있습니다. 클로저는 일반적으로 fn 함수처럼 매개변수의 유형이나 반환 값에 주석을 달 필요가 없습니다. 유형은 사용자에게 노출되는 명시적 인터페이스의 일부이기 때문에 유형 주석은 함수에 필요합니다. 이 인터페이스를 엄격하게 정의하는 것은 모든 사람이 함수가 사용하고 반환하는 값 유형에 동의하도록 하는 데 중요합니다. 반면에 클로저는 다음과 같이 노출된 인터페이스에서 사용되지 않습니다. 클로저는 변수에 저장되고 이름을 지정하지 않고 라이브러리 사용자에게 노출되지 않고 사용됩니다.\n폐쇄는 일반적으로 임의의 시나리오가 아닌 좁은 맥락 내에서만 짧고 관련이 있습니다. 이러한 제한된 컨텍스트 내에서 컴파일러는 대부분의 변수 유형을 유추할 수 있는 방법과 유사하게 매개 변수 및 반환 유형의 유형을 유추할 수 있습니다(컴파일러가 클로저 유형 주석도 필요로 하는 드문 경우가 있음).\n변수와 마찬가지로 엄격하게 필요한 것보다 더 자세한 비용으로 명확성과 명확성을 높이려는 경우 유형 주석을 추가할 수 있습니다. 클로저에 대한 유형에 주석을 다는 것은 Listing 13-2에 표시된 정의와 같습니다. 이 예제에서 우리는 목록 13-1에서 했던 것처럼 클로저를 인수로 전달하는 지점에서 클로저를 정의하는 대신 클로저를 정의하고 변수에 저장합니다.\n파일 이름: src/main.rs\n    let expensive_closure = |num: u32| -&gt; u32 {\n        println!(`calculating slowly...`);\n        thread::sleep(Duration::from_secs(2));\n        num\n    };\n\n목록 13-2: 클로저에서 매개변수 및 반환 값 유형의 선택적 유형 주석 추가\n유형 주석을 추가하면 클로저 구문이 함수 구문과 더 유사해 보입니다. 여기서 우리는 비교를 위해 매개변수에 1을 더하는 함수와 동일한 동작을 하는 클로저를 정의합니다. 관련 부분을 정렬하기 위해 공백을 추가했습니다. 이는 파이프 사용과 선택적 구문의 양을 제외하고 클로저 구문이 함수 구문과 얼마나 유사한지 보여줍니다.\nfn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }\nlet add_one_v2 = |x: u32| -&gt; u32 { x + 1 };\nlet add_one_v3 = |x|             { x + 1 };\nlet add_one_v4 = |x|               x + 1  ;\n\n첫 번째 줄은 함수 정의를 보여주고 두 번째 줄은 완전히 주석이 달린 클로저 정의를 보여줍니다. 세 번째 줄에서는 클로저 정의에서 유형 주석을 제거합니다. 네 번째 줄에서 대괄호를 제거합니다. 이는 클로저 본문에 표현식이 하나만 있기 때문에 선택적입니다. 이들은 모두 호출될 때 동일한 동작을 생성하는 유효한 정의입니다. add_one_v3 및 add_one_v4 줄은 유형이 사용에서 유추되기 때문에 컴파일할 수 있도록 클로저를 평가해야 합니다. 이것은 let v = Vec::new();와 유사합니다. Rust가 유형을 유추할 수 있도록 Vec에 삽입할 유형 주석 또는 일부 유형의 값이 필요합니다.\n클로저 정의의 경우 컴파일러는 각 매개 변수와 반환 값에 대해 하나의 구체적인 유형을 유추합니다. 예를 들어, 목록 13-3은 매개변수로 받은 값을 반환하는 짧은 클로저의 정의를 보여줍니다. 이 클로저는 이 예제의 목적을 제외하고는 그다지 유용하지 않습니다. 정의에 유형 주석을 추가하지 않았습니다. 타입 어노테이션이 없기 때문에 어떤 타입으로도 클로저를 호출할 수 있습니다. 여기에서 처음으로 String으로 했습니다. 그런 다음 정수로 example_closure를 호출하려고 하면 오류가 발생합니다.\n파일 이름: src/main.rs\n    let example_closure = |x| x;\n\n    let s = example_closure(String::from(`hello`));\n    let n = example_closure(5);\n\n목록 13-3: 유형이 두 가지 다른 유형으로 유추되는 클로저 호출 시도\n컴파일러는 다음 오류를 제공합니다.\n$ cargo run\n   Compiling closure-example v0.1.0 (file:///projects/closure-example)\nerror[E0308]: mismatched types\n --&gt; src/main.rs:5:29\n  |\n5 |     let n = example_closure(5);\n  |             --------------- ^- help: try using a conversion method: `.to_string()`\n  |             |               |\n  |             |               expected struct `String`, found integer\n  |             arguments to this function are incorrect\n  |\nnote: closure parameter defined here\n --&gt; src/main.rs:2:28\n  |\n2 |     let example_closure = |x| x;\n  |                            ^\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `closure-example` due to previous error\n\nstring 값으로 example_closure를 처음 호출할 때 컴파일러는 x 유형과 클로저의 반환 유형을 String으로 유추합니다. 그런 다음 이러한 유형은 example_closure의 클로저에 잠기며 다음에 동일한 클로저로 다른 유형을 사용하려고 하면 유형 오류가 발생합니다.\n참조 캡처 또는 소유권 이동\n클로저는 세 가지 방법으로 환경에서 값을 캡처할 수 있으며, 이는 함수가 매개변수를 취할 수 있는 세 가지 방법(변경불가 차용, 변경가능 차용 및 소유권 가져오기)에 직접 매핑됩니다. 클로저는 함수 본문이 캡처된 값으로 수행하는 작업을 기반으로 이들 중 사용할 것을 결정합니다.\n목록 13-4에서 우리는 list라는 이름의 벡터에 대한 불변 참조를 캡처하는 클로저를 정의합니다. 값을 출력하기 위해 불변 참조만 필요하기 때문입니다.\n파일 이름: src/main.rs\nfn main() {\n    let list = vec![1, 2, 3];\n    println!(`Before defining closure: {:?}`, list);\n\n    let only_borrows = || println!(`From closure: {:?}`, list);\n\n    println!(`Before calling closure: {:?}`, list);\n    only_borrows();\n    println!(`After calling closure: {:?}`, list);\n}\n\n목록 13-4: 불변 참조를 캡처하는 클로저 정의 및 호출\n이 예제는 또한 변수가 클로저 정의에 바인딩될 수 있고 나중에 변수 이름이 함수 이름인 것처럼 변수 이름과 괄호를 사용하여 클로저를 호출할 수 있음을 보여줍니다.\nlist에 대한 여러 불변 참조를 동시에 가질 수 있기 때문에 클로저 정의 이전, 클로저 정의 이후, 클로저 호출 전, 클로저 호출 이후 코드에서 여전히 list에 액세스할 수 있습니다. 이 코드는 다음을 컴파일, 실행 및 인쇄합니다.\n$ cargo run\n   Compiling closure-example v0.1.0 (file:///projects/closure-example)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.43s\n     Running `target/debug/closure-example`\nBefore defining closure: [1, 2, 3]\nBefore calling closure: [1, 2, 3]\nFrom closure: [1, 2, 3]\nAfter calling closure: [1, 2, 3]\n\n다음으로 목록 13-5에서 목록 벡터에 요소를 추가하도록 클로저 본문을 변경합니다. 클로저는 이제 변경 가능한 참조를 캡처합니다.\n파일 이름: src/main.rs\nfn main() {\n    let mut list = vec![1, 2, 3];\n    println!(`Before defining closure: {:?}`, list);\n\n    let mut borrows_mutably = || list.push(7);\n\n    borrows_mutably();\n    println!(`After calling closure: {:?}`, list);\n}\n\n목록 13-5: 변경 가능한 참조를 캡처하는 클로저 정의 및 호출\n이 코드는 다음을 컴파일, 실행 및 인쇄합니다.\n$ cargo run\n   Compiling closure-example v0.1.0 (file:///projects/closure-example)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.43s\n     Running `target/debug/closure-example`\nBefore defining closure: [1, 2, 3]\nAfter calling closure: [1, 2, 3, 7]\n\n더 이상 println! borrows_mutably 클로저의 정의와 호출 사이: borrows_mutably가 정의되면 list에 대한 가변 참조를 캡처합니다. 클로저가 호출된 후에는 클로저를 다시 사용하지 않으므로 가변 차용이 종료됩니다. 클로저 정의와 클로저 호출 사이에는 변경 가능한 차용이 있을 때 다른 차용이 허용되지 않기 때문에 인쇄할 변경 불가능한 차용이 허용되지 않습니다. println!을 추가해 보십시오. 어떤 오류 메시지가 표시되는지 확인하세요!\n클로저 본문에 소유권이 엄격하게 필요하지 않더라도 클로저가 환경에서 사용하는 값의 소유권을 갖도록 강제하려면 매개변수 목록 앞에 move 키워드를 사용할 수 있습니다.\n이 기법은 새 스레드가 데이터를 소유하도록 클로저를 새 스레드에 전달하여 데이터를 이동할 때 주로 유용합니다. 16장에서 동시성에 대해 이야기할 때 스레드와 스레드를 사용하려는 이유에 대해 자세히 설명하겠지만 지금은 이동 키워드가 필요한 클로저를 사용하여 새 스레드를 생성하는 방법을 간략하게 살펴보겠습니다. 목록 13-6은 주 스레드가 아닌 새 스레드에서 벡터를 인쇄하도록 수정된 목록 13-4를 보여줍니다.\n파일 이름: src/main.rs\nuse std::thread;\n\nfn main() {\n    let list = vec![1, 2, 3];\n    println!(`Before defining closure: {:?}`, list);\n\n    thread::spawn(move || println!(`From thread: {:?}`, list))\n        .join()\n        .unwrap();\n}\n\n목록 13-6: 이동을 사용하여 스레드가 목록의 소유권을 갖도록 강제 종료\n새 스레드를 생성하여 스레드가 인수로 실행할 클로저를 제공합니다. 클로저 본문은 목록을 출력합니다. 목록 13-4에서 클로저는 불변 참조를 사용하여 목록만 캡처했습니다. 목록을 인쇄하는 데 필요한 최소한의 액세스이기 때문입니다. 이 예에서 클로저 본문에는 여전히 불변 참조만 필요하지만 , 클로저 정의의 시작 부분에 move 키워드를 넣어 list가 클로저로 이동되도록 지정해야 합니다. 새 스레드는 나머지 메인 스레드가 완료되기 전에 완료되거나 메인 스레드가 완료될 수 있습니다. 첫째, 메인 스레드가 list의 소유권을 유지했지만 새 스레드가 list를 삭제하기 전에 종료된 경우 스레드의 불변 참조는 유효하지 않습니다. 컴파일러는 참조가 유효하도록 목록을 새 스레드에 지정된 클로저로 이동해야 합니다. move 키워드를 제거하거나 클로저가 정의된 후 메인 스레드에서 list를 사용하여 어떤 컴파일러 오류가 발생하는지 확인하십시오!\n클로저 및 Fn 특성에서 캡처된 값 이동\n클로저가 참조를 캡처하거나 클로저가 정의된 환경에서 값의 소유권을 캡처하면(따라서 클로저 로 이동되는 항목에 영향을 미침 ) 클로저 본문의 코드는 참조에 발생하는 작업을 정의합니다. 또는 클로저가 나중에 평가될 때의 값(따라서 클로저 밖으로 이동되는 항목에 영향을 미침 ). 클로저 본문은 다음 중 하나를 수행할 수 있습니다. 캡처된 값을 클로저 밖으로 이동, 캡처된 값을 변경, 값을 이동 또는 변경하지 않음, 시작하기 위해 환경에서 아무 것도 캡처하지 않음.\n클로저가 환경에서 값을 캡처하고 처리하는 방식은 클로저가 구현하는 특성에 영향을 미치며 특성은 함수와 구조체가 사용할 수 있는 클로저의 종류를 지정하는 방법입니다. 클로저는 클로저의 본문이 값을 처리하는 방식에 따라 추가 방식으로 이러한 Fn 특성 중 하나, 둘 또는 셋 모두를 자동으로 구현합니다.\n\nFnOnce는 한 번 호출할 수 있는 클로저에 적용됩니다. 모든 클로저가 호출될 수 있기 때문에 모든 클로저는 최소한 이 특성을 구현합니다. 캡처된 값을 본문 밖으로 옮기는 클로저는 한 번만 호출할 수 있기 때문에 FnOnce만 구현하고 다른 Fn 특성은 구현하지 않습니다.\nFnMut는 캡처된 값을 본문 밖으로 이동하지 않지만 캡처된 값을 변경할 수 있는 클로저에 적용됩니다. 이러한 클로저는 한 번 이상 호출될 수 있습니다.\nFn은 캡처된 값을 본문 밖으로 이동하지 않고 캡처된 값을 변경하지 않는 클로저와 환경에서 아무것도 캡처하지 않는 클로저에 적용됩니다. 이러한 클로저는 환경을 변경하지 않고 두 번 이상 호출할 수 있으며 이는 클로저를 동시에 여러 번 호출하는 것과 같은 경우에 중요합니다.\n\n옵션에서 unwrap_or_else 메서드의 정의를 살펴보겠습니다.` 우리가 Listing 13-1에서 사용한 것:\nimpl&lt;T&gt; Option&lt;T&gt; {\n    pub fn unwrap_or_else&lt;F&gt;(self, f: F) -&gt; T\n    where\n        F: FnOnce() -&gt; T\n    {\n        match self {\n            Some(x) =&gt; x,\n            None =&gt; f(),\n        }\n    }\n}\n\nT는 Option의 Some 변형에 있는 값의 유형을 나타내는 일반 유형임을 상기하십시오. 해당 유형 T는 unwrap_or_else 함수의 반환 유형이기도 합니다., 예를 들어 문자열`을 가져옵니다.\n다음으로 unwrap_or_else 함수에는 추가 일반 유형 매개변수 F가 있습니다. F 유형은 unwrap_or_else를 호출할 때 제공하는 클로저인 f라는 매개변수의 유형입니다.\n제네릭 유형 F에 지정된 특성 경계는 FnOnce() -&gt; T입니다. 즉, F는 한 번 호출할 수 있어야 하고 인수를 취하지 않고 T를 반환해야 합니다. 트레이트 바운드에서 FnOnce를 사용하면 unwrap_or_else가 최대 한 번만 f를 호출한다는 제약 조건을 나타냅니다. unwrap_or_else의 본문에서 Option이 Some인 경우 f가 호출되지 않는 것을 확인할 수 있습니다. Option이 None이면 f가 한 번 호출됩니다. 모든 클로저가 FnOnce를 구현하기 때문에 unwrap_or_else는 가장 다양한 종류의 클로저를 허용하고 최대한 유연합니다.\n\n참고: 함수는 세 가지 Fn 특성도 모두 구현할 수 있습니다. 우리가 하고 싶은 일이 환경에서 값을 캡처할 필요가 없다면 Fn 특성 중 하나를 구현하는 무언가가 필요한 클로저 대신 함수 이름을 사용할 수 있습니다. 예를 들어 Option&lt;Vec&gt; 값이 None이면 unwrap_or_else(Vec::new)를 호출하여 새로운 빈 벡터를 얻을 수 있습니다.\n\n이제 슬라이스에 정의된 표준 라이브러리 메서드 sort_by_key를 살펴보고 이것이 unwrap_or_else와 어떻게 다른지 그리고 sort_by_key가 특성 바인딩에 FnOnce 대신 FnMut을 사용하는 이유를 살펴보겠습니다. 클로저는 고려 중인 슬라이스의 현재 항목에 대한 참조 형식으로 하나의 인수를 가져오고 주문할 수 있는 K 유형의 값을 반환합니다. 이 기능은 각 항목의 특정 속성별로 조각을 정렬하려는 경우에 유용합니다. Listing 13-7에는 Rectangle 인스턴스 목록이 있고 sort_by_key를 사용하여 width 속성에 따라 낮은 값에서 높은 값으로 정렬합니다.\n파일 이름: src/main.rs\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let mut list = [\n        Rectangle { width: 10, height: 1 },\n        Rectangle { width: 3, height: 5 },\n        Rectangle { width: 7, height: 12 },\n    ];\n\n    list.sort_by_key(|r| r.width);\n    println!(`{:#?}`, list);\n}\n\n목록 13-7: sort_by_key를 사용하여 너비별로 사각형 정렬\n이 코드는 다음을 인쇄합니다.\n$ cargo run\n   Compiling rectangles v0.1.0 (file:///projects/rectangles)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.41s\n     Running `target/debug/rectangles`\n[\n    Rectangle {\n        width: 3,\n        height: 5,\n    },\n    Rectangle {\n        width: 7,\n        height: 12,\n    },\n    Rectangle {\n        width: 10,\n        height: 1,\n    },\n]\n\nsort_by_key가 FnMut 클로저를 취하도록 정의된 이유는 클로저를 슬라이스의 각 항목에 대해 한 번씩 여러 번 호출하기 때문입니다. 클로저 |r| r.width는 환경에서 아무것도 캡처, 변경 또는 이동하지 않으므로 특성 제한 요구 사항을 충족합니다.\n반대로 Listing 13-8은 FnOnce 특성만 구현하는 클로저의 예를 보여줍니다. 환경에서 값을 이동하기 때문입니다. 컴파일러는 sort_by_key와 함께 이 클로저를 사용하도록 허용하지 않습니다.\n파일 이름: src/main.rs\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let mut list = [\n        Rectangle { width: 10, height: 1 },\n        Rectangle { width: 3, height: 5 },\n        Rectangle { width: 7, height: 12 },\n    ];\n\n    let mut sort_operations = vec![];\n    let value = String::from(`by key called`);\n\n    list.sort_by_key(|r| {\n        sort_operations.push(value);\n        r.width\n    });\n    println!(`{:#?}`, list);\n}\n\n목록 13-8: sort_by_key와 함께 FnOnce 클로저 사용 시도\n이것은 목록을 정렬할 때 sort_by_key가 호출되는 횟수를 계산하기 위해 고안되고 복잡한 방법(작동하지 않음)입니다. 이 코드는 클로저 환경의 문자열인 value를 sort_operations 벡터로 푸시하여 이 계산을 시도합니다. 클로저는 value를 캡처한 다음 value의 소유권을 sort_operations 벡터로 전송하여 클로저 밖으로 value를 이동합니다. 이 클로저는 한 번만 호출할 수 있습니다. 두 번째로 호출하려고 하면 value가 더 이상 sort_operations로 다시 푸시되는 환경에 있지 않기 때문에 작동하지 않습니다! 따라서 이 클로저는 FnOnce만 구현합니다. 이 코드를 컴파일하려고 하면 value라는 오류가 발생합니다.\n$ cargo run\n   Compiling rectangles v0.1.0 (file:///projects/rectangles)\nerror[E0507]: cannot move out of `value`, a captured variable in an `FnMut` closure\n  --&gt; src/main.rs:18:30\n   |\n15 |     let value = String::from(`by key called`);\n   |         ----- captured outer variable\n16 |\n17 |     list.sort_by_key(|r| {\n   |                      --- captured by this `FnMut` closure\n18 |         sort_operations.push(value);\n   |                              ^^^^^ move occurs because `value` has type `String`, which does not implement the `Copy` trait\n\nFor more information about this error, try `rustc --explain E0507`.\nerror: could not compile `rectangles` due to previous error\n\n오류는 값을 환경 밖으로 이동시키는 클로저 본문의 라인을 가리킵니다. 이 문제를 해결하려면 값을 환경 밖으로 이동하지 않도록 클로저 본문을 변경해야 합니다. sort_by_key가 호출되는 횟수를 계산하려면 환경에 카운터를 유지하고 클로저 본문에서 해당 값을 증가시키는 것이 더 간단하게 계산할 수 있는 방법입니다. 목록 13-9의 클로저는 num_sort_operations 카운터에 대한 변경 가능한 참조만 캡처하므로 두 번 이상 호출될 수 있기 때문에 sort_by_key와 함께 작동합니다.\n파일 이름: src/main.rs\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let mut list = [\n        Rectangle { width: 10, height: 1 },\n        Rectangle { width: 3, height: 5 },\n        Rectangle { width: 7, height: 12 },\n    ];\n\n    let mut num_sort_operations = 0;\n    list.sort_by_key(|r| {\n        num_sort_operations += 1;\n        r.width\n    });\n    println!(`{:#?}, sorted in {num_sort_operations} operations`, list);\n}\n\n목록 13-9: sort_by_key와 함께 FnMut 클로저 사용이 허용됨\nFn 특성은 클로저를 사용하는 함수 또는 유형을 정의하거나 사용할 때 중요합니다. 다음 섹션에서는 반복자에 대해 설명합니다. 많은 반복자 메서드는 클로저 인수를 사용하므로 계속 진행하면서 이러한 클로저 세부 정보를 염두에 두십시오!\n\nIterator로 일련의 항목 처리\n반복자 패턴을 사용하면 일련의 항목에 대해 차례로 일부 작업을 수행할 수 있습니다. 반복자는 각 항목을 반복하고 시퀀스가 완료되는 시기를 결정하는 논리를 담당합니다. 반복자를 사용하면 해당 논리를 직접 다시 구현할 필요가 없습니다.\nRust에서 이터레이터는 게으르다 . 즉, 이터레이터를 소모하는 메서드를 호출하여 소진할 때까지 효과가 없습니다. 예를 들어 목록 13-10의 코드는 Vec에 정의된 iter 메서드를 호출하여 벡터 v1의 항목에 대한 반복자를 만듭니다.`. 이 코드 자체는 유용한 작업을 수행하지 않습니다.\n    let v1 = vec![1, 2, 3];\n\n    let v1_iter = v1.iter();\n\n목록 13-10: 이터레이터 만들기\n반복자는 v1_iter 변수에 저장됩니다. 반복자를 생성하면 다양한 방법으로 사용할 수 있습니다. 3장의 목록 3-5에서 for 루프를 사용하여 배열을 반복하여 각 항목에 대해 일부 코드를 실행했습니다. 내부적으로 이것은 암시적으로 반복자를 생성하고 소비했지만 지금까지 그것이 정확히 어떻게 작동하는지에 대해서는 얼버무렸습니다.\n목록 13-11의 예에서 for 루프에서 반복자의 사용과 반복자의 생성을 분리합니다. v1_iter의 반복자를 사용하여 for 루프를 호출하면 반복자의 각 요소가 각 값을 출력하는 루프의 한 반복에서 사용됩니다.\n    let v1 = vec![1, 2, 3];\n\n    let v1_iter = v1.iter();\n\n    for val in v1_iter {\n        println!(`Got: {}`, val);\n    }\n\nListing 13-11: for 루프에서 이터레이터 사용하기\n표준 라이브러리에서 제공하는 반복자가 없는 언어에서는 인덱스 0에서 변수를 시작하고 해당 변수를 사용하여 값을 얻기 위해 벡터로 인덱싱하고 루프에서 변수 값을 증가시키는 방식으로 이와 동일한 기능을 작성할 수 있습니다. 벡터의 총 항목 수에 도달할 때까지.\nIterator는 모든 논리를 처리하여 잠재적으로 엉망이 될 수 있는 반복 코드를 줄입니다. 반복자는 벡터와 같이 인덱싱할 수 있는 데이터 구조뿐만 아니라 다양한 종류의 시퀀스와 함께 동일한 논리를 사용할 수 있는 더 많은 유연성을 제공합니다. 이터레이터가 어떻게 하는지 살펴보겠습니다.\n반복자 특성 및 다음 방법\n모든 반복자는 표준 라이브러리에 정의된 반복자라는 특성을 구현합니다. 특성의 정의는 다음과 같습니다.\npub trait Iterator {\n    type Item;\n\n    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;\n\n    // methods with default implementations elided\n}\n\n이 정의는 type Item 및 Self::Item과 같은 몇 가지 새로운 구문을 사용하며 이 특성과 연관된 유형을 정의합니다. 19장에서 연관 유형에 대해 자세히 이야기하겠습니다. 지금은 이 코드에서 반복자 특성을 구현하려면 항목 유형도 정의해야 한다고 말하고 있고 이 항목 유형은 next 메서드의 반환 유형에 사용됩니다. 즉, 항목 유형은 반복자에서 반환된 유형이 됩니다.\n반복자 특성은 구현자가 하나의 메서드를 정의하기만 하면 됩니다. 다음 메서드는 Some으로 래핑된 반복자의 한 항목을 반환하고 반복이 끝나면 없음을 반환합니다.\n반복자에서 next 메서드를 직접 호출할 수 있습니다. 목록 13-12는 벡터에서 생성된 반복자에서 next에 대한 반복 호출에서 반환되는 값을 보여줍니다.\n파일 이름: src/lib.rs\n    #[test]\n    fn iterator_demonstration() {\n        let v1 = vec![1, 2, 3];\n\n        let mut v1_iter = v1.iter();\n\n        assert_eq!(v1_iter.next(), Some(&amp;1));\n        assert_eq!(v1_iter.next(), Some(&amp;2));\n        assert_eq!(v1_iter.next(), Some(&amp;3));\n        assert_eq!(v1_iter.next(), None);\n    }\n\nListing 13-12: 이터레이터에서 next 메소드 호출하기\n우리는 v1_iter를 변경 가능하게 만들어야 했습니다. 반복자에서 next 메서드를 호출하면 반복자가 시퀀스의 위치를 추적하는 데 사용하는 내부 상태가 변경됩니다. 즉, 이 코드는 iterator를 소비하거나 소모합니다. 다음을 호출할 때마다 반복자에서 항목을 먹습니다. for 루프를 사용할 때 v1_iter를 변경 가능하게 만들 필요가 없었습니다. 왜냐하면 루프가 v1_iter의 소유권을 가지고 뒤에서 변경 가능하게 만들었기 때문입니다.\n또한 next 호출에서 얻은 값은 벡터의 값에 대한 불변 참조입니다. iter 메서드는 불변 참조에 대한 반복자를 생성합니다. v1의 소유권을 갖고 소유한 값을 반환하는 반복자를 만들고 싶다면 iter 대신 into_iter를 호출할 수 있습니다. 마찬가지로 가변 참조를 반복하려면 iter 대신 iter_mut을 호출할 수 있습니다.\nIterator를 사용하는 메서드\n반복자 특성에는 표준 라이브러리에서 제공하는 기본 구현을 포함하는 다양한 메서드가 있습니다. 반복자 특성에 대한 표준 라이브러리 API 설명서를 보면 이러한 메서드에 대해 알아볼 수 있습니다. 이러한 메서드 중 일부는 정의에서 next 메서드를 호출하므로 Iterator 특성을 구현할 때 next 메서드를 구현해야 합니다.\nnext를 호출하는 메소드는 이를 호출하는 것이 반복자를 사용하기 때문에 소비 어댑터 라고 합니다. 한 가지 예는 반복자의 소유권을 가져오고 반복적으로 next를 호출하여 항목을 반복하여 반복자를 소비하는 sum 메서드입니다. 반복하면서 각 항목을 누적 합계에 추가하고 반복이 완료되면 합계를 반환합니다. 목록 13-13에는 sum 방법의 사용을 보여주는 테스트가 있습니다:\n파일 이름: src/lib.rs\n    #[test]\n    fn iterator_sum() {\n        let v1 = vec![1, 2, 3];\n\n        let v1_iter = v1.iter();\n\n        let total: i32 = v1_iter.sum();\n\n        assert_eq!(total, 6);\n    }\n\n목록 13-13: 반복자에 있는 모든 항목의 총계를 얻기 위해 sum 메서드 호출\nsum은 호출한 반복자의 소유권을 갖기 때문에 sum 호출 후에 v1_iter를 사용할 수 없습니다.\n다른 반복자를 생성하는 메서드\n반복자 어댑터는 반복자를 소비하지 않는 반복자 특성에 정의된 메서드입니다. 대신 원래 반복자의 일부 측면을 변경하여 다른 반복자를 생성합니다.\n목록 13-14는 항목이 반복될 때 각 항목을 호출하기 위해 클로저를 취하는 반복자 어댑터 메서드 map을 호출하는 예를 보여줍니다. map 메서드는 수정된 항목을 생성하는 새 반복자를 반환합니다. 여기서 클로저는 벡터의 각 항목이 1씩 증가하는 새 이터레이터를 만듭니다.\n파일 이름: src/main.rs\n    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];\n\n    v1.iter().map(|x| x + 1);\n\nListing 13-14: 새 반복자를 만들기 위해 반복자 어댑터 map 호출하기\n그러나 이 코드는 경고를 생성합니다.\n$ cargo run\n   Compiling iterators v0.1.0 (file:///projects/iterators)\nwarning: unused `Map` that must be used\n --&gt; src/main.rs:4:5\n  |\n4 |     v1.iter().map(|x| x + 1);\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: iterators are lazy and do nothing unless consumed\n  = note: `#[warn(unused_must_use)]` on by default\n\nwarning: `iterators` (bin `iterators`) generated 1 warning\n    Finished dev [unoptimized + debuginfo] target(s) in 0.47s\n     Running `target/debug/iterators`\n\n목록 13-14의 코드는 아무 것도 하지 않습니다. 우리가 지정한 클로저는 절대 호출되지 않습니다. 경고는 반복자 어댑터가 게으르고 여기에서 반복자를 소비해야 하는 이유를 상기시켜 줍니다.\n이 경고를 수정하고 반복자를 사용하기 위해 목록 12-1의 env::args와 함께 12장에서 사용한 collect 메서드를 사용합니다. 이 메서드는 반복자를 사용하고 결과 값을 컬렉션 데이터 형식으로 수집합니다.\nListing 13-15에서 map 호출에서 벡터로 반환된 반복자를 반복한 결과를 수집합니다. 이 벡터는 1씩 증가한 원래 벡터의 각 항목을 포함하게 됩니다.\n파일 이름: src/main.rs\n    let v1: Vec&lt;i32&gt; = vec![1, 2, 3];\n\n    let v2: Vec&lt;_&gt; = v1.iter().map(|x| x + 1).collect();\n\n    assert_eq!(v2, vec![2, 3, 4]);\n\n목록 13-15: map 메서드를 호출하여 새 반복자를 생성한 다음 collect 메서드를 호출하여 새 반복자를 소비하고 벡터를 생성\nmap은 클로저를 사용하기 때문에 각 항목에 대해 수행하려는 작업을 지정할 수 있습니다. 이것은 Iterator 특성이 제공하는 반복 동작을 재사용하면서 클로저를 통해 일부 동작을 사용자 정의할 수 있는 방법에 대한 좋은 예입니다.\n읽기 쉬운 방식으로 복잡한 작업을 수행하기 위해 반복자 어댑터에 대한 여러 호출을 연결할 수 있습니다. 그러나 모든 반복자는 게으르기 때문에 반복자 어댑터 호출에서 결과를 얻으려면 소비 어댑터 메서드 중 하나를 호출해야 합니다.\n환경을 캡처하는 클로저 사용\n많은 반복자 어댑터는 클로저를 인수로 사용하며 일반적으로 반복자 어댑터에 대한 인수로 지정하는 클로저는 해당 환경을 캡처하는 클로저입니다.\n이 예에서는 클로저를 사용하는 필터 메서드를 사용합니다. 클로저는 반복자에서 항목을 가져오고 부울을 반환합니다. 클로저가 true를 반환하면 값은 filter에 의해 생성된 반복에 포함됩니다. 클로저가 false를 반환하면 값이 포함되지 않습니다.\n목록 13-16에서 Shoe 구조체 인스턴스 컬렉션을 반복하기 위해 환경에서 shoe_size 변수를 캡처하는 클로저와 함께 filter를 사용합니다. 지정된 사이즈의 신발만 반환합니다.\n파일 이름: src/lib.rs\n#[derive(PartialEq, Debug)]\nstruct Shoe {\n    size: u32,\n    style: String,\n}\n\nfn shoes_in_size(shoes: Vec&lt;Shoe&gt;, shoe_size: u32) -&gt; Vec&lt;Shoe&gt; {\n    shoes.into_iter().filter(|s| s.size == shoe_size).collect()\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn filters_by_size() {\n        let shoes = vec![\n            Shoe {\n                size: 10,\n                style: String::from(`sneaker`),\n            },\n            Shoe {\n                size: 13,\n                style: String::from(`sandal`),\n            },\n            Shoe {\n                size: 10,\n                style: String::from(`boot`),\n            },\n        ];\n\n        let in_my_size = shoes_in_size(shoes, 10);\n\n        assert_eq!(\n            in_my_size,\n            vec![\n                Shoe {\n                    size: 10,\n                    style: String::from(`sneaker`)\n                },\n                Shoe {\n                    size: 10,\n                    style: String::from(`boot`)\n                },\n            ]\n        );\n    }\n}\n\n목록 13-16: shoe_size를 캡처하는 클로저와 함께 filter 메서드 사용\nshoes_in_size 함수는 신발 벡터와 신발 사이즈를 매개변수로 사용합니다. 지정된 크기의 신발만 포함하는 벡터를 반환합니다.\nshoes_in_size 본문에서 into_iter를 호출하여 벡터의 소유권을 갖는 이터레이터를 만듭니다. 그런 다음 filter를 호출하여 해당 반복자를 클로저가 true를 반환하는 요소만 포함하는 새 반복자로 조정합니다.\n클로저는 환경에서 shoe_size 매개변수를 캡처하고 지정된 크기의 신발만 유지하면서 각 신발의 크기와 값을 비교합니다. 마지막으로 collect를 호출하면 적응된 반복자가 반환한 값을 함수가 반환한 벡터로 수집합니다.\n테스트는 shoes_in_size를 호출할 때 지정한 값과 동일한 크기의 신발만 반환한다는 것을 보여줍니다.\n\nI/O 프로젝트 개선\n반복자에 대한 이 새로운 지식을 통해 반복자를 사용하여 코드의 위치를 보다 명확하고 간결하게 만들어 12장의 I/O 프로젝트를 개선할 수 있습니다. 반복자가 Config::build 기능과 검색 기능의 구현을 어떻게 개선할 수 있는지 살펴보겠습니다.\nIterator를 사용하여 복제본 제거\nListing 12-6에서 우리는 String 값의 슬라이스를 가져오고 슬라이스로 인덱싱하고 값을 복제하여 Config 구조체가 해당 값을 소유하도록 허용하여 Config 구조체의 인스턴스를 생성하는 코드를 추가했습니다. 목록 13-17에서 우리는 목록 12-23에서와 같이 Config::build 함수의 구현을 재현했습니다:\n파일 이름: src/lib.rs\nimpl Config {\n    pub fn build(args: &amp;[String]) -&gt; Result&lt;Config, &amp;`static str&gt; {\n        if args.len() &lt; 3 {\n            return Err(`not enough arguments`);\n        }\n\n        let query = args[1].clone();\n        let file_path = args[2].clone();\n\n        let ignore_case = env::var(`IGNORE_CASE`).is_ok();\n\n        Ok(Config {\n            query,\n            file_path,\n            ignore_case,\n        })\n    }\n}\n\nListing 13-17: Listing 12-23의 Config::build 함수 재현\n당시 우리는 비효율적인 복제 호출에 대해 걱정하지 말라고 했습니다. 나중에 제거할 것이기 때문입니다. 자, 그 때가 바로 지금입니다!\nargs 매개변수에 String 요소가 있는 슬라이스가 있지만 build 함수는 args를 소유하지 않기 때문에 여기에서 복제가 필요했습니다. Config 인스턴스의 소유권을 반환하려면 Config 인스턴스가 해당 값을 소유할 수 있도록 Config의 query 및 file_path 필드에서 값을 복제해야 했습니다.\n반복자에 대한 새로운 지식을 통해 슬라이스를 차용하는 대신 반복자의 소유권을 인수로 사용하도록 빌드 함수를 변경할 수 있습니다. 슬라이스의 길이를 확인하고 특정 위치로 인덱싱하는 코드 대신 반복기 기능을 사용합니다. 이터레이터가 값에 액세스하기 때문에 Config::build 함수가 수행하는 작업이 명확해집니다.\nConfig::build가 반복자의 소유권을 가져오고 빌린 인덱싱 작업 사용을 중지하면 복제를 호출하고 새 할당을 만드는 대신 반복자의 문자열 값을 Config로 이동할 수 있습니다.\n반환된 반복자를 직접 사용하기\n다음과 같은 I/O 프로젝트의 src/main.rs 파일을 엽니다.\n파일 이름: src/main.rs\nfn main() {\n    let args: Vec&lt;String&gt; = env::args().collect();\n\n    let config = Config::build(&amp;args).unwrap_or_else(|err| {\n        eprintln!(`Problem parsing arguments: {err}`);\n        process::exit(1);\n    });\n\n    // --snip--\n}\n\n우리는 먼저 Listing 12-24에 있는 main 함수의 시작을 Listing 13-18의 코드로 변경할 것입니다. 이번에는 이터레이터를 사용합니다. Config::build도 업데이트할 때까지 컴파일되지 않습니다.\n파일 이름: src/main.rs\nfn main() {\n    let config = Config::build(env::args()).unwrap_or_else(|err| {\n        eprintln!(`Problem parsing arguments: {err}`);\n        process::exit(1);\n    });\n\n    // --snip--\n}\n\n목록 13-18: env::args의 반환 값을 Config::build에 전달\nenv::args 함수는 이터레이터를 반환합니다! 반복자 값을 벡터로 수집한 다음 조각을 Config::build로 전달하는 대신 이제 env::args에서 반환된 반복자의 소유권을 Config::build로 직접 전달합니다.\n다음으로 Config::build 정의를 업데이트해야 합니다. I/O 프로젝트의 src/lib.rs 파일에서 Config::build의 서명을 목록 13-19처럼 보이도록 변경해 보겠습니다. 함수 본문을 업데이트해야 하므로 여전히 컴파일되지 않습니다.\n파일 이름: src/lib.rs\nimpl Config {\n    pub fn build(\n        mut args: impl Iterator&lt;Item = String&gt;,\n    ) -&gt; Result&lt;Config, &amp;`static str&gt; {\n        // --snip--\n\nListing 13-19: 반복자를 예상하도록 Config::build 서명 업데이트\nenv::args 함수에 대한 표준 라이브러리 문서는 이 함수가 반환하는 반복자의 유형이 std::env::Args이고 해당 유형이 Iterator 특성을 구현하고 문자열 값을 반환함을 보여줍니다.\nConfig::build 함수의 시그니처를 업데이트하여 args 매개변수가 &amp;[String] 대신 impl Iterator&lt;Item = String&gt; 특성 범위를 갖는 일반 유형을 가집니다. 10장의 매개 변수 [로서의 특성](https://doc.rust-lang.org/book/ch10-02-traits.html#traits-as-parameters)  섹션 에서 논의한 impl 특성 구문의 사용은 인자가 반복자 유형을 구현하고 문자열 항목을 반환하는 모든 유형이 될 수 있음을 의미합니다.\n우리는 args의 소유권을 갖고 그것을 반복함으로써 args를 변경하기 때문에 args 매개변수의 사양에 mut 키워드를 추가하여 변경할 수 있도록 할 수 있습니다.\n인덱싱 대신 반복자 특성 메서드 사용\n다음으로 Config::build의 본문을 수정합니다. args는 Iterator 특성을 구현하기 때문에 next 메서드를 호출할 수 있습니다! Listing 13-20은 Listing 12-23의 코드를 업데이트하여 next 메소드를 사용합니다:\n파일 이름: src/lib.rs\nimpl Config {\n    pub fn build(\n        mut args: impl Iterator&lt;Item = String&gt;,\n    ) -&gt; Result&lt;Config, &amp;`static str&gt; {\n        args.next();\n\n        let query = match args.next() {\n            Some(arg) =&gt; arg,\n            None =&gt; return Err(`Didn`t get a query string`),\n        };\n\n        let file_path = match args.next() {\n            Some(arg) =&gt; arg,\n            None =&gt; return Err(`Didn`t get a file path`),\n        };\n\n        let ignore_case = env::var(`IGNORE_CASE`).is_ok();\n\n        Ok(Config {\n            query,\n            file_path,\n            ignore_case,\n        })\n    }\n}\n\n목록 13-20: 반복자 메서드를 사용하도록 Config::build 본문 변경\nenv::args 반환 값의 첫 번째 값은 프로그램의 이름임을 기억하십시오. 우리는 이를 무시하고 다음 값으로 이동하기를 원하므로 먼저 next를 호출하고 반환 값으로 아무 작업도 수행하지 않습니다. 둘째, next를 호출하여 Config의 query 필드에 입력하려는 값을 가져옵니다. next가 Some을 반환하면 match를 사용하여 값을 추출합니다. None을 반환하면 충분한 인수가 제공되지 않았음을 의미하며 Err 값으로 일찍 반환됩니다. file_path 값에 대해 동일한 작업을 수행합니다.\n반복자 어댑터로 코드를 더 명확하게 만들기\n우리는 또한 I/O 프로젝트의 검색 기능에서 반복자를 활용할 수 있습니다. 이는 목록 12-19에서와 같이 여기 목록 13-21에 재현되어 있습니다.\n파일 이름: src/lib.rs\npub fn search&lt;`a&gt;(query: &amp;str, contents: &amp;`a str) -&gt; Vec&lt;&amp;`a str&gt; {\n    let mut results = Vec::new();\n\n    for line in contents.lines() {\n        if line.contains(query) {\n            results.push(line);\n        }\n    }\n\n    results\n}\n\nListing 13-21: Listing 12-19의 검색 기능 구현\n반복자 어댑터 메서드를 사용하여 이 코드를 보다 간결하게 작성할 수 있습니다. 이렇게 하면 변경 가능한 중간 결과 벡터를 사용하지 않아도 됩니다. 함수형 프로그래밍 스타일은 코드를 더 명확하게 만들기 위해 변경 가능한 상태의 양을 최소화하는 것을 선호합니다. 변경 가능한 상태를 제거하면 results 벡터에 대한 동시 액세스를 관리할 필요가 없기 때문에 검색이 병렬로 수행되도록 향후 개선이 가능할 수 있습니다. 목록 13-22는 이 변경 사항을 보여줍니다:\n파일 이름: src/lib.rs\npub fn search&lt;`a&gt;(query: &amp;str, contents: &amp;`a str) -&gt; Vec&lt;&amp;`a str&gt; {\n    contents\n        .lines()\n        .filter(|line| line.contains(query))\n        .collect()\n}\n\nListing 13-22: search 함수 구현에서 반복자 어댑터 메서드 사용\n검색 기능의 목적은 쿼리를 포함하는 내용의 모든 줄을 반환하는 것임을 상기하십시오. 목록 13-16의 필터 예제와 유사하게 이 코드는 line.contains(query)가 true를 반환하는 줄만 유지하기 위해 필터 어댑터를 사용합니다. 그런 다음 collect를 사용하여 일치하는 라인을 다른 벡터로 수집합니다. 훨씬 간단합니다! search_case_insensitive 함수에서도 반복자 메서드를 사용하도록 동일한 변경을 자유롭게 수행하십시오.\n루프 또는 반복자 중에서 선택\n다음 논리적 질문은 자신의 코드에서 어떤 스타일을 선택해야 하는지와 그 이유입니다: 목록 13-21의 원래 구현 또는 목록 13-22의 반복자를 사용하는 버전. 대부분의 Rust 프로그래머는 반복자 스타일을 선호합니다. 처음에는 요령을 터득하기가 조금 더 어렵지만 일단 다양한 반복자 어댑터와 그 역할에 대해 이해하고 나면 반복자를 이해하기가 더 쉬울 수 있습니다. 루프의 다양한 비트를 만지작거리고 새로운 벡터를 구축하는 대신 코드는 루프의 높은 수준의 목표에 초점을 맞춥니다. 이것은 일반적인 코드의 일부를 추상화하므로 반복자의 각 요소가 통과해야 하는 필터링 조건과 같이 이 코드에 고유한 개념을 더 쉽게 볼 수 있습니다.\n그러나 두 가지 구현이 정말 동일합니까? 직관적인 가정은 더 낮은 수준의 루프가 더 빠를 것이라는 것입니다. 성능에 대해 이야기합시다.\n\n성능 비교: 루프와 반복자\n루프 또는 반복기를 사용할지 여부를 결정하려면 어떤 구현이 더 빠른지 알아야 합니다. 명시적인 for 루프가 있는 검색 함수 버전 또는 반복자가 있는 버전입니다.\nArthur Conan Doyle 경의 Sherlock Holmes의 모험 전체 내용을 문자열로 로드 하고 내용에서 the라는 단어를 찾아 벤치마크를 실행했습니다. 다음은 for 루프를 사용하는 search 버전과 반복자를 사용하는 버전에 대한 벤치마크 결과입니다.\ntest bench_search_for  ... bench:  19,620,300 ns/iter (+/- 915,700)\ntest bench_search_iter ... bench:  19,234,900 ns/iter (+/- 657,200)\n\n반복자 버전이 약간 더 빠릅니다! 여기서는 벤치마크 코드에 대해 설명하지 않겠습니다. 요점은 두 버전이 동일하다는 것을 증명하는 것이 아니라 이러한 두 가지 구현이 성능 측면에서 어떻게 비교되는지에 대한 일반적인 이해를 얻는 것이기 때문입니다.\n보다 포괄적인 벤치마크를 위해 다양한 크기의 다양한 텍스트를 내용으로, 다양한 단어와 다양한 길이의 단어를 검색어로 사용하고 모든 종류의 기타 변형을 사용하여 확인해야 합니다. 요점은 이것입니다. 반복자는 상위 수준 추상화이지만 하위 수준 코드를 직접 작성한 것과 거의 동일한 코드로 컴파일됩니다. 반복자는 Rust의 제로 비용 추상화 중 하나입니다. 즉, 추상화를 사용하면 추가 런타임 오버헤드가 발생하지 않습니다. 이는 C++의 최초 설계자이자 구현자인 Bjarne Stroustrup이 Foundations of C++(2012)에서 제로 오버헤드를 정의한 방식과 유사합니다.\n\n일반적으로 C++ 구현은 제로 오버헤드 원칙을 따릅니다. 사용하지 않는 것은 비용을 지불하지 않습니다. 그리고 더 나아가, 당신이 사용하는 것을 손으로 더 잘 코딩할 수는 없습니다.\n\n또 다른 예로, 다음 코드는 오디오 디코더에서 가져온 것입니다. 디코딩 알고리즘은 선형 예측 수학 연산을 사용하여 이전 샘플의 선형 함수를 기반으로 미래 값을 추정합니다. 이 코드는 반복자 체인을 사용하여 범위의 세 가지 변수, 데이터의 버퍼 조각, 12개의 계수 배열 및 qlp_shift에서 데이터를 이동할 양에 대해 일부 수학을 수행합니다. 이 예제에서 변수를 선언했지만 값은 지정하지 않았습니다. 이 코드는 문맥 밖에서는 큰 의미가 없지만 Rust가 고수준 아이디어를 저수준 코드로 변환하는 방법에 대한 간결하고 실제적인 예입니다.\nlet buffer: &amp;mut [i32];\nlet coefficients: [i64; 12];\nlet qlp_shift: i16;\n\nfor i in 12..buffer.len() {\n    let prediction = coefficients.iter()\n                                 .zip(&amp;buffer[i - 12..i])\n                                 .map(|(&amp;c, &amp;s)| c * s as i64)\n                                 .sum::&lt;i64&gt;() &gt;&gt; qlp_shift;\n    let delta = buffer[i];\n    buffer[i] = prediction as i32 + delta;\n}\n\n예측 값을 계산하기 위해 이 코드는 coefficients의 12개 값 각각을 반복하고 zip 방법을 사용하여 buffer의 이전 12개 값과 계수 값을 쌍으로 만듭니다. 그런 다음 각 쌍에 대해 값을 함께 곱하고 모든 결과를 합한 다음 합계 qlp_shift 비트의 비트를 오른쪽으로 이동합니다.\n오디오 디코더와 같은 응용 프로그램의 계산은 종종 성능을 가장 높게 우선시합니다. 여기에서는 두 개의 어댑터를 사용하여 반복자를 만든 다음 값을 소비합니다. 이 Rust 코드는 어떤 어셈블리 코드로 컴파일됩니까? 글쎄, 이 글을 쓰는 시점에서 그것은 당신이 직접 작성한 것과 같은 어셈블리로 컴파일됩니다. 계수의 값에 대한 반복에 해당하는 루프가 전혀 없습니다. Rust는 12번의 반복이 있다는 것을 알고 있으므로 루프를 펼칩니다. 언롤링은 루프 제어 코드의 오버헤드를 제거하고 대신 루프의 각 반복에 대해 반복 코드를 생성하는 최적화입니다.\n모든 계수는 레지스터에 저장되므로 값에 액세스하는 것이 매우 빠릅니다. 런타임 시 배열 액세스에 대한 경계 검사가 없습니다. Rust가 적용할 수 있는 이러한 모든 최적화는 결과 코드를 매우 효율적으로 만듭니다. 이제 이것을 알았으니 두려움 없이 반복자와 클로저를 사용할 수 있습니다! 그들은 코드를 더 높은 수준으로 보이게 하지만 그렇게 한다고 해서 런타임 성능이 저하되지는 않습니다.\n요약\n클로저와 이터레이터는 함수형 프로그래밍 언어 아이디어에서 영감을 받은 Rust 기능입니다. 그들은 낮은 수준의 성능으로 높은 수준의 아이디어를 명확하게 표현하는 Rust의 기능에 기여합니다. 클로저와 반복자의 구현은 런타임 성능에 영향을 미치지 않습니다. 이것은 비용이 들지 않는 추상화를 제공하기 위해 노력하는 Rust의 목표의 일부입니다.\n이제 I/O 프로젝트의 표현력을 개선했으므로 프로젝트를 전 세계와 공유하는 데 도움이 되는 cargo의 몇 가지 기능을 더 살펴보겠습니다.\n\n14\nCargo 및 Crates.io에 대한 추가 정보\n지금까지 우리는 코드를 빌드, 실행 및 테스트하기 위해 Cargo의 가장 기본적인 기능만 사용했지만 훨씬 더 많은 일을 할 수 있습니다. 이 장에서는 다음을 수행하는 방법을 보여주는 다른 고급 기능에 대해 설명합니다.\n\n릴리스 프로필을 통해 빌드 사용자 지정\ncrates.io 에 라이브러리 게시\n작업 공간으로 대규모 프로젝트 구성\ncrates.io 에서 바이너리 설치\n사용자 지정 명령을 사용하여 Cargo 확장\n\nCargo는 이 장에서 다루는 기능보다 더 많은 기능을 수행할 수 있으므로 Cargo의 모든 기능에 대한 전체 설명은 설명서를 참조하십시오 .\n\n릴리스 프로필로 빌드 사용자 지정\nRust에서 릴리스 프로필은 프로그래머가 코드 컴파일을 위한 다양한 옵션을 더 잘 제어할 수 있도록 하는 다양한 구성을 가진 미리 정의되고 사용자 정의 가능한 프로필입니다. 각 프로필은 서로 독립적으로 구성됩니다.\nCargo에는 두 가지 주요 프로필이 있습니다. cargo build를 실행할 때 Cargo가 사용하는 dev 프로필과 cargo build --release를 실행할 때 Cargo가 사용하는 release 프로필입니다. dev 프로필은 개발에 적합한 기본값으로 정의되고 release 프로필은 릴리스 빌드에 적합한 기본값으로 정의됩니다.\n다음 프로필 이름은 빌드 출력에서 익숙할 수 있습니다.\n$ cargo build\n    Finished dev [unoptimized + debuginfo] target(s) in 0.0s\n$ cargo build --release\n    Finished release [optimized] target(s) in 0.0s\n\ndev와 release는 컴파일러에서 사용하는 서로 다른 프로필입니다.\nCargo는 [프로필을 명시적으로 추가하지 않았을 때 적용되는 각 프로필에 대한 기본 설정을 가지고 있습니다. *] 섹션을 프로젝트의 *Cargo.toml* 파일에 추가합니다. [profile.* ] 섹션에서 기본 설정의 하위 집합을 재정의합니다. 예를 들어 다음은 dev 및 release 프로필에 대한 opt-level 설정의 기본값입니다.\n파일 이름: Cargo.toml\n[profile.dev]\nopt-level = 0\n\n[profile.release]\nopt-level = 3\n\nopt-level 설정은 Rust가 코드에 적용할 최적화 수를 제어하며 범위는 0에서 3까지입니다. 더 많은 최적화를 적용하면 컴파일 시간이 연장되므로 개발 중이고 코드를 자주 컴파일하는 경우 결과 코드가 더 느리게 실행되더라도 더 적은 최적화를 통해 더 빨리 컴파일하기를 원합니다. 따라서 dev의 기본 opt-level은 0입니다. 코드를 릴리스할 준비가 되면 컴파일에 더 많은 시간을 할애하는 것이 가장 좋습니다. 릴리스 모드에서 한 번만 컴파일하지만 컴파일된 프로그램을 여러 번 실행하게 되므로 릴리스 모드는 더 빠르게 실행되는 코드를 위해 더 긴 컴파일 시간을 맞바꿉니다. 그렇기 때문에 릴리스 프로필의 기본 옵션 수준은 3입니다.\nCargo.toml 에 다른 값을 추가하여 기본 설정을 재정의할 수 있습니다. 예를 들어 개발 프로필에서 최적화 수준 1을 사용하려는 경우 프로젝트의 Cargo.toml 파일에 다음 두 줄을 추가할 수 있습니다.\n파일 이름: Cargo.toml\n[profile.dev]\nopt-level = 1\n\n이 코드는 기본 설정인 0을 재정의합니다. 이제 cargo build를 실행하면 Cargo는 dev 프로필의 기본값과 opt-level에 대한 사용자 정의를 사용합니다. opt-level을 1로 설정했기 때문에 Cargo는 기본값보다 더 많은 최적화를 적용하지만 릴리스 빌드 만큼은 아닙니다.\n구성 옵션의 전체 목록과 각 프로필의 기본값은 Cargo 문서를 참조하세요 .\n\nCrates.io에 크레이트 게시하기\n우리는 crates.io 의 패키지를 프로젝트의 종속성으로 사용했지만 자신의 패키지를 게시하여 다른 사람과 코드를 공유할 수도 있습니다. crates.io 의 크레이트 레지스트리는 패키지의 소스 코드를 배포하므로 주로 오픈 소스 코드를 호스팅합니다.\nRust 및 Cargo에는 게시된 패키지를 사람들이 더 쉽게 찾고 사용할 수 있도록 하는 기능이 있습니다. 다음에는 이러한 기능 중 일부에 대해 설명하고 패키지를 게시하는 방법에 대해 설명합니다.\n유용한 문서 주석 만들기\n패키지를 정확하게 문서화하면 다른 사용자가 패키지를 사용하는 방법과 시기를 알 수 있으므로 문서 작성에 시간을 투자할 가치가 있습니다. 3장에서 우리는 두 개의 슬래시 //를 사용하여 Rust 코드를 주석 처리하는 방법에 대해 논의했습니다. Rust는 또한 HTML 문서를 생성하는 문서 주석 으로 편리하게 알려진 문서에 대한 특정 종류의 주석을 가지고 있습니다. HTML은 크레이트 구현 방법이 아닌 크레이트 사용 방법에 관심이 있는 프로그래머를 위한 공개 API 항목에 대한 문서 주석 내용을 표시합니다.\n문서 주석은 2개가 아닌 3개의 슬래시 ///를 사용하며 텍스트 서식 지정을 위한 Markdown 표기법을 지원합니다. 문서화 중인 항목 바로 앞에 문서 주석을 배치합니다. 목록 14-1은 my_crate라는 크레이트의 add_one 함수에 대한 문서 주석을 보여줍니다.\n파일 이름: src/lib.rs\n/// Adds one to the number given.\n///\n/// # Examples\n///\n/// ```\n/// let arg = 5;\n/// let answer = my_crate::add_one(arg);\n///\n/// assert_eq!(6, answer);\n/// ```\npub fn add_one(x: i32) -&gt; i32 {\n    x + 1\n}\n\n목록 14-1: 함수에 대한 문서화 주석\n여기에서 add_one 함수가 수행하는 작업에 대한 설명을 제공하고 예제라는 제목으로 섹션을 시작한 다음 add_one 함수를 사용하는 방법을 보여주는 코드를 제공합니다. cargo doc를 실행하여 이 문서 주석에서 HTML 문서를 생성할 수 있습니다. 이 명령은 Rust와 함께 배포되는 rustdoc 도구를 실행하고 생성된 HTML 문서를 target/doc 디렉토리에 넣습니다.\n편의를 위해 cargo doc --open을 실행하면 현재 크레이트의 문서(크레이트의 모든 종속 항목에 대한 문서도 포함)에 대한 HTML을 빌드하고 웹 브라우저에서 결과를 엽니다. add_one 함수로 이동하면 그림 14-1과 같이 문서 주석의 텍스트가 어떻게 렌더링되는지 확인할 수 있습니다.\n\n그림 14-1: add_one 기능에 대한 HTML 문서\n일반적으로 사용되는 섹션\nListing 14-1에서 # Examples Markdown 제목을 사용하여 Examples라는 제목의 HTML 섹션을 만들었습니다. 크레이트 작성자가 문서에서 일반적으로 사용하는 다른 섹션은 다음과 같습니다.\n\nPanics : 문서화 중인 기능이 패닉할 수 있는 시나리오입니다. 프로그램 패닉을 원하지 않는 함수 호출자는 이러한 상황에서 함수를 호출하지 않도록 해야 합니다.\n오류 : 함수가 결과를 반환하는 경우 발생할 수 있는 오류 종류와 이러한 오류가 반환될 수 있는 조건을 설명하면 호출자가 다른 종류의 오류를 다른 방식으로 처리하는 코드를 작성할 수 있도록 도움이 될 수 있습니다.\n안전 : 함수가 호출하기에 안전하지 않은 경우(19장에서 안전하지 않음에 대해 설명함) 함수가 안전하지 않은 이유를 설명하고 함수가 호출자가 유지하기를 기대하는 불변성을 다루는 섹션이 있어야 합니다.\n\n대부분의 문서 주석에는 이러한 섹션이 모두 필요하지 않지만 이것은 사용자가 관심을 가질 코드 측면을 상기시키는 좋은 체크리스트입니다.\n테스트로서의 문서 주석\n문서 주석에 예제 코드 블록을 추가하면 라이브러리 사용 방법을 시연하는 데 도움이 될 수 있으며 추가 보너스가 있습니다. cargo test를 실행하면 문서의 코드 예제가 테스트로 실행됩니다! 예제가 있는 문서보다 더 좋은 것은 없습니다. 그러나 문서가 작성된 이후 코드가 변경되었기 때문에 작동하지 않는 예제보다 더 나쁜 것은 없습니다. Listing 14-1의 add_one 함수에 대한 문서와 함께 cargo test를 실행하면 테스트 결과에 다음과 같은 섹션이 표시됩니다.\n   Doc-tests my_crate\n\nrunning 1 test\ntest src/lib.rs - add_one (line 5) ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.27s\n\n이제 함수나 예제를 변경하면 assert_eq! 예제 패닉에서 cargo test를 다시 실행하면 문서 테스트가 예제와 코드가 서로 동기화되지 않은 것을 포착하는 것을 볼 수 있습니다!\n포함된 항목에 주석 달기\n문서 주석 //!의 스타일 주석 뒤에 오는 항목이 아니라 주석이 포함된 항목에 문서를 추가합니다. 우리는 일반적으로 크레이트 루트 파일( 협약에 따라 src/lib.rs ) 또는 모듈 내부에서 이러한 문서 주석을 사용하여 크레이트 또는 모듈 전체를 문서화합니다.\n예를 들어 add_one 기능이 포함된 my_crate 크레이트의 목적을 설명하는 문서를 추가하려면 //!로 시작하는 문서 주석을 추가합니다. 목록 14-2에 표시된 것처럼 src/lib.rs 파일 의 시작 부분에 :\n파일 이름: src/lib.rs\n//! # My Crate\n//!\n//! `my_crate` is a collection of utilities to make performing certain\n//! calculations more convenient.\n\n/// Adds one to the number given.\n// --snip--\n\n목록 14-2: my_crate 크레이트 전체에 대한 문서\n//!로 시작하는 마지막 줄 뒤에는 코드가 없습니다. //!로 주석을 시작했기 때문입니다. /// 대신 이 주석 뒤에 오는 항목이 아니라 이 주석이 포함된 항목을 문서화합니다. 이 경우 해당 항목은 크레이트 루트인 src/lib.rs 파일입니다. 이 주석은 전체 크레이트를 설명합니다.\ncargo doc --open을 실행하면 그림 14-2와 같이 크레이트의 공개 항목 목록 위에 있는 my_crate 문서의 첫 페이지에 이러한 주석이 표시됩니다.\n\n그림 14-2: 상자 전체를 설명하는 주석을 포함하여 my_crate에 대한 렌더링된 문서\n항목 내의 문서 주석은 특히 크레이트와 모듈을 설명하는 데 유용합니다. 사용자가 크레이트 구성을 이해하는 데 도움이 되도록 컨테이너의 전반적인 목적을 설명하는 데 사용하세요.\npub use로 편리한 공개 API 내보내기\n공개 API의 구조는 크레이트를 게시할 때 주요 고려 사항입니다. 당신의 상자를 사용하는 사람들은 당신보다 구조에 익숙하지 않으며 상자에 큰 모듈 계층이 있는 경우 사용하려는 조각을 찾는 데 어려움을 겪을 수 있습니다.\n7장에서 pub 키워드를 사용하여 항목을 공개하는 방법과 use 키워드를 사용하여 항목을 범위로 가져오는 방법을 다루었습니다. 그러나 크레이트를 개발하는 동안 이해하기 쉬운 구조가 사용자에게는 그다지 편리하지 않을 수 있습니다. 여러 수준을 포함하는 계층 구조에서 구조를 구성하려고 할 수 있지만 계층 구조 깊숙이 정의한 유형을 사용하려는 사람들은 해당 유형이 존재하는지 찾는 데 어려움을 겪을 수 있습니다. 또한 use my_crate::some_module::another_module::UsefulType;을 입력해야 하는 것에 짜증이 날 수도 있습니다. my_crate::UsefulType;을 사용하는 대신.\n좋은 소식은 다른 사람이 다른 라이브러리에서 구조를 사용하는 것이 편리 하지 않은 경우 내부 조직을 재정렬할 필요가 없다는 것입니다. 대신 항목을 다시 내보내 개인 구조와 다른 공용 구조를 만들 수 있습니다. 펍 사용을 사용하여. 다시 내보내기는 한 위치에서 공용 항목을 가져와 다른 위치에서 정의된 것처럼 다른 위치에서 공용으로 만듭니다.\n예를 들어 예술적 개념을 모델링하기 위해 art라는 이름의 라이브러리를 만들었다고 가정합니다. 이 라이브러리에는 두 개의 모듈이 있습니다. PrimaryColor와 SecondaryColor라는 두 개의 열거형을 포함하는 kinds 모듈과 mix라는 함수를 포함하는 utils 모듈입니다. 목록 14-3에 나와 있습니다.\n파일 이름: src/lib.rs\n//! # Art\n//!\n//! A library for modeling artistic concepts.\n\npub mod kinds {\n    /// The primary colors according to the RYB color model.\n    pub enum PrimaryColor {\n        Red,\n        Yellow,\n        Blue,\n    }\n\n    /// The secondary colors according to the RYB color model.\n    pub enum SecondaryColor {\n        Orange,\n        Green,\n        Purple,\n    }\n}\n\npub mod utils {\n    use crate::kinds::*;\n\n    /// Combines two primary colors in equal amounts to create\n    /// a secondary color.\n    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -&gt; SecondaryColor {\n        // --snip--\n    }\n}\n\n목록 14-3: kinds 및 utils 모듈로 구성된 항목이 있는 art 라이브러리\n그림 14-3은 cargo doc에 의해 생성된 이 상자에 대한 문서의 첫 페이지가 어떻게 생겼는지 보여줍니다.\n\n그림 14-3: kinds 및 utils 모듈을 나열하는 art 문서의 첫 페이지\nPrimaryColor 및 SecondaryColor 유형은 첫 페이지에 나열되지 않으며 mix 기능도 없습니다. 종류와 유틸을 클릭해야 볼 수 있습니다.\n이 라이브러리에 의존하는 또 다른 크레이트는 현재 정의된 모듈 구조를 지정하여 art의 항목을 범위로 가져오는 use 문이 필요합니다. 목록 14-4는 art 크레이트의 PrimaryColor 및 mix 항목을 사용하는 크레이트의 예를 보여줍니다:\n파일 이름: src/main.rs\nuse art::kinds::PrimaryColor;\nuse art::utils::mix;\n\nfn main() {\n    let red = PrimaryColor::Red;\n    let yellow = PrimaryColor::Yellow;\n    mix(red, yellow);\n}\n\n목록 14-4: 내부 구조를 내보낸 art 크레이트의 항목을 사용하는 크레이트\nart 크레이트를 사용하는 목록 14-4의 코드 작성자는 PrimaryColor가 kinds 모듈에 있고 mix가 utils 모듈에 있음을 알아내야 했습니다. art 크레이트의 모듈 구조는 art 크레이트를 사용하는 개발자보다 art 크레이트에서 작업하는 개발자와 더 관련이 있습니다. 내부 구조는 아트 크레이트를 사용하는 방법을 이해하려는 사람에게 유용한 정보를 포함하지 않고 오히려 혼란을 야기합니다. 왜냐하면 이를 사용하는 개발자는 어디를 봐야 하는지 파악해야 하고 모듈 이름을  사용 문.\n공개 API에서 내부 조직을 제거하기 위해 Listing 14-3의 art 크레이트 코드를 수정하여 Listing 14-5와 같이 최상위 수준에서 항목을 다시 내보내는 pub use 문을 추가할 수 있습니다.\n파일 이름: src/lib.rs\n//! # Art\n//!\n//! A library for modeling artistic concepts.\n\npub use self::kinds::PrimaryColor;\npub use self::kinds::SecondaryColor;\npub use self::utils::mix;\n\npub mod kinds {\n    // --snip--\n}\n\npub mod utils {\n    // --snip--\n}\n\n목록 14-5: 항목을 다시 내보내는 데 pub use 문 추가\ncargo doc이 이 크레이트에 대해 생성하는 API 문서는 이제 그림 14-4와 같이 첫 페이지에 재수출을 나열하고 링크하여 PrimaryColor 및 SecondaryColor 유형과 mix 기능을 더 쉽게 만듭니다. 찾다.\n\n그림 14-4: 재수출을 나열한 art 문서의 첫 페이지\nart 크레이트 사용자는 여전히 Listing 14-4에서 보여지는 것처럼 Listing 14-3의 내부 구조를 보고 사용할 수 있거나 Listing 14-6에서 보여지는 것처럼 Listing 14-5에서 더 편리한 구조를 사용할 수 있습니다:\n파일 이름: src/main.rs\nuse art::mix;\nuse art::PrimaryColor;\n\nfn main() {\n    // --snip--\n}\n\n목록 14-6: art 크레이트에서 다시 내보낸 항목을 사용하는 프로그램\n중첩된 모듈이 많은 경우 pub use를 사용하여 최상위 수준에서 유형을 다시 내보내면 크레이트를 사용하는 사람들의 경험에 상당한 차이를 만들 수 있습니다. pub use의 또 다른 일반적인 용도는 해당 크레이트의 정의를 크레이트의 공개 API의 일부로 만들기 위해 현재 크레이트의 종속성 정의를 다시 내보내는 것입니다.\n유용한 공개 API 구조를 만드는 것은 과학이라기보다는 예술에 가깝고 사용자에게 가장 적합한 API를 찾기 위해 반복할 수 있습니다. pub use를 선택하면 크레이트를 내부적으로 구성하는 방법에 유연성을 제공하고 내부 구조를 사용자에게 제공하는 것과 분리합니다. 내부 구조가 공개 API와 다른지 확인하려면 설치한 크레이트 코드를 살펴보세요.\nCrates.io 계정 설정\n크레이트를 게시하려면 crates.io 에서 계정을 만들고 API 토큰을 받아야 합니다. 그렇게 하려면 crates.io 홈페이지를 방문하여 GitHub 계정을 통해 로그인하십시오. (GitHub 계정은 현재 요구 사항이지만 사이트는 향후 계정을 만드는 다른 방법을 지원할 수 있습니다.) 로그인한 후 https://crates.io/me/에서 계정 설정을 방문하여 계정을 검색하십시오. API 키. 그런 다음 API 키를 사용하여 다음과 같이 cargo login 명령을 실행합니다.\n$ cargo login abcdefghijklmnopqrstuvwxyz012345\n\n이 명령은 API 토큰을 Cargo에 알리고 ~/.cargo/credentials 에 로컬로 저장합니다. 이 토큰은 비밀 입니다. 다른 사람과 공유하지 마십시오. 어떤 이유로든 다른 사람과 공유하는 경우 이를 취소하고 crates.io 에서 새 토큰을 생성해야 합니다.\n새 크레이트에 메타데이터 추가\n게시하려는 크레이트가 있다고 가정해 보겠습니다. 게시하기 전에 크레이트 Cargo.toml 파일 의 [패키지] 섹션에 일부 메타데이터를 추가해야 합니다.\n상자에는 고유한 이름이 필요합니다. 로컬에서 크레이트 작업을 하는 동안 크레이트 이름을 원하는 대로 지정할 수 있습니다. 그러나 crates.io 의 크레이트 이름은 선착순으로 할당됩니다. 크레이트 이름이 지정되면 아무도 해당 이름으로 크레이트를 게시할 수 없습니다. 크레이트 게시를 시도하기 전에 사용하려는 이름을 검색하세요. 이름이 사용된 경우 다른 이름을 찾아 [패키지] 섹션 아래의 Cargo.toml 파일에서 이름 필드를 편집하여 다음과 같이 게시에 새 이름을 사용해야 합니다.\n파일 이름: Cargo.toml\n[package]\nname = `guessing_game`\n\n고유한 이름을 선택했더라도 이 시점에서 크레이트를 게시하기 위해 cargo publish를 실행하면 경고가 표시된 다음 오류가 표시됩니다.\n$ cargo publish\n    Updating crates.io index\nwarning: manifest has no description, license, license-file, documentation, homepage or repository.\nSee https://doc.rust-lang.org/cargo/reference/manifest.html#package-metadata for more info.\n--snip--\nerror: failed to publish to registry at https://crates.io\n\nCaused by:\n  the remote server responded with an error: missing or empty metadata fields: description, license. Please see https://doc.rust-lang.org/cargo/reference/manifest.html for how to upload metadata\n\n이 오류는 몇 가지 중요한 정보를 누락했기 때문에 발생합니다. 사람들이 상자의 기능과 사용할 수 있는 조건을 알 수 있도록 설명과 라이선스가 필요합니다. Cargo.toml 에서 검색 결과에 크레이트와 함께 표시될 것이기 때문에 한 두 문장에 불과한 설명을 추가하십시오. 라이센스 필드의 경우 라이센스 식별자 값을 제공해야 합니다. Linux Foundation의 소프트웨어 패키지 데이터 Exchange(SPDX)는 이 값에 사용할 수 있는 식별자를 나열합니다. 예를 들어 MIT 라이선스를 사용하여 상자에 라이선스를 부여했음을 지정하려면 MIT 식별자를 추가합니다.\n파일 이름: Cargo.toml\n[package]\nname = `guessing_game`\nlicense = `MIT`\n\nSPDX에 표시되지 않는 라이선스를 사용하려면 해당 라이선스의 텍스트를 파일에 넣고 프로젝트에 파일을 포함시킨 다음 license-file을 사용하여 해당 라이선스의 이름을 지정해야 합니다. 라이센스 키를 사용하는 대신 파일.\n귀하의 프로젝트에 적합한 라이선스에 대한 지침은 이 책의 범위를 벗어납니다. Rust 커뮤니티의 많은 사람들은 MIT OR Apache-2.0의 이중 라이선스를 사용하여 Rust와 동일한 방식으로 프로젝트에 라이선스를 부여합니다. 이 방법은 OR로 구분된 여러 라이센스 식별자를 지정하여 프로젝트에 대한 여러 라이센스를 가질 수도 있음을 보여줍니다.\n고유한 이름, 버전, 설명 및 라이선스가 추가된 경우 게시할 준비가 된 프로젝트의 Cargo.toml 파일은 다음과 같습니다.\n파일 이름: Cargo.toml\n[package]\nname = `guessing_game`\nversion = `0.1.0`\nedition = `2021`\ndescription = `A fun game where you guess what number the computer has chosen.`\nlicense = `MIT OR Apache-2.0`\n\n[dependencies]\n\nCargo의 문서는 다른 사람들이 크레이트를 더 쉽게 발견하고 사용할 수 있도록 지정할 수 있는 다른 메타데이터에 대해 설명합니다.\nCrates.io에 게시\n이제 계정을 만들고 API 토큰을 저장하고 크레이트 이름을 선택하고 필수 메타데이터를 지정했으므로 게시할 준비가 되었습니다! 크레이트를 게시하면 다른 사람들이 사용할 수 있도록 crates.io 에 특정 버전이 업로드됩니다.\n게시는 영구적 이므로 주의하십시오 . 버전을 덮어쓸 수 없으며 코드를 삭제할 수 없습니다. crates.io 의 주요 목표 중 하나는 영구 코드 아카이브 역할을 하여 crates.io 의 크레이트에 의존하는 모든 프로젝트의 빌드가 계속 작동하도록 하는 것입니다. 버전 삭제를 허용하면 해당 목표를 달성할 수 없게 됩니다. 그러나 게시할 수 있는 크레이트 버전의 수에는 제한이 없습니다.\ncargo publish 명령을 다시 실행하십시오. 이제 성공해야 합니다.\n$ cargo publish\n    Updating crates.io index\n   Packaging guessing_game v0.1.0 (file:///projects/guessing_game)\n   Verifying guessing_game v0.1.0 (file:///projects/guessing_game)\n   Compiling guessing_game v0.1.0\n(file:///projects/guessing_game/target/package/guessing_game-0.1.0)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.19s\n   Uploading guessing_game v0.1.0 (file:///projects/guessing_game)\n\n축하해요! 이제 당신의 코드를 Rust 커뮤니티와 공유했고 누구나 쉽게 크레이트를 프로젝트의 의존성으로 추가할 수 있습니다.\n기존 크레이트의 새 버전 게시\n크레이트를 변경하고 새 버전을 출시할 준비가 되면 Cargo.toml 파일에 지정된 버전 값을 변경하고 다시 게시합니다. Semantic Versioning 규칙을 사용하여 수행한 변경 종류에 따라 적절한 다음 버전 번호를 결정합니다. 그런 다음 cargo publish를 실행하여 새 버전을 업로드합니다.\ncargo yank가 포함된 Crates.io 버전 사용 중단\n크레이트의 이전 버전을 제거할 수는 없지만 향후 프로젝트에서 크레이트를 새 종속성으로 추가하는 것을 방지할 수 있습니다. 이것은 이런저런 이유로 크레이트 버전이 깨졌을 때 유용합니다. 이러한 상황에서 Cargo는 크레이트 버전 끌어오기를 지원합니다.\n버전을 제거하면 새 프로젝트가 해당 버전에 의존하는 것을 방지하는 동시에 해당 버전에 의존하는 모든 기존 프로젝트를 계속할 수 있습니다. 기본적으로 복사는 Cargo.lock 이 있는 모든 프로젝트가 중단되지 않으며 향후 생성되는 모든 Cargo.lock 파일이 복사된 버전을 사용하지 않음을 의미합니다.\n크레이트 버전을 가져오려면 이전에 게시한 크레이트의 디렉토리에서 cargo yank를 실행하고 가져오려는 버전을 지정합니다. 예를 들어 guessing_game 버전 1.0.1이라는 이름의 크레이트를 게시하고 guessing_game의 프로젝트 디렉토리에서 이를 제거하려는 경우 다음을 실행합니다.\n$ cargo yank --vers 1.0.1\n    Updating crates.io index\n        Yank guessing_game@1.0.1\n\n명령에 --undo를 추가하면 끌어오기를 실행 취소하고 버전에 따라 프로젝트를 다시 시작할 수 있습니다.\n$ cargo yank --vers 1.0.1 --undo\n    Updating crates.io index\n      Unyank guessing_game@1.0.1\n\n잡아당기기는 어떤 코드도 삭제 하지 않습니다. 예를 들어 실수로 업로드된 비밀은 삭제할 수 없습니다. 그런 일이 발생하면 해당 암호를 즉시 재설정해야 합니다.\n\n화물 작업 공간\n12장에서 우리는 바이너리 크레이트와 라이브러리 크레이트를 포함하는 패키지를 만들었습니다. 프로젝트가 진행됨에 따라 라이브러리 크레이트가 계속 커지고 패키지를 여러 라이브러리 크레이트로 더 분할하고 싶을 수 있습니다. Cargo는 함께 개발된 여러 관련 패키지를 관리하는 데 도움이 되는 작업 공간 이라는 기능을 제공합니다.\n작업 공간 만들기\n작업 공간 은 동일한 Cargo.lock 및 출력 디렉토리를 공유하는 패키지 세트입니다. 작업 공간을 사용하여 프로젝트를 만들어 봅시다. 작업 공간의 구조에 집중할 수 있도록 간단한 코드를 사용할 것입니다. 작업 공간을 구성하는 방법은 여러 가지가 있으므로 일반적인 방법 하나만 보여드리겠습니다. 바이너리와 두 개의 라이브러리가 포함된 작업 공간이 있습니다. 주요 기능을 제공할 바이너리는 두 라이브러리에 따라 달라집니다. 하나 라이브러리는 add_one 기능을 제공하고 두 번째 라이브러리는 add_two 기능을 제공합니다. 이 세 크레이트는 동일한 작업 공간의 일부가 됩니다. 작업 공간을 위한 새 디렉토리를 생성하여 시작하겠습니다.\n$ mkdir add\n$ cd add\n\n다음으로 add 디렉토리에서 전체 작업 공간을 구성할 Cargo.toml 파일을 생성합니다. 이 파일에는 [패키지] 섹션이 없습니다. 대신 바이너리 크레이트가 있는 패키지 경로를 지정하여 작업 공간에 구성원을 추가할 수 있는 [workspace] 섹션으로 시작합니다. 이 경우 해당 경로는 adder 입니다.\n파일 이름: Cargo.toml\n[workspace]\n\nmembers = [\n    `adder`,\n]\n\n다음으로 add 디렉토리 내에서 cargo new를 실행하여 adder 바이너리 크레이트를 생성합니다.\n$ cargo new adder\n     Created binary (application) `adder` package\n\n이 시점에서 cargo build를 실행하여 작업 공간을 빌드할 수 있습니다. 추가 디렉토리 의 파일은 다음과 같아야 합니다.\n├── Cargo.lock\n├── Cargo.toml\n├── adder\n│   ├── Cargo.toml\n│   └── src\n│       └── main.rs\n└── target\n\n작업공간에는 컴파일된 아티팩트가 배치될 최상위 레벨에 하나의 대상 디렉토리가 있습니다. adder 패키지에는 자체 대상 디렉토리 가 없습니다. adder 디렉토리 내부에서 cargo build를 실행하더라도 컴파일된 아티팩트는 여전히 add/adder/target 이 아닌 add / target 으로 끝납니다. Cargo 는 작업 공간의 상자가 서로 의존하기 때문에 작업 공간의 대상 디렉토리를 이와 같이 구성합니다. 각 크레이트에 자체 대상 디렉토리가 있는 경우 각 크레이트는 자체 대상 에 아티팩트를 배치하기 위해 작업 공간의 다른 각 크레이트를 다시 컴파일해야 합니다.예배 규칙서. 하나 의 대상 디렉토리를 공유함으로써 크레이트는 불필요한 재구축을 피할 수 있습니다.\n작업 공간에서 두 번째 패키지 만들기\n다음으로 작업 공간에 다른 구성원 패키지를 만들고 이름을 add_one으로 지정하겠습니다. 최상위 Cargo.toml을 변경하여 구성원 목록에서 add_one 경로를 지정합니다.\n파일 이름: Cargo.toml\n[workspace]\n\nmembers = [\n    `adder`,\n    `add_one`,\n]\n\n그런 다음 add_one이라는 새 라이브러리 크레이트를 생성합니다.\n$ cargo new add_one --lib\n     Created library `add_one` package\n\n이제 추가 디렉토리 에 다음 디렉토리와 파일이 있어야 합니다.\n├── Cargo.lock\n├── Cargo.toml\n├── add_one\n│   ├── Cargo.toml\n│   └── src\n│       └── lib.rs\n├── adder\n│   ├── Cargo.toml\n│   └── src\n│       └── main.rs\n└── target\n\nadd_one/src/lib.rs 파일 에서 add_one 함수를 추가해 보겠습니다.\n파일 이름: add_one/src/lib.rs\npub fn add_one(x: i32) -&gt; i32 {\n    x + 1\n}\n\n이제 라이브러리가 있는 add_one 패키지에 의존하는 바이너리가 포함된 adder 패키지를 가질 수 있습니다. 먼저 adder/Cargo.toml 에 add_one에 대한 경로 종속성을 추가해야 합니다.\n파일 이름: adder/Cargo.toml\n[dependencies]\nadd_one = { path = `../add_one` }\n\nCargo는 작업 공간의 크레이트가 서로 의존할 것이라고 가정하지 않으므로 종속 관계에 대해 명시적으로 설명해야 합니다.\n다음으로, adder 크레이트에서 add_one 함수(add_one 크레이트에서)를 사용합시다. adder/src/main.rs 파일을 열고 상단에 use 줄을 추가하여 새로운 add_one 라이브러리 크레이트를 범위로 가져옵니다. 그런 다음 Listing 14-7과 같이 main 함수를 add_one 함수를 호출하도록 변경합니다.\n파일 이름: adder/src/main.rs\nuse add_one;\n\nfn main() {\n    let num = 10;\n    println!(`Hello, world! {num} plus one is {}!`, add_one::add_one(num));\n}\n\nListing 14-7: adder 크레이트에서 add_one 라이브러리 크레이트 사용하기\n최상위 add 디렉토리에서 cargo build를 실행하여 워크스페이스를 빌드하자!\n$ cargo build\n   Compiling add_one v0.1.0 (file:///projects/add/add_one)\n   Compiling adder v0.1.0 (file:///projects/add/adder)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.68s\n\nadd 디렉토리 에서 바이너리 크레이트를 실행하려면 -p 인수와 cargo run이 포함된 패키지 이름을 사용하여 작업 공간에서 실행할 패키지를 지정할 수 있습니다.\n$ cargo run -p adder\n    Finished dev [unoptimized + debuginfo] target(s) in 0.0s\n     Running `target/debug/adder`\nHello, world! 10 plus one is 11!\n\nadd_one 크레이트에 의존하는 adder/src/main.rs 의 코드를 실행합니다.\n작업 공간의 외부 패키지에 따라\n작업공간에는 각 크레이트의 디렉토리에 Cargo.lock이 있는 대신 최상위 수준에 Cargo.lock 파일이 하나만 있습니다. 이렇게 하면 모든 크레이트가 동일한 버전의 모든 종속성을 사용하게 됩니다. rand 패키지를 adder/Cargo.toml 및 add_one/Cargo.toml 파일 에 추가하면 Cargo는 이 두 가지를 하나의 rand 버전으로 해석하고 하나의 Cargo.lock 에 기록합니다. 작업 공간의 모든 크레이트가 동일한 종속성을 사용하도록 하면 크레이트가 항상 서로 호환됩니다. add_one/Cargo.toml 파일 의 [dependencies] 섹션에 rand 크레이트를 추가하여 add_one 크레이트에서 rand 크레이트를 사용할 수 있도록 합시다:\n파일 이름: add_one/Cargo.toml\n[dependencies]\nrand = `0.8.5`\n\n이제 use rand;를 추가할 수 있습니다. add_one/src/lib.rs 파일 에 추가 하고 add 디렉터리 에서 cargo build를 실행하여 전체 작업 공간을 빌드하면 rand 크레이트를 가져와 컴파일합니다. 우리는 우리가 범위로 가져온 rand를 참조하지 않기 때문에 한 가지 경고를 받게 됩니다.\n$ cargo build\n    Updating crates.io index\n  Downloaded rand v0.8.5\n   --snip--\n   Compiling rand v0.8.5\n   Compiling add_one v0.1.0 (file:///projects/add/add_one)\nwarning: unused import: `rand`\n --&gt; add_one/src/lib.rs:1:5\n  |\n1 | use rand;\n  |     ^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nwarning: `add_one` (lib) generated 1 warning\n   Compiling adder v0.1.0 (file:///projects/add/adder)\n    Finished dev [unoptimized + debuginfo] target(s) in 10.18s\n\n최상위 Cargo.lock은 이제 rand에 대한 add_one의 종속성에 대한 정보를 포함합니다. 그러나 rand가 작업 공간 어딘가에서 사용되더라도 Cargo.toml 파일에도 rand를 추가하지 않는 한 작업 공간의 다른 크레이트에서 사용할 수 없습니다. 예를 들어 use rand;를 추가하면 adder 패키지의 adder/src/main.rs 파일 에 오류가 발생합니다.\n$ cargo build\n  --snip--\n   Compiling adder v0.1.0 (file:///projects/add/adder)\nerror[E0432]: unresolved import `rand`\n --&gt; adder/src/main.rs:2:5\n  |\n2 | use rand;\n  |     ^^^^ no external crate `rand`\n\n이 문제를 해결하려면 adder 패키지에 대한 Cargo.toml 파일을 편집하고 rand도 이에 대한 종속성을 나타내십시오. adder 패키지를 빌드하면 Cargo.lock 의 adder 종속성 목록에 rand가 추가되지만 rand의 추가 사본은 다운로드되지 않습니다. Cargo는 rand 패키지를 사용하는 작업공간의 모든 패키지에 있는 모든 크레이트가 동일한 버전을 사용하도록 보장하여 공간을 절약하고 작업공간의 크레이트가 서로 호환되도록 합니다.\n작업 공간에 테스트 추가\n또 다른 향상을 위해 add_one 크레이트 내에 add_one::add_one 함수 테스트를 추가해 보겠습니다.\n파일 이름: add_one/src/lib.rs\npub fn add_one(x: i32) -&gt; i32 {\n    x + 1\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn it_works() {\n        assert_eq!(3, add_one(2));\n    }\n}\n\n이제 최상위 추가 디렉토리에서 cargo test를 실행하십시오. 다음과 같이 구성된 작업 공간에서 화물 테스트를 실행하면 작업 공간의 모든 상자에 대한 테스트가 실행됩니다.\n$ cargo test\n   Compiling add_one v0.1.0 (file:///projects/add/add_one)\n   Compiling adder v0.1.0 (file:///projects/add/adder)\n    Finished test [unoptimized + debuginfo] target(s) in 0.27s\n     Running unittests src/lib.rs (target/debug/deps/add_one-f0253159197f7841)\n\nrunning 1 test\ntest tests::it_works ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n     Running unittests src/main.rs (target/debug/deps/adder-49979ff40686fa8e)\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests add_one\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n출력의 첫 번째 섹션은 add_one 크레이트의 it_works 테스트가 통과되었음을 보여줍니다. 다음 섹션에서는 adder 크레이트에서 0개의 테스트가 발견되었음을 보여주고 마지막 섹션에서는 add_one 크레이트에서 0개의 문서 테스트가 발견되었음을 보여줍니다.\n또한 -p 플래그를 사용하고 테스트하려는 크레이트의 이름을 지정하여 최상위 디렉터리의 작업 공간에서 특정 크레이트 하나에 대한 테스트를 실행할 수 있습니다.\n$ cargo test -p add_one\n    Finished test [unoptimized + debuginfo] target(s) in 0.00s\n     Running unittests src/lib.rs (target/debug/deps/add_one-b3235fea9a156f74)\n\nrunning 1 test\ntest tests::it_works ... ok\n\ntest result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n   Doc-tests add_one\n\nrunning 0 tests\n\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\n이 출력은 cargo test가 add_one 크레이트에 대한 테스트만 실행했고 adder 크레이트 테스트는 실행하지 않았음을 보여줍니다.\n작업 공간의 크레이트를 crates.io 에 게시하는 경우 작업 공간의 각 크레이트를 별도로 게시해야 합니다. 화물 테스트와 마찬가지로 -p 플래그를 사용하고 게시하려는 크레이트의 이름을 지정하여 작업 공간에 특정 크레이트를 게시할 수 있습니다.\n추가 연습을 위해 add_one 크레이트와 유사한 방식으로 이 작업 공간에 add_two 크레이트를 추가합니다!\n프로젝트가 커짐에 따라 작업 공간 사용을 고려하십시오. 하나의 큰 코드 덩어리보다 작은 개별 구성 요소를 이해하는 것이 더 쉽습니다. 또한 상자를 작업 공간에 보관하면 동시에 자주 변경되는 경우 상자 간의 조정이 더 쉬워질 수 있습니다.\n\ncargo install로 바이너리 설치하기\ncargo install 명령을 사용하면 바이너리 크레이트를 로컬에 설치하고 사용할 수 있습니다. 이는 시스템 패키지를 대체하기 위한 것이 아닙니다. 이는 Rust 개발자가 다른 사람들이 crates.io 에서 공유한 도구를 설치하는 편리한 방법을 의미합니다. 바이너리 대상이 있는 패키지만 설치할 수 있습니다. 바이너리 타겟은 크레이트에 src/main.rs 파일이나 바이너리로 지정된 다른 파일이 있는 경우 생성되는 실행 가능한 프로그램입니다. 프로그램들. 일반적으로 크레이트는 README 파일에 크레이트가 라이브러리인지, 바이너리 타겟이 있는지 또는 둘 다에 대한 정보를 가지고 있습니다.\ncargo install로 설치된 모든 바이너리는 설치 루트의 bin 폴더에 저장됩니다. Rustup.rs를 사용하여 Rust를 설치했고 사용자 지정 구성이 없는 경우 이 디렉터리는 $HOME/.cargo/bin 이 됩니다. cargo install로 설치한 프로그램을 실행할 수 있도록 디렉토리가 $PATH에 있는지 확인하십시오.\n예를 들어, 12장에서 파일 검색을 위한 ripgrep이라는 grep 도구의 Rust 구현이 있다고 언급했습니다. ripgrep을 설치하려면 다음을 실행할 수 있습니다.\n$ cargo install ripgrep\n    Updating crates.io index\n  Downloaded ripgrep v13.0.0\n  Downloaded 1 crate (243.3 KB) in 0.88s\n  Installing ripgrep v13.0.0\n--snip--\n   Compiling ripgrep v13.0.0\n    Finished release [optimized + debuginfo] target(s) in 3m 10s\n  Installing ~/.cargo/bin/rg\n   Installed package `ripgrep v13.0.0` (executable `rg`)\n\n출력의 마지막에서 두 번째 줄에는 설치된 바이너리의 위치와 이름이 표시되며 ripgrep의 경우 rg입니다. 이전에 언급한 것처럼 설치 디렉토리가 $PATH에 있는 한 rg --help를 실행하고 파일 검색을 위한 더 빠르고 더 강력한 도구를 사용할 수 있습니다!\n\n사용자 지정 명령으로 Cargo 확장\nCargo는 Cargo를 수정할 필요 없이 새로운 하위 명령으로 확장할 수 있도록 설계되었습니다. $PATH의 바이너리 이름이 cargo-something인 경우 cargo something을 실행하여 Cargo 하위 명령인 것처럼 실행할 수 있습니다. 이와 같은 사용자 지정 명령은 cargo --list를 실행할 때도 나열됩니다. cargo install을 사용하여 확장 기능을 설치한 다음 내장 Cargo 도구처럼 실행할 수 있다는 것은 Cargo 디자인의 매우 편리한 이점입니다!\n요약\nCargo 및 crates.io 와 코드를 공유하는 것은 Rust 생태계를 다양한 작업에 유용하게 만드는 요소 중 하나입니다. Rust의 표준 라이브러리는 작고 안정적이지만 크레이트는 언어와 다른 타임라인에서 쉽게 공유, 사용 및 개선할 수 있습니다. 당신에게 유용한 코드를 crates.io 에 공유하는 것을 부끄러워하지 마세요 . 다른 사람에게도 유용할 것 같습니다!\n\n15\n스마트 포인터\n포인터 는 메모리의 주소를 포함하는 변수에 대한 일반적인 개념입니다. 이 주소는 다른 데이터를 참조하거나 가리키는 것입니다. Rust에서 가장 일반적인 종류의 포인터는 4장에서 배웠던 참조입니다. 참조는 &amp; 기호로 표시되며 가리키는 값을 빌립니다. 데이터를 참조하는 것 외에 특별한 기능이 없으며 오버헤드가 없습니다.\n반면에 스마트 포인터는 포인터처럼 작동하지만 추가 메타데이터 및 기능도 포함하는 데이터 구조입니다. 스마트 포인터의 개념은 Rust에만 있는 것이 아닙니다. 스마트 포인터는 C++에서 시작되었고 다른 언어에도 존재합니다. Rust는 참조에서 제공하는 것 이상의 기능을 제공하는 표준 라이브러리에 정의된 다양한 스마트 포인터를 가지고 있습니다. 일반적인 개념을 살펴보기 위해 참조 카운팅 스마트 포인터 유형 을 포함하여 스마트 포인터의 몇 가지 다른 예를 살펴보겠습니다. 이 포인터를 사용하면 소유자 수를 추적하고 소유자가 남아 있지 않으면 데이터를 정리하여 데이터가 여러 소유자를 갖도록 허용할 수 있습니다.\n소유권과 차용 개념이 있는 Rust는 참조와 스마트 포인터 사이에 또 다른 차이점이 있습니다. 참조는 데이터만 빌릴 수 있지만 대부분의 경우 스마트 포인터는 자신이 가리키는 데이터를 소유합니다.\n당시에는 그렇게 부르지 않았지만 이 책에서 String 및 Vec을 포함하여 몇 가지 스마트 포인터를 이미 접했습니다.8장에서. 이 두 유형 모두 일부 메모리를 소유하고 조작할 수 있기 때문에 스마트 포인터로 간주됩니다. 또한 메타데이터와 추가 기능 또는 보증이 있습니다. 예를 들어문자열`은 용량을 메타데이터로 저장하고 추가 데이터가 항상 유효한 UTF-8인지 확인하는 기능.\n스마트 포인터는 일반적으로 구조체를 사용하여 구현됩니다. 일반 구조체와 달리 스마트 포인터는 Deref 및 Drop 특성을 구현합니다. Deref 특성을 사용하면 스마트 포인터 구조체의 인스턴스가 참조처럼 동작할 수 있으므로 참조 또는 스마트 포인터와 함께 작동하도록 코드를 작성할 수 있습니다. 드롭 특성을 사용하면 스마트 포인터의 인스턴스가 범위를 벗어날 때 실행되는 코드를 사용자 지정할 수 있습니다. 이 장에서는 두 가지 특성에 대해 논의하고 스마트 포인터에 중요한 이유를 설명합니다.\n스마트 포인터 패턴이 Rust에서 자주 사용되는 일반적인 디자인 패턴이라는 점을 감안할 때, 이 장에서는 기존의 모든 스마트 포인터를 다루지는 않을 것입니다. 많은 라이브러리에는 자체 스마트 포인터가 있으며 직접 작성할 수도 있습니다. 표준 라이브러리에서 가장 일반적인 스마트 포인터를 다룰 것입니다.\n\n상자 힙에 값을 할당하기 위해\nRC, 다중 소유권을 가능하게 하는 참조 카운팅 유형\n참조 및 RefMut, RefCell을 통해 액세스, 컴파일 시간 대신 런타임에 차용 규칙을 적용하는 유형\n\n또한 불변 유형이 내부 값을 변경하기 위해 API를 노출하는 내부 변경 가능성 패턴을 다룰 것입니다. 우리는 또한 참조 순환에 대해 논의할 것입니다 : 메모리 누수를 방지하는 방법.\n다이빙하자!\n\n상자를 사용하여 힙의 데이터 가리키기\n가장 직관적인 스마트 포인터는 Box 형식의 상자 입니다.`. 상자를 사용하면 스택이 아닌 힙에 데이터를 저장할 수 있습니다. 스택에 남는 것은 힙 데이터에 대한 포인터입니다. 스택과 힙의 차이점을 검토하려면 4장을 참조하십시오.\n박스는 데이터를 스택이 아닌 힙에 저장하는 것 외에는 성능 오버헤드가 없습니다. 그러나 그들은 많은 추가 기능도 가지고 있지 않습니다. 다음과 같은 상황에서 가장 자주 사용하게 됩니다.\n\n컴파일 시간에 크기를 알 수 없는 유형이 있고 정확한 크기가 필요한 컨텍스트에서 해당 유형의 값을 사용하려는 경우\n많은 양의 데이터가 있고 소유권을 이전하고 싶지만 그렇게 할 때 데이터가 복사되지 않도록 할 때\n값을 소유하고 싶고 특정 유형이 아닌 특정 특성을 구현하는 유형이라는 점에만 관심이 있는 경우\n\n박스로 재귀 유형 활성화 섹션 에서 첫 번째 상황을 보여드리겠습니다. 두 번째 경우에는 데이터가 스택에 복사되기 때문에 많은 양의 데이터 소유권을 이전하는 데 시간이 오래 걸릴 수 있습니다. 이 상황에서 성능을 향상시키기 위해 많은 양의 데이터를 상자의 힙에 저장할 수 있습니다. 그런 다음 적은 양의 포인터 데이터만 스택에 복사되고 참조하는 데이터는 힙의 한 위치에 유지됩니다. 세 번째 경우는 특성 객체 로 알려져 있으며 17장에서는 다른 유형의 값을 허용하는 특성 객체 사용이라는 전체 섹션을 해당 주제에 할애합니다. 따라서 여기서 배운 내용은 17장에서 다시 적용하게 됩니다!\n상자를 사용하여 힙에 데이터 저장\nBox의 힙 저장소 사용 사례를 논의하기 전에에서 구문과 Box 내에 저장된 값과 상호 작용하는 방법을 다룰 것입니다..\n목록 15-1은 상자를 사용하여 힙에 i32 값을 저장하는 방법을 보여줍니다.\n파일 이름: src/main.rs\nfn main() {\n    let b = Box::new(5);\n    println!(`b = {}`, b);\n}\n\n목록 15-1: 상자를 사용하여 힙에 i32 값 저장\n힙에 할당된 값 5를 가리키는 Box의 값을 갖도록 변수 b를 정의합니다. 이 프로그램은 b = 5를 인쇄합니다. 이 경우 이 데이터가 스택에 있는 경우와 유사하게 상자의 데이터에 액세스할 수 있습니다. 모든 소유된 값과 마찬가지로 상자가 범위를 벗어나면 b가 main의 끝에서 하는 것처럼 할당이 해제됩니다. 할당 해제는 상자(스택에 저장됨)와 그것이 가리키는 데이터(힙에 저장됨) 모두에 대해 발생합니다.\n힙에 단일 값을 넣는 것은 그다지 유용하지 않으므로 이러한 방식으로 박스 자체를 자주 사용하지는 않을 것입니다. 기본적으로 저장되는 스택에 단일 i32와 같은 값을 갖는 것이 대부분의 상황에서 더 적절합니다. 상자가 없으면 허용되지 않는 유형을 상자를 통해 정의할 수 있는 경우를 살펴보겠습니다.\n상자로 재귀 유형 활성화\n재귀 유형 의 값은 자신의 일부와 동일한 유형의 다른 값을 가질 수 있습니다. 재귀 유형은 컴파일 시간에 러스트가 유형이 차지하는 공간을 알아야 하기 때문에 문제를 제기합니다. 그러나 재귀 유형 값의 중첩은 이론적으로 무한히 계속될 수 있으므로 러스트는 값이 얼마나 많은 공간을 필요로 하는지 알 수 없습니다. 상자의 크기가 알려져 있기 때문에 재귀 유형 정의에 상자를 삽입하여 재귀 유형을 활성화할 수 있습니다.\n재귀 유형의 예로 cons list 를 살펴보겠습니다. 함수형 프로그래밍 언어에서 흔히 볼 수 있는 데이터 유형입니다. 우리가 정의할 cons 목록 유형은 재귀를 제외하고는 간단합니다. 따라서 우리가 작업할 예제의 개념은 재귀 유형과 관련된 더 복잡한 상황에 처할 때마다 유용할 것입니다.\n단점 목록에 대한 추가 정보\ncons list 는 Lisp 프로그래밍 언어와 그 방언에서 나온 데이터 구조로 중첩된 쌍으로 구성되어 있으며 Lisp 버전의 연결 목록입니다. 그 이름은 두 개의 인수로부터 새로운 쌍을 구성하는 Lisp의 cons 함수(construct function의 줄임말)에서 유래했습니다. 값과 다른 쌍으로 구성된 쌍에서 cons를 호출하여 재귀 쌍으로 구성된 cons 목록을 구성할 수 있습니다.\n예를 들어, 다음은 목록 1, 2, 3을 포함하는 cons 목록의 의사 코드 표현이며 각 쌍은 괄호 안에 있습니다.\n(1, (2, (3, Nil)))\n\ncons 목록의 각 항목에는 현재 항목의 값과 다음 항목의 두 가지 요소가 포함됩니다. 목록의 마지막 항목에는 다음 항목 없이 Nil이라는 값만 포함되어 있습니다. cons 목록은 cons 함수를 재귀적으로 호출하여 생성됩니다. 재귀의 기본 사례를 나타내는 표준 이름은 Nil입니다. 이것은 유효하지 않거나 없는 값인 6장의 null 또는 nil 개념과 동일하지 않습니다.\ncons 목록은 Rust에서 일반적으로 사용되는 데이터 구조가 아닙니다. Rust에 항목 목록이 있을 때 대부분 Vec가 사용하기에 더 나은 선택입니다. 다른 더 복잡한 재귀 데이터 유형은 다양한 상황에서 유용 하지만 이 장의 단점 목록부터 시작하여 상자를 사용하여 많은 산만함 없이 재귀 데이터 유형을 정의할 수 있는 방법을 탐색할 수 있습니다.\n목록 15-2에는 cons 목록에 대한 열거형 정의가 포함되어 있습니다. 이 코드는 목록 유형에 알려진 크기가 없기 때문에 아직 컴파일되지 않습니다.\n파일 이름: src/main.rs\nenum List {\n    Cons(i32, List),\n    Nil,\n}\n\nListing 15-2: i32 값의 cons list 데이터 구조를 나타내기 위해 열거형을 정의하려는 첫 번째 시도\n\n참고: 이 예제의 목적을 위해 i32 값만 보유하는 cons 목록을 구현하고 있습니다. 10장에서 논의한 것처럼 모든 유형의 값을 저장할 수 있는 cons 목록 유형을 정의하기 위해 제네릭을 사용하여 구현했을 수 있습니다.\n\n목록 1, 2, 3을 저장하기 위해 목록 유형을 사용하는 것은 목록 15-3의 코드와 같습니다:\n파일 이름: src/main.rs\nuse crate::List::{Cons, Nil};\n\nfn main() {\n    let list = Cons(1, Cons(2, Cons(3, Nil)));\n}\n\nListing 15-3: List 열거형을 사용하여 1, 2, 3 목록 저장\n첫 번째 Cons 값에는 1과 다른 List 값이 있습니다. 이 목록 값은 2 및 다른 목록 값을 포함하는 또 다른 Cons 값입니다. 이 목록 값은 3과 목록 값을 보유하는 또 하나의 Cons 값이며, 최종적으로 목록의 끝을 알리는 비재귀적 변형인 Nil입니다.\n목록 15-3의 코드를 컴파일하려고 하면 목록 15-4에 표시된 오류가 발생합니다.\n$ cargo run\n   Compiling cons-list v0.1.0 (file:///projects/cons-list)\nerror[E0072]: recursive type `List` has infinite size\n --&gt; src/main.rs:1:1\n  |\n1 | enum List {\n  | ^^^^^^^^^\n2 |     Cons(i32, List),\n  |               ---- recursive without indirection\n  |\nhelp: insert some indirection (e.g., a `Box`, `Rc`, or `&amp;`) to break the cycle\n  |\n2 |     Cons(i32, Box&lt;List&gt;),\n  |               ++++    +\n\nFor more information about this error, try `rustc --explain E0072`.\nerror: could not compile `cons-list` due to previous error\n\n목록 15-4: 재귀 열거형을 정의하려고 시도할 때 발생하는 오류\n오류는 이 유형이 크기가 무한함을 나타냅니다. 그 이유는 우리가 재귀적 변형으로 목록을 정의했기 때문입니다. 즉, 자체의 또 다른 값을 직접 보유합니다. 결과적으로 Rust는 목록 값을 저장하는 데 필요한 공간을 파악할 수 없습니다. 이 오류가 발생하는 이유를 분석해 보겠습니다. 먼저 Rust가 비재귀 유형의 값을 저장하는 데 필요한 공간을 결정하는 방법을 살펴보겠습니다.\n비재귀 유형의 크기 계산\n6장에서 열거형 정의를 논의할 때 목록 6-2에서 정의한 Message 열거형을 상기하십시오.\nenum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n}\n\nMessage 값에 할당할 공간을 결정하기 위해 Rust는 각 변형을 검토하여 가장 많은 공간이 필요한 변형을 확인합니다. Rust는 Message::Quit에 공간이 필요하지 않고 Message::Move에 두 개의 i32 값을 저장하기에 충분한 공간이 필요하다는 것을 확인합니다. 하나의 변형만 사용되기 때문에 메시지 값에 필요한 최대 공간은 가장 큰 변형을 저장하는 데 필요한 공간입니다.\nRust가 목록 15-2의 List 열거형과 같은 재귀 유형에 필요한 공간을 결정하려고 할 때 발생하는 일과 대조하십시오. 컴파일러는 i32 유형의 값과 List 유형의 값을 보유하는 Cons 변형을 살펴보는 것으로 시작합니다. 따라서 Cons에는 i32 크기에 List 크기를 더한 것과 같은 공간이 필요합니다. List 유형에 필요한 메모리 양을 파악하기 위해 컴파일러는 Cons 변형부터 시작하여 변형을 살펴봅니다. Cons 변형은 i32 유형의 값과 List 유형의 값을 보유하며 이 프로세스는 그림 15-1과 같이 무한히 계속됩니다.\n\n그림 15-1: 무한 Cons 변형으로 구성된 무한 목록\nBox를 사용하여 알려진 크기의 재귀 유형 가져오기\nRust는 재귀적으로 정의된 유형에 할당할 공간을 파악할 수 없기 때문에 컴파일러는 다음과 같은 유용한 제안과 함께 오류를 표시합니다.\nhelp: insert some indirection (e.g., a `Box`, `Rc`, or `&amp;`) to make `List` representable\n  |\n2 |     Cons(i32, Box&lt;List&gt;),\n  |               ++++    +\n\n이 제안에서 간접이란 값을 직접 저장하는 대신 값에 대한 포인터를 저장하여 간접적으로 값을 저장하도록 데이터 구조를 변경해야 함을 의미합니다.\n왜냐하면 박스는 포인터이고 Rust는 항상 Box가 얼마나 많은 공간을 차지하는지 알고 있습니다.필요: 포인터의 크기는 포인터가 가리키는 데이터의 양에 따라 변경되지 않습니다. 즉,Box를 다른 List값 대신Cons변형 내부에 직접 입력합니다.Box는 Cons변형 내부가 아닌 힙에 있을 다음목록` 값을 가리킵니다. 개념적으로는 여전히 다른 목록을 포함하는 목록으로 생성된 목록이 있지만 이 구현은 이제 항목을 배치하는 것과 비슷합니다. 서로의 내부가 아닌 서로의 옆에.\nListing 15-2의 List enum 정의와 Listing 15-3의 List 사용법을 Listing 15-5의 코드로 변경할 수 있습니다.\n파일 이름: src/main.rs\nenum List {\n    Cons(i32, Box&lt;List&gt;),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\n\nfn main() {\n    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));\n}\n\nListing 15-5: Box를 사용하는 List의 정의` 알려진 크기를 갖기 위해\nCons 변형에는 i32의 크기와 상자의 포인터 데이터를 저장할 공간이 필요합니다. Nil 변형은 값을 저장하지 않으므로 Cons 변형보다 적은 공간이 필요합니다. 우리는 이제 모든 목록 값이 i32의 크기에 상자의 포인터 데이터 크기를 더한 값을 차지한다는 것을 알고 있습니다. 상자를 사용하여 무한한 재귀 체인을 끊었으므로 컴파일러는 목록 값을 저장하는 데 필요한 크기를 파악할 수 있습니다. 그림 15-2는 Cons 변종의 현재 모습을 보여줍니다.\n\n그림 15-2: Cons가 Box를 보유하기 때문에 크기가 무한하지 않은 List\n박스는 간접 및 힙 할당만 제공합니다. 다른 스마트 포인터 유형에서 볼 수 있는 것과 같은 다른 특수 기능이 없습니다. 또한 이러한 특수 기능이 발생시키는 성능 오버헤드가 없으므로 간접 지정이 필요한 유일한 기능인 cons 목록과 같은 경우에 유용할 수 있습니다. 17장에서도 상자에 대한 더 많은 사용 사례를 살펴보겠습니다.\n상자유형은Deref 특성을 구현하기 때문에 스마트 포인터입니다. 값은 참조처럼 취급됩니다. 상자 값이 범위를 벗어나면 Drop 특성 구현으로 인해 상자가 가리키는 힙 데이터도 정리됩니다. 이 두 특성은 우리가 제공하는 다른 스마트 포인터 유형에서 제공하는 기능에 훨씬 더 중요합니다. 이 장의 나머지 부분에서 논의할 것이므로 이 두 가지 특성에 대해 자세히 살펴보겠습니다.\n\nDeref 특성을 사용하여 스마트 포인터를 일반 참조처럼 취급\nDeref 특성을 구현하면 역참조 연산자 * 의 동작을 사용자 정의할 수 있습니다 (곱하기 또는 glob 연산자와 혼동하지 말 것). 스마트 포인터가 일반 참조처럼 취급될 수 있는 방식으로 Deref를 구현하면 참조에서 작동하는 코드를 작성하고 해당 코드를 스마트 포인터와 함께 사용할 수도 있습니다.\n먼저 역참조 연산자가 일반 참조와 함께 작동하는 방식을 살펴보겠습니다. 그런 다음 Box처럼 동작하는 사용자 지정 유형을 정의하려고 합니다., 역참조 연산자가 새로 정의된 유형에 대한 참조처럼 작동하지 않는 이유를 확인합니다. Deref` 특성을 구현하여 스마트 포인터가 참조와 유사한 방식으로 작동할 수 있는 방법을 살펴보겠습니다. 그런 다음 Rust의 역참조 강제 기능과 그것이 참조나 스마트 포인터로 작업하는 방법을 살펴보십시오.\n\n참고: MyBox 사이에는 한 가지 큰 차이점이 있습니다.우리가 만들려고 하는 유형과 실제상자: 우리 버전은 데이터를 힙에 저장하지 않습니다. 이 예제는 Deref`에 초점을 맞추고 있으므로 데이터가 실제로 저장되는 위치는 포인터와 같은 동작보다 덜 중요합니다.\n\n값에 대한 포인터를 따라\n일반 참조는 일종의 포인터이며 포인터를 다른 곳에 저장된 값에 대한 화살표로 생각하는 한 가지 방법입니다. 목록 15-6에서 i32 값에 대한 참조를 생성한 다음 값에 대한 참조를 따르기 위해 역참조 연산자를 사용합니다.\n파일 이름: src/main.rs\nfn main() {\n    let x = 5;\n    let y = &amp;x;\n\n    assert_eq!(5, x);\n    assert_eq!(5, *y);\n}\n\n목록 15-6: 역참조 연산자를 사용하여 i32 값에 대한 참조를 따르기\n변수 x는 i32 값 5를 보유합니다. y를 x에 대한 참조와 동일하게 설정합니다. 우리는 x가 5와 같다고 주장할 수 있습니다. 그러나 y의 값에 대한 주장을 하려면 컴파일러가 실제 값을 비교할 수 있도록 *y를 사용하여 가리키는 값에 대한 참조를 따라야 합니다(따라서 역참조 ). y를 역참조하면 5와 비교할 수 있는 y가 가리키는 정수 값에 액세스할 수 있습니다.\nassert_eq!(5, y);라고 쓰려고 하면 대신 다음과 같은 컴파일 오류가 발생합니다.\n$ cargo run\n   Compiling deref-example v0.1.0 (file:///projects/deref-example)\nerror[E0277]: can`t compare `{integer}` with `&amp;{integer}`\n --&gt; src/main.rs:6:5\n  |\n6 |     assert_eq!(5, y);\n  |     ^^^^^^^^^^^^^^^^ no implementation for `{integer} == &amp;{integer}`\n  |\n  = help: the trait `PartialEq&lt;&amp;{integer}&gt;` is not implemented for `{integer}`\n  = help: the following other types implement trait `PartialEq&lt;Rhs&gt;`:\n            f32\n            f64\n            i128\n            i16\n            i32\n            i64\n            i8\n            isize\n          and 6 others\n  = note: this error originates in the macro `assert_eq` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try `rustc --explain E0277`.\nerror: could not compile `deref-example` due to previous error\n\n숫자와 숫자에 대한 참조는 유형이 다르기 때문에 비교할 수 없습니다. 가리키는 값에 대한 참조를 따르려면 역참조 연산자를 사용해야 합니다.\n참조처럼 상자 사용\nListing 15-6의 코드를 Box를 사용하도록 다시 작성할 수 있습니다.참조 대신박스에 사용되는 역참조 연산자` 목록 15-7의 기능은 목록 15-6의 참조에 사용된 역참조 연산자와 같은 방식입니다.\n파일 이름: src/main.rs\nfn main() {\n    let x = 5;\n    let y = Box::new(x);\n\n    assert_eq!(5, x);\n    assert_eq!(5, *y);\n}\n\nListing 15-7: Box에 역참조 연산자 사용하기`\nListing 15-7과 Listing 15-6의 주요 차이점은 여기에서 y를 Box의 인스턴스로 설정했다는 것입니다.는 x의 값을 가리키는 참조가 아니라 x의 복사된 값을 가리킵니다. 마지막 어설션에서 역참조 연산자를 사용하여 Box의 포인터를 따라갈 수 있습니다.y가 참조일 때 했던 것과 같은 방식입니다. 다음으로 Box의 특별한 점을 살펴보겠습니다. 자체 형식을 정의하여 역참조 연산자를 사용할 수 있습니다.\n우리만의 스마트 포인터 정의하기\nBox와 유사한 스마트 포인터를 만들어 봅시다.` 스마트 포인터가 기본적으로 참조와 어떻게 다르게 동작하는지 경험하기 위해 표준 라이브러리에서 제공하는 유형. 그런 다음 역참조 연산자를 사용하는 기능을 추가하는 방법을 살펴보겠습니다.\n상자유형은 궁극적으로 하나의 요소가 있는 튜플 구조체로 정의되므로 목록 15-8은MyBox같은 방식으로 입력합니다. 또한Box에 정의된 new함수와 일치하도록new 함수를 정의합니다..\n파일 이름: src/main.rs\nstruct MyBox&lt;T&gt;(T);\n\nimpl&lt;T&gt; MyBox&lt;T&gt; {\n    fn new(x: T) -&gt; MyBox&lt;T&gt; {\n        MyBox(x)\n    }\n}\n\n목록 15-8: MyBox 정의하기 유형\nMyBox라는 구조체를 정의하고 일반 매개변수 T를 선언합니다. 유형이 모든 유형의 값을 보유하기를 원하기 때문입니다. MyBox 유형은 T 유형의 요소가 하나 있는 튜플 구조체입니다. MyBox::new 함수는 T 유형의 매개변수 하나를 사용하고 전달된 값을 보유하는 MyBox 인스턴스를 반환합니다.\nListing 15-7의 main 함수를 Listing 15-8에 추가하고 MyBox를 사용하도록 변경해 봅시다.유형을Box 대신에 정의했습니다.. Listing 15-9의 코드는 Rust가 MyBox를 역참조하는 방법을 모르기 때문에 컴파일되지 않습니다.\n파일 이름: src/main.rs\nfn main() {\n    let x = 5;\n    let y = MyBox::new(x);\n\n    assert_eq!(5, x);\n    assert_eq!(5, *y);\n}\n\nListing 15-9: MyBox 사용 시도같은 방식으로 참조를 사용하고Box`\n결과 컴파일 오류는 다음과 같습니다.\n$ cargo run\n   Compiling deref-example v0.1.0 (file:///projects/deref-example)\nerror[E0614]: type `MyBox&lt;{integer}&gt;` cannot be dereferenced\n  --&gt; src/main.rs:14:19\n   |\n14 |     assert_eq!(5, *y);\n   |                   ^^\n\nFor more information about this error, try `rustc --explain E0614`.\nerror: could not compile `deref-example` due to previous error\n\n우리의 마이박스 유형에 해당 기능을 구현하지 않았기 때문에 유형을 역참조할 수 없습니다. * 연산자로 역참조를 활성화하기 위해 Deref 특성을 구현합니다.\nDeref 특성을 구현하여 참조처럼 유형 처리\n10장의 유형에 대한 특성 구현 섹션 에서 설명한 것처럼 특성을 구현하려면 특성의 필수 메서드에 대한 구현을 제공해야 합니다. 표준 라이브러리에서 제공하는 Deref 특성은 self를 빌리고 내부 데이터에 대한 참조를 반환하는 deref라는 메서드를 구현해야 합니다. 목록 15-10에는 MyBox 정의에 추가할 Deref 구현이 포함되어 있습니다.\n파일 이름: src/main.rs\nuse std::ops::Deref;\n\nimpl&lt;T&gt; Deref for MyBox&lt;T&gt; {\n    type Target = T;\n\n    fn deref(&amp;self) -&gt; &amp;Self::Target {\n        &amp;self.0\n    }\n}\n\nListing 15-10: MyBox에 Deref 구현하기`\n유형 대상 = T; 구문은 사용할 Deref 특성에 대한 관련 유형을 정의합니다. 연관 유형은 일반 매개변수를 선언하는 약간 다른 방법이지만 지금은 이에 대해 걱정할 필요가 없습니다. 19장에서 더 자세히 다룰 것입니다.\nderef 메서드의 본문을 &amp;self.0으로 채워서 deref가   연산자로 액세스하려는 값에 대한 참조를 반환합니다 . .0이 튜플 구조체의 첫 번째 값에 액세스하는 5장의 명명된 필드 없이 튜플 구조체를 사용하여 다른 유형 만들기 섹션을 기억하십시오 . MyBox에서 * 를 호출하는 Listing 15-9의 main 함수* 이제 값이 컴파일되고 어설션이 통과됩니다!\nDeref 특성이 없으면 컴파일러는 &amp; 참조만 역참조할 수 있습니다. deref 메서드는 컴파일러가 Deref를 구현하는 모든 유형의 값을 가져오고 deref 메서드를 호출하여 역참조하는 방법을 알고 있는 &amp; 참조를 가져올 수 있는 기능을 제공합니다.\nListing 15-9에서 *y를 입력했을 때 Rust는 실제로 이 코드를 실행했습니다.\n*(y.deref())\n\nRust는 * 연산자를 deref 메서드에 대한 호출로 대체한 다음 일반 역참조로 대체하므로 deref 메서드를 호출해야 하는지 여부를 생각할 필요가 없습니다. 이 Rust 기능을 사용하면 일반 참조가 있든 Deref를 구현하는 유형이 있든 동일하게 작동하는 코드를 작성할 수 있습니다.\nderef 메서드가 값에 대한 참조를 반환하고 *(y.deref())에서 괄호 외부의 일반 역참조가 여전히 필요한 이유는 소유권 시스템과 관련이 있습니다. deref 메서드가 값에 대한 참조 대신 값을 직접 반환하면 값이 self 밖으로 이동됩니다. 우리는 MyBox 내부의 내부 가치를 소유하고 싶지 않습니다.` 이 경우 또는 대부분의 경우 역참조 연산자를 사용합니다.\n  연산자는 코드에서  를 사용할 때마다  deref 메서드를 호출한 다음   연산자를 한 번만 호출하는 것으로 대체됩니다.   연산자의 대체는 무한 반복되지 않기 때문에 assert_eq!의 5와 일치하는 i32 유형의 데이터로 끝납니다. 목록 15-9에서.\n함수 및 메서드를 사용한 암시적 역참조 강제 변환\nDeref 강제는 Deref 특성을 구현하는 유형에 대한 참조를 다른 유형에 대한 참조로 변환합니다. 예를 들어 역참조 강제는 &amp;String을 &amp;str로 변환할 수 있습니다. String은 &amp;str을 반환하도록 Deref 특성을 구현하기 때문입니다. Deref 강제는 Rust가 함수와 메서드에 대한 인수에 대해 수행하는 편리한 기능이며 Deref 특성을 구현하는 유형에서만 작동합니다. 함수 또는 메서드 정의의 매개 변수 유형과 일치하지 않는 함수 또는 메서드에 대한 인수로 특정 유형의 값에 대한 참조를 전달할 때 자동으로 발생합니다. deref 메서드에 대한 일련의 호출은 우리가 제공한 유형을 매개변수에 필요한 유형으로 변환합니다.\n함수 및 메서드 호출을 작성하는 프로그래머가 &amp; 및 *를 사용하여 많은 명시적 참조 및 역참조를 추가할 필요가 없도록 역참조 강제가 Rust에 추가되었습니다. 역참조 강제 기능을 사용하면 참조 또는 스마트 포인터에 대해 작동할 수 있는 더 많은 코드를 작성할 수 있습니다.\n역참조 강제가 작동하는 것을 보려면 MyBox 우리가 Listing 15-8에서 정의한 type과 Listing 15-10에서 추가한 Deref의 구현. Listing 15-11은 문자열 슬라이스 매개변수가 있는 함수의 정의를 보여줍니다:\n파일 이름: src/main.rs\nfn hello(name: &amp;str) {\n    println!(`Hello, {name}!`);\n}\n\n목록 15-11: &amp;str 유형의 매개변수 name을 갖는 hello 함수\nhello(Rust);와 같이 문자열 슬라이스를 인수로 사용하여 hello 함수를 호출할 수 있습니다. 예를 들어. Deref 강제는 MyBox 유형의 값에 대한 참조로 hello를 호출할 수 있게 합니다.`, Listing 15-12와 같이:\n파일 이름: src/main.rs\nfn main() {\n    let m = MyBox::new(String::from(`Rust`));\n    hello(&amp;m);\n}\n\nListing 15-12: MyBox에 대한 참조로 hello 호출하기역참조 강제로 인해 작동하는 값\n여기에서 MyBox에 대한 참조인 &amp;m 인수를 사용하여 hello 함수를 호출합니다.값.MyBox에 Deref 특성을 구현했기 때문입니다. 목록 15-10에서 Rust는 &amp;MyBox를 deref를 호출하여 &amp;String으로. 표준 라이브러리는 문자열 슬라이스를 반환하는 Deref on Deref 구현을 제공하며 이는 Deref에 대한 API 문서에 있습니다. Rust는 deref를 다시 호출하여 다음을 수행합니다. &amp;String을 hello 함수의 정의와 일치하는 &amp;str로 바꿉니다.\n러스트가 역참조 강제를 구현하지 않았다면 &amp;MyBox 유형의 값으로 hello를 호출하기 위해 목록 15-12의 코드 대신 목록 15-13의 코드를 작성해야 합니다.`.\n파일 이름: src/main.rs\nfn main() {\n    let m = MyBox::new(String::from(`Rust`));\n    hello(&amp;(*m)[..]);\n}\n\n목록 15-13: Rust에 역참조 강제가 없다면 작성해야 할 코드\n(*m)은 MyBox를 문자열로 변환합니다. 그런 다음 &amp; 및 [..]는 전체 문자열과 동일한 문자열의 문자열 조각을 가져와 hello의 서명과 일치시킵니다. 역참조 강제가 없는 이 코드는 다음과 같습니다. 관련된 모든 기호로 인해 읽고, 쓰고, 이해하기가 더 어렵습니다 역참조 강제는 Rust가 자동으로 이러한 변환을 처리할 수 있도록 합니다.\n관련된 유형에 대해 Deref 특성이 정의되면 Rust는 유형을 분석하고 Deref::deref를 매개변수의 유형과 일치하는 참조를 얻기 위해 필요한 만큼 많이 사용할 것입니다. Deref::deref가 삽입되어야 하는 횟수는 컴파일 시간에 해결되므로 역참조 강제를 활용하는 데 따른 런타임 페널티가 없습니다!\n역참조 강제가 가변성과 상호 작용하는 방법\nDeref 특성을 사용하여 불변 참조에서   연산자를 재정의하는 방법과 유사하게 DerefMut 특성을 사용하여 가변 참조에서   연산자를 재정의할 수 있습니다.\nRust는 세 가지 경우에서 유형과 특성 구현을 찾을 때 역참조 강제를 수행합니다.\n\nT: Deref&lt;Target=U&gt;인 경우 &amp;T에서 &amp;U로\nT: DerefMut&lt;Target=U&gt;일 때 &amp;mut T에서 &amp;mut U로\nT: Deref&lt;Target=U&gt;일 때 &amp;mut T에서 &amp;U로\n\n처음 두 경우는 두 번째가 가변성을 구현한다는 점을 제외하면 서로 동일합니다. 첫 번째 경우는 &amp;T가 있고 T가 일부 U 유형에 Deref를 구현하는 경우 투명하게 &amp;U를 얻을 수 있음을 나타냅니다. 두 번째 경우는 변경 가능한 참조에 대해 동일한 역참조 강제가 발생함을 나타냅니다.\n세 번째 경우는 더 까다롭습니다. Rust는 변경 가능한 참조를 변경 불가능한 참조로 강제하기도 합니다. 그러나 그 반대는 불가능 합니다. 불변 참조는 절대 가변 참조로 강제되지 않습니다. 차용 규칙으로 인해 가변 참조가 있는 경우 해당 가변 참조는 해당 데이터에 대한 유일한 참조여야 합니다(그렇지 않으면 프로그램이 컴파일되지 않음). 하나의 변경 가능한 참조를 하나의 변경 불가능한 참조로 변환해도 차용 규칙이 깨지지 않습니다. 불변 참조를 가변 참조로 변환하려면 초기 불변 참조가 해당 데이터에 대한 유일한 불변 참조여야 하지만 차용 규칙은 이를 보장하지 않습니다. 따라서 Rust는 불변 참조자를 가변 참조자로 변환하는 것이 가능하다는 가정을 할 수 없습니다.\n\n드롭 특성을 사용하여 정리 시 코드 실행\n스마트 포인터 패턴에 중요한 두 번째 특성은 값이 범위를 벗어나려고 할 때 발생하는 작업을 사용자 정의할 수 있는 드롭입니다. 모든 유형에서 삭제 특성에 대한 구현을 제공할 수 있으며 해당 코드를 사용하여 파일이나 네트워크 연결과 같은 리소스를 해제할 수 있습니다.\n스마트 포인터를 구현할 때 Drop 특성의 기능이 거의 항상 사용되기 때문에 스마트 포인터의 맥락에서 Drop을 소개합니다. 예를 들어, 상자를 드롭하면 상자가 가리키는 힙의 공간이 할당 해제됩니다.\n일부 언어에서 일부 형식의 경우 프로그래머는 해당 형식의 인스턴스 사용을 마칠 때마다 메모리나 리소스를 해제하는 코드를 호출해야 합니다. 파일 핸들, 소켓 또는 잠금을 예로 들 수 있습니다. 잊어버리면 시스템이 과부하되어 충돌할 수 있습니다. Rust에서는 값이 범위를 벗어날 때마다 특정 코드 비트가 실행되도록 지정할 수 있으며 컴파일러는 이 코드를 자동으로 삽입합니다. 결과적으로 특정 유형의 인스턴스가 완료된 프로그램의 모든 곳에 정리 코드를 배치하는 데 주의할 필요가 없습니다. 여전히 리소스가 누출되지 않습니다!\nDrop 특성을 구현하여 값이 범위를 벗어날 때 실행할 코드를 지정합니다. Drop 특성을 사용하려면 self에 대한 가변 참조를 사용하는 drop이라는 메서드를 구현해야 합니다. Rust가 언제 drop을 호출하는지 알아보기 위해 println!으로 drop을 구현해 봅시다. 지금은 진술.\n목록 15-14는 Dropping CustomSmartPointer!를 인쇄하는 유일한 사용자 정의 기능인 CustomSmartPointer 구조체를 보여줍니다. 인스턴스가 범위를 벗어날 때 Rust가 drop 기능을 실행할 때 표시합니다.\n파일 이름: src/main.rs\nstruct CustomSmartPointer {\n    data: String,\n}\n\nimpl Drop for CustomSmartPointer {\n    fn drop(&amp;mut self) {\n        println!(`Dropping CustomSmartPointer with data `{}`!`, self.data);\n    }\n}\n\nfn main() {\n    let c = CustomSmartPointer {\n        data: String::from(`my stuff`),\n    };\n    let d = CustomSmartPointer {\n        data: String::from(`other stuff`),\n    };\n    println!(`CustomSmartPointers created.`);\n}\n\n목록 15-14: 정리 코드를 넣을 Drop 특성을 구현하는 CustomSmartPointer 구조체\n드롭 특성은 서곡에 포함되어 있으므로 범위로 가져올 필요가 없습니다. CustomSmartPointer에 Drop 특성을 구현하고 println!을 호출하는 drop 메서드에 대한 구현을 제공합니다. drop 함수의 본문은 유형의 인스턴스가 범위를 벗어날 때 실행하려는 논리를 배치하는 위치입니다. Rust가 언제 드롭을 호출하는지 시각적으로 보여주기 위해 여기에 일부 텍스트를 인쇄하고 있습니다.\nmain에서 CustomSmartPointer의 두 인스턴스를 만든 다음 CustomSmartPointers created를 인쇄합니다. main의 끝에서 CustomSmartPointer의 인스턴스는 범위를 벗어나고 Rust는 drop 메서드에 넣은 코드를 호출하여 최종 메시지를 인쇄합니다. 명시적으로 drop 메서드를 호출할 필요가 없다는 점에 유의하십시오.\n이 프로그램을 실행하면 다음과 같은 결과가 표시됩니다.\n$ cargo run\n   Compiling drop-example v0.1.0 (file:///projects/drop-example)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.60s\n     Running `target/debug/drop-example`\nCustomSmartPointers created.\nDropping CustomSmartPointer with data `other stuff`!\nDropping CustomSmartPointer with data `my stuff`!\n\nRust는 인스턴스가 범위를 벗어나면 자동으로 drop을 호출하여 지정한 코드를 호출합니다. 변수는 생성 순서의 역순으로 삭제되므로 d가 c보다 먼저 삭제됩니다. 이 예제의 목적은 drop 방법이 작동하는 방식에 대한 시각적 가이드를 제공하는 것입니다. 일반적으로 인쇄 메시지가 아닌 유형이 실행해야 하는 정리 코드를 지정합니다.\nstd::mem::drop을 사용하여 초기에 값 삭제\n안타깝게도 자동 삭제 기능을 비활성화하는 것은 간단하지 않습니다. 일반적으로 드롭을 비활성화할 필요는 없습니다. Drop 특성의 요점은 자동으로 처리된다는 것입니다. 그러나 경우에 따라 값을 일찍 정리해야 할 수도 있습니다. 한 가지 예는 잠금을 관리하는 스마트 포인터를 사용하는 경우입니다. 동일한 범위의 다른 코드가 잠금을 획득할 수 있도록 잠금을 해제하는 드롭 메서드를 강제로 사용할 수 있습니다. Rust는 Drop 특성의 drop 메소드를 수동으로 호출하도록 허용하지 않습니다. 대신 범위가 끝나기 전에 값을 강제로 삭제하려면 표준 라이브러리에서 제공하는 std::mem::drop 함수를 호출해야 합니다.\nListing 15-15에 표시된 것처럼 Listing 15-14에서 main 함수를 수정하여 Drop 특성의 drop 메서드를 수동으로 호출하려고 하면 컴파일러 오류가 발생합니다.\n파일 이름: src/main.rs\nfn main() {\n    let c = CustomSmartPointer {\n        data: String::from(`some data`),\n    };\n    println!(`CustomSmartPointer created.`);\n    c.drop();\n    println!(`CustomSmartPointer dropped before the end of main.`);\n}\n\n목록 15-15: Drop 트레이트에서 수동으로 drop 메서드를 호출하여 조기에 정리하기 시도\n이 코드를 컴파일하려고 하면 다음 오류가 발생합니다.\n$ cargo run\n   Compiling drop-example v0.1.0 (file:///projects/drop-example)\nerror[E0040]: explicit use of destructor method\n  --&gt; src/main.rs:16:7\n   |\n16 |     c.drop();\n   |     --^^^^--\n   |     | |\n   |     | explicit destructor calls not allowed\n   |     help: consider using `drop` function: `drop(c)`\n\nFor more information about this error, try `rustc --explain E0040`.\nerror: could not compile `drop-example` due to previous error\n\n이 오류 메시지는 drop을 명시적으로 호출할 수 없음을 나타냅니다. 오류 메시지는 인스턴스를 정리하는 함수에 대한 일반적인 프로그래밍 용어인 소멸자 라는 용어를 사용합니다. 소멸자 는 인스턴스를 생성하는 생성자 와 유사합니다. Rust의 드롭 함수는 특정 소멸자 중 하나입니다.\nRust는 명시적으로 drop을 호출하도록 허용하지 않습니다. 왜냐하면 Rust는 여전히 main 끝에 있는 값에 대해 drop을 자동으로 호출하기 때문입니다. 이것은 Rust가 같은 값을 두 번 정리하려고 시도하기 때문에 이중 해제 오류가 발생합니다.\n값이 범위를 벗어날 때 drop의 자동 삽입을 비활성화할 수 없으며 drop 메서드를 명시적으로 호출할 수 없습니다. 따라서 초기에 값을 강제로 정리해야 하는 경우 std::mem::drop 함수를 사용합니다.\nstd::mem::drop 함수는 Drop 특성의 drop 메서드와 다릅니다. 강제로 삭제하려는 값을 인수로 전달하여 호출합니다. 이 함수는 서문에 있으므로 목록 15-16에 표시된 것처럼 drop 함수를 호출하도록 목록 15-15의 main을 수정할 수 있습니다.\n파일 이름: src/main.rs\nfn main() {\n    let c = CustomSmartPointer {\n        data: String::from(`some data`),\n    };\n    println!(`CustomSmartPointer created.`);\n    drop(c);\n    println!(`CustomSmartPointer dropped before the end of main.`);\n}\n\n목록 15-16: std::mem::drop을 호출하여 값이 범위를 벗어나기 전에 명시적으로 삭제\n이 코드를 실행하면 다음이 인쇄됩니다.\n$ cargo run\n   Compiling drop-example v0.1.0 (file:///projects/drop-example)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.73s\n     Running `target/debug/drop-example`\nCustomSmartPointer created.\nDropping CustomSmartPointer with data `some data`!\nCustomSmartPointer dropped before the end of main.\n\n일부 데이터 데이터가 있는 CustomSmartPointer 삭제!텍스트CustomSmartPointer가 생성되었습니다.사이에 인쇄됩니다. 및CustomSmartPointer가 메인이 끝나기 전에 떨어졌습니다. drop메서드 코드가 해당 지점에서c`를 드롭하도록 호출되었음을 보여주는 텍스트입니다.\n정리를 편리하고 안전하게 만들기 위해 여러 가지 방법으로 Drop 특성 구현에 지정된 코드를 사용할 수 있습니다. 예를 들어, 이를 사용하여 고유한 메모리 할당자를 만들 수 있습니다! 드롭 특성과 Rust의 소유권 시스템을 사용하면 Rust가 자동으로 정리하기 때문에 기억할 필요가 없습니다.\n또한 여전히 사용 중인 값을 실수로 정리하여 발생하는 문제에 대해 걱정할 필요가 없습니다. 참조가 항상 유효한지 확인하는 소유권 시스템은 값이 더 이상 사용되지 않을 때 drop이 한 번만 호출되도록 합니다.\n이제 상자를 살펴보았으므로`와 스마트 포인터의 몇 가지 특성, 표준 라이브러리에 정의된 몇 가지 다른 스마트 포인터를 살펴보겠습니다.\n\nRc, 참조 카운트 스마트 포인터\n대부분의 경우 소유권은 명확합니다. 주어진 값을 소유하는 변수를 정확히 알고 있습니다. 그러나 단일 값에 여러 소유자가 있는 경우가 있습니다. 예를 들어 그래프 데이터 구조에서 여러 에지가 동일한 노드를 가리킬 수 있으며 해당 노드는 개념적으로 이를 가리키는 모든 에지가 소유합니다. 노드를 가리키는 에지가 없어서 소유자가 없는 경우가 아니면 노드를 정리하면 안 됩니다.\nRust 유형 Rc를 사용하여 명시적으로 다중 소유권을 활성화해야 합니다.*는 참조 카운팅* 의 약자입니다. Rc` type은 값이 아직 사용 중인지 여부를 결정하기 위해 값에 대한 참조 수를 추적합니다. 값에 대한 참조가 0인 경우 참조가 무효화되지 않고 값을 정리할 수 있습니다.\n`Rc를 상상해보십시오.한 사람이 TV를 보려고 들어오면 틀고, 다른 사람이 방에 들어와서 TV를 볼 수 있다. 다른 사람들이 TV를 보고 있을 때 누군가가 TV를 끄면 나머지 TV 시청자들의 난리가 날 것입니다!\n우리는 RC 프로그램의 여러 부분을 읽을 수 있도록 힙에 일부 데이터를 할당하고 컴파일 시간에 데이터를 마지막으로 사용할 부분을 결정할 수 없는 경우 입력합니다. 마지막으로 끝나는 부분을 안다면 해당 부분을 데이터 소유자로 만들면 컴파일 시간에 적용되는 일반적인 소유권 규칙이 적용됩니다.\nRC는 단일 스레드 시나리오에서만 사용됩니다. 16장에서 동시성에 대해 논의할 때 다중 스레드 프로그램에서 참조 카운팅을 수행하는 방법을 다룰 것입니다.\nRc를 사용하여 데이터 공유\n목록 15-5의 cons 목록 예제로 돌아가 봅시다. Box를 사용하여 정의했음을 기억하십시오.`. 이번에는 세 번째 목록의 소유권을 공유하는 두 개의 목록을 만듭니다. 개념적으로 이것은 그림 15-3과 유사합니다.\n\n그림 15-3: 세 번째 목록인 a의 소유권을 공유하는 두 개의 목록 b와 c\n5와 10을 포함하는 목록 a를 만듭니다. 그런 다음 3으로 시작하는 b와 4로 시작하는 c라는 두 개의 목록을 더 만듭니다. b와 c 목록은 모두 그런 다음 5와 10을 포함하는 첫 번째 a 목록으로 계속 진행합니다. 즉, 두 목록은 5와 10을 포함하는 첫 번째 목록을 공유합니다.\n목록과 상자의 정의를 사용하여 이 시나리오를 구현하려고 합니다.`는 목록 15-17과 같이 작동하지 않습니다.\n파일 이름: src/main.rs\nenum List {\n    Cons(i32, Box&lt;List&gt;),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\n\nfn main() {\n    let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));\n    let b = Cons(3, Box::new(a));\n    let c = Cons(4, Box::new(a));\n}\n\n목록 15-17: Box를 사용하여 두 개의 목록을 가질 수 없음을 보여줍니다.` 세 번째 목록의 소유권을 공유하려는\n이 코드를 컴파일하면 다음 오류가 발생합니다.\n$ cargo run\n   Compiling cons-list v0.1.0 (file:///projects/cons-list)\nerror[E0382]: use of moved value: `a`\n  --&gt; src/main.rs:11:30\n   |\n9  |     let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));\n   |         - move occurs because `a` has type `List`, which does not implement the `Copy` trait\n10 |     let b = Cons(3, Box::new(a));\n   |                              - value moved here\n11 |     let c = Cons(4, Box::new(a));\n   |                              ^ value used here after move\n\nFor more information about this error, try `rustc --explain E0382`.\nerror: could not compile `cons-list` due to previous error\n\nCons 변형은 보유한 데이터를 소유하므로 b 목록을 만들 때 a는 b로 이동되고 b는 a를 소유합니다. 그런 다음 c를 만들 때 a를 다시 사용하려고 하면 a가 이동되었기 때문에 허용되지 않습니다.\n대신 참조를 보유하도록 Cons의 정의를 변경할 수 있지만, 그러면 수명 매개변수를 지정해야 합니다. 수명 매개변수를 지정하면 목록의 모든 요소가 최소한 전체 목록만큼 오래 지속되도록 지정할 수 있습니다. Listing 15-17에 있는 요소와 목록의 경우이지만 모든 시나리오에 해당되는 것은 아닙니다.\n대신 List의 정의를 Rc를 사용하도록 변경합니다.대신상자, 목록 15-18에 표시된 것처럼 각 Cons변형은 이제 값과Rc는 목록을 가리킵니다. a의 소유권을 가져오는 대신 b를 만들 때 Rc를 복제합니다.는 a가 보유하고 있으므로 참조 수가 1에서 2로 증가하고 a와 b가 해당 Rc의 데이터 소유권을 공유하도록 합니다.. 또한 c를 생성할 때 a를 복제하여 참조 수를 2개에서 3개로 늘립니다. Rc::clone을 호출할 때마다 Rc 내의 데이터에 대한 참조 카운트가`가 증가하고 데이터에 대한 참조가 0이 아닌 한 데이터가 정리되지 않습니다.\n파일 이름: src/main.rs\nenum List {\n    Cons(i32, Rc&lt;List&gt;),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\nuse std::rc::Rc;\n\nfn main() {\n    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));\n    let b = Cons(3, Rc::clone(&amp;a));\n    let c = Cons(4, Rc::clone(&amp;a));\n}\n\nListing 15-18: Rc를 사용하는 List의 정의`\nRc를 가져오려면 use 문을 추가해야 합니다.는 prelude에 없기 때문에 범위에 포함됩니다. main에서 5와 10을 포함하는 목록을 만들고 새 Rc에 저장합니다.그런 다음 b와 c를 만들 때 Rc::clone함수를 호출하고Rc에 대한 참조를 전달합니다.에서 a를 인수로 사용합니다.\n우리는 Rc::clone(&amp;a) 대신 a.clone()을 호출할 수 있었지만, Rust의 관례는 이 경우 Rc::clone을 사용하는 것입니다. Rc::clone 구현은 대부분의 유형의 clone 구현처럼 모든 데이터의 전체 복사본을 만들지 않습니다. Rc::clone에 대한 호출은 참조 횟수를 증가시킬 뿐이며 시간이 많이 걸리지 않습니다. 데이터의 깊은 복사본은 많은 시간이 걸릴 수 있습니다. 참조 카운팅에 Rc::clone을 사용하면 딥 카피 종류의 클론과 참조 카운트를 증가시키는 종류의 클론을 시각적으로 구분할 수 있습니다. 코드에서 성능 문제를 찾을 때 딥 카피 클론만 고려하면 되며 Rc::clone에 대한 호출을 무시할 수 있습니다.\nRc를 복제하면 참조 횟수가 증가합니다.\n목록 15-18의 작업 예제를 변경하여 Rc에 대한 참조를 생성하고 삭제할 때 참조 횟수가 변경되는 것을 볼 수 있습니다. 안에.\n목록 15-19에서 목록 c 주위에 내부 범위를 갖도록 main을 변경할 것입니다. 그런 다음 c가 범위를 벗어날 때 참조 횟수가 어떻게 변경되는지 확인할 수 있습니다.\n파일 이름: src/main.rs\nfn main() {\n    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));\n    println!(`count after creating a = {}`, Rc::strong_count(&amp;a));\n    let b = Cons(3, Rc::clone(&amp;a));\n    println!(`count after creating b = {}`, Rc::strong_count(&amp;a));\n    {\n        let c = Cons(4, Rc::clone(&amp;a));\n        println!(`count after creating c = {}`, Rc::strong_count(&amp;a));\n    }\n    println!(`count after c goes out of scope = {}`, Rc::strong_count(&amp;a));\n}\n\nListing 15-19: 참조 카운트 출력하기\n참조 카운트가 변경되는 프로그램의 각 지점에서 Rc::strong_count 함수를 호출하여 얻은 참조 카운트를 인쇄합니다. 이 함수의 이름은 count가 아니라 strong_count입니다.[유형에는weak_count도 있습니다. 참조 순환 방지: Rc를 약한으로 바꾸기](https://doc.rust-lang.org/book/ch15-06-reference-cycles.html#preventing-reference-cycles-turning-an-rct-into-a-weakt) 섹션 에서 weak_count`가 사용되는 것을 볼 수 있습니다.\n이 코드는 다음을 인쇄합니다.\n$ cargo run\n   Compiling cons-list v0.1.0 (file:///projects/cons-list)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.45s\n     Running `target/debug/cons-list`\ncount after creating a = 1\ncount after creating b = 2\ncount after creating c = 3\ncount after c goes out of scope = 2\n\n우리는 Rca의 초기 참조 횟수는 1입니다. 그런 다음 clone을 호출할 때마다 횟수가 1씩 증가합니다. c가 범위를 벗어나면 횟수가 1씩 감소합니다. 참조 카운트를 늘리기 위해 Rc::clone을 호출해야 하는 것처럼 참조 카운트를 줄이는 함수를 호출하려면: Drop특성의 구현은Rc` 값이 범위를 벗어납니다.\n이 예에서 볼 수 없는 것은 b와 a가 main의 끝에서 범위를 벗어나면 카운트가 0이 되고 Rc가 완전히 정리됩니다. Rc를 사용하여는 단일 값이 여러 소유자를 가질 수 있도록 허용하며 개수는 소유자가 여전히 존재하는 한 값이 유효한 상태로 유지되도록 합니다.\n불변 참조를 통해 Rc를 사용하면 읽기 전용으로 프로그램의 여러 부분 간에 데이터를 공유할 수 있습니다. Rc 변경 가능한 참조를 여러 개 가질 수 있도록 허용하면 4장에서 논의한 차용 규칙 중 하나를 위반할 수 있습니다. 섹션에서는 내부 가변성 패턴과 RefCell Rc와 함께 사용할 수 있는 유형 이 불변성 제한에 대해 작업합니다.\n\nRefCell 및 내부 가변성 패턴\n내부 가변성은 해당 데이터에 대한 불변 참조가 있는 경우에도 데이터를 변경할 수 있도록 하는 Rust의 디자인 패턴입니다. 일반적으로 이 작업은 차용 규칙에 의해 허용되지 않습니다. 데이터를 변경하기 위해 패턴은 데이터 구조 내에서 안전하지 않은 코드를 사용하여 변경 및 차용을 제어하는 Rust의 일반적인 규칙을 구부립니다. 안전하지 않은 코드는 규칙을 확인하기 위해 컴파일러에 의존하는 대신 수동으로 규칙을 확인하고 있음을 컴파일러에 나타냅니다. 19장에서 안전하지 않은 코드에 대해 더 논의할 것입니다.\n컴파일러가 보장할 수 없더라도 런타임 시 차용 규칙을 따를 것임을 보장할 수 있는 경우에만 내부 가변성 패턴을 사용하는 유형을 사용할 수 있습니다. 관련된 안전하지 않은 코드는 안전한 API로 래핑되며 외부 유형은 여전히 변경할 수 없습니다.\nRefCell을 살펴보고 이 개념을 살펴보겠습니다.` 내부 가변성 패턴을 따르는 유형입니다.\nRefCell을 사용하여 런타임에 차용 규칙 적용\nRc와 달리, 레프셀 유형은 보유한 데이터에 대한 단일 소유권을 나타냅니다. 따라서 RefCell는 Box와 같은 유형과 다릅니다.? 4장에서 배운 차용 규칙을 기억해 보십시오.\n\n주어진 시간에 하나의 변경 가능한 참조 또는 임의의 수의 변경 불가능한 참조 중 하나(둘 다는 아님)를 가질 수 있습니다 .\n참조는 항상 유효해야 합니다.\n\n참조 및 상자, 차용 규칙의 불변성은 컴파일 타임에 적용됩니다. RefCell*, 이러한 불변성은 런타임 시* 적용됩니다. 참조를 사용하여 이러한 규칙을 위반하면 컴파일러 오류가 발생합니다. RefCell, 이 규칙을 어기면 프로그램이 패닉 상태가 되어 종료됩니다.\n컴파일 시간에 차용 규칙을 확인하면 개발 프로세스에서 오류가 더 빨리 발견되고 모든 분석이 사전에 완료되기 때문에 런타임 성능에 영향을 미치지 않는다는 장점이 있습니다. 이러한 이유로 컴파일 시간에 차용 규칙을 확인하는 것이 대부분의 경우 최선의 선택이며 이것이 Rust의 기본값인 이유입니다.\n대신 런타임에 차용 규칙을 확인하는 것의 이점은 특정 메모리 안전 시나리오가 허용된다는 것입니다. 이 시나리오는 컴파일 타임 검사에서 허용되지 않습니다. Rust 컴파일러와 같은 정적 분석은 본질적으로 보수적입니다. 코드의 일부 속성은 코드를 분석하여 감지하는 것이 불가능합니다. 가장 유명한 예는 정지 문제입니다. 이 문제는 이 책의 범위를 벗어나지만 흥미로운 연구 주제입니다.\n일부 분석은 불가능하기 때문에 Rust 컴파일러가 코드가 소유권 규칙을 준수하는지 확신할 수 없으면 올바른 프로그램을 거부할 수 있습니다. 이런 식으로 보수적입니다. Rust가 잘못된 프로그램을 수락하면 사용자는 Rust가 제공하는 보증을 신뢰할 수 없습니다. 그러나 Rust가 올바른 프로그램을 거부하면 프로그래머가 불편을 겪을 뿐 치명적인 일은 발생하지 않습니다. RefCell 유형은 코드가 차용 규칙을 따르는 것이 확실하지만 컴파일러가 이를 이해하고 보장할 수 없을 때 유용합니다.\n유사 콘텐츠 RC, 레프셀는 단일 스레드 시나리오에서만 사용되며 다중 스레드 컨텍스트에서 사용하려고 하면 컴파일 타임 오류가 발생합니다. RefCell의 기능을 얻는 방법에 대해 이야기하겠습니다. 16장의 다중 스레드 프로그램에서.\n다음은 박스를 선택해야 하는 이유를 요약한 것입니다., RC또는참조 셀`:\n\nRC는 동일한 데이터의 여러 소유자를 활성화합니다. 상자 및 참조 셀독신 소유자가 있습니다.\n상자 컴파일 시간에 확인된 불변 또는 가변 차용을 허용합니다. Rc 컴파일 시간에 확인된 불변 차용만 허용합니다. RefCell 런타임에 확인된 불변 또는 가변 차용을 허용합니다.\n왜냐하면 레프셀 런타임에 확인된 변경 가능한 차용을 허용합니다. RefCell 내부의 값을 변경할 수 있습니다. RefCell는 불변입니다.\n\n변경할 수 없는 값 내부의 값을 변경하는 것이 내부 변경 가능 패턴입니다. 내부 가변성이 유용한 상황을 살펴보고 이것이 어떻게 가능한지 살펴보겠습니다.\n내부 가변성: 불변 가치에 대한 가변 차용\n차용 규칙의 결과는 불변의 가치를 가지고 있을 때 그것을 가변적으로 차용할 수 없다는 것입니다. 예를 들어 다음 코드는 컴파일되지 않습니다.\nfn main() {\n    let x = 5;\n    let y = &amp;mut x;\n}\n\n이 코드를 컴파일하려고 하면 다음 오류가 발생합니다.\n$ cargo run\n   Compiling borrowing v0.1.0 (file:///projects/borrowing)\nerror[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable\n --&gt; src/main.rs:3:13\n  |\n2 |     let x = 5;\n  |         - help: consider changing this to be mutable: `mut x`\n3 |     let y = &amp;mut x;\n  |             ^^^^^^ cannot borrow as mutable\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `borrowing` due to previous error\n\n그러나 값이 해당 메서드에서 자체적으로 변경되지만 다른 코드에서는 변경할 수 없는 것처럼 보이는 것이 유용한 상황이 있습니다. 값의 메서드 외부에 있는 코드는 값을 변경할 수 없습니다. 참조 셀 사용는 내부 가변성을 가질 수 있는 능력을 얻는 한 가지 방법이지만 RefCell는 차용 규칙을 완전히 우회하지 않습니다. 컴파일러의 차용 검사기는 이 내부 가변성을 허용하고 차용 규칙은 대신 런타임에 검사됩니다. 규칙을 위반하면 패닉! 컴파일러 오류.\nRefCell을 사용할 수 있는 실용적인 예를 살펴보겠습니다.` 변경 불가능한 값을 변경하고 이것이 유용한 이유를 확인합니다.\n내부 가변성에 대한 사용 사례: 모의 객체\n때때로 테스트 중에 프로그래머는 특정 동작을 관찰하고 올바르게 구현되었는지 확인하기 위해 다른 유형 대신 유형을 사용합니다. 이 자리 표시자 유형을 테스트 double 이라고 합니다. 사람이 개입하여 특정 까다로운 장면을 연기하기 위해 배우를 대신하는 영화 제작의 스턴트 더블의 의미로 생각하십시오. 테스트 더블은 테스트를 실행할 때 다른 유형을 나타냅니다. 모의 개체는 테스트 중에 발생하는 일을 기록하는 특정 유형의 테스트 복식이므로 올바른 작업이 수행되었음을 확인할 수 있습니다.\nRust에는 다른 언어에 객체가 있는 것과 같은 의미의 객체가 없으며 Rust에는 일부 다른 언어처럼 표준 라이브러리에 내장된 모의 객체 기능이 없습니다. 그러나 모의 개체와 동일한 목적을 제공하는 구조체를 확실히 만들 수 있습니다.\n테스트할 시나리오는 다음과 같습니다. 최대값에 대한 값을 추적하고 현재 값이 최대값에 얼마나 가까운지에 따라 메시지를 보내는 라이브러리를 만듭니다. 이 라이브러리는 예를 들어 허용된 API 호출 수에 대한 사용자 할당량을 추적하는 데 사용할 수 있습니다.\n우리 라이브러리는 최대값에 얼마나 근접했는지, 어떤 메시지가 어떤 시간에 있어야 하는지 추적하는 기능만 제공합니다. 우리 라이브러리를 사용하는 응용 프로그램은 메시지를 보내는 메커니즘을 제공할 것으로 예상됩니다. 응용 프로그램은 응용 프로그램에 메시지를 넣거나 전자 메일을 보내거나 문자 메시지를 보내는 등의 작업을 수행할 수 있습니다. 도서관은 그 세부 사항을 알 필요가 없습니다. 필요한 것은 우리가 제공할 메신저라는 특성을 구현하는 것입니다. Listing 15-20은 라이브러리 코드를 보여줍니다:\n파일 이름: src/lib.rs\npub trait Messenger {\n    fn send(&amp;self, msg: &amp;str);\n}\n\npub struct LimitTracker&lt;`a, T: Messenger&gt; {\n    messenger: &amp;`a T,\n    value: usize,\n    max: usize,\n}\n\nimpl&lt;`a, T&gt; LimitTracker&lt;`a, T&gt;\nwhere\n    T: Messenger,\n{\n    pub fn new(messenger: &amp;`a T, max: usize) -&gt; LimitTracker&lt;`a, T&gt; {\n        LimitTracker {\n            messenger,\n            value: 0,\n            max,\n        }\n    }\n\n    pub fn set_value(&amp;mut self, value: usize) {\n        self.value = value;\n\n        let percentage_of_max = self.value as f64 / self.max as f64;\n\n        if percentage_of_max &gt;= 1.0 {\n            self.messenger.send(`Error: You are over your quota!`);\n        } else if percentage_of_max &gt;= 0.9 {\n            self.messenger\n                .send(`Urgent warning: You`ve used up over 90% of your quota!`);\n        } else if percentage_of_max &gt;= 0.75 {\n            self.messenger\n                .send(`Warning: You`ve used up over 75% of your quota!`);\n        }\n    }\n}\n\n목록 15-20: 값이 최대값에 얼마나 가까운지 추적하고 값이 특정 수준에 도달하면 경고하는 라이브러리\n이 코드의 한 가지 중요한 부분은 Messenger 특성에 self 및 메시지 텍스트에 대한 불변 참조를 취하는 send라는 메서드가 하나 있다는 것입니다. 이 특성은 모의 객체가 실제 객체와 동일한 방식으로 사용될 수 있도록 구현해야 하는 인터페이스입니다. 다른 중요한 부분은 LimitTracker에서 set_value 메서드의 동작을 테스트하려는 것입니다. value 매개변수에 대해 전달하는 내용을 변경할 수 있지만 set_value는 어설션을 만들기 위해 아무 것도 반환하지 않습니다. Messenger 특성과 max에 대한 특정 값을 구현하는 것으로 LimitTracker를 생성하면 value에 다른 숫자를 전달할 때\n우리는 send를 호출할 때 이메일이나 문자 메시지를 보내는 대신 전송하라는 메시지만 추적하는 모의 개체가 필요합니다. 모의 개체의 새 인스턴스를 만들고, 모의 개체를 사용하는 LimitTracker를 만들고, LimitTracker에서 set_value 메서드를 호출한 다음, 모의 개체에 우리가 기대하는 메시지가 있는지 확인할 수 있습니다. Listing 15-21은 이를 수행하기 위해 모의 객체를 구현하려는 시도를 보여주지만 빌리기 검사기는 이를 허용하지 않습니다:\n파일 이름: src/lib.rs\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    struct MockMessenger {\n        sent_messages: Vec&lt;String&gt;,\n    }\n\n    impl MockMessenger {\n        fn new() -&gt; MockMessenger {\n            MockMessenger {\n                sent_messages: vec![],\n            }\n        }\n    }\n\n    impl Messenger for MockMessenger {\n        fn send(&amp;self, message: &amp;str) {\n            self.sent_messages.push(String::from(message));\n        }\n    }\n\n    #[test]\n    fn it_sends_an_over_75_percent_warning_message() {\n        let mock_messenger = MockMessenger::new();\n        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);\n\n        limit_tracker.set_value(80);\n\n        assert_eq!(mock_messenger.sent_messages.len(), 1);\n    }\n}\n\nListing 15-21: 빌림 검사기가 허용하지 않는 MockMessenger 구현 시도\n이 테스트 코드는 전송하라는 메시지를 추적하기 위해 String 값의 Vec가 있는 sent_messages 필드가 있는 MockMessenger 구조체를 정의합니다. 또한 빈 메시지 목록으로 시작하는 새로운 MockMessenger 값을 생성하는 것이 편리하도록 관련 함수 new를 정의합니다. 그런 다음 MockMessenger에 대한 Messenger 특성을 구현하여 LimitTracker에 MockMessenger를 제공할 수 있습니다. send 메소드의 정의에서 매개변수로 전달된 메시지를 sent_messages의 MockMessenger 목록에 저장합니다.\n테스트에서 LimitTracker가 최대 값의 75%보다 큰 값으로 값을 설정하라는 지시를 받았을 때 어떤 일이 발생하는지 테스트하고 있습니다. 먼저 빈 메시지 목록으로 시작할 새 MockMessenger를 만듭니다. 그런 다음 새 LimitTracker를 만들고 새 MockMessenger에 대한 참조와 100의 최대 값을 제공합니다. LimitTracker에서 set_value 메서드를 80의 값으로 호출합니다. 100의 75%. 그런 다음 MockMessenger가 추적하고 있는 메시지 목록에 이제 하나의 메시지가 있어야 한다고 주장합니다.\n그러나 이 테스트에는 다음과 같은 한 가지 문제가 있습니다.\n$ cargo test\n   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)\nerror[E0596]: cannot borrow `self.sent_messages` as mutable, as it is behind a `&amp;` reference\n  --&gt; src/lib.rs:58:13\n   |\n2  |     fn send(&amp;self, msg: &amp;str);\n   |             ----- help: consider changing that to be a mutable reference: `&amp;mut self`\n...\n58 |             self.sent_messages.push(String::from(message));\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `self` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `limit-tracker` due to previous error\nwarning: build failed, waiting for other jobs to finish...\n\n메시지를 추적하기 위해 MockMessenger를 수정할 수 없습니다. send 메서드가 self에 대한 불변 참조를 사용하기 때문입니다. 또한 &amp;mut self를 대신 사용하라는 오류 텍스트의 제안을 받아들일 수 없습니다. 왜냐하면 send의 서명이 Messenger 특성 정의의 서명과 일치하지 않기 때문입니다. 받는 메시지).\n이것은 내부 가변성이 도움이 될 수 있는 상황입니다! RefCell 내에 sent_messages를 저장합니다., 그리고 나서 send메소드는 우리가 본 메시지를 저장하기 위해sent_messages`를 수정할 수 있을 것입니다. 목록 15-22는 그 모습을 보여줍니다:\n파일 이름: src/lib.rs\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use std::cell::RefCell;\n\n    struct MockMessenger {\n        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,\n    }\n\n    impl MockMessenger {\n        fn new() -&gt; MockMessenger {\n            MockMessenger {\n                sent_messages: RefCell::new(vec![]),\n            }\n        }\n    }\n\n    impl Messenger for MockMessenger {\n        fn send(&amp;self, message: &amp;str) {\n            self.sent_messages.borrow_mut().push(String::from(message));\n        }\n    }\n\n    #[test]\n    fn it_sends_an_over_75_percent_warning_message() {\n        // --snip--\n\n        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);\n    }\n}\n\nListing 15-22: RefCell 사용하기 외부 값은 변경할 수 없는 것으로 간주하면서 내부 값을 변경합니다.\nsent_messages 필드는 이제 RefCell&lt;Vec 유형입니다.&gt; 대신 Vec. new 함수에서 새로운 RefCell&lt;Vec&gt; 빈 벡터 주위의 인스턴스.\nsend 메소드 구현을 위해 첫 번째 매개변수는 여전히 특성 정의와 일치하는 self의 불변 차용입니다. RefCell&lt;Vec에서 borrow_mut을 호출합니다.&gt; self.sent_messages에서 RefCell&lt;Vec 내부의 값에 대한 변경 가능한 참조를 가져옵니다.&gt;, 벡터입니다. 그런 다음 테스트 중에 전송된 메시지를 추적하기 위해 벡터에 대한 가변 참조에서 푸시`를 호출할 수 있습니다.\n우리가 해야 할 마지막 변경은 어설션에 있습니다. 내부 벡터에 얼마나 많은 항목이 있는지 확인하기 위해 RefCell&lt;Vec에서 borrow를 호출합니다.&gt;` 벡터에 대한 불변 참조를 가져옵니다.\n이제 RefCell을 사용하는 방법을 살펴보았습니다.`, 어떻게 작동하는지 파헤쳐 봅시다!\nRefCell을 사용하여 런타임에 빌림 추적\n불변 및 가변 참조를 생성할 때 각각 &amp; 및 &amp;mut 구문을 사용합니다. 레프셀, 우리는 RefCell에 속한 안전한 API의 일부인 borrow및borrow_mut 메소드를 사용합니다.. borrow 메서드는 스마트 포인터 유형 Ref 및 borrow_mut은 스마트 포인터 유형 RefMut을 반환합니다.. 두 유형 모두 Deref`를 구현하므로 일반 참조처럼 취급할 수 있습니다.\nRefCell는 얼마나 많은 Ref를 추적합니다. 및 RefMut 스마트 포인터가 현재 활성화되어 있습니다. 빌려를 호출할 때마다 RefCell 활성화된 변경 불가능한 차용 횟수를 증가시킵니다. Ref 값이 범위를 벗어나면 변경할 수 없는 차용 횟수가 하나씩 줄어듭니다. 컴파일 타임 차용 규칙과 마찬가지로 RefCell언제든지 많은 불변 차용 또는 하나의 가변 차용을 가질 수 있습니다.\n이러한 규칙을 위반하려고 하면 참조와 마찬가지로 컴파일러 오류가 발생하지 않고 RefCell는 런타임 시 패닉 상태가 됩니다. 목록 15-23은 목록 15-22의 send 구현 수정을 보여줍니다. 우리는 RefCell 런타임에 이 작업을 수행하지 못하게 합니다.\n파일 이름: src/lib.rs\n    impl Messenger for MockMessenger {\n        fn send(&amp;self, message: &amp;str) {\n            let mut one_borrow = self.sent_messages.borrow_mut();\n            let mut two_borrow = self.sent_messages.borrow_mut();\n\n            one_borrow.push(String::from(message));\n            two_borrow.push(String::from(message));\n        }\n    }\n\n목록 15-23: RefCell 당황 할 것\nRefMut에 대한 one_borrow 변수를 생성합니다. borrow_mut에서 스마트 포인터가 반환되었습니다. 그런 다음 two_borrow` 변수에서 동일한 방식으로 또 다른 변경 가능한 차용을 생성합니다. 이렇게 하면 동일한 범위에서 두 개의 변경 가능한 참조가 생성되며 이는 허용되지 않습니다. 라이브러리에 대한 테스트를 실행할 때 , 목록 15-23의 코드는 오류 없이 컴파일되지만 테스트는 실패합니다.\n$ cargo test\n   Compiling limit-tracker v0.1.0 (file:///projects/limit-tracker)\n    Finished test [unoptimized + debuginfo] target(s) in 0.91s\n     Running unittests src/lib.rs (target/debug/deps/limit_tracker-e599811fa246dbde)\n\nrunning 1 test\ntest tests::it_sends_an_over_75_percent_warning_message ... FAILED\n\nfailures:\n\n---- tests::it_sends_an_over_75_percent_warning_message stdout ----\nthread `tests::it_sends_an_over_75_percent_warning_message` panicked at `already borrowed: BorrowMutError`, src/lib.rs:60:53\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\n\nfailures:\n    tests::it_sends_an_over_75_percent_warning_message\n\ntest result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s\n\nerror: test failed, to rerun pass `--lib`\n\n이미 빌린 것: BorrowMutError라는 메시지와 함께 코드가 패닉에 빠진 것을 주목하세요. 이것이 RefCell 런타임 시 차용 규칙 위반을 처리합니다.\n여기에서 수행한 것처럼 컴파일 시간이 아닌 런타임에 차용 오류를 포착하도록 선택하면 개발 프로세스 후반에 코드에서 잠재적으로 실수를 발견할 수 있음을 의미합니다. 아마도 코드가 프로덕션에 배포될 때까지는 발견되지 않을 것입니다. 또한 코드는 컴파일 시간이 아닌 런타임에 차용을 추적한 결과로 약간의 런타임 성능 저하를 초래합니다. 그러나 RefCell을 사용하여를 사용하면 변경 불가능한 값만 허용되는 컨텍스트에서 사용하는 동안 본 메시지를 추적하기 위해 스스로 수정할 수 있는 모의 개체를 작성할 수 있습니다. RefCell을 사용할 수 있습니다. 일반 참조가 제공하는 것보다 더 많은 기능을 얻기 위한 절충에도 불구하고.\nRc와 RefCell을 결합하여 가변 데이터의 다중 소유자 보유\nRefCell을 사용하는 일반적인 방법는 Rc. Rc를 사용하면 일부 데이터의 소유자가 여러 명일 수 있지만 해당 데이터에 대한 변경 불가능한 액세스만 제공합니다. Rc가 있는 경우는 RefCell*`, 여러 소유자를 가질 수 있고* 변경할 수 있는 값을 얻을 수 있습니다 !\n예를 들어, Listing 15-18에서 우리가 Rc 여러 목록이 다른 목록의 소유권을 공유하도록 허용합니다. 왜냐하면 Rc는 변경할 수 없는 값만 보유하므로 일단 생성한 목록의 값을 변경할 수 없습니다. RefCell에 추가해 보겠습니다.를 사용하여 목록의 값을 변경할 수 있습니다. 목록 15-24는 RefCell Cons 정의에서 모든 목록에 저장된 값을 수정할 수 있습니다.\n파일 이름: src/main.rs\n#[derive(Debug)]\nenum List {\n    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),\n    Nil,\n}\n\nuse crate::List::{Cons, Nil};\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\nfn main() {\n    let value = Rc::new(RefCell::new(5));\n\n    let a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));\n\n    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&amp;a));\n    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&amp;a));\n\n    *value.borrow_mut() += 10;\n\n    println!(`a after = {:?}`, a);\n    println!(`b after = {:?}`, b);\n    println!(`c after = {:?}`, c);\n}\n\nListing 15-24: Rc&lt;RefCell 사용하기&gt; 변경 가능한 목록 생성\n우리는 Rc&lt;RefCell&gt; 그리고 나중에 직접 액세스할 수 있도록 value라는 변수에 저장합니다. 그런 다음 value를 보유하는 Cons 변형을 사용하여 a에 List를 만듭니다. value를 복제해야 합니다. 따라서 a와 value는 value에서 a로 소유권을 이전하거나 a가 value에서 차용하는 대신 내부 5 값의 소유권을 갖습니다.\n목록 a를 Rc로 래핑합니다.따라서 목록b와 c를 만들 때 목록 15-18에서 수행한 것과 같이 둘 다 a`를 참조할 수 있습니다.\na, b 및 c에 목록을 만든 후 value의 값에 10을 추가하려고 합니다. value에서 borrow_mut를 호출하여 이를 수행합니다. 이 기능은 5장에서 논의한 자동 역참조 기능을 사용합니다( [-&gt; 연산자는 어디에 있습니까?](https://doc.rust-lang.org/book/ch05-03-method-syntax.html#wheres-the---operator) 절 참조).를 내부 RefCell 값. borrow_mut 메서드는 RefMut 스마트 포인터에 역참조 연산자를 사용하고 내부 값을 변경합니다.\na, b 및 c를 인쇄하면 모두 5가 아닌 15의 수정된 값을 갖는 것을 볼 수 있습니다.\n$ cargo run\n   Compiling cons-list v0.1.0 (file:///projects/cons-list)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.63s\n     Running `target/debug/cons-list`\na after = Cons(RefCell { value: 15 }, Nil)\nb after = Cons(RefCell { value: 3 }, Cons(RefCell { value: 15 }, Nil))\nc after = Cons(RefCell { value: 4 }, Cons(RefCell { value: 15 }, Nil))\n\n이 기술은 꽤 깔끔합니다! RefCell을 사용하여, 우리는 외부적으로 불변의 목록 값을 가지고 있습니다. 그러나 우리는 RefCell의 메소드를 사용할 수 있습니다.내부 변경 가능성에 대한 액세스를 제공하므로 필요할 때 데이터를 수정할 수 있습니다. 차용 규칙의 런타임 검사는 데이터 경합으로부터 우리를 보호하며 때로는 데이터 구조의 이러한 유연성을 위해 약간의 속도를 거래할 가치가 있습니다. 참고 그RefCell멀티스레드 코드에서는 작동하지 않습니다!Mutex는 RefCell의 스레드 안전 버전입니다.그리고 우리는Mutex` 16장에서.\n\n참조 순환이 메모리를 누수할 수 있음\nRust의 메모리 안전 보장은 결코 정리되지 않는 메모리를 우발적으로 생성하는 것을 어렵게 만들지만 불가능하지는 않습니다(메모리 누수 로 알려짐 ). 메모리 누수를 완전히 방지하는 것은 Rust의 보증 중 하나가 아닙니다. 즉, 메모리 누수는 Rust에서 메모리에 안전합니다. Rust가 Rc를 사용하여 메모리 누수를 허용한다는 것을 알 수 있습니다.및참조 셀`: 주기에서 항목이 서로를 참조하는 참조를 생성할 수 있습니다. 주기에서 각 항목의 참조 횟수가 절대 0에 도달하지 않고 값이 삭제되지 않기 때문에 이로 인해 메모리 누수가 발생합니다.\n참조 순환 만들기\nListing 15-25에 있는 List 열거형과 tail 메서드의 정의부터 시작하여 참조 순환이 어떻게 발생하고 이를 방지하는 방법을 살펴보겠습니다.\n파일 이름: src/main.rs\nuse crate::List::{Cons, Nil};\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\n#[derive(Debug)]\nenum List {\n    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),\n    Nil,\n}\n\nimpl List {\n    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {\n        match self {\n            Cons(_, item) =&gt; Some(item),\n            Nil =&gt; None,\n        }\n    }\n}\n\nfn main() {}\n\n목록 15-25: RefCell을 보유하는 cons 목록 정의 Cons` 변형이 참조하는 것을 수정할 수 있습니다.\n우리는 목록 15-5에서 목록 정의의 또 다른 변형을 사용하고 있습니다. Cons 변형의 두 번째 요소는 이제 RefCell&lt;Rc&gt;, Listing 15-24에서 했던 것처럼 i32 값을 수정하는 기능 대신 Cons 변형이 가리키는 List 값을 수정하고 싶다는 의미입니다. Cons 변형이 있는 경우 두 번째 항목에 쉽게 액세스할 수 있도록 tail 메서드를 사용합니다.\nListing 15-26에서는 Listing 15-25의 정의를 사용하는 main 함수를 추가하고 있습니다. 이 코드는 a에 목록을 만들고 a의 목록을 가리키는 b에 목록을 만듭니다. 그런 다음 a의 목록을 b를 가리키도록 수정하여 참조 순환을 만듭니다. println!이 있습니다. 이 프로세스의 다양한 지점에서 참조 카운트가 무엇인지 보여주는 방법을 따라 설명합니다.\n파일 이름: src/main.rs\nfn main() {\n    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));\n\n    println!(`a initial rc count = {}`, Rc::strong_count(&amp;a));\n    println!(`a next item = {:?}`, a.tail());\n\n    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&amp;a))));\n\n    println!(`a rc count after b creation = {}`, Rc::strong_count(&amp;a));\n    println!(`b initial rc count = {}`, Rc::strong_count(&amp;b));\n    println!(`b next item = {:?}`, b.tail());\n\n    if let Some(link) = a.tail() {\n        *link.borrow_mut() = Rc::clone(&amp;b);\n    }\n\n    println!(`b rc count after changing a = {}`, Rc::strong_count(&amp;b));\n    println!(`a rc count after changing a = {}`, Rc::strong_count(&amp;a));\n\n    // Uncomment the next line to see that we have a cycle;\n    // it will overflow the stack\n    // println!(`a next item = {:?}`, a.tail());\n}\n\n목록 15-26: 서로를 가리키는 두 개의 목록 값의 참조 순환 만들기\n우리는 Rc 초기 목록이 5, Nil인 변수 a에 목록 값을 보유하는 인스턴스. 그런 다음 Rc를 생성합니다.값 10을 포함하고 a의 목록을 가리키는 변수 b에 또 다른 목록 값을 보유하는 인스턴스.\na를 수정하여 Nil 대신 b를 가리키도록 하여 순환을 생성합니다. RefCell&lt;Rc에 대한 참조를 얻기 위해 tail 메서드를 사용하여 이를 수행합니다.a의 link변수에 넣은 다음RefCell&lt;Rc에서 borrow_mut 메서드를 사용합니다.&gt;는 Rc에서 내부 값을 변경합니다.는 Rc에 Nil 값을 보유합니다.에서 b.\n이 코드를 실행할 때 마지막 println! 잠시 동안 주석 처리하면 다음과 같은 결과가 표시됩니다.\n$ cargo run\n   Compiling cons-list v0.1.0 (file:///projects/cons-list)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.53s\n     Running `target/debug/cons-list`\na initial rc count = 1\na next item = Some(RefCell { value: Nil })\na rc count after b creation = 2\nb initial rc count = 1\nb next item = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })\nb rc count after changing a = 2\na rc count after changing a = 2\n\nRc의 참조 횟수 a의 목록을 b를 가리키도록 변경한 후 a와 b의 인스턴스는 모두 2입니다. main의 끝에서 Rust는 참조 횟수를 줄이는 변수 b를 삭제합니다. b Rc의 인스턴스를 2에서 1로. Rc는 참조 횟수가 0이 아니라 1이기 때문에 이 시점에서 삭제되지 않습니다. 그런 다음 Rust는 a를 삭제하고 a Rc의 참조 횟수를 줄입니다. 인스턴스도 2에서 1로 변경합니다. 이 인스턴스의 메모리도 삭제할 수 없습니다. 왜냐하면 다른 Rc 인스턴스는 여전히 그것을 참조합니다. 목록에 할당된 메모리는 영원히 수집되지 않은 상태로 유지됩니다. 이 참조 순환을 시각화하기 위해 그림 15-4에 다이어그램을 만들었습니다.\n\n그림 15-4: 서로를 가리키는 목록 a와 b의 참조 순환\n마지막 println! 그리고 프로그램을 실행하면 Rust는 a가 a를 가리키는 a를 가리키는 a로 이 주기를 인쇄하려고 시도할 것입니다. 스택을 넘칠 때까지 계속됩니다.\n실제 프로그램과 비교할 때 이 예에서 참조 순환을 생성하는 결과는 그리 심각하지 않습니다. 참조 순환을 생성한 직후 프로그램이 종료됩니다. 그러나 더 복잡한 프로그램이 한 주기에 많은 메모리를 할당하고 오랫동안 유지하면 프로그램은 필요한 것보다 더 많은 메모리를 사용하고 시스템을 압도하여 사용 가능한 메모리가 부족해질 수 있습니다.\n참조 순환을 만드는 것은 쉬운 일이 아니지만 불가능한 일도 아닙니다. RefCell이 있는 경우 Rc를 포함하는 값` 값 또는 내부 가변성과 참조 카운팅이 있는 유사한 유형의 중첩된 조합, 순환을 생성하지 않도록 해야 합니다. 이를 포착하기 위해 Rust에 의존할 수 없습니다. 참조 순환을 생성하는 것은 프로그램에서 논리 버그가 될 것입니다. 자동화된 테스트, 코드 검토 및 기타 소프트웨어 개발 방식을 사용하여 최소화해야 합니다.\n참조 순환을 피하는 또 다른 솔루션은 데이터 구조를 재구성하여 일부 참조는 소유권을 표현하고 일부 참조는 그렇지 않도록 하는 것입니다. 결과적으로 일부 소유권 관계와 일부 비소유 관계로 구성된 주기를 가질 수 있으며 소유권 관계만 값을 삭제할 수 있는지 여부에 영향을 미칩니다. 목록 15-25에서 우리는 항상 Cons 변형이 자신의 목록을 소유하기를 원하므로 데이터 구조를 재구성하는 것은 불가능합니다. 부모 노드와 자식 노드로 구성된 그래프를 사용하여 비소유 관계가 참조 순환을 방지하는 적절한 방법인 경우를 살펴보겠습니다.\n참조 순환 방지: Rc를 약한으로 바꾸기\n지금까지 Rc::clone을 호출하면 Rc의 strong_count가 증가한다는 것을 보여주었습니다.인스턴스 및Rc인스턴스는strong_count가 0인 경우에만 정리됩니다. Rc 내의 값에 대한 *약한 참조를* 만들 수도 있습니다. 인스턴스를 호출하여 Rc::downgrade를 호출하고 Rc에 대한 참조를 전달합니다.. 강력한 참조는 Rc의 소유권을 공유할 수 있는 방법입니다. 인스턴스. 약한 참조는 소유권 관계를 표현하지 않으며 Rc 인스턴스가 정리됩니다. 관련된 값의 강한 참조 수가 0이 되면 일부 약한 참조와 관련된 모든 순환이 중단되기 때문에 참조 순환이 발생하지 않습니다.\nRc::downgrade를 호출하면 Weak 유형의 스마트 포인터를 얻습니다.. Rc에서 strong_count를 늘리는 대신인스턴스를 1씩 늘리면Rc::downgrade를 호출하면 weak_count가 1씩 증가합니다. Rc유형은weak_count를 사용하여 약한 수를 추적합니다.strong_count와 유사한 참조가 존재합니다. 차이점은 weak_count가 Rc에 대해 0일 필요가 없다는 것입니다.` 정리할 인스턴스입니다.\n약한 참조가 삭제되어 약한가 가리키는 경우 값이 여전히 존재하는지 확인해야 합니다. 약한 인스턴스는 Option&lt;Rc&gt;. Rc 값은 아직 삭제되지 않았으며 Rc 값이 삭제되었습니다. upgrade가 Option&lt;Rc&gt;, Rust는 Some 사례와 None 사례가 처리되도록 하고 유효하지 않은 포인터가 없도록 합니다.\n예를 들어 항목이 다음 항목에 대해서만 알고 있는 목록을 사용하는 대신 자식 항목 과 부모 항목 에 대해 알고 있는 항목이 있는 트리를 만듭니다.\n트리 데이터 구조 만들기: 자식 노드가 있는 노드\n시작하려면 자식 노드에 대해 알고 있는 노드로 트리를 만듭니다. 자체 i32 값과 하위 Node 값에 대한 참조를 보유하는 Node라는 구조체를 생성합니다.\n파일 이름: src/main.rs\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\n#[derive(Debug)]\nstruct Node {\n    value: i32,\n    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,\n}\n\n우리는 노드가 자식을 소유하기를 원하고 그 소유권을 변수와 공유하여 트리의 각 노드에 직접 액세스할 수 있기를 원합니다. 이를 위해 Vec 유형 Rc의 값이 될 항목. 또한 어떤 노드가 다른 노드의 자식인지 수정하고 싶기 때문에 RefCell에서 Vec&lt;Rc 주위의 어린이&gt;.\n다음으로, 구조체 정의를 사용하여 값이 3이고 자식이 없는 leaf라는 Node 인스턴스 하나와 값이 5이고 자식 중 하나가 leaf인 branch라는 또 다른 인스턴스를 다음과 같이 만듭니다. 목록 15-27에 나와 있습니다:\n파일 이름: src/main.rs\nfn main() {\n    let leaf = Rc::new(Node {\n        value: 3,\n        children: RefCell::new(vec![]),\n    });\n\n    let branch = Rc::new(Node {\n        value: 5,\n        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),\n    });\n}\n\n목록 15-27: 자식이 없는 리프 노드와 자식 중 하나로 리프가 있는 브랜치 노드 만들기\n우리는 Rc를 리프에 저장하고 리프의 노드를 의미하는 브랜치에 저장하면 이제 리프와 브랜치라는 두 명의 소유자가 있습니다. 브랜치에서 브랜치를 통해 리프로 이동할 수 있습니다. leaf에서 branch로 이동할 방법이 없습니다. 그 이유는 leaf가 branch에 대한 참조가 없고 서로 관련되어 있다는 것을 모르기 때문입니다. 우리는 leaf가 그것을 알기를 원합니다. branch는 그 부모입니다. 다음에 그렇게 하겠습니다.\n자식에서 부모로 참조 추가\n자식 노드가 부모를 인식하게 하려면 Node 구조체 정의에 parent 필드를 추가해야 합니다. 문제는 `부모\"의 유형을 결정하는 데 있습니다. \"Rc\"를 포함할 수 없다는 것을 알고 있습니다.\"는 \"branch\"를 가리키는 \"leaf.parent\"와 \"leaf\"를 가리키는 \"branch.children\"이 있는 참조 순환을 생성하므로 \"strong_count\" 값이 0이 되지 않도록 합니다.\n관계를 다른 방식으로 생각하면 부모 노드는 자식을 소유해야 합니다. 부모 노드가 삭제되면 자식 노드도 삭제되어야 합니다. 그러나 자식은 부모를 소유해서는 안 됩니다. 자식 노드를 삭제해도 부모는 여전히 존재해야 합니다. 이것은 약한 참조의 경우입니다!\n따라서 \"Rc 대신\", 우리는 \"부모\"의 유형을 \"약함\"을 사용하도록 만들 것입니다.\", 특히 \"RefCell&lt;약함&gt;\". 이제 \"Node\" 구조체 정의는 다음과 같습니다.\n파일 이름: src/main.rs\nuse std::cell::RefCell;\nuse std::rc::{Rc, Weak};\n\n#[derive(Debug)]\nstruct Node {\n    value: i32,\n    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,\n    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,\n}\n\n노드는 부모 노드를 참조할 수 있지만 부모를 소유하지는 않습니다. 목록 15-28에서 우리는 이 새로운 정의를 사용하기 위해 \"main\"을 업데이트하여 \"leaf\" 노드가 부모인 \"branch\"를 참조할 수 있도록 합니다.\n파일 이름: src/main.rs\nfn main() {\n    let leaf = Rc::new(Node {\n        value: 3,\n        parent: RefCell::new(Weak::new()),\n        children: RefCell::new(vec![]),\n    });\n\n    println!(\"leaf parent = {:?}\", leaf.parent.borrow().upgrade());\n\n    let branch = Rc::new(Node {\n        value: 5,\n        parent: RefCell::new(Weak::new()),\n        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),\n    });\n\n    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);\n\n    println!(\"leaf parent = {:?}\", leaf.parent.borrow().upgrade());\n}\n\nListing 15-28: 상위 노드 \"branch\"에 대한 약한 참조가 있는 \"리프\" 노드\n\"리프\" 노드를 생성하는 것은 \"부모\" 필드를 제외하고 목록 15-27과 유사합니다. \"리프\"는 부모 없이 시작하므로 비어 있는 새 \"약한\"\" 참조 인스턴스.\n이 시점에서 \"업그레이드\" 메서드를 사용하여 \"리프\"의 부모에 대한 참조를 얻으려고 하면 \"없음\" 값을 얻습니다. 첫 번째 \"println!\"의 출력에서 이것을 볼 수 있습니다. 성명:\nleaf parent = None\n\n\"branch\" 노드를 생성하면 새로운 \"Weak\" 노드도 갖게 됩니다.\" \"branch\"에는 부모 노드가 없기 때문에 \"parent\" 필드의 참조. 우리는 여전히 \"branch\"의 자식 중 하나로 \"leaf\"를 가지고 있습니다. \"branch\"에 \"Node\" 인스턴스가 있으면 \"잎\"을 수정하여 \"약함\"을 줄 수 있습니다.\" 참조. 우리는 \"RefCell\"를 \"leaf\"의 \"parent\" 필드에 넣은 다음 \"Rc::downgrade\" 함수를 사용하여 \"Weak\" \"Rc에서 \"분기\" 참조\"에서 \"지점.\"\n\"leaf\"의 부모를 다시 인쇄하면 이번에는 \"branch\"를 포함하는 \"Some\" 변형을 얻게 됩니다. 이제 \"leaf\"는 부모에 액세스할 수 있습니다! \"리프\"를 인쇄할 때 목록 15-26에서와 같이 결국 스택 오버플로로 끝나는 주기도 피합니다. 약한\" 참조는 \"(약함)\"으로 인쇄됩니다.\nleaf parent = Some(Node { value: 5, parent: RefCell { value: (Weak) },\nchildren: RefCell { value: [Node { value: 3, parent: RefCell { value: (Weak) },\nchildren: RefCell { value: [] } }] } })\n\n무한 출력이 없다는 것은 이 코드가 참조 순환을 생성하지 않았음을 나타냅니다. \"Rc::strong_count\" 및 \"Rc::weak_count\"를 호출하여 얻은 값을 보면 이를 알 수 있습니다.\n\"strong_count\" 및 \"weak_count\" 변경 사항 시각화\n\"Rc\"의 \"strong_count\" 및 \"weak_count\" 값이 어떻게 변하는지 살펴보겠습니다.\" 인스턴스는 새로운 내부 범위를 생성하고 \"branch\" 생성을 해당 범위로 이동하여 변경됩니다. 이렇게 하면 \"branch\"가 생성되고 범위를 벗어날 때 삭제되는 경우 발생하는 상황을 확인할 수 있습니다. 수정 사항이 표시됩니다. 목록 15-29에서:\n파일 이름: src/main.rs\nfn main() {\n    let leaf = Rc::new(Node {\n        value: 3,\n        parent: RefCell::new(Weak::new()),\n        children: RefCell::new(vec![]),\n    });\n\n    println!(\n        \"leaf strong = {}, weak = {}\",\n        Rc::strong_count(&amp;leaf),\n        Rc::weak_count(&amp;leaf),\n    );\n\n    {\n        let branch = Rc::new(Node {\n            value: 5,\n            parent: RefCell::new(Weak::new()),\n            children: RefCell::new(vec![Rc::clone(&amp;leaf)]),\n        });\n\n        *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);\n\n        println!(\n            \"branch strong = {}, weak = {}\",\n            Rc::strong_count(&amp;branch),\n            Rc::weak_count(&amp;branch),\n        );\n\n        println!(\n            \"leaf strong = {}, weak = {}\",\n            Rc::strong_count(&amp;leaf),\n            Rc::weak_count(&amp;leaf),\n        );\n    }\n\n    println!(\"leaf parent = {:?}\", leaf.parent.borrow().upgrade());\n    println!(\n        \"leaf strong = {}, weak = {}\",\n        Rc::strong_count(&amp;leaf),\n        Rc::weak_count(&amp;leaf),\n    );\n}\n\nListing 15-29: 내부 스코프에 \"브랜치\" 생성 및 강한 참조 카운트와 약한 참조 카운트 검사\n\"리프\"가 생성된 후 \"Rc\"는 1의 강한 카운트와 0의 약한 카운트를 가집니다. 내부 범위에서 우리는 \"브랜치\"를 만들고 \"리프\"와 연결합니다. 이 지점에서 카운트를 인쇄할 때 \"Rc\"branch\"에서 \"branch\"를 가리키는 \"leaf.parent\"의 경우 강한 수는 1이고 약한 수는 1입니다.\"). \"leaf\"에 카운트를 인쇄하면 \"branch\"가 이제 \"Rc\"branch.children\"에 저장된 \"leaf\"의 \"는 여전히 약한 카운트가 0입니다.\n내부 범위가 종료되면 \"분기\"가 범위를 벗어나 \"Rc\"의 강한 카운트\"가 0으로 감소하므로 \"Node\"가 삭제됩니다. \"leaf.parent\"의 약한 카운트 1은 \"Node\"가 삭제되었는지 여부와 관련이 없으므로 메모리 누수가 발생하지 않습니다!\n범위가 끝난 후 \"leaf\"의 부모에 액세스하려고 하면 \"None\"이 다시 표시됩니다. 프로그램의 끝에서 \"Rc\"leaf\"의 \"는 변수 \"leaf\"가 이제 \"Rc\"에 대한 유일한 참조이기 때문에 강한 카운트는 1이고 약한 카운트는 0입니다.\" 다시.\n카운트 및 값 삭제를 관리하는 모든 로직은 \"Rc\"에 내장되어 있습니다.\"와 \"약하다.\" 및 \"Drop\" 특성의 구현. 자식에서 부모로의 관계가 \"약함\"이어야 함을 지정함으로써\"노드\"의 정의에서 참조를 사용하면 참조 순환 및 메모리 누수를 생성하지 않고 상위 노드가 하위 노드를 가리키도록 할 수 있으며 그 반대도 가능합니다.\n요약\n이 장에서는 스마트 포인터를 사용하여 러스트가 일반 참조로 기본적으로 만드는 것과 다른 보증 및 장단점을 만드는 방법을 다루었습니다. 상자\" 유형은 알려진 크기를 가지며 힙에 할당된 데이터를 가리킵니다. \"Rc\" 유형은 데이터가 여러 소유자를 가질 수 있도록 힙의 데이터에 대한 참조 수를 추적합니다. \"RefCell\" 내부 변경 가능성이 있는 유형은 변경할 수 없는 유형이 필요하지만 해당 유형의 내부 값을 변경해야 할 때 사용할 수 있는 유형을 제공합니다. 또한 컴파일 시간이 아닌 런타임에 차용 규칙을 적용합니다.\n또한 스마트 포인터의 많은 기능을 가능하게 하는 \"Deref\" 및 \"Drop\" 특성에 대해서도 논의했습니다. 메모리 누수를 일으킬 수 있는 참조 순환과 \"약함\"을 사용하여 이를 방지하는 방법을 살펴보았습니다.\".\n이 장이 당신의 관심을 불러일으켰고 자신만의 스마트 포인터를 구현하고 싶다면 \"The Rustonomicon\" 에서 더 유용한 정보를 확인하십시오.\n다음으로 Rust의 동시성에 대해 이야기하겠습니다. 몇 가지 새로운 스마트 포인터에 대해서도 배우게 됩니다.\n\n16\n두려움 없는 동시성\n동시 프로그래밍을 안전하고 효율적으로 처리하는 것은 Rust의 주요 목표 중 하나입니다. 프로그램 의 다른 부분이 독립적으로 실행되는 동시 프로그래밍과 프로그램의 다른 부분이 동시에 실행되는 병렬 프로그래밍은 더 많은 컴퓨터가 다중 프로세서를 활용함에 따라 점점 더 중요해지고 있습니다. 역사적으로 이러한 맥락에서 프로그래밍하는 것은 어렵고 오류가 발생하기 쉽습니다. Rust는 이를 변경하기를 희망합니다.\n처음에 Rust 팀은 메모리 안전을 보장하는 것과 동시성 문제를 방지하는 것이 서로 다른 방법으로 해결해야 할 두 가지 별도의 과제라고 생각했습니다. 시간이 지남에 따라 팀은 소유권 및 유형 시스템이 메모리 안전 및동시성 문제! 소유권 및 유형 검사를 활용함으로써 많은 동시성 오류는 런타임 오류가 아닌 Rust의 컴파일 타임 오류입니다. 따라서 런타임 동시성 버그가 발생하는 정확한 상황을 재현하는 데 많은 시간을 소비하는 대신 잘못된 코드는 컴파일을 거부하고 문제를 설명하는 오류를 표시합니다. 결과적으로 잠재적으로 프로덕션으로 배송된 후가 아니라 작업하는 동안 코드를 수정할 수 있습니다. 우리는 Rust Fearless Concurrency 의 이러한 측면을 별명으로 지정했습니다. 두려움 없는 동시성을 통해 미묘한 버그가 없는 코드를 작성할 수 있으며 새로운 버그를 도입하지 않고 쉽게 리팩터링할 수 있습니다.\n\n참고: 단순화를 위해 많은 문제를 concurrent 및/또는 parallel 로 더 정확하게 표현하기보다는 동시성 이라고 합니다. 이 책이 동시성 및/또는 병렬성에 관한 것이라면 더 구체적일 것입니다. 이 장에서는 concurrent 를 사용할 때마다 마음속으로 concurrent 및/또는 parallel 로 대체하세요 .\n\n많은 언어는 동시 발생 문제를 처리하기 위해 제공하는 솔루션에 대해 독단적입니다. 예를 들어 Erlang에는 메시지 전달 동시성을 위한 우아한 기능이 있지만 스레드 간에 상태를 공유하는 모호한 방법만 있습니다. 가능한 솔루션의 하위 집합만 지원하는 것은 고급 언어에 대한 합리적인 전략입니다. 고급 언어는 추상화를 얻기 위해 일부 제어를 포기함으로써 이점을 약속하기 때문입니다. 그러나 낮은 수준의 언어는 주어진 상황에서 최상의 성능을 가진 솔루션을 제공하고 하드웨어에 대한 추상화가 적을 것으로 예상됩니다. 따라서 Rust는 상황과 요구 사항에 적합한 방식으로 문제를 모델링하기 위한 다양한 도구를 제공합니다.\n이 장에서 다룰 주제는 다음과 같습니다.\n\n동시에 여러 코드 조각을 실행하는 스레드를 만드는 방법\n채널이 스레드 간에 메시지를 보내는 메시지 전달 동시성\n여러 스레드가 일부 데이터에 액세스할 수 있는 공유 상태 동시성\nRust의 동시성 보장을 사용자 정의 유형 및 표준 라이브러리에서 제공하는 유형으로 확장하는 \"동기화\" 및 \"보내기\" 특성\n\n\n스레드를 사용하여 코드를 동시에 실행\n대부분의 현재 운영 체제에서 실행된 프로그램의 코드는 프로세스에서 실행되며 운영 체제는 한 번에 여러 프로세스를 관리합니다. 프로그램 내에서 동시에 실행되는 독립적인 부분을 가질 수도 있습니다. 이러한 독립적인 부분을 실행하는 기능을 스레드 라고 합니다. 예를 들어, 웹 서버는 동시에 둘 이상의 요청에 응답할 수 있도록 여러 스레드를 가질 수 있습니다.\n프로그램의 계산을 여러 스레드로 분할하여 동시에 여러 작업을 실행하면 성능이 향상될 수 있지만 복잡성도 추가됩니다. 스레드가 동시에 실행될 수 있기 때문에 서로 다른 스레드에서 코드 부분이 실행되는 순서에 대한 고유한 보장이 없습니다. 이로 인해 다음과 같은 문제가 발생할 수 있습니다.\n\n스레드가 일관성 없는 순서로 데이터 또는 리소스에 액세스하는 경쟁 조건\n두 스레드가 서로를 기다리고 있어 두 스레드가 계속 진행되지 않는 교착 상태\n특정 상황에서만 발생하고 안정적으로 재현 및 수정하기 어려운 버그\n\nRust는 스레드 사용의 부정적인 영향을 완화하려고 시도하지만 다중 스레드 컨텍스트에서 프로그래밍하려면 여전히 신중한 생각이 필요하며 단일 스레드에서 실행되는 프로그램과 다른 코드 구조가 필요합니다.\n프로그래밍 언어는 몇 가지 다른 방식으로 스레드를 구현하며 많은 운영 체제는 언어가 새 스레드를 생성하기 위해 호출할 수 있는 API를 제공합니다. Rust 표준 라이브러리는 스레드 구현의 1:1 모델을 사용하므로 프로그램은 하나의 언어 스레드당 하나의 운영 체제 스레드를 사용합니다. 1:1 모델과 다른 트레이드오프를 만드는 다른 스레딩 모델을 구현하는 크레이트가 있습니다.\n\"spawn\"으로 새 스레드 만들기\n새로운 스레드를 생성하기 위해 \"thread::spawn\" 함수를 호출하고 새 스레드에서 실행하려는 코드가 포함된 클로저(13장에서 클로저에 대해 이야기함)를 전달합니다. 목록 16-1의 예는 메인 스레드의 일부 텍스트와 새 스레드의 다른 텍스트를 인쇄합니다.\n파일 이름: src/main.rs\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    thread::spawn(|| {\n        for i in 1..10 {\n            println!(\"hi number {} from the spawned thread!\", i);\n            thread::sleep(Duration::from_millis(1));\n        }\n    });\n\n    for i in 1..5 {\n        println!(\"hi number {} from the main thread!\", i);\n        thread::sleep(Duration::from_millis(1));\n    }\n}\n\n목록 16-1: 메인 스레드가 다른 것을 인쇄하는 동안 한 가지를 인쇄하기 위한 새 스레드 만들기\nRust 프로그램의 메인 스레드가 완료되면 생성된 모든 스레드는 실행 완료 여부에 관계없이 종료됩니다. 이 프로그램의 출력은 매번 조금씩 다를 수 있지만 다음과 유사하게 표시됩니다.\nhi number 1 from the main thread!\nhi number 1 from the spawned thread!\nhi number 2 from the main thread!\nhi number 2 from the spawned thread!\nhi number 3 from the main thread!\nhi number 3 from the spawned thread!\nhi number 4 from the main thread!\nhi number 4 from the spawned thread!\nhi number 5 from the spawned thread!\n\n\"thread::sleep\"에 대한 호출은 스레드가 짧은 기간 동안 실행을 중지하도록 강제하여 다른 스레드가 실행될 수 있도록 합니다. 스레드는 순서대로 진행되지만 보장되지는 않습니다. 운영 체제에서 스레드를 예약하는 방법에 따라 다릅니다. 이 실행에서는 생성된 스레드의 인쇄 문이 코드에서 첫 번째로 나타나더라도 기본 스레드가 먼저 인쇄됩니다. 그리고 \"i\"가 9가 될 때까지 출력하도록 생성된 스레드에 지시했지만 기본 스레드가 종료되기 전에 5에 도달했습니다.\n이 코드를 실행하고 기본 스레드의 출력만 표시되거나 겹치는 부분이 표시되지 않는 경우 범위의 숫자를 늘려 운영 체제가 스레드 간에 전환할 수 있는 기회를 더 많이 만드십시오.\n\"조인\" 핸들을 사용하여 모든 스레드가 완료될 때까지 대기\n목록 16-1의 코드는 메인 스레드 종료로 인해 대부분의 경우 생성된 스레드를 조기에 중지할 뿐만 아니라 스레드가 실행되는 순서에 대한 보장이 없기 때문에 생성된 스레드가 실행된다는 보장도 할 수 없습니다. 전혀 실행하십시오!\n\"thread::spawn\"의 반환 값을 변수에 저장하여 생성된 스레드가 실행되지 않거나 조기에 종료되는 문제를 해결할 수 있습니다. \"thread::spawn\"의 반환 유형은 \"JoinHandle\"입니다. \"JoinHandle\"은 \"join\" 메서드를 호출할 때 스레드가 완료될 때까지 기다리는 소유된 값입니다. Listing 16-2는 Listing 16-1에서 만든 스레드의 \"JoinHandle\"을 사용하고 \"main\"이 종료되기 전에 생성된 스레드가 완료되도록 \"join\"을 호출하는 방법을 보여줍니다.\n파일 이름: src/main.rs\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    let handle = thread::spawn(|| {\n        for i in 1..10 {\n            println!(\"hi number {} from the spawned thread!\", i);\n            thread::sleep(Duration::from_millis(1));\n        }\n    });\n\n    for i in 1..5 {\n        println!(\"hi number {} from the main thread!\", i);\n        thread::sleep(Duration::from_millis(1));\n    }\n\n    handle.join().unwrap();\n}\n\n목록 16-2: \"thread::spawn\"에서 \"JoinHandle\"을 저장하여 스레드 실행이 완료되도록 보장\n핸들에서 \"join\"을 호출하면 핸들이 나타내는 스레드가 종료될 때까지 현재 실행 중인 스레드가 차단됩니다. 스레드를 차단한다는 것은 스레드가 작업을 수행하거나 종료하는 것을 방지함을 의미합니다. 메인 스레드의 \"for\" 루프 뒤에 \"join\"에 대한 호출을 넣었기 때문에 목록 16-2를 실행하면 다음과 유사한 출력이 생성되어야 합니다.\nhi number 1 from the main thread!\nhi number 2 from the main thread!\nhi number 1 from the spawned thread!\nhi number 3 from the main thread!\nhi number 2 from the spawned thread!\nhi number 4 from the main thread!\nhi number 3 from the spawned thread!\nhi number 4 from the spawned thread!\nhi number 5 from the spawned thread!\nhi number 6 from the spawned thread!\nhi number 7 from the spawned thread!\nhi number 8 from the spawned thread!\nhi number 9 from the spawned thread!\n\n두 쓰레드는 계속 번갈아 가며 진행되지만, 메인 쓰레드는 \"handle.join()\" 호출 때문에 기다리며 생성된 쓰레드가 끝날 때까지 끝나지 않는다.\n그러나 다음과 같이 \"main\"의 \"for\" 루프 전에 \"handle.join()\"을 대신 이동하면 어떤 일이 발생하는지 살펴보겠습니다.\n파일 이름: src/main.rs\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    let handle = thread::spawn(|| {\n        for i in 1..10 {\n            println!(\"hi number {} from the spawned thread!\", i);\n            thread::sleep(Duration::from_millis(1));\n        }\n    });\n\n    handle.join().unwrap();\n\n    for i in 1..5 {\n        println!(\"hi number {} from the main thread!\", i);\n        thread::sleep(Duration::from_millis(1));\n    }\n}\n\n메인 스레드는 생성된 스레드가 완료될 때까지 기다린 다음 \"for\" 루프를 실행하므로 다음과 같이 출력이 더 이상 인터리브되지 않습니다.\nhi number 1 from the spawned thread!\nhi number 2 from the spawned thread!\nhi number 3 from the spawned thread!\nhi number 4 from the spawned thread!\nhi number 5 from the spawned thread!\nhi number 6 from the spawned thread!\nhi number 7 from the spawned thread!\nhi number 8 from the spawned thread!\nhi number 9 from the spawned thread!\nhi number 1 from the main thread!\nhi number 2 from the main thread!\nhi number 3 from the main thread!\nhi number 4 from the main thread!\n\n\"join\"이 호출되는 위치와 같은 작은 세부 정보는 스레드가 동시에 실행되는지 여부에 영향을 줄 수 있습니다.\n스레드와 함께 \"이동\" 클로저 사용\n\"thread::spawn\"으로 전달된 클로저와 함께 \"move\" 키워드를 자주 사용합니다. 클로저가 환경에서 사용하는 값의 소유권을 가져가서 해당 값의 소유권을 한 스레드에서 다른 스레드로 이전하기 때문입니다. 13장의 \"참조 캡처 또는 소유권 이동\" 섹션에서 클로저의 맥락에서 \"이동\"에 대해 논의했습니다. 이제 \"이동\"과 \"thread::spawn\" 사이의 상호 작용에 더 집중하겠습니다.\n목록 16-1에서 우리가 \"thread::spawn\"에 전달하는 클로저는 인자를 취하지 않는다는 것을 주목하세요: 우리는 스폰된 스레드의 코드에서 메인 스레드의 데이터를 사용하지 않습니다. 생성된 스레드에서 메인 스레드의 데이터를 사용하려면 생성된 스레드의 클로저가 필요한 값을 캡처해야 합니다. 목록 16-3은 메인 스레드에서 벡터를 생성하고 생성된 스레드에서 사용하려는 시도를 보여줍니다. 그러나 잠시 후에 보게 되겠지만 이것은 아직 작동하지 않습니다.\n파일 이름: src/main.rs\nuse std::thread;\n\nfn main() {\n    let v = vec![1, 2, 3];\n\n    let handle = thread::spawn(|| {\n        println!(\"Here\"s a vector: {:?}\", v);\n    });\n\n    handle.join().unwrap();\n}\n\nListing 16-3: 메인 스레드가 생성한 벡터를 다른 스레드에서 사용하려고 시도\n클로저는 \"v\"를 사용하므로 \"v\"를 캡처하여 클로저 환경의 일부로 만듭니다. \"thread::spawn\"은 새 스레드에서 이 클로저를 실행하기 때문에 새 스레드 내부에서 \"v\"에 액세스할 수 있어야 합니다. 하지만 이 예제를 컴파일하면 다음 오류가 발생합니다.\n$ cargo run\n   Compiling threads v0.1.0 (file:///projects/threads)\nerror[E0373]: closure may outlive the current function, but it borrows \"v\", which is owned by the current function\n --&gt; src/main.rs:6:32\n  |\n6 |     let handle = thread::spawn(|| {\n  |                                ^^ may outlive borrowed value \"v\"\n7 |         println!(\"Here\"s a vector: {:?}\", v);\n  |                                           - \"v\" is borrowed here\n  |\nnote: function requires argument type to outlive \"\"static\"\n --&gt; src/main.rs:6:18\n  |\n6 |       let handle = thread::spawn(|| {\n  |  __________________^\n7 | |         println!(\"Here\"s a vector: {:?}\", v);\n8 | |     });\n  | |______^\nhelp: to force the closure to take ownership of \"v\" (and any other referenced variables), use the \"move\" keyword\n  |\n6 |     let handle = thread::spawn(move || {\n  |                                ++++\n\nFor more information about this error, try \"rustc --explain E0373\".\nerror: could not compile \"threads\" due to previous error\n\nRust는 \" v\"를 캡처하는 방법과 \"println!\" \"v\"에 대한 참조만 필요하고 클로저는 \"v\"를 빌리기 위해 시도합니다. 그러나 문제가 있습니다. Rust는 생성된 스레드가 얼마나 오래 실행되는지 알 수 없으므로 \"v\"에 대한 참조가 항상 유효한지 알 수 없습니다.\n목록 16-4는 유효하지 않은 \"v\"에 대한 참조를 가질 가능성이 더 높은 시나리오를 제공합니다:\n파일 이름: src/main.rs\nuse std::thread;\n\nfn main() {\n    let v = vec![1, 2, 3];\n\n    let handle = thread::spawn(|| {\n        println!(\"Here\"s a vector: {:?}\", v);\n    });\n\n    drop(v); // oh no!\n\n    handle.join().unwrap();\n}\n\n목록 16-4: \"v\"를 드롭하는 메인 스레드에서 \"v\"에 대한 참조를 캡처하려고 시도하는 클로저가 있는 스레드\nRust가 이 코드를 실행하도록 허용하면 생성된 스레드가 전혀 실행되지 않고 즉시 백그라운드에 배치될 가능성이 있습니다. 생성된 스레드는 내부에 \"v\"에 대한 참조를 가지고 있지만 메인 스레드는 15장에서 논의한 \"drop\" 함수를 사용하여 즉시 \"v\"를 삭제합니다. 그러면 생성된 스레드가 실행되기 시작하면 \"v\"는 더 이상 존재하지 않습니다. 유효하므로 이에 대한 참조도 유효하지 않습니다. 안 돼!\n목록 16-3의 컴파일러 오류를 수정하기 위해 오류 메시지의 조언을 사용할 수 있습니다.\nhelp: to force the closure to take ownership of \"v\" (and any other referenced variables), use the \"move\" keyword\n  |\n6 |     let handle = thread::spawn(move || {\n  |                                ++++\n\n클로저 앞에 \"이동\" 키워드를 추가함으로써 러스트가 값을 빌려야 한다고 추론하도록 허용하지 않고 클로저가 사용하는 값의 소유권을 갖도록 합니다. Listing 16-5에 표시된 Listing 16-3에 대한 수정 사항은 의도한 대로 컴파일되고 실행됩니다.\n파일 이름: src/main.rs\nuse std::thread;\n\nfn main() {\n    let v = vec![1, 2, 3];\n\n    let handle = thread::spawn(move || {\n        println!(\"Here\"s a vector: {:?}\", v);\n    });\n\n    handle.join().unwrap();\n}\n\nListing 16-5: \"move\" 키워드를 사용하여 클로저가 사용하는 값의 소유권을 가지도록 합니다.\n\"이동\" 클로저를 사용하여 메인 스레드가 \"드롭\"을 호출한 Listing 16-4의 코드를 수정하기 위해 동일한 작업을 시도하고 싶은 유혹을 느낄 수 있습니다. 그러나 Listing 16-4가 하려는 것이 다른 이유로 허용되지 않기 때문에 이 수정은 작동하지 않습니다. 클로저에 \"move\"를 추가하면 클로저의 환경으로 \"v\"를 이동하고 더 이상 메인 스레드에서 \"drop\"을 호출할 수 없습니다. 대신 다음 컴파일러 오류가 발생합니다.\n$ cargo run\n   Compiling threads v0.1.0 (file:///projects/threads)\nerror[E0382]: use of moved value: \"v\"\n  --&gt; src/main.rs:10:10\n   |\n4  |     let v = vec![1, 2, 3];\n   |         - move occurs because \"v\" has type \"Vec&lt;i32&gt;\", which does not implement the \"Copy\" trait\n5  |\n6  |     let handle = thread::spawn(move || {\n   |                                ------- value moved into closure here\n7  |         println!(\"Here\"s a vector: {:?}\", v);\n   |                                           - variable moved due to use in closure\n...\n10 |     drop(v); // oh no!\n   |          ^ value used here after move\n\nFor more information about this error, try \"rustc --explain E0382\".\nerror: could not compile \"threads\" due to previous error\n\nRust의 소유권 규칙이 우리를 다시 구했습니다! Listing 16-3의 코드에서 오류가 발생했습니다. 왜냐하면 Rust는 보수적이고 스레드에 대해 \"v\"만 차용했기 때문입니다. 이는 메인 스레드가 이론적으로 생성된 스레드의 참조를 무효화할 수 있음을 의미했습니다. Rust에게 \"v\"의 소유권을 생성된 스레드로 이동하라고 지시함으로써 우리는 Rust에게 메인 스레드가 더 이상 \"v\"를 사용하지 않을 것임을 보장합니다. 목록 16-4를 같은 방식으로 변경하면 메인 스레드에서 \"v\"를 사용하려고 할 때 소유권 규칙을 위반하는 것입니다. \"이동\" 키워드는 Rust의 보수적인 차용 기본값을 무시합니다. 소유권 규칙을 위반하지 않습니다.\n스레드와 스레드 API에 대한 기본적인 이해를 바탕으로 스레드로 무엇 을 할 수 있는지 살펴보겠습니다.\n\n메시지 전달을 사용하여 스레드 간 데이터 전송\n안전한 동시성을 보장하기 위해 점점 인기를 얻고 있는 접근 방식 중 하나는 스레드 또는 액터가 데이터가 포함된 메시지를 서로 전송하여 통신하는 메시지 전달 입니다. 다음은 Go 언어 문서 의 슬로건에 있는 아이디어입니다. “메모리를 공유하여 통신하지 마십시오. 대신 의사 소통을 통해 메모리를 공유하십시오.”\n메시지 전송 동시성을 달성하기 위해 Rust의 표준 라이브러리는 채널 구현을 제공합니다. 채널은 한 스레드에서 다른 스레드로 데이터를 보내는 일반적인 프로그래밍 개념입니다.\n프로그래밍의 채널은 개울이나 강과 같은 물의 방향성 채널과 같다고 상상할 수 있습니다. 고무 오리 같은 것을 강물에 넣으면 하류로 흘러가 물길 끝까지 갑니다.\n채널에는 송신기와 수신기의 두 부분이 있습니다. 송신기 절반은 고무 오리를 강에 넣는 상류 위치이고 수신기 절반은 고무 오리가 하류로 끝나는 곳입니다. 코드의 한 부분은 전송하려는 데이터를 사용하여 전송기의 메서드를 호출하고 다른 부분은 메시지 도착을 위해 수신단을 확인합니다. 송신기 또는 수신기 절반이 떨어지면 채널이 닫혔다 고 합니다.\n여기에서 우리는 값을 생성하고 채널로 보내는 하나의 스레드와 값을 수신하고 출력하는 다른 스레드가 있는 프로그램을 만들 것입니다. 기능을 설명하기 위해 채널을 사용하여 스레드 간에 간단한 값을 보낼 것입니다. 이 기술에 익숙해지면 채팅 시스템이나 많은 스레드가 계산의 일부를 수행하고 해당 부분을 하나의 스레드로 보내는 시스템과 같이 서로 통신해야 하는 모든 스레드에 대해 채널을 사용할 수 있습니다. 결과.\n먼저 Listing 16-6에서 채널을 생성하지만 아무 작업도 수행하지 않습니다. Rust는 채널을 통해 어떤 유형의 값을 보내고 싶은지 알 수 없기 때문에 아직 컴파일되지 않는다는 점에 유의하세요.\n파일 이름: src/main.rs\nuse std::sync::mpsc;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n}\n\n목록 16-6: 채널 생성 및 \"tx\" 및 \"rx\"에 두 개의 절반 할당\n\"mpsc::channel\" 기능을 사용하여 새 채널을 만듭니다. \"mpsc\"는 다중 생산자, 단일 소비자를 나타냅니다. 요컨대, Rust의 표준 라이브러리가 채널을 구현하는 방식은 채널이 값을 생성하는 여러 송신단을 가질 수 있지만 해당 값을 소비하는 수신단은 하나만 가질 수 있음을 의미합니다. 하나의 큰 강으로 함께 흐르는 여러 개울을 상상해 보십시오. 개울로 보내진 모든 것은 결국 하나의 강으로 끝납니다. 지금은 단일 생산자로 시작하지만 이 예제가 작동하면 여러 생산자를 추가할 것입니다.\n\"mpsc::channel\" 함수는 튜플을 반환하며, 첫 번째 요소는 송신측(송신기)이고 두 번째 요소는 수신측(수신기)입니다. 약어 \"tx\" 및 \"rx\"는 전통적으로 각각 송신기 및 수신기 에 대해 많은 분야에서 사용되므로 각 끝을 나타내기 위해 변수 이름을 지정합니다. 튜플을 분해하는 패턴이 있는 \"let\" 문을 사용하고 있습니다. 18장에서 \"let\" 문에서의 패턴 사용과 구조 분해에 대해 논의할 것입니다. 지금은 \"let\" 문을 이 방법으로 사용하는 것이 \"mpsc::channel에서 반환된 튜플 조각을 추출하는 편리한 접근 방식이라는 것을 알고 계십시오. \".\n목록 16-7에 표시된 것처럼 생성된 스레드가 주 스레드와 통신하도록 전송 끝을 생성된 스레드로 이동하고 하나의 문자열을 보내도록 합시다. 이것은 강 상류에 고무 오리를 두거나 한 스레드에서 다른 스레드로 채팅 메시지를 보내는 것과 같습니다.\n파일 이름: src/main.rs\nuse std::sync::mpsc;\nuse std::thread;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n\n    thread::spawn(move || {\n        let val = String::from(\"hi\");\n        tx.send(val).unwrap();\n    });\n}\n\nListing 16-7: 생성된 스레드로 \"tx\" 이동 및 \"hi\" 전송\n다시, \"thread::spawn\"을 사용하여 새 스레드를 생성한 다음 \"move\"를 사용하여 \"tx\"를 클로저로 이동하여 생성된 스레드가 \"tx\"를 소유하도록 합니다. 생성된 스레드는 채널을 통해 메시지를 보낼 수 있도록 송신기를 소유해야 합니다. 송신기에는 우리가 보내려는 값을 받는 \"보내기\" 메서드가 있습니다. \"send\" 메서드는 \"Result&lt;T, E&gt;\" 유형을 반환하므로 수신자가 이미 삭제되었고 값을 보낼 곳이 없는 경우 보내기 작업은 오류를 반환합니다. 이 예제에서는 \"unwrap\"을 호출하여 오류가 발생할 경우 당황하게 합니다. 그러나 실제 응용 프로그램에서는 적절하게 처리할 것입니다. 적절한 오류 처리를 위한 전략을 검토하려면 9장으로 돌아가십시오.\n목록 16-8에서 우리는 메인 스레드의 수신자로부터 값을 얻을 것입니다. 이것은 마치 강가에 있는 물에서 고무 오리를 회수하거나 채팅 메시지를 받는 것과 같습니다.\n파일 이름: src/main.rs\nuse std::sync::mpsc;\nuse std::thread;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n\n    thread::spawn(move || {\n        let val = String::from(\"hi\");\n        tx.send(val).unwrap();\n    });\n\n    let received = rx.recv().unwrap();\n    println!(\"Got: {}\", received);\n}\n\nListing 16-8: 메인 스레드에서 \"hi\" 값을 받고 출력하기\n수신기에는 \"recv\" 및 \"try_recv\"라는 두 가지 유용한 메서드가 있습니다. 우리는 메인 스레드의 실행을 차단하고 값이 채널 아래로 전송될 때까지 대기하는 \" recv\"를 사용하고 있습니다. 값이 전송되면 \"recv\"는 \"Result&lt;T, E&gt;\"로 값을 반환합니다. 송신기가 닫히면 \"recv\"는 더 이상 값이 오지 않는다는 신호로 오류를 반환합니다.\n\"try_recv\" 메서드는 차단되지 않지만 대신 \"Result&lt;T, E&gt;\"를 즉시 반환합니다. 메시지가 있는 경우 메시지를 포함하는 \"Ok\" 값과 메시지가 없으면 \"Err\" 값을 반환합니다. 이 시간. \"try_recv\"를 사용하는 것은 이 스레드가 메시지를 기다리는 동안 해야 할 다른 작업이 있는 경우에 유용합니다. \"try_recv\"를 자주 호출하고 메시지가 사용 가능한 경우 메시지를 처리하고 잠시 동안 다른 작업을 수행하는 루프를 작성할 수 있습니다. 다시 확인할 때까지.\n이 예제에서는 단순화를 위해 \"recv\"를 사용했습니다. 메인 스레드가 메시지를 기다리는 것 외에는 할 일이 없으므로 메인 스레드를 차단하는 것이 적절합니다.\n목록 16-8의 코드를 실행하면 메인 스레드에서 출력된 값을 볼 수 있습니다.\nGot: hi\n\n완벽한!\n채널 및 소유권 이전\n소유권 규칙은 안전한 동시 코드를 작성하는 데 도움이 되므로 메시지 전송에서 중요한 역할을 합니다. 동시 프로그래밍에서 오류를 방지하는 것은 Rust 프로그램 전체에서 소유권에 대해 생각하는 이점입니다. 문제를 방지하기 위해 채널과 소유권이 함께 작동하는 방식을 보여주는 실험을 해 봅시다. 스레드를 채널 아래로 보낸 후 생성된 스레드에서 \"val\" 값을 사용하려고 합니다. Listing 16-9의 코드를 컴파일하여 이 코드가 허용되지 않는 이유를 확인하십시오:\n파일 이름: src/main.rs\nuse std::sync::mpsc;\nuse std::thread;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n\n    thread::spawn(move || {\n        let val = String::from(\"hi\");\n        tx.send(val).unwrap();\n        println!(\"val is {}\", val);\n    });\n\n    let received = rx.recv().unwrap();\n    println!(\"Got: {}\", received);\n}\n\n목록 16-9: \"val\"을 채널 아래로 보낸 후 사용 시도\n여기에서 \"tx.send\"를 통해 채널 아래로 전송한 후 \"val\"을 인쇄하려고 합니다. 이를 허용하는 것은 나쁜 생각입니다. 값이 다른 스레드로 전송되면 해당 스레드는 값을 다시 사용하려고 시도하기 전에 값을 수정하거나 삭제할 수 있습니다. 잠재적으로 다른 스레드의 수정으로 인해 일관성이 없거나 존재하지 않는 데이터로 인해 오류 또는 예기치 않은 결과가 발생할 수 있습니다. 그러나 Listing 16-9의 코드를 컴파일하려고 하면 Rust에서 오류가 발생합니다.\n$ cargo run\n   Compiling message-passing v0.1.0 (file:///projects/message-passing)\nerror[E0382]: borrow of moved value: \"val\"\n  --&gt; src/main.rs:10:31\n   |\n8  |         let val = String::from(\"hi\");\n   |             --- move occurs because \"val\" has type \"String\", which does not implement the \"Copy\" trait\n9  |         tx.send(val).unwrap();\n   |                 --- value moved here\n10 |         println!(\"val is {}\", val);\n   |                               ^^^ value borrowed here after move\n   |\n   = note: this error originates in the macro \"$crate::format_args_nl\" which comes from the expansion of the macro \"println\" (in Nightly builds, run with -Z macro-backtrace for more info)\n\nFor more information about this error, try \"rustc --explain E0382\".\nerror: could not compile \"message-passing\" due to previous error\n\n동시성 실수로 인해 컴파일 시간 오류가 발생했습니다. \"보내기\" 함수는 해당 매개변수의 소유권을 가지며 값이 이동되면 수신자가 소유권을 갖습니다. 이렇게 하면 값을 보낸 후 실수로 값을 다시 사용하는 것을 방지할 수 있습니다. 소유권 시스템은 모든 것이 정상인지 확인합니다.\n여러 값을 보내고 기다리는 수신기 보기\n목록 16-8의 코드는 컴파일되고 실행되었지만 두 개의 개별 스레드가 채널을 통해 서로 대화하고 있음을 명확하게 보여주지 않았습니다. 목록 16-10에서 우리는 목록 16-8의 코드가 동시에 실행되고 있음을 증명할 약간의 수정을 했습니다. 생성된 스레드는 이제 여러 메시지를 보내고 각 메시지 사이에 1초 동안 일시 중지합니다.\n파일 이름: src/main.rs\nuse std::sync::mpsc;\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    let (tx, rx) = mpsc::channel();\n\n    thread::spawn(move || {\n        let vals = vec![\n            String::from(\"hi\"),\n            String::from(\"from\"),\n            String::from(\"the\"),\n            String::from(\"thread\"),\n        ];\n\n        for val in vals {\n            tx.send(val).unwrap();\n            thread::sleep(Duration::from_secs(1));\n        }\n    });\n\n    for received in rx {\n        println!(\"Got: {}\", received);\n    }\n}\n\nListing 16-10: 여러 메시지를 보내고 각 메시지 사이에 일시 중지\n이번에 생성된 스레드에는 기본 스레드로 보내려는 문자열 벡터가 있습니다. 우리는 그것들을 반복하고, 각각을 개별적으로 보내고, \"Duration\" 값이 1초인 \"thread::sleep\" 함수를 호출하여 각각 사이에서 일시 중지합니다.\n메인 스레드에서 우리는 더 이상 \"recv\" 함수를 명시적으로 호출하지 않습니다. 대신 \"rx\"를 이터레이터로 취급합니다. 받은 각 값에 대해 인쇄합니다. 채널이 닫히면 반복이 종료됩니다.\n목록 16-10의 코드를 실행할 때 각 줄 사이에 1초간 일시 중지가 있는 다음 출력이 표시되어야 합니다.\nGot: hi\nGot: from\nGot: the\nGot: thread\n\n메인 스레드의 \"for\" 루프에서 일시 중지하거나 지연시키는 코드가 없기 때문에 메인 스레드가 생성된 스레드로부터 값을 받기 위해 대기하고 있음을 알 수 있습니다.\n송신기를 복제하여 여러 생산자 만들기\n앞에서 \"mpsc\"가 다중 생산자, 단일 소비자 의 약어라고 언급했습니다. \"mpsc\"를 사용하고 Listing 16-10의 코드를 확장하여 모두 동일한 수신자에게 값을 보내는 여러 스레드를 생성해 보겠습니다. Listing 16-11과 같이 송신기를 복제하여 그렇게 할 수 있습니다.\n파일 이름: src/main.rs\n    // --snip--\n\n    let (tx, rx) = mpsc::channel();\n\n    let tx1 = tx.clone();\n    thread::spawn(move || {\n        let vals = vec![\n            String::from(\"hi\"),\n            String::from(\"from\"),\n            String::from(\"the\"),\n            String::from(\"thread\"),\n        ];\n\n        for val in vals {\n            tx1.send(val).unwrap();\n            thread::sleep(Duration::from_secs(1));\n        }\n    });\n\n    thread::spawn(move || {\n        let vals = vec![\n            String::from(\"more\"),\n            String::from(\"messages\"),\n            String::from(\"for\"),\n            String::from(\"you\"),\n        ];\n\n        for val in vals {\n            tx.send(val).unwrap();\n            thread::sleep(Duration::from_secs(1));\n        }\n    });\n\n    for received in rx {\n        println!(\"Got: {}\", received);\n    }\n\n    // --snip--\n\nListing 16-11: 여러 생산자로부터 여러 메시지 보내기\n이번에는 첫 번째 생성된 스레드를 만들기 전에 송신기에서 \"clone\"을 호출합니다. 이렇게 하면 첫 번째 생성된 스레드에 전달할 수 있는 새 송신기가 제공됩니다. 원래 송신기를 두 번째 생성된 스레드로 전달합니다. 이렇게 하면 각각 다른 메시지를 하나의 수신자에게 보내는 두 개의 스레드가 제공됩니다.\n코드를 실행하면 출력은 다음과 같아야 합니다.\nGot: hi\nGot: more\nGot: from\nGot: messages\nGot: for\nGot: the\nGot: thread\nGot: you\n\n시스템에 따라 값이 다른 순서로 표시될 수 있습니다. 이것이 동시성을 흥미롭고 어렵게 만드는 것입니다. \"thread::sleep\"을 실험하고 다른 스레드에서 다양한 값을 제공하면 각 실행은 더 비결정적이며 매번 다른 출력을 생성합니다.\n이제 채널이 작동하는 방식을 살펴보았으므로 다른 동시성 방법을 살펴보겠습니다.\n\n공유 상태 동시성\n메시지 전달은 동시성을 처리하는 훌륭한 방법이지만 유일한 방법은 아닙니다. 또 다른 방법은 여러 스레드가 동일한 공유 데이터에 액세스하는 것입니다. Go 언어 문서의 슬로건 중 이 부분을 다시 생각해 보십시오. \"메모리를 공유하여 통신하지 마십시오.\"\n메모리 공유를 통한 통신은 어떤 모습일까요? 또한 메시지 전달 애호가들이 메모리 공유를 사용하지 말라고 주의하는 이유는 무엇입니까?\n어떤 면에서 모든 프로그래밍 언어의 채널은 단일 소유권과 유사합니다. 값을 채널 아래로 전송하면 더 이상 해당 값을 사용하지 않아야 하기 때문입니다. 공유 메모리 동시성은 다중 소유권과 같습니다. 여러 스레드가 동시에 동일한 메모리 위치에 액세스할 수 있습니다. 스마트 포인터가 다중 소유권을 가능하게 한 15장에서 보았듯이 다중 소유권은 이러한 서로 다른 소유자가 관리해야 하기 때문에 복잡성을 추가할 수 있습니다. Rust의 타입 시스템과 소유권 규칙은 이 관리를 올바르게 하는 데 크게 도움이 됩니다. 예를 들어, 공유 메모리에 대한 보다 일반적인 동시성 프리미티브 중 하나인 뮤텍스를 살펴보겠습니다.\n뮤텍스를 사용하여 한 번에 하나의 스레드에서 데이터 액세스 허용\n뮤텍스 는 상호 배제 의 약자입니다. 뮤텍스는 주어진 시간에 하나의 스레드만 일부 데이터에 액세스할 수 있도록 허용합니다. 뮤텍스의 데이터에 액세스하려면 스레드는 먼저 뮤텍스의 잠금 획득을 요청하여 액세스를 원한다는 신호를 보내야 합니다. 잠금은 현재 누가 데이터에 독점적으로 액세스할 수 있는지 추적하는 뮤텍스의 일부인 데이터 구조입니다. 따라서 뮤텍스는 잠금 시스템을 통해 보유하고 있는 데이터를 보호하는 것으로 설명됩니다.\n뮤텍스는 다음 두 가지 규칙을 기억해야 하기 때문에 사용하기 어렵다는 평판이 있습니다.\n\n데이터를 사용하기 전에 잠금 획득을 시도해야 합니다.\n뮤텍스가 보호하는 데이터 작업을 마치면 다른 스레드가 잠금을 획득할 수 있도록 데이터 잠금을 해제해야 합니다.\n\n뮤텍스에 대한 실제 비유를 들어 회의에서 마이크가 하나만 있는 패널 토론을 상상해 보십시오. 패널리스트가 발언하기 전에 마이크를 사용하고 싶다고 묻거나 신호를 보내야 합니다. 마이크를 받으면 원하는 만큼 길게 이야기한 후 발언을 요청하는 다음 패널리스트에게 마이크를 건네줄 수 있습니다. 패널리스트가 마이크 사용을 마치고 마이크를 빼는 것을 잊어버리면 아무도 발언할 수 없습니다. 공유 마이크 관리가 잘못되면 패널이 계획대로 작동하지 않습니다!\n뮤텍스 관리는 제대로 하기가 엄청나게 까다로울 수 있으며, 이것이 바로 많은 사람들이 채널에 열광하는 이유입니다. 그러나 Rust의 유형 시스템 및 소유권 규칙 덕분에 잠금 및 잠금 해제가 잘못될 수 없습니다.\n\"Mutex\"의 API\n뮤텍스를 사용하는 방법의 예로, 목록 16-12에 표시된 것처럼 단일 스레드 컨텍스트에서 뮤텍스를 사용하여 시작하겠습니다.\n파일 이름: src/main.rs\nuse std::sync::Mutex;\n\nfn main() {\n    let m = Mutex::new(5);\n\n    {\n        let mut num = m.lock().unwrap();\n        *num = 6;\n    }\n\n    println!(\"m = {:?}\", m);\n}\n\n목록 16-12: \"Mutex\"의 API 탐색\" 단순화를 위해 단일 스레드 컨텍스트에서\n많은 유형과 마찬가지로 \"Mutex\"를 생성합니다.\" 연관된 함수 \"new\"를 사용합니다. 뮤텍스 내부의 데이터에 액세스하려면 \"lock\" 메서드를 사용하여 잠금을 획득합니다. 이 호출은 현재 스레드를 차단하므로 우리 차례가 될 때까지 아무 작업도 수행할 수 없습니다. 자물쇠.\n잠금을 보유한 다른 스레드가 패닉 상태가 되면 \"잠금\"에 대한 호출이 실패합니다. 이 경우 아무도 잠금을 얻을 수 없으므로 \"언래핑\"을 선택하고 해당 상황에 있는 경우 이 스레드를 패닉 상태로 만듭니다.\n잠금을 획득한 후 반환 값(이 경우 \"num\")을 내부 데이터에 대한 변경 가능한 참조로 처리할 수 있습니다. 유형 시스템은 \"m\"의 값을 사용하기 전에 잠금을 획득하도록 합니다. \"m\"의 유형은 \"Mutex\"입니다.\", \"i32\"가 아니라 \"i32\" 값을 사용하려면 \"lock\"을 호출 해야 합니다 . 그렇지 않으면 유형 시스템에서 내부 \"i32\"에 액세스할 수 없습니다.\n짐작할 수 있듯이 \"Mutex\"는 스마트 포인터입니다. 더 정확하게는 \"잠금\"에 대한 호출은 \" unwrap\"에 대한 호출로 처리한 \"LockResult\"에 래핑된 \"MutexGuard\"라는 스마트 포인터를 반환합니다. \"MutexGuard\" 스마트 포인터는 \" Deref \" 내부 데이터를 가리키기 위해 스마트 포인터에는 \"MutexGuard\"가 내부 범위의 끝에서 발생하는 범위를 벗어날 때 자동으로 잠금을 해제하는 \"Drop\" 구현도 있습니다. 결과적으로 우리는 ' 잠금 해제가 자동으로 발생하기 때문에 잠금 해제를 잊고 다른 스레드에서 사용하는 뮤텍스를 차단할 위험이 있습니다.\n잠금을 해제한 후 뮤텍스 값을 인쇄하고 내부 \"i32\"를 6으로 변경할 수 있음을 확인할 수 있습니다.\n여러 스레드 간에 \"뮤텍스\" 공유\n이제 \"Mutex\"를 사용하여 여러 스레드 간에 값을 공유해 보겠습니다.\". 우리는 10개의 스레드를 스핀업하고 각각 카운터 값을 1씩 증가시켜 카운터가 0에서 10으로 가도록 할 것입니다. 목록 16-13의 다음 예제에는 컴파일러 오류가 있으며 이 오류를 사용하겠습니다. \"Mutex\" 사용에 대해 자세히 알아보려면\" 그리고 Rust가 우리가 그것을 올바르게 사용하는 데 어떻게 도움이 되는지.\n파일 이름: src/main.rs\nuse std::sync::Mutex;\nuse std::thread;\n\nfn main() {\n    let counter = Mutex::new(0);\n    let mut handles = vec![];\n\n    for _ in 0..10 {\n        let handle = thread::spawn(move || {\n            let mut num = counter.lock().unwrap();\n\n            *num += 1;\n        });\n        handles.push(handle);\n    }\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n\n    println!(\"Result: {}\", *counter.lock().unwrap());\n}\n\n목록 16-13: 10개의 스레드는 각각 \"Mutex\"에 의해 보호되는 카운터를 증가시킵니다.\"\n\"Mutex\" 내부에 \"i32\"를 보유하기 위해 \"카운터\" 변수를 생성합니다.\", 목록 16-12에서 했던 것처럼. 다음으로, 숫자 범위를 반복하여 10개의 스레드를 생성합니다. \"thread::spawn\"을 사용하고 모든 스레드에 동일한 클로저를 제공합니다. 하나는 카운터를 스레드로 이동시키는 것입니다. , \"Mutex에 대한 잠금을 획득합니다.\" \"lock\" 메서드를 호출하여 뮤텍스의 값에 1을 추가합니다. 스레드가 클로저 실행을 완료하면 \"num\"은 범위를 벗어나 잠금을 해제하여 다른 스레드가 획득할 수 있도록 합니다.\n기본 스레드에서 모든 조인 핸들을 수집합니다. 그런 다음 Listing 16-2에서 했던 것처럼 모든 스레드가 완료되었는지 확인하기 위해 각 핸들에서 \"join\"을 호출합니다. 그 시점에서 주 스레드는 잠금을 획득하고 이 프로그램의 결과를 인쇄합니다.\n우리는 이 예제가 컴파일되지 않을 것이라고 암시했습니다. 이제 그 이유를 알아봅시다!\n$ cargo run\n   Compiling shared-state v0.1.0 (file:///projects/shared-state)\nerror[E0382]: use of moved value: \"counter\"\n  --&gt; src/main.rs:9:36\n   |\n5  |     let counter = Mutex::new(0);\n   |         ------- move occurs because \"counter\" has type \"Mutex&lt;i32&gt;\", which does not implement the \"Copy\" trait\n...\n9  |         let handle = thread::spawn(move || {\n   |                                    ^^^^^^^ value moved into closure here, in previous iteration of loop\n10 |             let mut num = counter.lock().unwrap();\n   |                           ------- use occurs due to use in closure\n\nFor more information about this error, try \"rustc --explain E0382\".\nerror: could not compile \"shared-state\" due to previous error\n\n오류 메시지는 루프의 이전 반복에서 \"카운터\" 값이 이동되었음을 나타냅니다. Rust는 잠금 \"카운터\"의 소유권을 여러 스레드로 옮길 수 없다고 말합니다. 15장에서 논의한 다중 소유권 방식으로 컴파일러 오류를 수정해 보겠습니다.\n다중 스레드의 다중 소유권\n15장에서 스마트 포인터 \"Rc\"를 사용하여 값에 여러 소유자를 부여했습니다.\" 참조 카운트 값을 생성합니다. 여기에서도 동일한 작업을 수행하고 어떤 일이 발생하는지 확인하겠습니다. \"Mutex\"에서 \"RC\"를 목록 16-14에서 \"Rc\" 소유권을 스레드로 이동하기 전에.\n파일 이름: src/main.rs\nuse std::rc::Rc;\nuse std::sync::Mutex;\nuse std::thread;\n\nfn main() {\n    let counter = Rc::new(Mutex::new(0));\n    let mut handles = vec![];\n\n    for _ in 0..10 {\n        let counter = Rc::clone(&amp;counter);\n        let handle = thread::spawn(move || {\n            let mut num = counter.lock().unwrap();\n\n            *num += 1;\n        });\n        handles.push(handle);\n    }\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n\n    println!(\"Result: {}\", *counter.lock().unwrap());\n}\n\n목록 16-14: \"Rc 사용 시도\" 여러 스레드가 \"Mutex\"\n다시 한 번, 우리는 컴파일하고 ... 다른 오류를 얻습니다! 컴파일러는 우리에게 많은 것을 가르쳐줍니다.\n$ cargo run\n   Compiling shared-state v0.1.0 (file:///projects/shared-state)\nerror[E0277]: \"Rc&lt;Mutex&lt;i32&gt;&gt;\" cannot be sent between threads safely\n  --&gt; src/main.rs:11:36\n   |\n11 |           let handle = thread::spawn(move || {\n   |                        ------------- ^------\n   |                        |             |\n   |  ______________________|_____________within this \"[closure@src/main.rs:11:36: 11:43]\"\n   | |                      |\n   | |                      required by a bound introduced by this call\n12 | |             let mut num = counter.lock().unwrap();\n13 | |\n14 | |             *num += 1;\n15 | |         });\n   | |_________^ \"Rc&lt;Mutex&lt;i32&gt;&gt;\" cannot be sent between threads safely\n   |\n   = help: within \"[closure@src/main.rs:11:36: 11:43]\", the trait \"Send\" is not implemented for \"Rc&lt;Mutex&lt;i32&gt;&gt;\"\nnote: required because it\"s used within this closure\n  --&gt; src/main.rs:11:36\n   |\n11 |         let handle = thread::spawn(move || {\n   |                                    ^^^^^^^\nnote: required by a bound in \"spawn\"\n  --&gt; /rustc/d5a82bbd26e1ad8b7401f6a718a9c57c96905483/library/std/src/thread/mod.rs:704:8\n   |\n   = note: required by this bound in \"spawn\"\n\nFor more information about this error, try \"rustc --explain E0277\".\nerror: could not compile \"shared-state\" due to previous error\n\n와우, 그 오류 메시지는 매우 장황합니다! 집중해야 할 중요한 부분은 다음과 같습니다. \"\"Rc\" 스레드 간에 안전하게 보낼 수 없습니다.\" 컴파일러는 또한 \"Rc&lt;Mutex에 대해 \"Send\" 특성이 구현되지 않은 이유를 알려줍니다.&gt;\" \". 다음 섹션에서 \"보내기\"에 대해 이야기하겠습니다. 스레드와 함께 사용하는 유형이 동시 상황에서 사용되도록 보장하는 특성 중 하나입니다.\n아쉽게도 \"RC\"는 스레드 간에 공유하기에 안전하지 않습니다. \"Rc\" 참조 카운트를 관리하고, \"clone\"에 대한 각 호출에 대한 카운트에 추가하고 각 클론이 삭제될 때 카운트에서 뺍니다. 그러나 카운트에 대한 변경이 불가능하도록 동시성 프리미티브를 사용하지 않습니다. 다른 스레드에 의해 중단됩니다. 이로 인해 잘못된 카운트가 발생할 수 있습니다. 메모리 누수 또는 작업이 완료되기 전에 값이 삭제될 수 있는 미묘한 버그입니다. 우리에게 필요한 것은 정확히 \"Rc\"와 같은 유형입니다.\" 그러나 스레드로부터 안전한 방식으로 참조 횟수를 변경하는 것입니다.\n\"Arc\"를 사용한 원자 참조 카운팅\n다행히 \"아크\" 는 \"Rc와 같은 유형 입니다.\" 는 동시 상황에서 사용하기에 안전합니다. a 는 atomic 를 나타내며 원자적으로 참조 카운트되는 유형 임을 의미합니다. Atomics는 여기서 자세히 다루지 않을 동시성 프리미티브의 추가적인 종류입니다. \"std 에 대한 표준 라이브러리 문서를 참조하십시오. ::sync::atomic\"을 참조하십시오. 이 시점에서 원자는 기본 유형처럼 작동하지만 스레드 간에 공유하는 것이 안전하다는 것을 알아야 합니다.\n그런 다음 모든 기본 유형이 원자적이지 않은 이유와 표준 라이브러리 유형이 \"Arc\"를 사용하도록 구현되지 않은 이유가 궁금할 수 있습니다.\" 기본적으로. 그 이유는 스레드 안전에는 실제로 필요할 때만 지불하려는 성능 패널티가 있기 때문입니다. 단일 스레드 내에서 값에 대한 작업을 수행하는 경우 코드가 더 빨리 실행될 수 있습니다. 원자가 제공하는 보증을 시행해야 합니다.\n예를 들어 보겠습니다. \"아크\"와 \"RC\"는 동일한 API를 가지고 있으므로 \"use\" 줄, \"new\" 호출 및 \"clone\" 호출을 변경하여 프로그램을 수정합니다. Listing 16-15의 코드는 최종적으로 컴파일되고 실행됩니다.\n파일 이름: src/main.rs\nuse std::sync::{Arc, Mutex};\nuse std::thread;\n\nfn main() {\n    let counter = Arc::new(Mutex::new(0));\n    let mut handles = vec![];\n\n    for _ in 0..10 {\n        let counter = Arc::clone(&amp;counter);\n        let handle = thread::spawn(move || {\n            let mut num = counter.lock().unwrap();\n\n            *num += 1;\n        });\n        handles.push(handle);\n    }\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n\n    println!(\"Result: {}\", *counter.lock().unwrap());\n}\n\nListing 16-15: \"호\" 사용하기\"를 래핑하려면 \"뮤텍스\" 여러 스레드에서 소유권을 공유할 수 있도록\n이 코드는 다음을 인쇄합니다.\nResult: 10\n\n우리는 해냈다! 우리는 0부터 10까지 세었는데 그다지 인상적이지 않을 수도 있지만 \"Mutex\"에 대해 많은 것을 가르쳐 주었습니다.\" 및 스레드 안전성. 또한 이 프로그램의 구조를 사용하여 카운터를 증가시키는 것보다 더 복잡한 작업을 수행할 수 있습니다. 이 전략을 사용하면 계산을 독립적인 부분으로 나누고 해당 부분을 스레드 간에 분할한 다음 \"Mutex\"를 사용할 수 있습니다.\" 각 스레드가 해당 부분으로 최종 결과를 업데이트하도록 합니다.\n간단한 숫자 연산을 수행하는 경우 \"Mutex\"보다 간단한 유형이 있습니다.\" 표준 라이브러리의 \"std::sync::atomic\" 모듈 에서 제공하는 유형 . 이러한 유형은 기본 유형에 대한 안전하고 동시적인 원자 액세스를 제공합니다. 우리는 \"Mutex\"를 사용하기로 선택했습니다.\"를 기본 유형으로 사용하여 \"Mutex\" 방법에 집중할 수 있습니다.\" 작동합니다.\n\"RefCell\"/\"Rc\"와 \"Mutex\"/\"Arc\"의 유사점\n\"카운터\"는 변경 불가능하지만 그 안에 있는 값에 대한 변경 가능한 참조를 얻을 수 있음을 알아차렸을 것입니다. 이것은 \"뮤텍스\"는 \"Cell\" 계열과 마찬가지로 내부 가변성을 제공합니다. 같은 방식으로 \"RefCell\" 15장에서 \"Rc 내부의 내용을 변경할 수 있도록 합니다.\", 우리는 \"뮤텍스\"는 \"Arc 내부의 내용을 변경합니다.\".\n주의해야 할 또 다른 세부 사항은 Rust가 \"Mutex\"를 사용할 때 모든 종류의 논리 오류로부터 사용자를 보호할 수 없다는 것입니다.\". 15장에서 \"Rc\" 참조 순환을 생성할 위험이 있습니다. 여기서 두 개의 \"Rc\" 값이 서로를 참조하여 메모리 누수를 일으킵니다. 유사하게 \"Mutex*\" 교착 상태* 가 발생할 위험이 있습니다. 작업이 두 개의 리소스를 잠글 필요가 있고 두 스레드가 각각 잠금 중 하나를 획득하여 서로를 영원히 기다리게 할 때 발생합니다. 교착 상태에 관심이 있는 경우 교착 상태를 만들어 보십시오. 교착 상태가 있는 Rust 프로그램; 그런 다음 모든 언어의 뮤텍스에 대한 교착 상태 완화 전략을 연구하고 이를 Rust에서 구현해 봅니다. \"Mutex에 대한 표준 라이브러리 API 문서\" 및 \"MutexGuard\"는 유용한 정보를 제공합니다.\n\"보내기\" 및 \"동기화\" 특성과 이를 사용자 정의 유형과 함께 사용하는 방법에 대해 이야기하면서 이 장을 마무리하겠습니다.\n\n\"동기화\" 및 \"보내기\" 특성을 사용한 확장 가능한 동시성\n흥미롭게도 Rust 언어에는 동시성 기능이 거의 없습니다. 이 장에서 지금까지 이야기한 거의 모든 동시성 기능은 언어가 아니라 표준 라이브러리의 일부였습니다. 동시성을 처리하기 위한 옵션은 언어나 표준 라이브러리에 국한되지 않습니다. 자신의 동시성 기능을 작성하거나 다른 사람이 작성한 기능을 사용할 수 있습니다.\n그러나 두 가지 동시성 개념이 언어에 포함되어 있습니다. \"std::marker\" 특성 \"Sync\" 및 \"Send\"입니다.\n\"보내기\"를 사용하여 스레드 간 소유권 이전 허용\n\"보내기\" 마커 특성은 \"보내기\"를 구현하는 유형의 값 소유권이 스레드 간에 전송될 수 있음을 나타냅니다. 거의 모든 Rust 유형은 \"Send\"이지만 \"Rc\"를 포함하여 몇 가지 예외가 있습니다.\": \"Rc를 복제한 경우 \"보내기\"가 될 수 없습니다.\" 값을 지정하고 복제본의 소유권을 다른 스레드로 이전하려고 하면 두 스레드가 동시에 참조 횟수를 업데이트할 수 있습니다. 이러한 이유로 \"Rc\"는 스레드로부터 안전한 성능 패널티를 지불하고 싶지 않은 단일 스레드 상황에서 사용하기 위해 구현됩니다.\n따라서 Rust의 유형 시스템과 특성 범위는 실수로 \"Rc\"를 보내지 않도록 합니다.Listing 16-14에서 이 작업을 시도했을 때 \"Rc&lt;Mutex에 대해 특성 Send가 구현되지 않았습니다.&gt;\". \"Arc\"로 전환했을 때\", 코드가 컴파일된 \"보내기\"입니다.\n\"보내기\" 유형으로만 구성된 모든 유형도 자동으로 \"보내기\"로 표시됩니다. 19장에서 논의할 원시 포인터를 제외하고 거의 모든 기본 유형은 \"보내기\"입니다.\n\"동기화\"를 사용하여 여러 스레드에서 액세스 허용\n\"동기화\" 마커 특성은 \"동기화\"를 구현하는 유형이 여러 스레드에서 참조되는 것이 안전함을 나타냅니다. 즉, \"&amp;T\"(\"T\"에 대한 불변 참조)가 \"보내기\"인 경우 모든 유형 \"T\"는 \"동기화\"입니다. 이는 참조를 다른 스레드로 안전하게 보낼 수 있음을 의미합니다. \"Send\"와 유사하게 기본형은 \"Sync\"이며 \"Sync\"인 유형으로만 구성된 유형도 \"Sync\"입니다.\n스마트 포인터 \"Rc\"도 \"Send\"가 아닌 것과 같은 이유로 \"Sync\"가 아닙니다. \"RefCell\" 유형(15장에서 언급) 및 관련된 \"세포\" 유형은 \"동기화\"가 아닙니다. \"RefCell\"을 확인하는 차용 구현\"는 런타임에 스레드로부터 안전하지 않습니다. 스마트 포인터 \"Mutex\"는 \"동기화\"이며 \"여러 스레드 간에 \"뮤텍스\" 공유\" 섹션 에서 본 것처럼 여러 스레드와 액세스를 공유하는 데 사용할 수 있습니다.\n\"보내기\" 및 \"동기화\"를 수동으로 구현하는 것은 안전하지 않습니다.\n\"Send\" 및 \"Sync\" 특성으로 구성된 유형은 자동으로 \"Send\" 및 \"Sync\"이기도 하므로 해당 특성을 수동으로 구현할 필요가 없습니다. 마커 특성으로서 구현할 메서드도 없습니다. 동시성과 관련된 불변성을 적용하는 데 유용합니다.\n이러한 특성을 수동으로 구현하려면 안전하지 않은 Rust 코드를 구현해야 합니다. 우리는 19장에서 안전하지 않은 Rust 코드를 사용하는 것에 대해 이야기할 것입니다. 지금 중요한 정보는 \"Send\" 및 \"Sync\" 부분으로 구성되지 않은 새로운 동시 유형을 빌드하려면 안전 보장을 유지하기 위해 신중한 생각이 필요하다는 것입니다. \"The Rustonomicon\"에는 이러한 보증과 이를 유지하는 방법에 대한 자세한 정보가 있습니다.\n요약\n이것이 이 책에서 보게 될 마지막 동시성은 아닙니다. 20장의 프로젝트는 여기서 논의된 작은 예제보다 더 현실적인 상황에서 이 장의 개념을 사용할 것입니다.\n앞서 언급했듯이 Rust가 동시성을 처리하는 방식이 언어의 일부이기 때문에 많은 동시성 솔루션이 크레이트로 구현됩니다. 이들은 표준 라이브러리보다 더 빠르게 발전하므로 멀티스레드 상황에서 사용할 최신 최신 크레이트를 온라인에서 검색하십시오.\nRust 표준 라이브러리는 \"Mutex\"와 같은 메시지 전달 및 스마트 포인터 유형을 위한 채널을 제공합니다.\" 및 \"아크\", 동시 컨텍스트에서 사용하기에 안전합니다. 유형 시스템과 차용 검사기는 이러한 솔루션을 사용하는 코드가 데이터 경합 또는 유효하지 않은 참조로 끝나지 않도록 합니다. 일단 코드를 컴파일하면 안심할 수 있습니다. 동시성 프로그래밍은 더 이상 두려워할 개념이 아닙니다.\n다음으로 Rust 프로그램이 커짐에 따라 문제를 모델링하고 솔루션을 구조화하는 관용적인 방법에 대해 이야기하겠습니다. 또한 Rust의 관용구가 객체 지향 프로그래밍에서 친숙한 관용구와 어떻게 관련되는지 논의할 것입니다.\n","id":"http://127.0.0.1:1111/rust/chapter11-17/trans/","title":"11-17 translation"},"http://127.0.0.1:1111/rust/chapter17-21/":{"body":"18\nPatterns and Matching\nPatterns are a special syntax in Rust for matching against the structure of types, both complex and simple. Using patterns in conjunction with \"match\" expressions and other constructs gives you more control over a program’s control flow. A pattern consists of some combination of the following:\n\nLiterals\nDestructured arrays, enums, structs, or tuples\nVariables\nWildcards\nPlaceholders\n\nSome example patterns include \"x\", \"(a, 3)\", and \"Some(Color::Red)\". In the contexts in which patterns are valid, these components describe the shape of data. Our program then matches values against the patterns to determine whether it has the correct shape of data to continue running a particular piece of code.\nTo use a pattern, we compare it to some value. If the pattern matches the value, we use the value parts in our code. Recall the \"match\" expressions in Chapter 6 that used patterns, such as the coin-sorting machine example. If the value fits the shape of the pattern, we can use the named pieces. If it doesn’t, the code associated with the pattern won’t run.\nThis chapter is a reference on all things related to patterns. We’ll cover the valid places to use patterns, the difference between refutable and irrefutable patterns, and the different kinds of pattern syntax that you might see. By the end of the chapter, you’ll know how to use patterns to express many concepts in a clear way.\n\nAll the Places Patterns Can Be Used\nPatterns pop up in a number of places in Rust, and you’ve been using them a lot without realizing it! This section discusses all the places where patterns are valid.\n\"match\" Arms\nAs discussed in Chapter 6, we use patterns in the arms of \"match\" expressions. Formally, \"match\" expressions are defined as the keyword \"match\", a value to match on, and one or more match arms that consist of a pattern and an expression to run if the value matches that arm’s pattern, like this:\nmatch VALUE {\n    PATTERN =&gt; EXPRESSION,\n    PATTERN =&gt; EXPRESSION,\n    PATTERN =&gt; EXPRESSION,\n}\n\nFor example, here\"s the \"match\" expression from Listing 6-5 that matches on an \"Option\" value in the variable \"x\":\nmatch x {\n    None =&gt; None,\n    Some(i) =&gt; Some(i + 1),\n}\n\nThe patterns in this \"match\" expression are the \"None\" and \"Some(i)\" on the left of each arrow.\nOne requirement for \"match\" expressions is that they need to be exhaustive in the sense that all possibilities for the value in the \"match\" expression must be accounted for. One way to ensure you’ve covered every possibility is to have a catchall pattern for the last arm: for example, a variable name matching any value can never fail and thus covers every remaining case.\nThe particular pattern \"\" will match anything, but it never binds to a variable, so it’s often used in the last match arm. The \"\" pattern can be useful when you want to ignore any value not specified, for example. We’ll cover the \"_\" pattern in more detail in the “Ignoring Values in a Pattern” section later in this chapter.\nConditional \"if let\" Expressions\nIn Chapter 6 we discussed how to use \"if let\" expressions mainly as a shorter way to write the equivalent of a \"match\" that only matches one case. Optionally, \"if let\" can have a corresponding \"else\" containing code to run if the pattern in the \"if let\" doesn’t match.\nListing 18-1 shows that it’s also possible to mix and match \"if let\", \"else if\", and \"else if let\" expressions. Doing so gives us more flexibility than a \"match\" expression in which we can express only one value to compare with the patterns. Also, Rust doesn\"t require that the conditions in a series of \"if let\", \"else if\", \"else if let\" arms relate to each other.\nThe code in Listing 18-1 determines what color to make your background based on a series of checks for several conditions. For this example, we’ve created variables with hardcoded values that a real program might receive from user input.\nFilename: src/main.rs\nfn main() {\n    let favorite_color: Option&lt;&amp;str&gt; = None;\n    let is_tuesday = false;\n    let age: Result&lt;u8, _&gt; = \"34\".parse();\n\n    if let Some(color) = favorite_color {\n        println!(\"Using your favorite color, {color}, as the background\");\n    } else if is_tuesday {\n        println!(\"Tuesday is green day!\");\n    } else if let Ok(age) = age {\n        if age &gt; 30 {\n            println!(\"Using purple as the background color\");\n        } else {\n            println!(\"Using orange as the background color\");\n        }\n    } else {\n        println!(\"Using blue as the background color\");\n    }\n}\n\nListing 18-1: Mixing \"if let\", \"else if\", \"else if let\", and \"else\"\nIf the user specifies a favorite color, that color is used as the background. If no favorite color is specified and today is Tuesday, the background color is green. Otherwise, if the user specifies their age as a string and we can parse it as a number successfully, the color is either purple or orange depending on the value of the number. If none of these conditions apply, the background color is blue.\nThis conditional structure lets us support complex requirements. With the hardcoded values we have here, this example will print \"Using purple as the background color\".\nYou can see that \"if let\" can also introduce shadowed variables in the same way that \"match\" arms can: the line \"if let Ok(age) = age\" introduces a new shadowed \"age\" variable that contains the value inside the \"Ok\" variant. This means we need to place the \"if age &gt; 30\" condition within that block: we can’t combine these two conditions into \"if let Ok(age) = age &amp;&amp; age &gt; 30\". The shadowed \"age\" we want to compare to 30 isn’t valid until the new scope starts with the curly bracket.\nThe downside of using \"if let\" expressions is that the compiler doesn’t check for exhaustiveness, whereas with \"match\" expressions it does. If we omitted the last \"else\" block and therefore missed handling some cases, the compiler would not alert us to the possible logic bug.\n\"while let\" Conditional Loops\nSimilar in construction to \"if let\", the \"while let\" conditional loop allows a \"while\" loop to run for as long as a pattern continues to match. In Listing 18-2 we code a \"while let\" loop that uses a vector as a stack and prints the values in the vector in the opposite order in which they were pushed.\n    let mut stack = Vec::new();\n\n    stack.push(1);\n    stack.push(2);\n    stack.push(3);\n    \n    while let Some(top) = stack.pop() {\n        println!(\"{}\", top);\n    }\n\nListing 18-2: Using a \"while let\" loop to print values for as long as \"stack.pop()\" returns \"Some\"\nThis example prints 3, 2, and then 1. The \"pop\" method takes the last element out of the vector and returns \"Some(value)\". If the vector is empty, \"pop\" returns \"None\". The \"while\" loop continues running the code in its block as long as \"pop\" returns \"Some\". When \"pop\" returns \"None\", the loop stops. We can use \"while let\" to pop every element off our stack.\n\"for\" Loops\nIn a \"for\" loop, the value that directly follows the keyword \"for\" is a pattern. For example, in \"for x in y\" the \"x\" is the pattern. Listing 18-3 demonstrates how to use a pattern in a \"for\" loop to destructure, or break apart, a tuple as part of the \"for\" loop.\n    let v = vec![\"a\", \"b\", \"c\"];\n\n    for (index, value) in v.iter().enumerate() {\n        println!(\"{} is at index {}\", value, index);\n    }\n\nListing 18-3: Using a pattern in a \"for\" loop to destructure a tuple\nThe code in Listing 18-3 will print the following:\n$ cargo run\n   Compiling patterns v0.1.0 (file:///projects/patterns)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.52s\n     Running \"target/debug/patterns\"\na is at index 0\nb is at index 1\nc is at index 2\n\nWe adapt an iterator using the \"enumerate\" method so it produces a value and the index for that value, placed into a tuple. The first value produced is the tuple \"(0, \"a\")\". When this value is matched to the pattern \"(index, value)\", \"index\" will be \"0\" and \"value\" will be \"\"a\"\", printing the first line of the output.\n\"let\" Statements\nPrior to this chapter, we had only explicitly discussed using patterns with \"match\" and \"if let\", but in fact, we’ve used patterns in other places as well, including in \"let\" statements. For example, consider this straightforward variable assignment with \"let\":\nlet x = 5;\n\nEvery time you\"ve used a \"let\" statement like this you\"ve been using patterns, although you might not have realized it! More formally, a \"let\" statement looks like this:\nlet PATTERN = EXPRESSION;\n\nIn statements like \"let x = 5;\" with a variable name in the \"PATTERN\" slot, the variable name is just a particularly simple form of a pattern. Rust compares the expression against the pattern and assigns any names it finds. So in the \"let x = 5;\" example, \"x\" is a pattern that means “bind what matches here to the variable \"x\".” Because the name \"x\" is the whole pattern, this pattern effectively means “bind everything to the variable \"x\", whatever the value is.”\nTo see the pattern matching aspect of \"let\" more clearly, consider Listing 18-4, which uses a pattern with \"let\" to destructure a tuple.\n    let (x, y, z) = (1, 2, 3);\n\nListing 18-4: Using a pattern to destructure a tuple and create three variables at once\nHere, we match a tuple against a pattern. Rust compares the value \"(1, 2, 3)\" to the pattern \"(x, y, z)\" and sees that the value matches the pattern, so Rust binds \"1\" to \"x\", \"2\" to \"y\", and \"3\" to \"z\". You can think of this tuple pattern as nesting three individual variable patterns inside it.\nIf the number of elements in the pattern doesn’t match the number of elements in the tuple, the overall type won’t match and we’ll get a compiler error. For example, Listing 18-5 shows an attempt to destructure a tuple with three elements into two variables, which won’t work.\n    let (x, y) = (1, 2, 3);\n\nListing 18-5: Incorrectly constructing a pattern whose variables don’t match the number of elements in the tuple\nAttempting to compile this code results in this type error:\n$ cargo run\n   Compiling patterns v0.1.0 (file:///projects/patterns)\nerror[E0308]: mismatched types\n --&gt; src/main.rs:2:9\n  |\n2 |     let (x, y) = (1, 2, 3);\n  |         ^^^^^^   --------- this expression has type \"({integer}, {integer}, {integer})\"\n  |         |\n  |         expected a tuple with 3 elements, found one with 2 elements\n  |\n  = note: expected tuple \"({integer}, {integer}, {integer})\"\n             found tuple \"(_, _)\"\n\nFor more information about this error, try \"rustc --explain E0308\".\nerror: could not compile \"patterns\" due to previous error\n\nTo fix the error, we could ignore one or more of the values in the tuple using \"_\" or \"..\", as you’ll see in the “Ignoring Values in a Pattern” section. If the problem is that we have too many variables in the pattern, the solution is to make the types match by removing variables so the number of variables equals the number of elements in the tuple.\nFunction Parameters\nFunction parameters can also be patterns. The code in Listing 18-6, which declares a function named \"foo\" that takes one parameter named \"x\" of type \"i32\", should by now look familiar.\nfn foo(x: i32) {\n    // code goes here\n}\n\nListing 18-6: A function signature uses patterns in the parameters\nThe \"x\" part is a pattern! As we did with \"let\", we could match a tuple in a function’s arguments to the pattern. Listing 18-7 splits the values in a tuple as we pass it to a function.\nFilename: src/main.rs\nfn print_coordinates(&amp;(x, y): &amp;(i32, i32)) {\n    println!(\"Current location: ({}, {})\", x, y);\n}\n\nfn main() {\n    let point = (3, 5);\n    print_coordinates(&amp;point);\n}\n\nListing 18-7: A function with parameters that destructure a tuple\nThis code prints \"Current location: (3, 5)\". The values \"&amp;(3, 5)\" match the pattern \"&amp;(x, y)\", so \"x\" is the value \"3\" and \"y\" is the value \"5\".\nWe can also use patterns in closure parameter lists in the same way as in function parameter lists, because closures are similar to functions, as discussed in Chapter 13.\nAt this point, you’ve seen several ways of using patterns, but patterns don’t work the same in every place we can use them. In some places, the patterns must be irrefutable; in other circumstances, they can be refutable. We’ll discuss these two concepts next.\n\nRefutability: Whether a Pattern Might Fail to Match\nPatterns come in two forms: refutable and irrefutable. Patterns that will match for any possible value passed are irrefutable. An example would be \"x\" in the statement \"let x = 5;\" because \"x\" matches anything and therefore cannot fail to match. Patterns that can fail to match for some possible value are refutable. An example would be \"Some(x)\" in the expression \"if let Some(x) = a_value\" because if the value in the \"a_value\" variable is \"None\" rather than \"Some\", the \"Some(x)\" pattern will not match.\nFunction parameters, \"let\" statements, and \"for\" loops can only accept irrefutable patterns, because the program cannot do anything meaningful when values don’t match. The \"if let\" and \"while let\" expressions accept refutable and irrefutable patterns, but the compiler warns against irrefutable patterns because by definition they’re intended to handle possible failure: the functionality of a conditional is in its ability to perform differently depending on success or failure.\nIn general, you shouldn’t have to worry about the distinction between refutable and irrefutable patterns; however, you do need to be familiar with the concept of refutability so you can respond when you see it in an error message. In those cases, you’ll need to change either the pattern or the construct you’re using the pattern with, depending on the intended behavior of the code.\nLet’s look at an example of what happens when we try to use a refutable pattern where Rust requires an irrefutable pattern and vice versa. Listing 18-8 shows a \"let\" statement, but for the pattern we’ve specified \"Some(x)\", a refutable pattern. As you might expect, this code will not compile.\n    let Some(x) = some_option_value;\n\nListing 18-8: Attempting to use a refutable pattern with \"let\"\nIf \"some_option_value\" was a \"None\" value, it would fail to match the pattern \"Some(x)\", meaning the pattern is refutable. However, the \"let\" statement can only accept an irrefutable pattern because there is nothing valid the code can do with a \"None\" value. At compile time, Rust will complain that we’ve tried to use a refutable pattern where an irrefutable pattern is required:\n$ cargo run\n   Compiling patterns v0.1.0 (file:///projects/patterns)\nerror[E0005]: refutable pattern in local binding: \"None\" not covered\n --&gt; src/main.rs:3:9\n  |\n3 |     let Some(x) = some_option_value;\n  |         ^^^^^^^ pattern \"None\" not covered\n  |\n  = note: \"let\" bindings require an \"irrefutable pattern\", like a \"struct\" or an \"enum\" with only one variant\n  = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\nnote: \"Option&lt;i32&gt;\" defined here\n --&gt; /rustc/d5a82bbd26e1ad8b7401f6a718a9c57c96905483/library/core/src/option.rs:518:1\n  |\n  = note: \n/rustc/d5a82bbd26e1ad8b7401f6a718a9c57c96905483/library/core/src/option.rs:522:5: not covered\n  = note: the matched value is of type \"Option&lt;i32&gt;\"\nhelp: you might want to use \"if let\" to ignore the variant that isn\"t matched\n  |\n3 |     let x = if let Some(x) = some_option_value { x } else { todo!() };\n  |     ++++++++++                                 ++++++++++++++++++++++\nhelp: alternatively, you might want to use let else to handle the variant that isn\"t matched\n  |\n3 |     let Some(x) = some_option_value else { todo!() };\n  |                                     ++++++++++++++++\n\nFor more information about this error, try \"rustc --explain E0005\".\nerror: could not compile \"patterns\" due to previous error\n\nBecause we didn’t cover (and couldn’t cover!) every valid value with the pattern \"Some(x)\", Rust rightfully produces a compiler error.\nIf we have a refutable pattern where an irrefutable pattern is needed, we can fix it by changing the code that uses the pattern: instead of using \"let\", we can use \"if let\". Then if the pattern doesn’t match, the code will just skip the code in the curly brackets, giving it a way to continue validly. Listing 18-9 shows how to fix the code in Listing 18-8.\n    if let Some(x) = some_option_value {\n        println!(\"{}\", x);\n    }\n\nListing 18-9: Using \"if let\" and a block with refutable patterns instead of \"let\"\nWe’ve given the code an out! This code is perfectly valid, although it means we cannot use an irrefutable pattern without receiving an error. If we give \"if let\" a pattern that will always match, such as \"x\", as shown in Listing 18-10, the compiler will give a warning.\n    if let x = 5 {\n        println!(\"{}\", x);\n    };\n\nListing 18-10: Attempting to use an irrefutable pattern with \"if let\"\nRust complains that it doesn’t make sense to use \"if let\" with an irrefutable pattern:\n$ cargo run\n   Compiling patterns v0.1.0 (file:///projects/patterns)\nwarning: irrefutable \"if let\" pattern\n --&gt; src/main.rs:2:8\n  |\n2 |     if let x = 5 {\n  |        ^^^^^^^^^\n  |\n  = note: this pattern will always match, so the \"if let\" is useless\n  = help: consider replacing the \"if let\" with a \"let\"\n  = note: \"#[warn(irrefutable_let_patterns)]\" on by default\n\nwarning: \"patterns\" (bin \"patterns\") generated 1 warning\n    Finished dev [unoptimized + debuginfo] target(s) in 0.39s\n     Running \"target/debug/patterns\"\n5\n\nFor this reason, match arms must use refutable patterns, except for the last arm, which should match any remaining values with an irrefutable pattern. Rust allows us to use an irrefutable pattern in a \"match\" with only one arm, but this syntax isn’t particularly useful and could be replaced with a simpler \"let\" statement.\nNow that you know where to use patterns and the difference between refutable and irrefutable patterns, let’s cover all the syntax we can use to create patterns.\n\nPattern Syntax\nIn this section, we gather all the syntax valid in patterns and discuss why and when you might want to use each one.\nMatching Literals\nAs you saw in Chapter 6, you can match patterns against literals directly. The following code gives some examples:\n    let x = 1;\n\n    match x {\n        1 =&gt; println!(\"one\"),\n        2 =&gt; println!(\"two\"),\n        3 =&gt; println!(\"three\"),\n        _ =&gt; println!(\"anything\"),\n    }\n\nThis code prints \"one\" because the value in \"x\" is 1. This syntax is useful when you want your code to take an action if it gets a particular concrete value.\nMatching Named Variables\nNamed variables are irrefutable patterns that match any value, and we’ve used them many times in the book. However, there is a complication when you use named variables in \"match\" expressions. Because \"match\" starts a new scope, variables declared as part of a pattern inside the \"match\" expression will shadow those with the same name outside the \"match\" construct, as is the case with all variables. In Listing 18-11, we declare a variable named \"x\" with the value \"Some(5)\" and a variable \"y\" with the value \"10\". We then create a \"match\" expression on the value \"x\". Look at the patterns in the match arms and \"println!\" at the end, and try to figure out what the code will print before running this code or reading further.\nFilename: src/main.rs\n    let x = Some(5);\n    let y = 10;\n\n    match x {\n        Some(50) =&gt; println!(\"Got 50\"),\n        Some(y) =&gt; println!(\"Matched, y = {y}\"),\n        _ =&gt; println!(\"Default case, x = {:?}\", x),\n    }\n    \n    println!(\"at the end: x = {:?}, y = {y}\", x);\n\nListing 18-11: A \"match\" expression with an arm that introduces a shadowed variable \"y\"\nLet’s walk through what happens when the \"match\" expression runs. The pattern in the first match arm doesn’t match the defined value of \"x\", so the code continues.\nThe pattern in the second match arm introduces a new variable named \"y\" that will match any value inside a \"Some\" value. Because we’re in a new scope inside the \"match\" expression, this is a new \"y\" variable, not the \"y\" we declared at the beginning with the value 10. This new \"y\" binding will match any value inside a \"Some\", which is what we have in \"x\". Therefore, this new \"y\" binds to the inner value of the \"Some\" in \"x\". That value is \"5\", so the expression for that arm executes and prints \"Matched, y = 5\".\nIf \"x\" had been a \"None\" value instead of \"Some(5)\", the patterns in the first two arms wouldn’t have matched, so the value would have matched to the underscore. We didn’t introduce the \"x\" variable in the pattern of the underscore arm, so the \"x\" in the expression is still the outer \"x\" that hasn’t been shadowed. In this hypothetical case, the \"match\" would print \"Default case, x = None\".\nWhen the \"match\" expression is done, its scope ends, and so does the scope of the inner \"y\". The last \"println!\" produces \"at the end: x = Some(5), y = 10\".\nTo create a \"match\" expression that compares the values of the outer \"x\" and \"y\", rather than introducing a shadowed variable, we would need to use a match guard conditional instead. We’ll talk about match guards later in the “Extra Conditionals with Match Guards” section.\nMultiple Patterns\nIn \"match\" expressions, you can match multiple patterns using the \"|\" syntax, which is the pattern or operator. For example, in the following code we match the value of \"x\" against the match arms, the first of which has an or option, meaning if the value of \"x\" matches either of the values in that arm, that arm’s code will run:\n    let x = 1;\n\n    match x {\n        1 | 2 =&gt; println!(\"one or two\"),\n        3 =&gt; println!(\"three\"),\n        _ =&gt; println!(\"anything\"),\n    }\n\nThis code prints \"one or two\".\nMatching Ranges of Values with \"..=\"\nThe \"..=\" syntax allows us to match to an inclusive range of values. In the following code, when a pattern matches any of the values within the given range, that arm will execute:\n    let x = 5;\n\n    match x {\n        1..=5 =&gt; println!(\"one through five\"),\n        _ =&gt; println!(\"something else\"),\n    }\n\nIf \"x\" is 1, 2, 3, 4, or 5, the first arm will match. This syntax is more convenient for multiple match values than using the \"|\" operator to express the same idea; if we were to use \"|\" we would have to specify \"1 | 2 | 3 | 4 | 5\". Specifying a range is much shorter, especially if we want to match, say, any number between 1 and 1,000!\nThe compiler checks that the range isn’t empty at compile time, and because the only types for which Rust can tell if a range is empty or not are \"char\" and numeric values, ranges are only allowed with numeric or \"char\" values.\nHere is an example using ranges of \"char\" values:\n    let x = \"c\";\n\n    match x {\n        \"a\"..=\"j\" =&gt; println!(\"early ASCII letter\"),\n        \"k\"..=\"z\" =&gt; println!(\"late ASCII letter\"),\n        _ =&gt; println!(\"something else\"),\n    }\n\nRust can tell that \"\"c\"\" is within the first pattern’s range and prints \"early ASCII letter\".\nDestructuring to Break Apart Values\nWe can also use patterns to destructure structs, enums, and tuples to use different parts of these values. Let’s walk through each value.\nDestructuring Structs\nListing 18-12 shows a \"Point\" struct with two fields, \"x\" and \"y\", that we can break apart using a pattern with a \"let\" statement.\nFilename: src/main.rs\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let p = Point { x: 0, y: 7 };\n\n    let Point { x: a, y: b } = p;\n    assert_eq!(0, a);\n    assert_eq!(7, b);\n}\n\nListing 18-12: Destructuring a struct’s fields into separate variables\nThis code creates the variables \"a\" and \"b\" that match the values of the \"x\" and \"y\" fields of the \"p\" struct. This example shows that the names of the variables in the pattern don’t have to match the field names of the struct. However, it’s common to match the variable names to the field names to make it easier to remember which variables came from which fields. Because of this common usage, and because writing \"let Point { x: x, y: y } = p;\" contains a lot of duplication, Rust has a shorthand for patterns that match struct fields: you only need to list the name of the struct field, and the variables created from the pattern will have the same names. Listing 18-13 behaves in the same way as the code in Listing 18-12, but the variables created in the \"let\" pattern are \"x\" and \"y\" instead of \"a\" and \"b\".\nFilename: src/main.rs\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let p = Point { x: 0, y: 7 };\n\n    let Point { x, y } = p;\n    assert_eq!(0, x);\n    assert_eq!(7, y);\n}\n\nListing 18-13: Destructuring struct fields using struct field shorthand\nThis code creates the variables \"x\" and \"y\" that match the \"x\" and \"y\" fields of the \"p\" variable. The outcome is that the variables \"x\" and \"y\" contain the values from the \"p\" struct.\nWe can also destructure with literal values as part of the struct pattern rather than creating variables for all the fields. Doing so allows us to test some of the fields for particular values while creating variables to destructure the other fields.\nIn Listing 18-14, we have a \"match\" expression that separates \"Point\" values into three cases: points that lie directly on the \"x\" axis (which is true when \"y = 0\"), on the \"y\" axis (\"x = 0\"), or neither.\nFilename: src/main.rs\nfn main() {\n    let p = Point { x: 0, y: 7 };\n\n    match p {\n        Point { x, y: 0 } =&gt; println!(\"On the x axis at {x}\"),\n        Point { x: 0, y } =&gt; println!(\"On the y axis at {y}\"),\n        Point { x, y } =&gt; {\n            println!(\"On neither axis: ({x}, {y})\");\n        }\n    }\n}\n\nListing 18-14: Destructuring and matching literal values in one pattern\nThe first arm will match any point that lies on the \"x\" axis by specifying that the \"y\" field matches if its value matches the literal \"0\". The pattern still creates an \"x\" variable that we can use in the code for this arm.\nSimilarly, the second arm matches any point on the \"y\" axis by specifying that the \"x\" field matches if its value is \"0\" and creates a variable \"y\" for the value of the \"y\" field. The third arm doesn’t specify any literals, so it matches any other \"Point\" and creates variables for both the \"x\" and \"y\" fields.\nIn this example, the value \"p\" matches the second arm by virtue of \"x\" containing a 0, so this code will print \"On the y axis at 7\".\nRemember that a \"match\" expression stops checking arms once it has found the first matching pattern, so even though \"Point { x: 0, y: 0}\" is on the \"x\" axis and the \"y\" axis, this code would only print \"On the x axis at 0\".\nDestructuring Enums\nWe\"ve destructured enums in this book (for example, Listing 6-5 in Chapter 6), but haven’t yet explicitly discussed that the pattern to destructure an enum corresponds to the way the data stored within the enum is defined. As an example, in Listing 18-15 we use the \"Message\" enum from Listing 6-2 and write a \"match\" with patterns that will destructure each inner value.\nFilename: src/main.rs\nenum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n}\n\nfn main() {\n    let msg = Message::ChangeColor(0, 160, 255);\n\n    match msg {\n        Message::Quit =&gt; {\n            println!(\"The Quit variant has no data to destructure.\");\n        }\n        Message::Move { x, y } =&gt; {\n            println!(\"Move in the x direction {x} and in the y direction {y}\");\n        }\n        Message::Write(text) =&gt; {\n            println!(\"Text message: {text}\");\n        }\n        Message::ChangeColor(r, g, b) =&gt; {\n            println!(\"Change the color to red {r}, green {g}, and blue {b}\",)\n        }\n    }\n}\n\nListing 18-15: Destructuring enum variants that hold different kinds of values\nThis code will print \"Change the color to red 0, green 160, and blue 255\". Try changing the value of \"msg\" to see the code from the other arms run.\nFor enum variants without any data, like \"Message::Quit\", we can’t destructure the value any further. We can only match on the literal \"Message::Quit\" value, and no variables are in that pattern.\nFor struct-like enum variants, such as \"Message::Move\", we can use a pattern similar to the pattern we specify to match structs. After the variant name, we place curly brackets and then list the fields with variables so we break apart the pieces to use in the code for this arm. Here we use the shorthand form as we did in Listing 18-13.\nFor tuple-like enum variants, like \"Message::Write\" that holds a tuple with one element and \"Message::ChangeColor\" that holds a tuple with three elements, the pattern is similar to the pattern we specify to match tuples. The number of variables in the pattern must match the number of elements in the variant we’re matching.\nDestructuring Nested Structs and Enums\nSo far, our examples have all been matching structs or enums one level deep, but matching can work on nested items too! For example, we can refactor the code in Listing 18-15 to support RGB and HSV colors in the \"ChangeColor\" message, as shown in Listing 18-16.\nenum Color {\n    Rgb(i32, i32, i32),\n    Hsv(i32, i32, i32),\n}\n\nenum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(Color),\n}\n\nfn main() {\n    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));\n\n    match msg {\n        Message::ChangeColor(Color::Rgb(r, g, b)) =&gt; {\n            println!(\"Change color to red {r}, green {g}, and blue {b}\");\n        }\n        Message::ChangeColor(Color::Hsv(h, s, v)) =&gt; {\n            println!(\"Change color to hue {h}, saturation {s}, value {v}\")\n        }\n        _ =&gt; (),\n    }\n}\n\nListing 18-16: Matching on nested enums\nThe pattern of the first arm in the \"match\" expression matches a \"Message::ChangeColor\" enum variant that contains a \"Color::Rgb\" variant; then the pattern binds to the three inner \"i32\" values. The pattern of the second arm also matches a \"Message::ChangeColor\" enum variant, but the inner enum matches \"Color::Hsv\" instead. We can specify these complex conditions in one \"match\" expression, even though two enums are involved.\nDestructuring Structs and Tuples\nWe can mix, match, and nest destructuring patterns in even more complex ways. The following example shows a complicated destructure where we nest structs and tuples inside a tuple and destructure all the primitive values out:\n    let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });\n\nThis code lets us break complex types into their component parts so we can use the values we’re interested in separately.\nDestructuring with patterns is a convenient way to use pieces of values, such as the value from each field in a struct, separately from each other.\nIgnoring Values in a Pattern\nYou’ve seen that it’s sometimes useful to ignore values in a pattern, such as in the last arm of a \"match\", to get a catchall that doesn’t actually do anything but does account for all remaining possible values. There are a few ways to ignore entire values or parts of values in a pattern: using the \"\" pattern (which you’ve seen), using the \"\" pattern within another pattern, using a name that starts with an underscore, or using \"..\" to ignore remaining parts of a value. Let’s explore how and why to use each of these patterns.\nIgnoring an Entire Value with \"_\"\nWe’ve used the underscore as a wildcard pattern that will match any value but not bind to the value. This is especially useful as the last arm in a \"match\" expression, but we can also use it in any pattern, including function parameters, as shown in Listing 18-17.\nFilename: src/main.rs\nfn foo(_: i32, y: i32) {\n    println!(\"This code only uses the y parameter: {}\", y);\n}\n\nfn main() {\n    foo(3, 4);\n}\n\nListing 18-17: Using \"_\" in a function signature\nThis code will completely ignore the value \"3\" passed as the first argument, and will print \"This code only uses the y parameter: 4\".\nIn most cases when you no longer need a particular function parameter, you would change the signature so it doesn’t include the unused parameter. Ignoring a function parameter can be especially useful in cases when, for example, you\"re implementing a trait when you need a certain type signature but the function body in your implementation doesn’t need one of the parameters. You then avoid getting a compiler warning about unused function parameters, as you would if you used a name instead.\nIgnoring Parts of a Value with a Nested \"_\"\nWe can also use \"_\" inside another pattern to ignore just part of a value, for example, when we want to test for only part of a value but have no use for the other parts in the corresponding code we want to run. Listing 18-18 shows code responsible for managing a setting’s value. The business requirements are that the user should not be allowed to overwrite an existing customization of a setting but can unset the setting and give it a value if it is currently unset.\n    let mut setting_value = Some(5);\n    let new_setting_value = Some(10);\n\n    match (setting_value, new_setting_value) {\n        (Some(_), Some(_)) =&gt; {\n            println!(\"Can\"t overwrite an existing customized value\");\n        }\n        _ =&gt; {\n            setting_value = new_setting_value;\n        }\n    }\n    \n    println!(\"setting is {:?}\", setting_value);\n\nListing 18-18: Using an underscore within patterns that match \"Some\" variants when we don’t need to use the value inside the \"Some\"\nThis code will print \"Can\"t overwrite an existing customized value\" and then \"setting is Some(5)\". In the first match arm, we don’t need to match on or use the values inside either \"Some\" variant, but we do need to test for the case when \"setting_value\" and \"new_setting_value\" are the \"Some\" variant. In that case, we print the reason for not changing \"setting_value\", and it doesn’t get changed.\nIn all other cases (if either \"setting_value\" or \"new_setting_value\" are \"None\") expressed by the \"_\" pattern in the second arm, we want to allow \"new_setting_value\" to become \"setting_value\".\nWe can also use underscores in multiple places within one pattern to ignore particular values. Listing 18-19 shows an example of ignoring the second and fourth values in a tuple of five items.\n    let numbers = (2, 4, 8, 16, 32);\n\n    match numbers {\n        (first, _, third, _, fifth) =&gt; {\n            println!(\"Some numbers: {first}, {third}, {fifth}\")\n        }\n    }\n\nListing 18-19: Ignoring multiple parts of a tuple\nThis code will print \"Some numbers: 2, 8, 32\", and the values 4 and 16 will be ignored.\nIgnoring an Unused Variable by Starting Its Name with \"_\"\nIf you create a variable but don’t use it anywhere, Rust will usually issue a warning because an unused variable could be a bug. However, sometimes it’s useful to be able to create a variable you won’t use yet, such as when you’re prototyping or just starting a project. In this situation, you can tell Rust not to warn you about the unused variable by starting the name of the variable with an underscore. In Listing 18-20, we create two unused variables, but when we compile this code, we should only get a warning about one of them.\nFilename: src/main.rs\nfn main() {\n    let _x = 5;\n    let y = 10;\n}\n\nListing 18-20: Starting a variable name with an underscore to avoid getting unused variable warnings\nHere we get a warning about not using the variable \"y\", but we don’t get a warning about not using \"_x\".\nNote that there is a subtle difference between using only \"_\" and using a name that starts with an underscore. The syntax \"x\" still binds the value to the variable, whereas \"\" doesn’t bind at all. To show a case where this distinction matters, Listing 18-21 will provide us with an error.\n    let s = Some(String::from(\"Hello!\"));\n\n    if let Some(_s) = s {\n        println!(\"found a string\");\n    }\n    \n    println!(\"{:?}\", s);\n\nListing 18-21: An unused variable starting with an underscore still binds the value, which might take ownership of the value\nWe’ll receive an error because the \"s\" value will still be moved into \"s\", which prevents us from using \"s\" again. However, using the underscore by itself doesn’t ever bind to the value. Listing 18-22 will compile without any errors because \"s\" doesn’t get moved into \"\".\n    let s = Some(String::from(\"Hello!\"));\n\n    if let Some(_) = s {\n        println!(\"found a string\");\n    }\n    \n    println!(\"{:?}\", s);\n\nListing 18-22: Using an underscore does not bind the value\nThis code works just fine because we never bind \"s\" to anything; it isn’t moved.\nIgnoring Remaining Parts of a Value with \"..\"\nWith values that have many parts, we can use the \"..\" syntax to use specific parts and ignore the rest, avoiding the need to list underscores for each ignored value. The \"..\" pattern ignores any parts of a value that we haven’t explicitly matched in the rest of the pattern. In Listing 18-23, we have a \"Point\" struct that holds a coordinate in three-dimensional space. In the \"match\" expression, we want to operate only on the \"x\" coordinate and ignore the values in the \"y\" and \"z\" fields.\n    struct Point {\n        x: i32,\n        y: i32,\n        z: i32,\n    }\n\n    let origin = Point { x: 0, y: 0, z: 0 };\n    \n    match origin {\n        Point { x, .. } =&gt; println!(\"x is {}\", x),\n    }\n\nListing 18-23: Ignoring all fields of a \"Point\" except for \"x\" by using \"..\"\nWe list the \"x\" value and then just include the \"..\" pattern. This is quicker than having to list \"y: _\" and \"z: _\", particularly when we’re working with structs that have lots of fields in situations where only one or two fields are relevant.\nThe syntax \"..\" will expand to as many values as it needs to be. Listing 18-24 shows how to use \"..\" with a tuple.\nFilename: src/main.rs\nfn main() {\n    let numbers = (2, 4, 8, 16, 32);\n\n    match numbers {\n        (first, .., last) =&gt; {\n            println!(\"Some numbers: {first}, {last}\");\n        }\n    }\n}\n\nListing 18-24: Matching only the first and last values in a tuple and ignoring all other values\nIn this code, the first and last value are matched with \"first\" and \"last\". The \"..\" will match and ignore everything in the middle.\nHowever, using \"..\" must be unambiguous. If it is unclear which values are intended for matching and which should be ignored, Rust will give us an error. Listing 18-25 shows an example of using \"..\" ambiguously, so it will not compile.\nFilename: src/main.rs\nfn main() {\n    let numbers = (2, 4, 8, 16, 32);\n\n    match numbers {\n        (.., second, ..) =&gt; {\n            println!(\"Some numbers: {}\", second)\n        },\n    }\n}\n\nListing 18-25: An attempt to use \"..\" in an ambiguous way\nWhen we compile this example, we get this error:\n$ cargo run\n   Compiling patterns v0.1.0 (file:///projects/patterns)\nerror: \"..\" can only be used once per tuple pattern\n --&gt; src/main.rs:5:22\n  |\n5 |         (.., second, ..) =&gt; {\n  |          --          ^^ can only be used once per tuple pattern\n  |          |\n  |          previously used here\n\nerror: could not compile \"patterns\" due to previous error\n\nIt’s impossible for Rust to determine how many values in the tuple to ignore before matching a value with \"second\" and then how many further values to ignore thereafter. This code could mean that we want to ignore \"2\", bind \"second\" to \"4\", and then ignore \"8\", \"16\", and \"32\"; or that we want to ignore \"2\" and \"4\", bind \"second\" to \"8\", and then ignore \"16\" and \"32\"; and so forth. The variable name \"second\" doesn’t mean anything special to Rust, so we get a compiler error because using \"..\" in two places like this is ambiguous.\nExtra Conditionals with Match Guards\nA match guard is an additional \"if\" condition, specified after the pattern in a \"match\" arm, that must also match for that arm to be chosen. Match guards are useful for expressing more complex ideas than a pattern alone allows.\nThe condition can use variables created in the pattern. Listing 18-26 shows a \"match\" where the first arm has the pattern \"Some(x)\" and also has a match guard of \"if x % 2 == 0\" (which will be true if the number is even).\n    let num = Some(4);\n\n    match num {\n        Some(x) if x % 2 == 0 =&gt; println!(\"The number {} is even\", x),\n        Some(x) =&gt; println!(\"The number {} is odd\", x),\n        None =&gt; (),\n    }\n\nListing 18-26: Adding a match guard to a pattern\nThis example will print \"The number 4 is even\". When \"num\" is compared to the pattern in the first arm, it matches, because \"Some(4)\" matches \"Some(x)\". Then the match guard checks whether the remainder of dividing \"x\" by 2 is equal to 0, and because it is, the first arm is selected.\nIf \"num\" had been \"Some(5)\" instead, the match guard in the first arm would have been false because the remainder of 5 divided by 2 is 1, which is not equal to 0. Rust would then go to the second arm, which would match because the second arm doesn’t have a match guard and therefore matches any \"Some\" variant.\nThere is no way to express the \"if x % 2 == 0\" condition within a pattern, so the match guard gives us the ability to express this logic. The downside of this additional expressiveness is that the compiler doesn\"t try to check for exhaustiveness when match guard expressions are involved.\nIn Listing 18-11, we mentioned that we could use match guards to solve our pattern-shadowing problem. Recall that we created a new variable inside the pattern in the \"match\" expression instead of using the variable outside the \"match\". That new variable meant we couldn’t test against the value of the outer variable. Listing 18-27 shows how we can use a match guard to fix this problem.\nFilename: src/main.rs\nfn main() {\n    let x = Some(5);\n    let y = 10;\n\n    match x {\n        Some(50) =&gt; println!(\"Got 50\"),\n        Some(n) if n == y =&gt; println!(\"Matched, n = {n}\"),\n        _ =&gt; println!(\"Default case, x = {:?}\", x),\n    }\n    \n    println!(\"at the end: x = {:?}, y = {y}\", x);\n}\n\nListing 18-27: Using a match guard to test for equality with an outer variable\nThis code will now print \"Default case, x = Some(5)\". The pattern in the second match arm doesn’t introduce a new variable \"y\" that would shadow the outer \"y\", meaning we can use the outer \"y\" in the match guard. Instead of specifying the pattern as \"Some(y)\", which would have shadowed the outer \"y\", we specify \"Some(n)\". This creates a new variable \"n\" that doesn’t shadow anything because there is no \"n\" variable outside the \"match\".\nThe match guard \"if n == y\" is not a pattern and therefore doesn’t introduce new variables. This \"y\" is the outer \"y\" rather than a new shadowed \"y\", and we can look for a value that has the same value as the outer \"y\" by comparing \"n\" to \"y\".\nYou can also use the or operator \"|\" in a match guard to specify multiple patterns; the match guard condition will apply to all the patterns. Listing 18-28 shows the precedence when combining a pattern that uses \"|\" with a match guard. The important part of this example is that the \"if y\" match guard applies to \"4\", \"5\", and \"6\", even though it might look like \"if y\" only applies to \"6\".\n    let x = 4;\n    let y = false;\n\n    match x {\n        4 | 5 | 6 if y =&gt; println!(\"yes\"),\n        _ =&gt; println!(\"no\"),\n    }\n\nListing 18-28: Combining multiple patterns with a match guard\nThe match condition states that the arm only matches if the value of \"x\" is equal to \"4\", \"5\", or \"6\" and if \"y\" is \"true\". When this code runs, the pattern of the first arm matches because \"x\" is \"4\", but the match guard \"if y\" is false, so the first arm is not chosen. The code moves on to the second arm, which does match, and this program prints \"no\". The reason is that the \"if\" condition applies to the whole pattern \"4 | 5 | 6\", not only to the last value \"6\". In other words, the precedence of a match guard in relation to a pattern behaves like this:\n(4 | 5 | 6) if y =&gt; ...\n\nrather than this:\n4 | 5 | (6 if y) =&gt; ...\n\nAfter running the code, the precedence behavior is evident: if the match guard were applied only to the final value in the list of values specified using the \"|\" operator, the arm would have matched and the program would have printed \"yes\".\n\"@\" Bindings\nThe at operator \"@\" lets us create a variable that holds a value at the same time as we’re testing that value for a pattern match. In Listing 18-29, we want to test that a \"Message::Hello\" \"id\" field is within the range \"3..=7\". We also want to bind the value to the variable \"id_variable\" so we can use it in the code associated with the arm. We could name this variable \"id\", the same as the field, but for this example we’ll use a different name.\n    enum Message {\n        Hello { id: i32 },\n    }\n\n    let msg = Message::Hello { id: 5 };\n    \n    match msg {\n        Message::Hello {\n            id: id_variable @ 3..=7,\n        } =&gt; println!(\"Found an id in range: {}\", id_variable),\n        Message::Hello { id: 10..=12 } =&gt; {\n            println!(\"Found an id in another range\")\n        }\n        Message::Hello { id } =&gt; println!(\"Found some other id: {}\", id),\n    }\n\nListing 18-29: Using \"@\" to bind to a value in a pattern while also testing it\nThis example will print \"Found an id in range: 5\". By specifying \"id_variable @\" before the range \"3..=7\", we’re capturing whatever value matched the range while also testing that the value matched the range pattern.\nIn the second arm, where we only have a range specified in the pattern, the code associated with the arm doesn’t have a variable that contains the actual value of the \"id\" field. The \"id\" field’s value could have been 10, 11, or 12, but the code that goes with that pattern doesn’t know which it is. The pattern code isn’t able to use the value from the \"id\" field, because we haven’t saved the \"id\" value in a variable.\nIn the last arm, where we’ve specified a variable without a range, we do have the value available to use in the arm’s code in a variable named \"id\". The reason is that we’ve used the struct field shorthand syntax. But we haven’t applied any test to the value in the \"id\" field in this arm, as we did with the first two arms: any value would match this pattern.\nUsing \"@\" lets us test a value and save it in a variable within one pattern.\nSummary\nRust’s patterns are very useful in distinguishing between different kinds of data. When used in \"match\" expressions, Rust ensures your patterns cover every possible value, or your program won’t compile. Patterns in \"let\" statements and function parameters make those constructs more useful, enabling the destructuring of values into smaller parts at the same time as assigning to variables. We can create simple or complex patterns to suit our needs.\nNext, for the penultimate chapter of the book, we’ll look at some advanced aspects of a variety of Rust’s features.\n\n19\nAdvanced Features\nBy now, you’ve learned the most commonly used parts of the Rust programming language. Before we do one more project in Chapter 20, we’ll look at a few aspects of the language you might run into every once in a while, but may not use every day. You can use this chapter as a reference for when you encounter any unknowns. The features covered here are useful in very specific situations. Although you might not reach for them often, we want to make sure you have a grasp of all the features Rust has to offer.\nIn this chapter, we’ll cover:\n\nUnsafe Rust: how to opt out of some of Rust’s guarantees and take responsibility for manually upholding those guarantees\nAdvanced traits: associated types, default type parameters, fully qualified syntax, supertraits, and the newtype pattern in relation to traits\nAdvanced types: more about the newtype pattern, type aliases, the never type, and dynamically sized types\nAdvanced functions and closures: function pointers and returning closures\nMacros: ways to define code that defines more code at compile time\n\nIt’s a panoply of Rust features with something for everyone! Let’s dive in!\n\nUnsafe Rust\nAll the code we’ve discussed so far has had Rust’s memory safety guarantees enforced at compile time. However, Rust has a second language hidden inside it that doesn’t enforce these memory safety guarantees: it’s called unsafe Rust and works just like regular Rust, but gives us extra superpowers.\nUnsafe Rust exists because, by nature, static analysis is conservative. When the compiler tries to determine whether or not code upholds the guarantees, it’s better for it to reject some valid programs than to accept some invalid programs. Although the code might be okay, if the Rust compiler doesn’t have enough information to be confident, it will reject the code. In these cases, you can use unsafe code to tell the compiler, “Trust me, I know what I’m doing.” Be warned, however, that you use unsafe Rust at your own risk: if you use unsafe code incorrectly, problems can occur due to memory unsafety, such as null pointer dereferencing.\nAnother reason Rust has an unsafe alter ego is that the underlying computer hardware is inherently unsafe. If Rust didn’t let you do unsafe operations, you couldn’t do certain tasks. Rust needs to allow you to do low-level systems programming, such as directly interacting with the operating system or even writing your own operating system. Working with low-level systems programming is one of the goals of the language. Let’s explore what we can do with unsafe Rust and how to do it.\nUnsafe Superpowers\nTo switch to unsafe Rust, use the \"unsafe\" keyword and then start a new block that holds the unsafe code. You can take five actions in unsafe Rust that you can’t in safe Rust, which we call unsafe superpowers. Those superpowers include the ability to:\n\nDereference a raw pointer\nCall an unsafe function or method\nAccess or modify a mutable static variable\nImplement an unsafe trait\nAccess fields of \"union\"s\n\nIt’s important to understand that \"unsafe\" doesn’t turn off the borrow checker or disable any other of Rust’s safety checks: if you use a reference in unsafe code, it will still be checked. The \"unsafe\" keyword only gives you access to these five features that are then not checked by the compiler for memory safety. You’ll still get some degree of safety inside of an unsafe block.\nIn addition, \"unsafe\" does not mean the code inside the block is necessarily dangerous or that it will definitely have memory safety problems: the intent is that as the programmer, you’ll ensure the code inside an \"unsafe\" block will access memory in a valid way.\nPeople are fallible, and mistakes will happen, but by requiring these five unsafe operations to be inside blocks annotated with \"unsafe\" you’ll know that any errors related to memory safety must be within an \"unsafe\" block. Keep \"unsafe\" blocks small; you’ll be thankful later when you investigate memory bugs.\nTo isolate unsafe code as much as possible, it’s best to enclose unsafe code within a safe abstraction and provide a safe API, which we’ll discuss later in the chapter when we examine unsafe functions and methods. Parts of the standard library are implemented as safe abstractions over unsafe code that has been audited. Wrapping unsafe code in a safe abstraction prevents uses of \"unsafe\" from leaking out into all the places that you or your users might want to use the functionality implemented with \"unsafe\" code, because using a safe abstraction is safe.\nLet’s look at each of the five unsafe superpowers in turn. We’ll also look at some abstractions that provide a safe interface to unsafe code.\nDereferencing a Raw Pointer\nIn Chapter 4, in the “Dangling References” section, we mentioned that the compiler ensures references are always valid. Unsafe Rust has two new types called raw pointers that are similar to references. As with references, raw pointers can be immutable or mutable and are written as \"*const T\" and \"*mut T\", respectively. The asterisk isn’t the dereference operator; it’s part of the type name. In the context of raw pointers, immutable means that the pointer can’t be directly assigned to after being dereferenced.\nDifferent from references and smart pointers, raw pointers:\n\nAre allowed to ignore the borrowing rules by having both immutable and mutable pointers or multiple mutable pointers to the same location\nAren’t guaranteed to point to valid memory\nAre allowed to be null\nDon’t implement any automatic cleanup\n\nBy opting out of having Rust enforce these guarantees, you can give up guaranteed safety in exchange for greater performance or the ability to interface with another language or hardware where Rust’s guarantees don’t apply.\nListing 19-1 shows how to create an immutable and a mutable raw pointer from references.\n    let mut num = 5;\n\n    let r1 = &amp;num as *const i32;\n    let r2 = &amp;mut num as *mut i32;\n\nListing 19-1: Creating raw pointers from references\nNotice that we don’t include the \"unsafe\" keyword in this code. We can create raw pointers in safe code; we just can’t dereference raw pointers outside an unsafe block, as you’ll see in a bit.\nWe’ve created raw pointers by using \"as\" to cast an immutable and a mutable reference into their corresponding raw pointer types. Because we created them directly from references guaranteed to be valid, we know these particular raw pointers are valid, but we can’t make that assumption about just any raw pointer.\nTo demonstrate this, next we’ll create a raw pointer whose validity we can’t be so certain of. Listing 19-2 shows how to create a raw pointer to an arbitrary location in memory. Trying to use arbitrary memory is undefined: there might be data at that address or there might not, the compiler might optimize the code so there is no memory access, or the program might error with a segmentation fault. Usually, there is no good reason to write code like this, but it is possible.\n    let address = 0x012345usize;\n    let r = address as *const i32;\n\nListing 19-2: Creating a raw pointer to an arbitrary memory address\nRecall that we can create raw pointers in safe code, but we can’t dereference raw pointers and read the data being pointed to. In Listing 19-3, we use the dereference operator \"*\" on a raw pointer that requires an \"unsafe\" block.\n    let mut num = 5;\n\n    let r1 = &amp;num as *const i32;\n    let r2 = &amp;mut num as *mut i32;\n    \n    unsafe {\n        println!(\"r1 is: {}\", *r1);\n        println!(\"r2 is: {}\", *r2);\n    }\n\nListing 19-3: Dereferencing raw pointers within an \"unsafe\" block\nCreating a pointer does no harm; it’s only when we try to access the value that it points at that we might end up dealing with an invalid value.\nNote also that in Listing 19-1 and 19-3, we created \"*const i32\" and \"*mut i32\" raw pointers that both pointed to the same memory location, where \"num\" is stored. If we instead tried to create an immutable and a mutable reference to \"num\", the code would not have compiled because Rust’s ownership rules don’t allow a mutable reference at the same time as any immutable references. With raw pointers, we can create a mutable pointer and an immutable pointer to the same location and change data through the mutable pointer, potentially creating a data race. Be careful!\nWith all of these dangers, why would you ever use raw pointers? One major use case is when interfacing with C code, as you’ll see in the next section, “Calling an Unsafe Function or Method.” Another case is when building up safe abstractions that the borrow checker doesn’t understand. We’ll introduce unsafe functions and then look at an example of a safe abstraction that uses unsafe code.\nCalling an Unsafe Function or Method\nThe second type of operation you can perform in an unsafe block is calling unsafe functions. Unsafe functions and methods look exactly like regular functions and methods, but they have an extra \"unsafe\" before the rest of the definition. The \"unsafe\" keyword in this context indicates the function has requirements we need to uphold when we call this function, because Rust can’t guarantee we’ve met these requirements. By calling an unsafe function within an \"unsafe\" block, we’re saying that we’ve read this function’s documentation and take responsibility for upholding the function’s contracts.\nHere is an unsafe function named \"dangerous\" that doesn’t do anything in its body:\n    unsafe fn dangerous() {}\n\n    unsafe {\n        dangerous();\n    }\n\nWe must call the \"dangerous\" function within a separate \"unsafe\" block. If we try to call \"dangerous\" without the \"unsafe\" block, we’ll get an error:\n$ cargo run\n   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)\nerror[E0133]: call to unsafe function is unsafe and requires unsafe function or block\n --&gt; src/main.rs:4:5\n  |\n4 |     dangerous();\n  |     ^^^^^^^^^^^ call to unsafe function\n  |\n  = note: consult the function\"s documentation for information on how to avoid undefined behavior\n\nFor more information about this error, try \"rustc --explain E0133\".\nerror: could not compile \"unsafe-example\" due to previous error\n\nWith the \"unsafe\" block, we’re asserting to Rust that we’ve read the function’s documentation, we understand how to use it properly, and we’ve verified that we’re fulfilling the contract of the function.\nBodies of unsafe functions are effectively \"unsafe\" blocks, so to perform other unsafe operations within an unsafe function, we don’t need to add another \"unsafe\" block.\nCreating a Safe Abstraction over Unsafe Code\nJust because a function contains unsafe code doesn’t mean we need to mark the entire function as unsafe. In fact, wrapping unsafe code in a safe function is a common abstraction. As an example, let’s study the \"split_at_mut\" function from the standard library, which requires some unsafe code. We’ll explore how we might implement it. This safe method is defined on mutable slices: it takes one slice and makes it two by splitting the slice at the index given as an argument. Listing 19-4 shows how to use \"split_at_mut\".\n    let mut v = vec![1, 2, 3, 4, 5, 6];\n\n    let r = &amp;mut v[..];\n    \n    let (a, b) = r.split_at_mut(3);\n    \n    assert_eq!(a, &amp;mut [1, 2, 3]);\n    assert_eq!(b, &amp;mut [4, 5, 6]);\n\nListing 19-4: Using the safe \"split_at_mut\" function\nWe can’t implement this function using only safe Rust. An attempt might look something like Listing 19-5, which won’t compile. For simplicity, we’ll implement \"split_at_mut\" as a function rather than a method and only for slices of \"i32\" values rather than for a generic type \"T\".\nfn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {\n    let len = values.len();\n\n    assert!(mid &lt;= len);\n    \n    (&amp;mut values[..mid], &amp;mut values[mid..])\n}\n\nListing 19-5: An attempted implementation of \"split_at_mut\" using only safe Rust\nThis function first gets the total length of the slice. Then it asserts that the index given as a parameter is within the slice by checking whether it’s less than or equal to the length. The assertion means that if we pass an index that is greater than the length to split the slice at, the function will panic before it attempts to use that index.\nThen we return two mutable slices in a tuple: one from the start of the original slice to the \"mid\" index and another from \"mid\" to the end of the slice.\nWhen we try to compile the code in Listing 19-5, we’ll get an error.\n$ cargo run\n   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)\nerror[E0499]: cannot borrow \"*values\" as mutable more than once at a time\n --&gt; src/main.rs:6:31\n  |\n1 | fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {\n  |                         - let\"s call the lifetime of this reference \"\"1\"\n...\n6 |     (&amp;mut values[..mid], &amp;mut values[mid..])\n  |     --------------------------^^^^^^--------\n  |     |     |                   |\n  |     |     |                   second mutable borrow occurs here\n  |     |     first mutable borrow occurs here\n  |     returning this value requires that \"*values\" is borrowed for \"\"1\"\n\nFor more information about this error, try \"rustc --explain E0499\".\nerror: could not compile \"unsafe-example\" due to previous error\n\nRust’s borrow checker can’t understand that we’re borrowing different parts of the slice; it only knows that we’re borrowing from the same slice twice. Borrowing different parts of a slice is fundamentally okay because the two slices aren’t overlapping, but Rust isn’t smart enough to know this. When we know code is okay, but Rust doesn’t, it’s time to reach for unsafe code.\nListing 19-6 shows how to use an \"unsafe\" block, a raw pointer, and some calls to unsafe functions to make the implementation of \"split_at_mut\" work.\nuse std::slice;\n\nfn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {\n    let len = values.len();\n    let ptr = values.as_mut_ptr();\n\n    assert!(mid &lt;= len);\n    \n    unsafe {\n        (\n            slice::from_raw_parts_mut(ptr, mid),\n            slice::from_raw_parts_mut(ptr.add(mid), len - mid),\n        )\n    }\n}\n\nListing 19-6: Using unsafe code in the implementation of the \"split_at_mut\" function\nRecall from “The Slice Type” section in Chapter 4 that slices are a pointer to some data and the length of the slice. We use the \"len\" method to get the length of a slice and the \"as_mut_ptr\" method to access the raw pointer of a slice. In this case, because we have a mutable slice to \"i32\" values, \"as_mut_ptr\" returns a raw pointer with the type \"*mut i32\", which we’ve stored in the variable \"ptr\".\nWe keep the assertion that the \"mid\" index is within the slice. Then we get to the unsafe code: the \"slice::from_raw_parts_mut\" function takes a raw pointer and a length, and it creates a slice. We use this function to create a slice that starts from \"ptr\" and is \"mid\" items long. Then we call the \"add\" method on \"ptr\" with \"mid\" as an argument to get a raw pointer that starts at \"mid\", and we create a slice using that pointer and the remaining number of items after \"mid\" as the length.\nThe function \"slice::from_raw_parts_mut\" is unsafe because it takes a raw pointer and must trust that this pointer is valid. The \"add\" method on raw pointers is also unsafe, because it must trust that the offset location is also a valid pointer. Therefore, we had to put an \"unsafe\" block around our calls to \"slice::from_raw_parts_mut\" and \"add\" so we could call them. By looking at the code and by adding the assertion that \"mid\" must be less than or equal to \"len\", we can tell that all the raw pointers used within the \"unsafe\" block will be valid pointers to data within the slice. This is an acceptable and appropriate use of \"unsafe\".\nNote that we don’t need to mark the resulting \"split_at_mut\" function as \"unsafe\", and we can call this function from safe Rust. We’ve created a safe abstraction to the unsafe code with an implementation of the function that uses \"unsafe\" code in a safe way, because it creates only valid pointers from the data this function has access to.\nIn contrast, the use of \"slice::from_raw_parts_mut\" in Listing 19-7 would likely crash when the slice is used. This code takes an arbitrary memory location and creates a slice 10,000 items long.\n    use std::slice;\n\n    let address = 0x01234usize;\n    let r = address as *mut i32;\n    \n    let values: &amp;[i32] = unsafe { slice::from_raw_parts_mut(r, 10000) };\n\nListing 19-7: Creating a slice from an arbitrary memory location\nWe don’t own the memory at this arbitrary location, and there is no guarantee that the slice this code creates contains valid \"i32\" values. Attempting to use \"values\" as though it’s a valid slice results in undefined behavior.\nUsing \"extern\" Functions to Call External Code\nSometimes, your Rust code might need to interact with code written in another language. For this, Rust has the keyword \"extern\" that facilitates the creation and use of a Foreign Function Interface (FFI). An FFI is a way for a programming language to define functions and enable a different (foreign) programming language to call those functions.\nListing 19-8 demonstrates how to set up an integration with the \"abs\" function from the C standard library. Functions declared within \"extern\" blocks are always unsafe to call from Rust code. The reason is that other languages don’t enforce Rust’s rules and guarantees, and Rust can’t check them, so responsibility falls on the programmer to ensure safety.\nFilename: src/main.rs\nextern \"C\" {\n    fn abs(input: i32) -&gt; i32;\n}\n\nfn main() {\n    unsafe {\n        println!(\"Absolute value of -3 according to C: {}\", abs(-3));\n    }\n}\n\nListing 19-8: Declaring and calling an \"extern\" function defined in another language\nWithin the \"extern \"C\"\" block, we list the names and signatures of external functions from another language we want to call. The \"\"C\"\" part defines which application binary interface (ABI) the external function uses: the ABI defines how to call the function at the assembly level. The \"\"C\"\" ABI is the most common and follows the C programming language’s ABI.\n\nCalling Rust Functions from Other Languages\nWe can also use \"extern\" to create an interface that allows other languages to call Rust functions. Instead of creating a whole \"extern\" block, we add the \"extern\" keyword and specify the ABI to use just before the \"fn\" keyword for the relevant function. We also need to add a \"#[no_mangle]\" annotation to tell the Rust compiler not to mangle the name of this function. Mangling is when a compiler changes the name we’ve given a function to a different name that contains more information for other parts of the compilation process to consume but is less human readable. Every programming language compiler mangles names slightly differently, so for a Rust function to be nameable by other languages, we must disable the Rust compiler’s name mangling.\nIn the following example, we make the \"call_from_c\" function accessible from C code, after it’s compiled to a shared library and linked from C:\n#[no_mangle]\npub extern \"C\" fn call_from_c() {\n    println!(\"Just called a Rust function from C!\");\n}\n\nThis usage of \"extern\" does not require \"unsafe\".\n\nAccessing or Modifying a Mutable Static Variable\nIn this book, we’ve not yet talked about global variables, which Rust does support but can be problematic with Rust’s ownership rules. If two threads are accessing the same mutable global variable, it can cause a data race.\nIn Rust, global variables are called static variables. Listing 19-9 shows an example declaration and use of a static variable with a string slice as a value.\nFilename: src/main.rs\nstatic HELLO_WORLD: &amp;str = \"Hello, world!\";\n\nfn main() {\n    println!(\"name is: {}\", HELLO_WORLD);\n}\n\nListing 19-9: Defining and using an immutable static variable\nStatic variables are similar to constants, which we discussed in the “Differences Between Variables and Constants” section in Chapter 3. The names of static variables are in \"SCREAMING_SNAKE_CASE\" by convention. Static variables can only store references with the \"\"static\" lifetime, which means the Rust compiler can figure out the lifetime and we aren’t required to annotate it explicitly. Accessing an immutable static variable is safe.\nA subtle difference between constants and immutable static variables is that values in a static variable have a fixed address in memory. Using the value will always access the same data. Constants, on the other hand, are allowed to duplicate their data whenever they’re used. Another difference is that static variables can be mutable. Accessing and modifying mutable static variables is unsafe. Listing 19-10 shows how to declare, access, and modify a mutable static variable named \"COUNTER\".\nFilename: src/main.rs\nstatic mut COUNTER: u32 = 0;\n\nfn add_to_count(inc: u32) {\n    unsafe {\n        COUNTER += inc;\n    }\n}\n\nfn main() {\n    add_to_count(3);\n\n    unsafe {\n        println!(\"COUNTER: {}\", COUNTER);\n    }\n}\n\nListing 19-10: Reading from or writing to a mutable static variable is unsafe\nAs with regular variables, we specify mutability using the \"mut\" keyword. Any code that reads or writes from \"COUNTER\" must be within an \"unsafe\" block. This code compiles and prints \"COUNTER: 3\" as we would expect because it’s single threaded. Having multiple threads access \"COUNTER\" would likely result in data races.\nWith mutable data that is globally accessible, it’s difficult to ensure there are no data races, which is why Rust considers mutable static variables to be unsafe. Where possible, it’s preferable to use the concurrency techniques and thread-safe smart pointers we discussed in Chapter 16 so the compiler checks that data accessed from different threads is done safely.\nImplementing an Unsafe Trait\nWe can use \"unsafe\" to implement an unsafe trait. A trait is unsafe when at least one of its methods has some invariant that the compiler can’t verify. We declare that a trait is \"unsafe\" by adding the \"unsafe\" keyword before \"trait\" and marking the implementation of the trait as \"unsafe\" too, as shown in Listing 19-11.\nunsafe trait Foo {\n    // methods go here\n}\n\nunsafe impl Foo for i32 {\n    // method implementations go here\n}\n\nfn main() {}\n\nListing 19-11: Defining and implementing an unsafe trait\nBy using \"unsafe impl\", we’re promising that we’ll uphold the invariants that the compiler can’t verify.\nAs an example, recall the \"Sync\" and \"Send\" marker traits we discussed in the “Extensible Concurrency with the \"Sync\" and \"Send\" Traits” section in Chapter 16: the compiler implements these traits automatically if our types are composed entirely of \"Send\" and \"Sync\" types. If we implement a type that contains a type that is not \"Send\" or \"Sync\", such as raw pointers, and we want to mark that type as \"Send\" or \"Sync\", we must use \"unsafe\". Rust can’t verify that our type upholds the guarantees that it can be safely sent across threads or accessed from multiple threads; therefore, we need to do those checks manually and indicate as such with \"unsafe\".\nAccessing Fields of a Union\nThe final action that works only with \"unsafe\" is accessing fields of a union. A \"union\" is similar to a \"struct\", but only one declared field is used in a particular instance at one time. Unions are primarily used to interface with unions in C code. Accessing union fields is unsafe because Rust can’t guarantee the type of the data currently being stored in the union instance. You can learn more about unions in the Rust Reference.\nWhen to Use Unsafe Code\nUsing \"unsafe\" to take one of the five actions (superpowers) just discussed isn’t wrong or even frowned upon. But it is trickier to get \"unsafe\" code correct because the compiler can’t help uphold memory safety. When you have a reason to use \"unsafe\" code, you can do so, and having the explicit \"unsafe\" annotation makes it easier to track down the source of problems when they occur.\n\nAdvanced Traits\nWe first covered traits in the “Traits: Defining Shared Behavior” section of Chapter 10, but we didn’t discuss the more advanced details. Now that you know more about Rust, we can get into the nitty-gritty.\nSpecifying Placeholder Types in Trait Definitions with Associated Types\nAssociated types connect a type placeholder with a trait such that the trait method definitions can use these placeholder types in their signatures. The implementor of a trait will specify the concrete type to be used instead of the placeholder type for the particular implementation. That way, we can define a trait that uses some types without needing to know exactly what those types are until the trait is implemented.\nWe’ve described most of the advanced features in this chapter as being rarely needed. Associated types are somewhere in the middle: they’re used more rarely than features explained in the rest of the book but more commonly than many of the other features discussed in this chapter.\nOne example of a trait with an associated type is the \"Iterator\" trait that the standard library provides. The associated type is named \"Item\" and stands in for the type of the values the type implementing the \"Iterator\" trait is iterating over. The definition of the \"Iterator\" trait is as shown in Listing 19-12.\npub trait Iterator {\n    type Item;\n\n    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;\n}\n\nListing 19-12: The definition of the \"Iterator\" trait that has an associated type \"Item\"\nThe type \"Item\" is a placeholder, and the \"next\" method’s definition shows that it will return values of type \"OptionSelf::Item\". Implementors of the \"Iterator\" trait will specify the concrete type for \"Item\", and the \"next\" method will return an \"Option\" containing a value of that concrete type.\nAssociated types might seem like a similar concept to generics, in that the latter allow us to define a function without specifying what types it can handle. To examine the difference between the two concepts, we’ll look at an implementation of the \"Iterator\" trait on a type named \"Counter\" that specifies the \"Item\" type is \"u32\":\nFilename: src/lib.rs\nimpl Iterator for Counter {\n    type Item = u32;\n\n    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {\n        // --snip--\n\nThis syntax seems comparable to that of generics. So why not just define the \"Iterator\" trait with generics, as shown in Listing 19-13?\npub trait Iterator&lt;T&gt; {\n    fn next(&amp;mut self) -&gt; Option&lt;T&gt;;\n}\n\nListing 19-13: A hypothetical definition of the \"Iterator\" trait using generics\nThe difference is that when using generics, as in Listing 19-13, we must annotate the types in each implementation; because we can also implement \"Iterator for Counter\" or any other type, we could have multiple implementations of \"Iterator\" for \"Counter\". In other words, when a trait has a generic parameter, it can be implemented for a type multiple times, changing the concrete types of the generic type parameters each time. When we use the \"next\" method on \"Counter\", we would have to provide type annotations to indicate which implementation of \"Iterator\" we want to use.\nWith associated types, we don’t need to annotate types because we can’t implement a trait on a type multiple times. In Listing 19-12 with the definition that uses associated types, we can only choose what the type of \"Item\" will be once, because there can only be one \"impl Iterator for Counter\". We don’t have to specify that we want an iterator of \"u32\" values everywhere that we call \"next\" on \"Counter\".\nAssociated types also become part of the trait’s contract: implementors of the trait must provide a type to stand in for the associated type placeholder. Associated types often have a name that describes how the type will be used, and documenting the associated type in the API documentation is good practice.\nDefault Generic Type Parameters and Operator Overloading\nWhen we use generic type parameters, we can specify a default concrete type for the generic type. This eliminates the need for implementors of the trait to specify a concrete type if the default type works. You specify a default type when declaring a generic type with the \"&lt;PlaceholderType=ConcreteType&gt;\" syntax.\nA great example of a situation where this technique is useful is with operator overloading, in which you customize the behavior of an operator (such as \"+\") in particular situations.\nRust doesn’t allow you to create your own operators or overload arbitrary operators. But you can overload the operations and corresponding traits listed in \"std::ops\" by implementing the traits associated with the operator. For example, in Listing 19-14 we overload the \"+\" operator to add two \"Point\" instances together. We do this by implementing the \"Add\" trait on a \"Point\" struct:\nFilename: src/main.rs\nuse std::ops::Add;\n\n#[derive(Debug, Copy, Clone, PartialEq)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nimpl Add for Point {\n    type Output = Point;\n\n    fn add(self, other: Point) -&gt; Point {\n        Point {\n            x: self.x + other.x,\n            y: self.y + other.y,\n        }\n    }\n}\n\nfn main() {\n    assert_eq!(\n        Point { x: 1, y: 0 } + Point { x: 2, y: 3 },\n        Point { x: 3, y: 3 }\n    );\n}\n\nListing 19-14: Implementing the \"Add\" trait to overload the \"+\" operator for \"Point\" instances\nThe \"add\" method adds the \"x\" values of two \"Point\" instances and the \"y\" values of two \"Point\" instances to create a new \"Point\". The \"Add\" trait has an associated type named \"Output\" that determines the type returned from the \"add\" method.\nThe default generic type in this code is within the \"Add\" trait. Here is its definition:\ntrait Add&lt;Rhs=Self&gt; {\n    type Output;\n\n    fn add(self, rhs: Rhs) -&gt; Self::Output;\n}\n\nThis code should look generally familiar: a trait with one method and an associated type. The new part is \"Rhs=Self\": this syntax is called default type parameters. The \"Rhs\" generic type parameter (short for “right hand side”) defines the type of the \"rhs\" parameter in the \"add\" method. If we don’t specify a concrete type for \"Rhs\" when we implement the \"Add\" trait, the type of \"Rhs\" will default to \"Self\", which will be the type we’re implementing \"Add\" on.\nWhen we implemented \"Add\" for \"Point\", we used the default for \"Rhs\" because we wanted to add two \"Point\" instances. Let’s look at an example of implementing the \"Add\" trait where we want to customize the \"Rhs\" type rather than using the default.\nWe have two structs, \"Millimeters\" and \"Meters\", holding values in different units. This thin wrapping of an existing type in another struct is known as the newtype pattern, which we describe in more detail in the “Using the Newtype Pattern to Implement External Traits on External Types” section. We want to add values in millimeters to values in meters and have the implementation of \"Add\" do the conversion correctly. We can implement \"Add\" for \"Millimeters\" with \"Meters\" as the \"Rhs\", as shown in Listing 19-15.\nFilename: src/lib.rs\nuse std::ops::Add;\n\nstruct Millimeters(u32);\nstruct Meters(u32);\n\nimpl Add&lt;Meters&gt; for Millimeters {\n    type Output = Millimeters;\n\n    fn add(self, other: Meters) -&gt; Millimeters {\n        Millimeters(self.0 + (other.0 * 1000))\n    }\n}\n\nListing 19-15: Implementing the \"Add\" trait on \"Millimeters\" to add \"Millimeters\" to \"Meters\"\nTo add \"Millimeters\" and \"Meters\", we specify \"impl Add\" to set the value of the \"Rhs\" type parameter instead of using the default of \"Self\".\nYou’ll use default type parameters in two main ways:\n\nTo extend a type without breaking existing code\nTo allow customization in specific cases most users won’t need\n\nThe standard library’s \"Add\" trait is an example of the second purpose: usually, you’ll add two like types, but the \"Add\" trait provides the ability to customize beyond that. Using a default type parameter in the \"Add\" trait definition means you don’t have to specify the extra parameter most of the time. In other words, a bit of implementation boilerplate isn’t needed, making it easier to use the trait.\nThe first purpose is similar to the second but in reverse: if you want to add a type parameter to an existing trait, you can give it a default to allow extension of the functionality of the trait without breaking the existing implementation code.\nFully Qualified Syntax for Disambiguation: Calling Methods with the Same Name\nNothing in Rust prevents a trait from having a method with the same name as another trait’s method, nor does Rust prevent you from implementing both traits on one type. It’s also possible to implement a method directly on the type with the same name as methods from traits.\nWhen calling methods with the same name, you’ll need to tell Rust which one you want to use. Consider the code in Listing 19-16 where we’ve defined two traits, \"Pilot\" and \"Wizard\", that both have a method called \"fly\". We then implement both traits on a type \"Human\" that already has a method named \"fly\" implemented on it. Each \"fly\" method does something different.\nFilename: src/main.rs\ntrait Pilot {\n    fn fly(&amp;self);\n}\n\ntrait Wizard {\n    fn fly(&amp;self);\n}\n\nstruct Human;\n\nimpl Pilot for Human {\n    fn fly(&amp;self) {\n        println!(\"This is your captain speaking.\");\n    }\n}\n\nimpl Wizard for Human {\n    fn fly(&amp;self) {\n        println!(\"Up!\");\n    }\n}\n\nimpl Human {\n    fn fly(&amp;self) {\n        println!(\"*waving arms furiously*\");\n    }\n}\n\nListing 19-16: Two traits are defined to have a \"fly\" method and are implemented on the \"Human\" type, and a \"fly\" method is implemented on \"Human\" directly\nWhen we call \"fly\" on an instance of \"Human\", the compiler defaults to calling the method that is directly implemented on the type, as shown in Listing 19-17.\nFilename: src/main.rs\nfn main() {\n    let person = Human;\n    person.fly();\n}\n\nListing 19-17: Calling \"fly\" on an instance of \"Human\"\nRunning this code will print \"waving arms furiously\", showing that Rust called the \"fly\" method implemented on \"Human\" directly.\nTo call the \"fly\" methods from either the \"Pilot\" trait or the \"Wizard\" trait, we need to use more explicit syntax to specify which \"fly\" method we mean. Listing 19-18 demonstrates this syntax.\nFilename: src/main.rs\nfn main() {\n    let person = Human;\n    Pilot::fly(&amp;person);\n    Wizard::fly(&amp;person);\n    person.fly();\n}\n\nListing 19-18: Specifying which trait’s \"fly\" method we want to call\nSpecifying the trait name before the method name clarifies to Rust which implementation of \"fly\" we want to call. We could also write \"Human::fly(&amp;person)\", which is equivalent to the \"person.fly()\" that we used in Listing 19-18, but this is a bit longer to write if we don’t need to disambiguate.\nRunning this code prints the following:\n$ cargo run\n   Compiling traits-example v0.1.0 (file:///projects/traits-example)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.46s\n     Running \"target/debug/traits-example\"\nThis is your captain speaking.\nUp!\n*waving arms furiously*\n\nBecause the \"fly\" method takes a \"self\" parameter, if we had two types that both implement one trait, Rust could figure out which implementation of a trait to use based on the type of \"self\".\nHowever, associated functions that are not methods don’t have a \"self\" parameter. When there are multiple types or traits that define non-method functions with the same function name, Rust doesn\"t always know which type you mean unless you use fully qualified syntax. For example, in Listing 19-19 we create a trait for an animal shelter that wants to name all baby dogs Spot. We make an \"Animal\" trait with an associated non-method function \"baby_name\". The \"Animal\" trait is implemented for the struct \"Dog\", on which we also provide an associated non-method function \"baby_name\" directly.\nFilename: src/main.rs\ntrait Animal {\n    fn baby_name() -&gt; String;\n}\n\nstruct Dog;\n\nimpl Dog {\n    fn baby_name() -&gt; String {\n        String::from(\"Spot\")\n    }\n}\n\nimpl Animal for Dog {\n    fn baby_name() -&gt; String {\n        String::from(\"puppy\")\n    }\n}\n\nfn main() {\n    println!(\"A baby dog is called a {}\", Dog::baby_name());\n}\n\nListing 19-19: A trait with an associated function and a type with an associated function of the same name that also implements the trait\nWe implement the code for naming all puppies Spot in the \"baby_name\" associated function that is defined on \"Dog\". The \"Dog\" type also implements the trait \"Animal\", which describes characteristics that all animals have. Baby dogs are called puppies, and that is expressed in the implementation of the \"Animal\" trait on \"Dog\" in the \"baby_name\" function associated with the \"Animal\" trait.\nIn \"main\", we call the \"Dog::baby_name\" function, which calls the associated function defined on \"Dog\" directly. This code prints the following:\n$ cargo run\n   Compiling traits-example v0.1.0 (file:///projects/traits-example)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.54s\n     Running \"target/debug/traits-example\"\nA baby dog is called a Spot\n\nThis output isn’t what we wanted. We want to call the \"baby_name\" function that is part of the \"Animal\" trait that we implemented on \"Dog\" so the code prints \"A baby dog is called a puppy\". The technique of specifying the trait name that we used in Listing 19-18 doesn’t help here; if we change \"main\" to the code in Listing 19-20, we’ll get a compilation error.\nFilename: src/main.rs\nfn main() {\n    println!(\"A baby dog is called a {}\", Animal::baby_name());\n}\n\nListing 19-20: Attempting to call the \"baby_name\" function from the \"Animal\" trait, but Rust doesn’t know which implementation to use\nBecause \"Animal::baby_name\" doesn’t have a \"self\" parameter, and there could be other types that implement the \"Animal\" trait, Rust can’t figure out which implementation of \"Animal::baby_name\" we want. We’ll get this compiler error:\n$ cargo run\n   Compiling traits-example v0.1.0 (file:///projects/traits-example)\nerror[E0790]: cannot call associated function on trait without specifying the corresponding \"impl\" type\n  --&gt; src/main.rs:20:43\n   |\n2  |     fn baby_name() -&gt; String;\n   |     ------------------------- \"Animal::baby_name\" defined here\n...\n20 |     println!(\"A baby dog is called a {}\", Animal::baby_name());\n   |                                           ^^^^^^^^^^^^^^^^^ cannot call associated function of trait\n   |\nhelp: use the fully-qualified path to the only available implementation\n   |\n20 |     println!(\"A baby dog is called a {}\", &lt;Dog as Animal&gt;::baby_name());\n   |                                           +++++++       +\n\nFor more information about this error, try \"rustc --explain E0790\".\nerror: could not compile \"traits-example\" due to previous error\n\nTo disambiguate and tell Rust that we want to use the implementation of \"Animal\" for \"Dog\" as opposed to the implementation of \"Animal\" for some other type, we need to use fully qualified syntax. Listing 19-21 demonstrates how to use fully qualified syntax.\nFilename: src/main.rs\nfn main() {\n    println!(\"A baby dog is called a {}\", &lt;Dog as Animal&gt;::baby_name());\n}\n\nListing 19-21: Using fully qualified syntax to specify that we want to call the \"baby_name\" function from the \"Animal\" trait as implemented on \"Dog\"\nWe’re providing Rust with a type annotation within the angle brackets, which indicates we want to call the \"baby_name\" method from the \"Animal\" trait as implemented on \"Dog\" by saying that we want to treat the \"Dog\" type as an \"Animal\" for this function call. This code will now print what we want:\n$ cargo run\n   Compiling traits-example v0.1.0 (file:///projects/traits-example)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.48s\n     Running \"target/debug/traits-example\"\nA baby dog is called a puppy\n\nIn general, fully qualified syntax is defined as follows:\n&lt;Type as Trait&gt;::function(receiver_if_method, next_arg, ...);\n\nFor associated functions that aren’t methods, there would not be a \"receiver\": there would only be the list of other arguments. You could use fully qualified syntax everywhere that you call functions or methods. However, you’re allowed to omit any part of this syntax that Rust can figure out from other information in the program. You only need to use this more verbose syntax in cases where there are multiple implementations that use the same name and Rust needs help to identify which implementation you want to call.\nUsing Supertraits to Require One Trait’s Functionality Within Another Trait\nSometimes, you might write a trait definition that depends on another trait: for a type to implement the first trait, you want to require that type to also implement the second trait. You would do this so that your trait definition can make use of the associated items of the second trait. The trait your trait definition is relying on is called a supertrait of your trait.\nFor example, let’s say we want to make an \"OutlinePrint\" trait with an \"outline_print\" method that will print a given value formatted so that it\"s framed in asterisks. That is, given a \"Point\" struct that implements the standard library trait \"Display\" to result in \"(x, y)\", when we call \"outline_print\" on a \"Point\" instance that has \"1\" for \"x\" and \"3\" for \"y\", it should print the following:\n**********\n*        *\n* (1, 3) *\n*        *\n**********\n\nIn the implementation of the \"outline_print\" method, we want to use the \"Display\" trait’s functionality. Therefore, we need to specify that the \"OutlinePrint\" trait will work only for types that also implement \"Display\" and provide the functionality that \"OutlinePrint\" needs. We can do that in the trait definition by specifying \"OutlinePrint: Display\". This technique is similar to adding a trait bound to the trait. Listing 19-22 shows an implementation of the \"OutlinePrint\" trait.\nFilename: src/main.rs\nuse std::fmt;\n\ntrait OutlinePrint: fmt::Display {\n    fn outline_print(&amp;self) {\n        let output = self.to_string();\n        let len = output.len();\n        println!(\"{}\", \"*\".repeat(len + 4));\n        println!(\"*{}*\", \" \".repeat(len + 2));\n        println!(\"* {} *\", output);\n        println!(\"*{}*\", \" \".repeat(len + 2));\n        println!(\"{}\", \"*\".repeat(len + 4));\n    }\n}\n\nListing 19-22: Implementing the \"OutlinePrint\" trait that requires the functionality from \"Display\"\nBecause we’ve specified that \"OutlinePrint\" requires the \"Display\" trait, we can use the \"to_string\" function that is automatically implemented for any type that implements \"Display\". If we tried to use \"to_string\" without adding a colon and specifying the \"Display\" trait after the trait name, we’d get an error saying that no method named \"to_string\" was found for the type \"&amp;Self\" in the current scope.\nLet’s see what happens when we try to implement \"OutlinePrint\" on a type that doesn’t implement \"Display\", such as the \"Point\" struct:\nFilename: src/main.rs\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nimpl OutlinePrint for Point {}\n\nWe get an error saying that \"Display\" is required but not implemented:\n$ cargo run\n   Compiling traits-example v0.1.0 (file:///projects/traits-example)\nerror[E0277]: \"Point\" doesn\"t implement \"std::fmt::Display\"\n  --&gt; src/main.rs:20:6\n   |\n20 | impl OutlinePrint for Point {}\n   |      ^^^^^^^^^^^^ \"Point\" cannot be formatted with the default formatter\n   |\n   = help: the trait \"std::fmt::Display\" is not implemented for \"Point\"\n   = note: in format strings you may be able to use \"{:?}\" (or {:#?} for pretty-print) instead\nnote: required by a bound in \"OutlinePrint\"\n  --&gt; src/main.rs:3:21\n   |\n3  | trait OutlinePrint: fmt::Display {\n   |                     ^^^^^^^^^^^^ required by this bound in \"OutlinePrint\"\n\nFor more information about this error, try \"rustc --explain E0277\".\nerror: could not compile \"traits-example\" due to previous error\n\nTo fix this, we implement \"Display\" on \"Point\" and satisfy the constraint that \"OutlinePrint\" requires, like so:\nFilename: src/main.rs\nuse std::fmt;\n\nimpl fmt::Display for Point {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {\n        write!(f, \"({}, {})\", self.x, self.y)\n    }\n}\n\nThen implementing the \"OutlinePrint\" trait on \"Point\" will compile successfully, and we can call \"outline_print\" on a \"Point\" instance to display it within an outline of asterisks.\nUsing the Newtype Pattern to Implement External Traits on External Types\nIn Chapter 10 in the “Implementing a Trait on a Type” section, we mentioned the orphan rule that states we’re only allowed to implement a trait on a type if either the trait or the type are local to our crate. It’s possible to get around this restriction using the newtype pattern, which involves creating a new type in a tuple struct. (We covered tuple structs in the “Using Tuple Structs without Named Fields to Create Different Types” section of Chapter 5.) The tuple struct will have one field and be a thin wrapper around the type we want to implement a trait for. Then the wrapper type is local to our crate, and we can implement the trait on the wrapper. Newtype is a term that originates from the Haskell programming language. There is no runtime performance penalty for using this pattern, and the wrapper type is elided at compile time.\nAs an example, let’s say we want to implement \"Display\" on \"Vec\", which the orphan rule prevents us from doing directly because the \"Display\" trait and the \"Vec\" type are defined outside our crate. We can make a \"Wrapper\" struct that holds an instance of \"Vec\"; then we can implement \"Display\" on \"Wrapper\" and use the \"Vec\" value, as shown in Listing 19-23.\nFilename: src/main.rs\nuse std::fmt;\n\nstruct Wrapper(Vec&lt;String&gt;);\n\nimpl fmt::Display for Wrapper {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {\n        write!(f, \"[{}]\", self.0.join(\", \"))\n    }\n}\n\nfn main() {\n    let w = Wrapper(vec![String::from(\"hello\"), String::from(\"world\")]);\n    println!(\"w = {}\", w);\n}\n\nListing 19-23: Creating a \"Wrapper\" type around \"Vec\" to implement \"Display\"\nThe implementation of \"Display\" uses \"self.0\" to access the inner \"Vec\", because \"Wrapper\" is a tuple struct and \"Vec\" is the item at index 0 in the tuple. Then we can use the functionality of the \"Display\" type on \"Wrapper\".\nThe downside of using this technique is that \"Wrapper\" is a new type, so it doesn’t have the methods of the value it’s holding. We would have to implement all the methods of \"Vec\" directly on \"Wrapper\" such that the methods delegate to \"self.0\", which would allow us to treat \"Wrapper\" exactly like a \"Vec\". If we wanted the new type to have every method the inner type has, implementing the \"Deref\" trait (discussed in Chapter 15 in the “Treating Smart Pointers Like Regular References with the \"Deref\" Trait” section) on the \"Wrapper\" to return the inner type would be a solution. If we don’t want the \"Wrapper\" type to have all the methods of the inner type—for example, to restrict the \"Wrapper\" type’s behavior—we would have to implement just the methods we do want manually.\nThis newtype pattern is also useful even when traits are not involved. Let’s switch focus and look at some advanced ways to interact with Rust’s type system.\n\nAdvanced Types\nThe Rust type system has some features that we’ve so far mentioned but haven’t yet discussed. We’ll start by discussing newtypes in general as we examine why newtypes are useful as types. Then we’ll move on to type aliases, a feature similar to newtypes but with slightly different semantics. We’ll also discuss the \"!\" type and dynamically sized types.\nUsing the Newtype Pattern for Type Safety and Abstraction\n\nNote: This section assumes you’ve read the earlier section “Using the Newtype Pattern to Implement External Traits on External Types.”\n\nThe newtype pattern is also useful for tasks beyond those we’ve discussed so far, including statically enforcing that values are never confused and indicating the units of a value. You saw an example of using newtypes to indicate units in Listing 19-15: recall that the \"Millimeters\" and \"Meters\" structs wrapped \"u32\" values in a newtype. If we wrote a function with a parameter of type \"Millimeters\", we couldn’t compile a program that accidentally tried to call that function with a value of type \"Meters\" or a plain \"u32\".\nWe can also use the newtype pattern to abstract away some implementation details of a type: the new type can expose a public API that is different from the API of the private inner type.\nNewtypes can also hide internal implementation. For example, we could provide a \"People\" type to wrap a \"HashMap&lt;i32, String&gt;\" that stores a person’s ID associated with their name. Code using \"People\" would only interact with the public API we provide, such as a method to add a name string to the \"People\" collection; that code wouldn’t need to know that we assign an \"i32\" ID to names internally. The newtype pattern is a lightweight way to achieve encapsulation to hide implementation details, which we discussed in the “Encapsulation that Hides Implementation Details” section of Chapter 17.\nCreating Type Synonyms with Type Aliases\nRust provides the ability to declare a type alias to give an existing type another name. For this we use the \"type\" keyword. For example, we can create the alias \"Kilometers\" to \"i32\" like so:\n    type Kilometers = i32;\n\nNow, the alias \"Kilometers\" is a synonym for \"i32\"; unlike the \"Millimeters\" and \"Meters\" types we created in Listing 19-15, \"Kilometers\" is not a separate, new type. Values that have the type \"Kilometers\" will be treated the same as values of type \"i32\":\n    type Kilometers = i32;\n\n    let x: i32 = 5;\n    let y: Kilometers = 5;\n    \n    println!(\"x + y = {}\", x + y);\n\nBecause \"Kilometers\" and \"i32\" are the same type, we can add values of both types and we can pass \"Kilometers\" values to functions that take \"i32\" parameters. However, using this method, we don’t get the type checking benefits that we get from the newtype pattern discussed earlier. In other words, if we mix up \"Kilometers\" and \"i32\" values somewhere, the compiler will not give us an error.\nThe main use case for type synonyms is to reduce repetition. For example, we might have a lengthy type like this:\nBox&lt;dyn Fn() + Send + \"static&gt;\n\nWriting this lengthy type in function signatures and as type annotations all over the code can be tiresome and error prone. Imagine having a project full of code like that in Listing 19-24.\n    let f: Box&lt;dyn Fn() + Send + \"static&gt; = Box::new(|| println!(\"hi\"));\n\n    fn takes_long_type(f: Box&lt;dyn Fn() + Send + \"static&gt;) {\n        // --snip--\n    }\n    \n    fn returns_long_type() -&gt; Box&lt;dyn Fn() + Send + \"static&gt; {\n        // --snip--\n    }\n\nListing 19-24: Using a long type in many places\nA type alias makes this code more manageable by reducing the repetition. In Listing 19-25, we’ve introduced an alias named \"Thunk\" for the verbose type and can replace all uses of the type with the shorter alias \"Thunk\".\n    type Thunk = Box&lt;dyn Fn() + Send + \"static&gt;;\n\n    let f: Thunk = Box::new(|| println!(\"hi\"));\n    \n    fn takes_long_type(f: Thunk) {\n        // --snip--\n    }\n    \n    fn returns_long_type() -&gt; Thunk {\n        // --snip--\n    }\n\nListing 19-25: Introducing a type alias \"Thunk\" to reduce repetition\nThis code is much easier to read and write! Choosing a meaningful name for a type alias can help communicate your intent as well (thunk is a word for code to be evaluated at a later time, so it’s an appropriate name for a closure that gets stored).\nType aliases are also commonly used with the \"Result&lt;T, E&gt;\" type for reducing repetition. Consider the \"std::io\" module in the standard library. I/O operations often return a \"Result&lt;T, E&gt;\" to handle situations when operations fail to work. This library has a \"std::io::Error\" struct that represents all possible I/O errors. Many of the functions in \"std::io\" will be returning \"Result&lt;T, E&gt;\" where the \"E\" is \"std::io::Error\", such as these functions in the \"Write\" trait:\nuse std::fmt;\nuse std::io::Error;\n\npub trait Write {\n    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize, Error&gt;;\n    fn flush(&amp;mut self) -&gt; Result&lt;(), Error&gt;;\n\n    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;(), Error&gt;;\n    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;(), Error&gt;;\n}\n\nThe \"Result&lt;..., Error&gt;\" is repeated a lot. As such, \"std::io\" has this type alias declaration:\ntype Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;\n\nBecause this declaration is in the \"std::io\" module, we can use the fully qualified alias \"std::io::Result\"; that is, a \"Result&lt;T, E&gt;\" with the \"E\" filled in as \"std::io::Error\". The \"Write\" trait function signatures end up looking like this:\npub trait Write {\n    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;\n    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;\n\n    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;\n    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt;;\n}\n\nThe type alias helps in two ways: it makes code easier to write and it gives us a consistent interface across all of \"std::io\". Because it’s an alias, it’s just another \"Result&lt;T, E&gt;\", which means we can use any methods that work on \"Result&lt;T, E&gt;\" with it, as well as special syntax like the \"?\" operator.\nThe Never Type that Never Returns\nRust has a special type named \"!\" that’s known in type theory lingo as the empty type because it has no values. We prefer to call it the never type because it stands in the place of the return type when a function will never return. Here is an example:\nfn bar() -&gt; ! {\n    // --snip--\n}\n\nThis code is read as “the function \"bar\" returns never.” Functions that return never are called diverging functions. We can’t create values of the type \"!\" so \"bar\" can never possibly return.\nBut what use is a type you can never create values for? Recall the code from Listing 2-5, part of the number guessing game; we’ve reproduced a bit of it here in Listing 19-26.\n        let guess: u32 = match guess.trim().parse() {\n            Ok(num) =&gt; num,\n            Err(_) =&gt; continue,\n        };\n\nListing 19-26: A \"match\" with an arm that ends in \"continue\"\nAt the time, we skipped over some details in this code. In Chapter 6 in “The \"match\" Control Flow Operator” section, we discussed that \"match\" arms must all return the same type. So, for example, the following code doesn’t work:\n    let guess = match guess.trim().parse() {\n        Ok(_) =&gt; 5,\n        Err(_) =&gt; \"hello\",\n    };\n\nThe type of \"guess\" in this code would have to be an integer and a string, and Rust requires that \"guess\" have only one type. So what does \"continue\" return? How were we allowed to return a \"u32\" from one arm and have another arm that ends with \"continue\" in Listing 19-26?\nAs you might have guessed, \"continue\" has a \"!\" value. That is, when Rust computes the type of \"guess\", it looks at both match arms, the former with a value of \"u32\" and the latter with a \"!\" value. Because \"!\" can never have a value, Rust decides that the type of \"guess\" is \"u32\".\nThe formal way of describing this behavior is that expressions of type \"!\" can be coerced into any other type. We’re allowed to end this \"match\" arm with \"continue\" because \"continue\" doesn’t return a value; instead, it moves control back to the top of the loop, so in the \"Err\" case, we never assign a value to \"guess\".\nThe never type is useful with the \"panic!\" macro as well. Recall the \"unwrap\" function that we call on \"Option\" values to produce a value or panic with this definition:\nimpl&lt;T&gt; Option&lt;T&gt; {\n    pub fn unwrap(self) -&gt; T {\n        match self {\n            Some(val) =&gt; val,\n            None =&gt; panic!(\"called \"Option::unwrap()\" on a \"None\" value\"),\n        }\n    }\n}\n\nIn this code, the same thing happens as in the \"match\" in Listing 19-26: Rust sees that \"val\" has the type \"T\" and \"panic!\" has the type \"!\", so the result of the overall \"match\" expression is \"T\". This code works because \"panic!\" doesn’t produce a value; it ends the program. In the \"None\" case, we won’t be returning a value from \"unwrap\", so this code is valid.\nOne final expression that has the type \"!\" is a \"loop\":\n    print!(\"forever \");\n\n    loop {\n        print!(\"and ever \");\n    }\n\nHere, the loop never ends, so \"!\" is the value of the expression. However, this wouldn’t be true if we included a \"break\", because the loop would terminate when it got to the \"break\".\nDynamically Sized Types and the \"Sized\" Trait\nRust needs to know certain details about its types, such as how much space to allocate for a value of a particular type. This leaves one corner of its type system a little confusing at first: the concept of dynamically sized types. Sometimes referred to as DSTs or unsized types, these types let us write code using values whose size we can know only at runtime.\nLet’s dig into the details of a dynamically sized type called \"str\", which we’ve been using throughout the book. That’s right, not \"&amp;str\", but \"str\" on its own, is a DST. We can’t know how long the string is until runtime, meaning we can’t create a variable of type \"str\", nor can we take an argument of type \"str\". Consider the following code, which does not work:\n    let s1: str = \"Hello there!\";\n    let s2: str = \"How\"s it going?\";\n\nRust needs to know how much memory to allocate for any value of a particular type, and all values of a type must use the same amount of memory. If Rust allowed us to write this code, these two \"str\" values would need to take up the same amount of space. But they have different lengths: \"s1\" needs 12 bytes of storage and \"s2\" needs 15. This is why it’s not possible to create a variable holding a dynamically sized type.\nSo what do we do? In this case, you already know the answer: we make the types of \"s1\" and \"s2\" a \"&amp;str\" rather than a \"str\". Recall from the “String Slices” section of Chapter 4 that the slice data structure just stores the starting position and the length of the slice. So although a \"&amp;T\" is a single value that stores the memory address of where the \"T\" is located, a \"&amp;str\" is two values: the address of the \"str\" and its length. As such, we can know the size of a \"&amp;str\" value at compile time: it’s twice the length of a \"usize\". That is, we always know the size of a \"&amp;str\", no matter how long the string it refers to is. In general, this is the way in which dynamically sized types are used in Rust: they have an extra bit of metadata that stores the size of the dynamic information. The golden rule of dynamically sized types is that we must always put values of dynamically sized types behind a pointer of some kind.\nWe can combine \"str\" with all kinds of pointers: for example, \"Box\" or \"Rc\". In fact, you’ve seen this before but with a different dynamically sized type: traits. Every trait is a dynamically sized type we can refer to by using the name of the trait. In Chapter 17 in the “Using Trait Objects That Allow for Values of Different Types” section, we mentioned that to use traits as trait objects, we must put them behind a pointer, such as \"&amp;dyn Trait\" or \"Box\" (\"Rc\" would work too).\nTo work with DSTs, Rust provides the \"Sized\" trait to determine whether or not a type’s size is known at compile time. This trait is automatically implemented for everything whose size is known at compile time. In addition, Rust implicitly adds a bound on \"Sized\" to every generic function. That is, a generic function definition like this:\nfn generic&lt;T&gt;(t: T) {\n    // --snip--\n}\n\nis actually treated as though we had written this:\nfn generic&lt;T: Sized&gt;(t: T) {\n    // --snip--\n}\n\nBy default, generic functions will work only on types that have a known size at compile time. However, you can use the following special syntax to relax this restriction:\nfn generic&lt;T: ?Sized&gt;(t: &amp;T) {\n    // --snip--\n}\n\nA trait bound on \"?Sized\" means “\"T\" may or may not be \"Sized\"” and this notation overrides the default that generic types must have a known size at compile time. The \"?Trait\" syntax with this meaning is only available for \"Sized\", not any other traits.\nAlso note that we switched the type of the \"t\" parameter from \"T\" to \"&amp;T\". Because the type might not be \"Sized\", we need to use it behind some kind of pointer. In this case, we’ve chosen a reference.\nNext, we’ll talk about functions and closures!\n\nAdvanced Functions and Closures\nThis section explores some advanced features related to functions and closures, including function pointers and returning closures.\nFunction Pointers\nWe’ve talked about how to pass closures to functions; you can also pass regular functions to functions! This technique is useful when you want to pass a function you’ve already defined rather than defining a new closure. Functions coerce to the type \"fn\" (with a lowercase f), not to be confused with the \"Fn\" closure trait. The \"fn\" type is called a function pointer. Passing functions with function pointers will allow you to use functions as arguments to other functions.\nThe syntax for specifying that a parameter is a function pointer is similar to that of closures, as shown in Listing 19-27, where we’ve defined a function \"add_one\" that adds one to its parameter. The function \"do_twice\" takes two parameters: a function pointer to any function that takes an \"i32\" parameter and returns an \"i32\", and one \"i32 value\". The \"do_twice\" function calls the function \"f\" twice, passing it the \"arg\" value, then adds the two function call results together. The \"main\" function calls \"do_twice\" with the arguments \"add_one\" and \"5\".\nFilename: src/main.rs\nfn add_one(x: i32) -&gt; i32 {\n    x + 1\n}\n\nfn do_twice(f: fn(i32) -&gt; i32, arg: i32) -&gt; i32 {\n    f(arg) + f(arg)\n}\n\nfn main() {\n    let answer = do_twice(add_one, 5);\n\n    println!(\"The answer is: {}\", answer);\n}\n\nListing 19-27: Using the \"fn\" type to accept a function pointer as an argument\nThis code prints \"The answer is: 12\". We specify that the parameter \"f\" in \"do_twice\" is an \"fn\" that takes one parameter of type \"i32\" and returns an \"i32\". We can then call \"f\" in the body of \"do_twice\". In \"main\", we can pass the function name \"add_one\" as the first argument to \"do_twice\".\nUnlike closures, \"fn\" is a type rather than a trait, so we specify \"fn\" as the parameter type directly rather than declaring a generic type parameter with one of the \"Fn\" traits as a trait bound.\nFunction pointers implement all three of the closure traits (\"Fn\", \"FnMut\", and \"FnOnce\"), meaning you can always pass a function pointer as an argument for a function that expects a closure. It’s best to write functions using a generic type and one of the closure traits so your functions can accept either functions or closures.\nThat said, one example of where you would want to only accept \"fn\" and not closures is when interfacing with external code that doesn’t have closures: C functions can accept functions as arguments, but C doesn’t have closures.\nAs an example of where you could use either a closure defined inline or a named function, let’s look at a use of the \"map\" method provided by the \"Iterator\" trait in the standard library. To use the \"map\" function to turn a vector of numbers into a vector of strings, we could use a closure, like this:\n    let list_of_numbers = vec![1, 2, 3];\n    let list_of_strings: Vec&lt;String&gt; =\n        list_of_numbers.iter().map(|i| i.to_string()).collect();\n\nOr we could name a function as the argument to \"map\" instead of the closure, like this:\n    let list_of_numbers = vec![1, 2, 3];\n    let list_of_strings: Vec&lt;String&gt; =\n        list_of_numbers.iter().map(ToString::to_string).collect();\n\nNote that we must use the fully qualified syntax that we talked about earlier in the “Advanced Traits” section because there are multiple functions available named \"to_string\". Here, we’re using the \"to_string\" function defined in the \"ToString\" trait, which the standard library has implemented for any type that implements \"Display\".\nRecall from the “Enum values” section of Chapter 6 that the name of each enum variant that we define also becomes an initializer function. We can use these initializer functions as function pointers that implement the closure traits, which means we can specify the initializer functions as arguments for methods that take closures, like so:\n    enum Status {\n        Value(u32),\n        Stop,\n    }\n\n    let list_of_statuses: Vec&lt;Status&gt; = (0u32..20).map(Status::Value).collect();\n\nHere we create \"Status::Value\" instances using each \"u32\" value in the range that \"map\" is called on by using the initializer function of \"Status::Value\". Some people prefer this style, and some people prefer to use closures. They compile to the same code, so use whichever style is clearer to you.\nReturning Closures\nClosures are represented by traits, which means you can’t return closures directly. In most cases where you might want to return a trait, you can instead use the concrete type that implements the trait as the return value of the function. However, you can’t do that with closures because they don’t have a concrete type that is returnable; you’re not allowed to use the function pointer \"fn\" as a return type, for example.\nThe following code tries to return a closure directly, but it won’t compile:\nfn returns_closure() -&gt; dyn Fn(i32) -&gt; i32 {\n    |x| x + 1\n}\n\nThe compiler error is as follows:\n$ cargo build\n   Compiling functions-example v0.1.0 (file:///projects/functions-example)\nerror[E0746]: return type cannot have an unboxed trait object\n --&gt; src/lib.rs:1:25\n  |\n1 | fn returns_closure() -&gt; dyn Fn(i32) -&gt; i32 {\n  |                         ^^^^^^^^^^^^^^^^^^ doesn\"t have a size known at compile-time\n  |\n  = note: for information on \"impl Trait\", see &lt;https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits&gt;\nhelp: use \"impl Fn(i32) -&gt; i32\" as the return type, as all return paths are of type \"[closure@src/lib.rs:2:5: 2:8]\", which implements \"Fn(i32) -&gt; i32\"\n  |\n1 | fn returns_closure() -&gt; impl Fn(i32) -&gt; i32 {\n  |                         ~~~~~~~~~~~~~~~~~~~\n\nFor more information about this error, try \"rustc --explain E0746\".\nerror: could not compile \"functions-example\" due to previous error\n\nThe error references the \"Sized\" trait again! Rust doesn’t know how much space it will need to store the closure. We saw a solution to this problem earlier. We can use a trait object:\nfn returns_closure() -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {\n    Box::new(|x| x + 1)\n}\n\nThis code will compile just fine. For more about trait objects, refer to the section “Using Trait Objects That Allow for Values of Different Types” in Chapter 17.\nNext, let’s look at macros!\n\nMacros\nWe’ve used macros like \"println!\" throughout this book, but we haven’t fully explored what a macro is and how it works. The term macro refers to a family of features in Rust: declarative macros with \"macro_rules!\" and three kinds of procedural macros:\n\nCustom \"#[derive]\" macros that specify code added with the \"derive\" attribute used on structs and enums\nAttribute-like macros that define custom attributes usable on any item\nFunction-like macros that look like function calls but operate on the tokens specified as their argument\n\nWe’ll talk about each of these in turn, but first, let’s look at why we even need macros when we already have functions.\nThe Difference Between Macros and Functions\nFundamentally, macros are a way of writing code that writes other code, which is known as metaprogramming. In Appendix C, we discuss the \"derive\" attribute, which generates an implementation of various traits for you. We’ve also used the \"println!\" and \"vec!\" macros throughout the book. All of these macros expand to produce more code than the code you’ve written manually.\nMetaprogramming is useful for reducing the amount of code you have to write and maintain, which is also one of the roles of functions. However, macros have some additional powers that functions don’t.\nA function signature must declare the number and type of parameters the function has. Macros, on the other hand, can take a variable number of parameters: we can call \"println!(\"hello\")\" with one argument or \"println!(\"hello {}\", name)\" with two arguments. Also, macros are expanded before the compiler interprets the meaning of the code, so a macro can, for example, implement a trait on a given type. A function can’t, because it gets called at runtime and a trait needs to be implemented at compile time.\nThe downside to implementing a macro instead of a function is that macro definitions are more complex than function definitions because you’re writing Rust code that writes Rust code. Due to this indirection, macro definitions are generally more difficult to read, understand, and maintain than function definitions.\nAnother important difference between macros and functions is that you must define macros or bring them into scope before you call them in a file, as opposed to functions you can define anywhere and call anywhere.\nDeclarative Macros with \"macro_rules!\" for General Metaprogramming\nThe most widely used form of macros in Rust is the declarative macro. These are also sometimes referred to as “macros by example,” “\"macro_rules!\" macros,” or just plain “macros.” At their core, declarative macros allow you to write something similar to a Rust \"match\" expression. As discussed in Chapter 6, \"match\" expressions are control structures that take an expression, compare the resulting value of the expression to patterns, and then run the code associated with the matching pattern. Macros also compare a value to patterns that are associated with particular code: in this situation, the value is the literal Rust source code passed to the macro; the patterns are compared with the structure of that source code; and the code associated with each pattern, when matched, replaces the code passed to the macro. This all happens during compilation.\nTo define a macro, you use the \"macro_rules!\" construct. Let’s explore how to use \"macro_rules!\" by looking at how the \"vec!\" macro is defined. Chapter 8 covered how we can use the \"vec!\" macro to create a new vector with particular values. For example, the following macro creates a new vector containing three integers:\nlet v: Vec&lt;u32&gt; = vec![1, 2, 3];\n\nWe could also use the \"vec!\" macro to make a vector of two integers or a vector of five string slices. We wouldn’t be able to use a function to do the same because we wouldn’t know the number or type of values up front.\nListing 19-28 shows a slightly simplified definition of the \"vec!\" macro.\nFilename: src/lib.rs\n#[macro_export]\nmacro_rules! vec {\n    ( $( $x:expr ),* ) =&gt; {\n        {\n            let mut temp_vec = Vec::new();\n            $(\n                temp_vec.push($x);\n            )*\n            temp_vec\n        }\n    };\n}\n\nListing 19-28: A simplified version of the \"vec!\" macro definition\n\nNote: The actual definition of the \"vec!\" macro in the standard library includes code to preallocate the correct amount of memory up front. That code is an optimization that we don’t include here to make the example simpler.\n\nThe \"#[macro_export]\" annotation indicates that this macro should be made available whenever the crate in which the macro is defined is brought into scope. Without this annotation, the macro can’t be brought into scope.\nWe then start the macro definition with \"macro_rules!\" and the name of the macro we’re defining without the exclamation mark. The name, in this case \"vec\", is followed by curly brackets denoting the body of the macro definition.\nThe structure in the \"vec!\" body is similar to the structure of a \"match\" expression. Here we have one arm with the pattern \"( $( $x:expr ),* )\", followed by \"=&gt;\" and the block of code associated with this pattern. If the pattern matches, the associated block of code will be emitted. Given that this is the only pattern in this macro, there is only one valid way to match; any other pattern will result in an error. More complex macros will have more than one arm.\nValid pattern syntax in macro definitions is different than the pattern syntax covered in Chapter 18 because macro patterns are matched against Rust code structure rather than values. Let’s walk through what the pattern pieces in Listing 19-28 mean; for the full macro pattern syntax, see the Rust Reference.\nFirst, we use a set of parentheses to encompass the whole pattern. We use a dollar sign (\"$\") to declare a variable in the macro system that will contain the Rust code matching the pattern. The dollar sign makes it clear this is a macro variable as opposed to a regular Rust variable. Next comes a set of parentheses that captures values that match the pattern within the parentheses for use in the replacement code. Within \"$()\" is \"$x:expr\", which matches any Rust expression and gives the expression the name \"$x\".\nThe comma following \"$()\" indicates that a literal comma separator character could optionally appear after the code that matches the code in \"$()\". The \"\" specifies that the pattern matches zero or more of whatever precedes the \"\".\nWhen we call this macro with \"vec![1, 2, 3];\", the \"$x\" pattern matches three times with the three expressions \"1\", \"2\", and \"3\".\nNow let’s look at the pattern in the body of the code associated with this arm: \"temp_vec.push()\" within \"$()*\" is generated for each part that matches \"$()\" in the pattern zero or more times depending on how many times the pattern matches. The \"$x\" is replaced with each expression matched. When we call this macro with \"vec![1, 2, 3];\", the code generated that replaces this macro call will be the following:\n{\n    let mut temp_vec = Vec::new();\n    temp_vec.push(1);\n    temp_vec.push(2);\n    temp_vec.push(3);\n    temp_vec\n}\n\nWe’ve defined a macro that can take any number of arguments of any type and can generate code to create a vector containing the specified elements.\nTo learn more about how to write macros, consult the online documentation or other resources, such as “The Little Book of Rust Macros” started by Daniel Keep and continued by Lukas Wirth.\nProcedural Macros for Generating Code from Attributes\nThe second form of macros is the procedural macro, which acts more like a function (and is a type of procedure). Procedural macros accept some code as an input, operate on that code, and produce some code as an output rather than matching against patterns and replacing the code with other code as declarative macros do. The three kinds of procedural macros are custom derive, attribute-like, and function-like, and all work in a similar fashion.\nWhen creating procedural macros, the definitions must reside in their own crate with a special crate type. This is for complex technical reasons that we hope to eliminate in the future. In Listing 19-29, we show how to define a procedural macro, where \"some_attribute\" is a placeholder for using a specific macro variety.\nFilename: src/lib.rs\nuse proc_macro;\n\n#[some_attribute]\npub fn some_name(input: TokenStream) -&gt; TokenStream {\n}\n\nListing 19-29: An example of defining a procedural macro\nThe function that defines a procedural macro takes a \"TokenStream\" as an input and produces a \"TokenStream\" as an output. The \"TokenStream\" type is defined by the \"proc_macro\" crate that is included with Rust and represents a sequence of tokens. This is the core of the macro: the source code that the macro is operating on makes up the input \"TokenStream\", and the code the macro produces is the output \"TokenStream\". The function also has an attribute attached to it that specifies which kind of procedural macro we’re creating. We can have multiple kinds of procedural macros in the same crate.\nLet’s look at the different kinds of procedural macros. We’ll start with a custom derive macro and then explain the small dissimilarities that make the other forms different.\nHow to Write a Custom \"derive\" Macro\nLet’s create a crate named \"hello_macro\" that defines a trait named \"HelloMacro\" with one associated function named \"hello_macro\". Rather than making our users implement the \"HelloMacro\" trait for each of their types, we’ll provide a procedural macro so users can annotate their type with \"#[derive(HelloMacro)]\" to get a default implementation of the \"hello_macro\" function. The default implementation will print \"Hello, Macro! My name is TypeName!\" where \"TypeName\" is the name of the type on which this trait has been defined. In other words, we’ll write a crate that enables another programmer to write code like Listing 19-30 using our crate.\nFilename: src/main.rs\nuse hello_macro::HelloMacro;\nuse hello_macro_derive::HelloMacro;\n\n#[derive(HelloMacro)]\nstruct Pancakes;\n\nfn main() {\n    Pancakes::hello_macro();\n}\n\nListing 19-30: The code a user of our crate will be able to write when using our procedural macro\nThis code will print \"Hello, Macro! My name is Pancakes!\" when we’re done. The first step is to make a new library crate, like this:\n$ cargo new hello_macro --lib\n\nNext, we’ll define the \"HelloMacro\" trait and its associated function:\nFilename: src/lib.rs\npub trait HelloMacro {\n    fn hello_macro();\n}\n\nWe have a trait and its function. At this point, our crate user could implement the trait to achieve the desired functionality, like so:\nuse hello_macro::HelloMacro;\n\nstruct Pancakes;\n\nimpl HelloMacro for Pancakes {\n    fn hello_macro() {\n        println!(\"Hello, Macro! My name is Pancakes!\");\n    }\n}\n\nfn main() {\n    Pancakes::hello_macro();\n}\n\nHowever, they would need to write the implementation block for each type they wanted to use with \"hello_macro\"; we want to spare them from having to do this work.\nAdditionally, we can’t yet provide the \"hello_macro\" function with default implementation that will print the name of the type the trait is implemented on: Rust doesn’t have reflection capabilities, so it can’t look up the type’s name at runtime. We need a macro to generate code at compile time.\nThe next step is to define the procedural macro. At the time of this writing, procedural macros need to be in their own crate. Eventually, this restriction might be lifted. The convention for structuring crates and macro crates is as follows: for a crate named \"foo\", a custom derive procedural macro crate is called \"foo_derive\". Let’s start a new crate called \"hello_macro_derive\" inside our \"hello_macro\" project:\n$ cargo new hello_macro_derive --lib\n\nOur two crates are tightly related, so we create the procedural macro crate within the directory of our \"hello_macro\" crate. If we change the trait definition in \"hello_macro\", we’ll have to change the implementation of the procedural macro in \"hello_macro_derive\" as well. The two crates will need to be published separately, and programmers using these crates will need to add both as dependencies and bring them both into scope. We could instead have the \"hello_macro\" crate use \"hello_macro_derive\" as a dependency and re-export the procedural macro code. However, the way we’ve structured the project makes it possible for programmers to use \"hello_macro\" even if they don’t want the \"derive\" functionality.\nWe need to declare the \"hello_macro_derive\" crate as a procedural macro crate. We’ll also need functionality from the \"syn\" and \"quote\" crates, as you’ll see in a moment, so we need to add them as dependencies. Add the following to the Cargo.toml file for \"hello_macro_derive\":\nFilename: hello_macro_derive/Cargo.toml\n[lib]\nproc-macro = true\n\n[dependencies]\nsyn = \"1.0\"\nquote = \"1.0\"\n\nTo start defining the procedural macro, place the code in Listing 19-31 into your src/lib.rs file for the \"hello_macro_derive\" crate. Note that this code won’t compile until we add a definition for the \"impl_hello_macro\" function.\nFilename: hello_macro_derive/src/lib.rs\nuse proc_macro::TokenStream;\nuse quote::quote;\nuse syn;\n\n#[proc_macro_derive(HelloMacro)]\npub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {\n    // Construct a representation of Rust code as a syntax tree\n    // that we can manipulate\n    let ast = syn::parse(input).unwrap();\n\n    // Build the trait implementation\n    impl_hello_macro(&amp;ast)\n}\n\nListing 19-31: Code that most procedural macro crates will require in order to process Rust code\nNotice that we’ve split the code into the \"hello_macro_derive\" function, which is responsible for parsing the \"TokenStream\", and the \"impl_hello_macro\" function, which is responsible for transforming the syntax tree: this makes writing a procedural macro more convenient. The code in the outer function (\"hello_macro_derive\" in this case) will be the same for almost every procedural macro crate you see or create. The code you specify in the body of the inner function (\"impl_hello_macro\" in this case) will be different depending on your procedural macro’s purpose.\nWe’ve introduced three new crates: \"proc_macro\", \"syn\", and \"quote\". The \"proc_macro\" crate comes with Rust, so we didn’t need to add that to the dependencies in Cargo.toml. The \"proc_macro\" crate is the compiler’s API that allows us to read and manipulate Rust code from our code.\nThe \"syn\" crate parses Rust code from a string into a data structure that we can perform operations on. The \"quote\" crate turns \"syn\" data structures back into Rust code. These crates make it much simpler to parse any sort of Rust code we might want to handle: writing a full parser for Rust code is no simple task.\nThe \"hello_macro_derive\" function will be called when a user of our library specifies \"#[derive(HelloMacro)]\" on a type. This is possible because we’ve annotated the \"hello_macro_derive\" function here with \"proc_macro_derive\" and specified the name \"HelloMacro\", which matches our trait name; this is the convention most procedural macros follow.\nThe \"hello_macro_derive\" function first converts the \"input\" from a \"TokenStream\" to a data structure that we can then interpret and perform operations on. This is where \"syn\" comes into play. The \"parse\" function in \"syn\" takes a \"TokenStream\" and returns a \"DeriveInput\" struct representing the parsed Rust code. Listing 19-32 shows the relevant parts of the \"DeriveInput\" struct we get from parsing the \"struct Pancakes;\" string:\nDeriveInput {\n    // --snip--\n\n    ident: Ident {\n        ident: \"Pancakes\",\n        span: #0 bytes(95..103)\n    },\n    data: Struct(\n        DataStruct {\n            struct_token: Struct,\n            fields: Unit,\n            semi_token: Some(\n                Semi\n            )\n        }\n    )\n}\n\nListing 19-32: The \"DeriveInput\" instance we get when parsing the code that has the macro’s attribute in Listing 19-30\nThe fields of this struct show that the Rust code we’ve parsed is a unit struct with the \"ident\" (identifier, meaning the name) of \"Pancakes\". There are more fields on this struct for describing all sorts of Rust code; check the \"syn\" documentation for \"DeriveInput\" for more information.\nSoon we’ll define the \"impl_hello_macro\" function, which is where we’ll build the new Rust code we want to include. But before we do, note that the output for our derive macro is also a \"TokenStream\". The returned \"TokenStream\" is added to the code that our crate users write, so when they compile their crate, they’ll get the extra functionality that we provide in the modified \"TokenStream\".\nYou might have noticed that we’re calling \"unwrap\" to cause the \"hello_macro_derive\" function to panic if the call to the \"syn::parse\" function fails here. It’s necessary for our procedural macro to panic on errors because \"proc_macro_derive\" functions must return \"TokenStream\" rather than \"Result\" to conform to the procedural macro API. We’ve simplified this example by using \"unwrap\"; in production code, you should provide more specific error messages about what went wrong by using \"panic!\" or \"expect\".\nNow that we have the code to turn the annotated Rust code from a \"TokenStream\" into a \"DeriveInput\" instance, let’s generate the code that implements the \"HelloMacro\" trait on the annotated type, as shown in Listing 19-33.\nFilename: hello_macro_derive/src/lib.rs\nfn impl_hello_macro(ast: &amp;syn::DeriveInput) -&gt; TokenStream {\n    let name = &amp;ast.ident;\n    let gen = quote! {\n        impl HelloMacro for #name {\n            fn hello_macro() {\n                println!(\"Hello, Macro! My name is {}!\", stringify!(#name));\n            }\n        }\n    };\n    gen.into()\n}\n\nListing 19-33: Implementing the \"HelloMacro\" trait using the parsed Rust code\nWe get an \"Ident\" struct instance containing the name (identifier) of the annotated type using \"ast.ident\". The struct in Listing 19-32 shows that when we run the \"impl_hello_macro\" function on the code in Listing 19-30, the \"ident\" we get will have the \"ident\" field with a value of \"\"Pancakes\"\". Thus, the \"name\" variable in Listing 19-33 will contain an \"Ident\" struct instance that, when printed, will be the string \"\"Pancakes\"\", the name of the struct in Listing 19-30.\nThe \"quote!\" macro lets us define the Rust code that we want to return. The compiler expects something different to the direct result of the \"quote!\" macro’s execution, so we need to convert it to a \"TokenStream\". We do this by calling the \"into\" method, which consumes this intermediate representation and returns a value of the required \"TokenStream\" type.\nThe \"quote!\" macro also provides some very cool templating mechanics: we can enter \"#name\", and \"quote!\" will replace it with the value in the variable \"name\". You can even do some repetition similar to the way regular macros work. Check out the \"quote\" crate’s docs for a thorough introduction.\nWe want our procedural macro to generate an implementation of our \"HelloMacro\" trait for the type the user annotated, which we can get by using \"#name\". The trait implementation has the one function \"hello_macro\", whose body contains the functionality we want to provide: printing \"Hello, Macro! My name is\" and then the name of the annotated type.\nThe \"stringify!\" macro used here is built into Rust. It takes a Rust expression, such as \"1 + 2\", and at compile time turns the expression into a string literal, such as \"\"1 + 2\"\". This is different than \"format!\" or \"println!\", macros which evaluate the expression and then turn the result into a \"String\". There is a possibility that the \"#name\" input might be an expression to print literally, so we use \"stringify!\". Using \"stringify!\" also saves an allocation by converting \"#name\" to a string literal at compile time.\nAt this point, \"cargo build\" should complete successfully in both \"hello_macro\" and \"hello_macro_derive\". Let’s hook up these crates to the code in Listing 19-30 to see the procedural macro in action! Create a new binary project in your projects directory using \"cargo new pancakes\". We need to add \"hello_macro\" and \"hello_macro_derive\" as dependencies in the \"pancakes\" crate’s Cargo.toml. If you’re publishing your versions of \"hello_macro\" and \"hello_macro_derive\" to crates.io, they would be regular dependencies; if not, you can specify them as \"path\" dependencies as follows:\nhello_macro = { path = \"../hello_macro\" }\nhello_macro_derive = { path = \"../hello_macro/hello_macro_derive\" }\n\nPut the code in Listing 19-30 into src/main.rs, and run \"cargo run\": it should print \"Hello, Macro! My name is Pancakes!\" The implementation of the \"HelloMacro\" trait from the procedural macro was included without the \"pancakes\" crate needing to implement it; the \"#[derive(HelloMacro)]\" added the trait implementation.\nNext, let’s explore how the other kinds of procedural macros differ from custom derive macros.\nAttribute-like macros\nAttribute-like macros are similar to custom derive macros, but instead of generating code for the \"derive\" attribute, they allow you to create new attributes. They’re also more flexible: \"derive\" only works for structs and enums; attributes can be applied to other items as well, such as functions. Here’s an example of using an attribute-like macro: say you have an attribute named \"route\" that annotates functions when using a web application framework:\n#[route(GET, \"/\")]\nfn index() {\n\nThis \"#[route]\" attribute would be defined by the framework as a procedural macro. The signature of the macro definition function would look like this:\n#[proc_macro_attribute]\npub fn route(attr: TokenStream, item: TokenStream) -&gt; TokenStream {\n\nHere, we have two parameters of type \"TokenStream\". The first is for the contents of the attribute: the \"GET, \"/\"\" part. The second is the body of the item the attribute is attached to: in this case, \"fn index() {}\" and the rest of the function’s body.\nOther than that, attribute-like macros work the same way as custom derive macros: you create a crate with the \"proc-macro\" crate type and implement a function that generates the code you want!\nFunction-like macros\nFunction-like macros define macros that look like function calls. Similarly to \"macro_rules!\" macros, they’re more flexible than functions; for example, they can take an unknown number of arguments. However, \"macro_rules!\" macros can be defined only using the match-like syntax we discussed in the section “Declarative Macros with \"macro_rules!\" for General Metaprogramming” earlier. Function-like macros take a \"TokenStream\" parameter and their definition manipulates that \"TokenStream\" using Rust code as the other two types of procedural macros do. An example of a function-like macro is an \"sql!\" macro that might be called like so:\nlet sql = sql!(SELECT * FROM posts WHERE id=1);\n\nThis macro would parse the SQL statement inside it and check that it’s syntactically correct, which is much more complex processing than a \"macro_rules!\" macro can do. The \"sql!\" macro would be defined like this:\n#[proc_macro]\npub fn sql(input: TokenStream) -&gt; TokenStream {\n\nThis definition is similar to the custom derive macro’s signature: we receive the tokens that are inside the parentheses and return the code we wanted to generate.\nSummary\nWhew! Now you have some Rust features in your toolbox that you likely won’t use often, but you’ll know they’re available in very particular circumstances. We’ve introduced several complex topics so that when you encounter them in error message suggestions or in other peoples’ code, you’ll be able to recognize these concepts and syntax. Use this chapter as a reference to guide you to solutions.\nNext, we’ll put everything we’ve discussed throughout the book into practice and do one more project!\n\n20\nFinal Project: Building a Multithreaded Web Server\nIt’s been a long journey, but we’ve reached the end of the book. In this chapter, we’ll build one more project together to demonstrate some of the concepts we covered in the final chapters, as well as recap some earlier lessons.\nFor our final project, we’ll make a web server that says “hello” and looks like Figure 20-1 in a web browser.\n\nFigure 20-1: Our final shared project\nHere is our plan for building the web server:\n\nLearn a bit about TCP and HTTP.\nListen for TCP connections on a socket.\nParse a small number of HTTP requests.\nCreate a proper HTTP response.\nImprove the throughput of our server with a thread pool.\n\nBefore we get started, we should mention one detail: the method we’ll use won’t be the best way to build a web server with Rust. Community members have published a number of production-ready crates available on crates.io that provide more complete web server and thread pool implementations than we’ll build. However, our intention in this chapter is to help you learn, not to take the easy route. Because Rust is a systems programming language, we can choose the level of abstraction we want to work with and can go to a lower level than is possible or practical in other languages. We’ll therefore write the basic HTTP server and thread pool manually so you can learn the general ideas and techniques behind the crates you might use in the future.\n\nBuilding a Single-Threaded Web Server\nWe’ll start by getting a single-threaded web server working. Before we begin, let’s look at a quick overview of the protocols involved in building web servers. The details of these protocols are beyond the scope of this book, but a brief overview will give you the information you need.\nThe two main protocols involved in web servers are Hypertext Transfer Protocol (HTTP) and Transmission Control Protocol (TCP). Both protocols are request-response protocols, meaning a client initiates requests and a server listens to the requests and provides a response to the client. The contents of those requests and responses are defined by the protocols.\nTCP is the lower-level protocol that describes the details of how information gets from one server to another but doesn’t specify what that information is. HTTP builds on top of TCP by defining the contents of the requests and responses. It’s technically possible to use HTTP with other protocols, but in the vast majority of cases, HTTP sends its data over TCP. We’ll work with the raw bytes of TCP and HTTP requests and responses.\nListening to the TCP Connection\nOur web server needs to listen to a TCP connection, so that’s the first part we’ll work on. The standard library offers a \"std::net\" module that lets us do this. Let’s make a new project in the usual fashion:\n$ cargo new hello\n     Created binary (application) \"hello\" project\n$ cd hello\n\nNow enter the code in Listing 20-1 in src/main.rs to start. This code will listen at the local address \"127.0.0.1:7878\" for incoming TCP streams. When it gets an incoming stream, it will print \"Connection established!\".\nFilename: src/main.rs\nuse std::net::TcpListener;\n\nfn main() {\n    let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n\n    for stream in listener.incoming() {\n        let stream = stream.unwrap();\n    \n        println!(\"Connection established!\");\n    }\n}\n\nListing 20-1: Listening for incoming streams and printing a message when we receive a stream\nUsing \"TcpListener\", we can listen for TCP connections at the address \"127.0.0.1:7878\". In the address, the section before the colon is an IP address representing your computer (this is the same on every computer and doesn’t represent the authors’ computer specifically), and \"7878\" is the port. We’ve chosen this port for two reasons: HTTP isn’t normally accepted on this port so our server is unlikely to conflict with any other web server you might have running on your machine, and 7878 is rust typed on a telephone.\nThe \"bind\" function in this scenario works like the \"new\" function in that it will return a new \"TcpListener\" instance. The function is called \"bind\" because, in networking, connecting to a port to listen to is known as “binding to a port.”\nThe \"bind\" function returns a \"Result&lt;T, E&gt;\", which indicates that it’s possible for binding to fail. For example, connecting to port 80 requires administrator privileges (nonadministrators can listen only on ports higher than 1023), so if we tried to connect to port 80 without being an administrator, binding wouldn’t work. Binding also wouldn’t work, for example, if we ran two instances of our program and so had two programs listening to the same port. Because we’re writing a basic server just for learning purposes, we won’t worry about handling these kinds of errors; instead, we use \"unwrap\" to stop the program if errors happen.\nThe \"incoming\" method on \"TcpListener\" returns an iterator that gives us a sequence of streams (more specifically, streams of type \"TcpStream\"). A single stream represents an open connection between the client and the server. A connection is the name for the full request and response process in which a client connects to the server, the server generates a response, and the server closes the connection. As such, we will read from the \"TcpStream\" to see what the client sent and then write our response to the stream to send data back to the client. Overall, this \"for\" loop will process each connection in turn and produce a series of streams for us to handle.\nFor now, our handling of the stream consists of calling \"unwrap\" to terminate our program if the stream has any errors; if there aren’t any errors, the program prints a message. We’ll add more functionality for the success case in the next listing. The reason we might receive errors from the \"incoming\" method when a client connects to the server is that we’re not actually iterating over connections. Instead, we’re iterating over connection attempts. The connection might not be successful for a number of reasons, many of them operating system specific. For example, many operating systems have a limit to the number of simultaneous open connections they can support; new connection attempts beyond that number will produce an error until some of the open connections are closed.\nLet’s try running this code! Invoke \"cargo run\" in the terminal and then load 127.0.0.1:7878 in a web browser. The browser should show an error message like “Connection reset,” because the server isn’t currently sending back any data. But when you look at your terminal, you should see several messages that were printed when the browser connected to the server!\n     Running \"target/debug/hello\"\nConnection established!\nConnection established!\nConnection established!\n\nSometimes, you’ll see multiple messages printed for one browser request; the reason might be that the browser is making a request for the page as well as a request for other resources, like the favicon.ico icon that appears in the browser tab.\nIt could also be that the browser is trying to connect to the server multiple times because the server isn’t responding with any data. When \"stream\" goes out of scope and is dropped at the end of the loop, the connection is closed as part of the \"drop\" implementation. Browsers sometimes deal with closed connections by retrying, because the problem might be temporary. The important factor is that we’ve successfully gotten a handle to a TCP connection!\nRemember to stop the program by pressing ctrl-c when you’re done running a particular version of the code. Then restart the program by invoking the \"cargo run\" command after you’ve made each set of code changes to make sure you’re running the newest code.\nReading the Request\nLet’s implement the functionality to read the request from the browser! To separate the concerns of first getting a connection and then taking some action with the connection, we’ll start a new function for processing connections. In this new \"handle_connection\" function, we’ll read data from the TCP stream and print it so we can see the data being sent from the browser. Change the code to look like Listing 20-2.\nFilename: src/main.rs\nuse std::{\n    io::{prelude::*, BufReader},\n    net::{TcpListener, TcpStream},\n};\n\nfn main() {\n    let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n\n    for stream in listener.incoming() {\n        let stream = stream.unwrap();\n    \n        handle_connection(stream);\n    }\n}\n\nfn handle_connection(mut stream: TcpStream) {\n    let buf_reader = BufReader::new(&amp;mut stream);\n    let http_request: Vec&lt;_&gt; = buf_reader\n        .lines()\n        .map(|result| result.unwrap())\n        .take_while(|line| !line.is_empty())\n        .collect();\n\n    println!(\"Request: {:#?}\", http_request);\n}\n\nListing 20-2: Reading from the \"TcpStream\" and printing the data\nWe bring \"std::io::prelude\" and \"std::io::BufReader\" into scope to get access to traits and types that let us read from and write to the stream. In the \"for\" loop in the \"main\" function, instead of printing a message that says we made a connection, we now call the new \"handle_connection\" function and pass the \"stream\" to it.\nIn the \"handle_connection\" function, we create a new \"BufReader\" instance that wraps a mutable reference to the \"stream\". \"BufReader\" adds buffering by managing calls to the \"std::io::Read\" trait methods for us.\nWe create a variable named \"http_request\" to collect the lines of the request the browser sends to our server. We indicate that we want to collect these lines in a vector by adding the \"Vec&lt;_&gt;\" type annotation.\n\"BufReader\" implements the \"std::io::BufRead\" trait, which provides the \"lines\" method. The \"lines\" method returns an iterator of \"Result&lt;String, std::io::Error&gt;\" by splitting the stream of data whenever it sees a newline byte. To get each \"String\", we map and \"unwrap\" each \"Result\". The \"Result\" might be an error if the data isn’t valid UTF-8 or if there was a problem reading from the stream. Again, a production program should handle these errors more gracefully, but we’re choosing to stop the program in the error case for simplicity.\nThe browser signals the end of an HTTP request by sending two newline characters in a row, so to get one request from the stream, we take lines until we get a line that is the empty string. Once we’ve collected the lines into the vector, we’re printing them out using pretty debug formatting so we can take a look at the instructions the web browser is sending to our server.\nLet’s try this code! Start the program and make a request in a web browser again. Note that we’ll still get an error page in the browser, but our program’s output in the terminal will now look similar to this:\n$ cargo run\n   Compiling hello v0.1.0 (file:///projects/hello)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.42s\n     Running \"target/debug/hello\"\nRequest: [\n    \"GET / HTTP/1.1\",\n    \"Host: 127.0.0.1:7878\",\n    \"User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:99.0) Gecko/20100101 Firefox/99.0\",\n    \"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8\",\n    \"Accept-Language: en-US,en;q=0.5\",\n    \"Accept-Encoding: gzip, deflate, br\",\n    \"DNT: 1\",\n    \"Connection: keep-alive\",\n    \"Upgrade-Insecure-Requests: 1\",\n    \"Sec-Fetch-Dest: document\",\n    \"Sec-Fetch-Mode: navigate\",\n    \"Sec-Fetch-Site: none\",\n    \"Sec-Fetch-User: ?1\",\n    \"Cache-Control: max-age=0\",\n]\n\nDepending on your browser, you might get slightly different output. Now that we’re printing the request data, we can see why we get multiple connections from one browser request by looking at the path after \"GET\" in the first line of the request. If the repeated connections are all requesting /, we know the browser is trying to fetch / repeatedly because it’s not getting a response from our program.\nLet’s break down this request data to understand what the browser is asking of our program.\nA Closer Look at an HTTP Request\nHTTP is a text-based protocol, and a request takes this format:\nMethod Request-URI HTTP-Version CRLF\nheaders CRLF\nmessage-body\n\nThe first line is the request line that holds information about what the client is requesting. The first part of the request line indicates the method being used, such as \"GET\" or \"POST\", which describes how the client is making this request. Our client used a \"GET\" request, which means it is asking for information.\nThe next part of the request line is /, which indicates the Uniform Resource Identifier (URI) the client is requesting: a URI is almost, but not quite, the same as a Uniform Resource Locator (URL). The difference between URIs and URLs isn’t important for our purposes in this chapter, but the HTTP spec uses the term URI, so we can just mentally substitute URL for URI here.\nThe last part is the HTTP version the client uses, and then the request line ends in a CRLF sequence. (CRLF stands for carriage return and line feed, which are terms from the typewriter days!) The CRLF sequence can also be written as \"\\r\\n\", where \"\\r\" is a carriage return and \"\\n\" is a line feed. The CRLF sequence separates the request line from the rest of the request data. Note that when the CRLF is printed, we see a new line start rather than \"\\r\\n\".\nLooking at the request line data we received from running our program so far, we see that \"GET\" is the method, / is the request URI, and \"HTTP/1.1\" is the version.\nAfter the request line, the remaining lines starting from \"Host:\" onward are headers. \"GET\" requests have no body.\nTry making a request from a different browser or asking for a different address, such as 127.0.0.1:7878/test, to see how the request data changes.\nNow that we know what the browser is asking for, let’s send back some data!\nWriting a Response\nWe’re going to implement sending data in response to a client request. Responses have the following format:\nHTTP-Version Status-Code Reason-Phrase CRLF\nheaders CRLF\nmessage-body\n\nThe first line is a status line that contains the HTTP version used in the response, a numeric status code that summarizes the result of the request, and a reason phrase that provides a text description of the status code. After the CRLF sequence are any headers, another CRLF sequence, and the body of the response.\nHere is an example response that uses HTTP version 1.1, has a status code of 200, an OK reason phrase, no headers, and no body:\nHTTP/1.1 200 OK\\r\\n\\r\\n\n\nThe status code 200 is the standard success response. The text is a tiny successful HTTP response. Let’s write this to the stream as our response to a successful request! From the \"handle_connection\" function, remove the \"println!\" that was printing the request data and replace it with the code in Listing 20-3.\nFilename: src/main.rs\nfn handle_connection(mut stream: TcpStream) {\n    let buf_reader = BufReader::new(&amp;mut stream);\n    let http_request: Vec&lt;_&gt; = buf_reader\n        .lines()\n        .map(|result| result.unwrap())\n        .take_while(|line| !line.is_empty())\n        .collect();\n\n    let response = \"HTTP/1.1 200 OK\\r\\n\\r\\n\";\n    \n    stream.write_all(response.as_bytes()).unwrap();\n}\n\nListing 20-3: Writing a tiny successful HTTP response to the stream\nThe first new line defines the \"response\" variable that holds the success message’s data. Then we call \"as_bytes\" on our \"response\" to convert the string data to bytes. The \"write_all\" method on \"stream\" takes a \"&amp;[u8]\" and sends those bytes directly down the connection. Because the \"write_all\" operation could fail, we use \"unwrap\" on any error result as before. Again, in a real application you would add error handling here.\nWith these changes, let’s run our code and make a request. We’re no longer printing any data to the terminal, so we won’t see any output other than the output from Cargo. When you load 127.0.0.1:7878 in a web browser, you should get a blank page instead of an error. You’ve just hand-coded receiving an HTTP request and sending a response!\nReturning Real HTML\nLet’s implement the functionality for returning more than a blank page. Create the new file hello.html in the root of your project directory, not in the src directory. You can input any HTML you want; Listing 20-4 shows one possibility.\nFilename: hello.html\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;Hello!&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;Hello!&lt;/h1&gt;\n    &lt;p&gt;Hi from Rust&lt;/p&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n\nListing 20-4: A sample HTML file to return in a response\nThis is a minimal HTML5 document with a heading and some text. To return this from the server when a request is received, we’ll modify \"handle_connection\" as shown in Listing 20-5 to read the HTML file, add it to the response as a body, and send it.\nFilename: src/main.rs\nuse std::{\n    fs,\n    io::{prelude::*, BufReader},\n    net::{TcpListener, TcpStream},\n};\n// --snip--\n\nfn handle_connection(mut stream: TcpStream) {\n    let buf_reader = BufReader::new(&amp;mut stream);\n    let http_request: Vec&lt;_&gt; = buf_reader\n        .lines()\n        .map(|result| result.unwrap())\n        .take_while(|line| !line.is_empty())\n        .collect();\n\n    let status_line = \"HTTP/1.1 200 OK\";\n    let contents = fs::read_to_string(\"hello.html\").unwrap();\n    let length = contents.len();\n    \n    let response =\n        format!(\"{status_line}\\r\\nContent-Length: {length}\\r\\n\\r\\n{contents}\");\n    \n    stream.write_all(response.as_bytes()).unwrap();\n}\n\nListing 20-5: Sending the contents of hello.html as the body of the response\nWe’ve added \"fs\" to the \"use\" statement to bring the standard library’s filesystem module into scope. The code for reading the contents of a file to a string should look familiar; we used it in Chapter 12 when we read the contents of a file for our I/O project in Listing 12-4.\nNext, we use \"format!\" to add the file’s contents as the body of the success response. To ensure a valid HTTP response, we add the \"Content-Length\" header which is set to the size of our response body, in this case the size of \"hello.html\".\nRun this code with \"cargo run\" and load 127.0.0.1:7878 in your browser; you should see your HTML rendered!\nCurrently, we’re ignoring the request data in \"http_request\" and just sending back the contents of the HTML file unconditionally. That means if you try requesting 127.0.0.1:7878/something-else in your browser, you’ll still get back this same HTML response. At the moment, our server is very limited and does not do what most web servers do. We want to customize our responses depending on the request and only send back the HTML file for a well-formed request to /.\nValidating the Request and Selectively Responding\nRight now, our web server will return the HTML in the file no matter what the client requested. Let’s add functionality to check that the browser is requesting / before returning the HTML file and return an error if the browser requests anything else. For this we need to modify \"handle_connection\", as shown in Listing 20-6. This new code checks the content of the request received against what we know a request for / looks like and adds \"if\" and \"else\" blocks to treat requests differently.\nFilename: src/main.rs\n// --snip--\n\nfn handle_connection(mut stream: TcpStream) {\n    let buf_reader = BufReader::new(&amp;mut stream);\n    let request_line = buf_reader.lines().next().unwrap().unwrap();\n\n    if request_line == \"GET / HTTP/1.1\" {\n        let status_line = \"HTTP/1.1 200 OK\";\n        let contents = fs::read_to_string(\"hello.html\").unwrap();\n        let length = contents.len();\n    \n        let response = format!(\n            \"{status_line}\\r\\nContent-Length: {length}\\r\\n\\r\\n{contents}\"\n        );\n    \n        stream.write_all(response.as_bytes()).unwrap();\n    } else {\n        // some other request\n    }\n}\n\nListing 20-6: Handling requests to / differently from other requests\nWe’re only going to be looking at the first line of the HTTP request, so rather than reading the entire request into a vector, we’re calling \"next\" to get the first item from the iterator. The first \"unwrap\" takes care of the \"Option\" and stops the program if the iterator has no items. The second \"unwrap\" handles the \"Result\" and has the same effect as the \"unwrap\" that was in the \"map\" added in Listing 20-2.\nNext, we check the \"request_line\" to see if it equals the request line of a GET request to the / path. If it does, the \"if\" block returns the contents of our HTML file.\nIf the \"request_line\" does not equal the GET request to the / path, it means we’ve received some other request. We’ll add code to the \"else\" block in a moment to respond to all other requests.\nRun this code now and request 127.0.0.1:7878; you should get the HTML in hello.html. If you make any other request, such as 127.0.0.1:7878/something-else, you’ll get a connection error like those you saw when running the code in Listing 20-1 and Listing 20-2.\nNow let’s add the code in Listing 20-7 to the \"else\" block to return a response with the status code 404, which signals that the content for the request was not found. We’ll also return some HTML for a page to render in the browser indicating the response to the end user.\nFilename: src/main.rs\n    // --snip--\n    } else {\n        let status_line = \"HTTP/1.1 404 NOT FOUND\";\n        let contents = fs::read_to_string(\"404.html\").unwrap();\n        let length = contents.len();\n\n        let response = format!(\n            \"{status_line}\\r\\nContent-Length: {length}\\r\\n\\r\\n{contents}\"\n        );\n    \n        stream.write_all(response.as_bytes()).unwrap();\n    }\n\nListing 20-7: Responding with status code 404 and an error page if anything other than / was requested\nHere, our response has a status line with status code 404 and the reason phrase \"NOT FOUND\". The body of the response will be the HTML in the file 404.html. You’ll need to create a 404.html file next to hello.html for the error page; again feel free to use any HTML you want or use the example HTML in Listing 20-8.\nFilename: 404.html\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;Hello!&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;Oops!&lt;/h1&gt;\n    &lt;p&gt;Sorry, I don\"t know what you\"re asking for.&lt;/p&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n\nListing 20-8: Sample content for the page to send back with any 404 response\nWith these changes, run your server again. Requesting 127.0.0.1:7878 should return the contents of hello.html, and any other request, like 127.0.0.1:7878/foo, should return the error HTML from 404.html.\nA Touch of Refactoring\nAt the moment the \"if\" and \"else\" blocks have a lot of repetition: they’re both reading files and writing the contents of the files to the stream. The only differences are the status line and the filename. Let’s make the code more concise by pulling out those differences into separate \"if\" and \"else\" lines that will assign the values of the status line and the filename to variables; we can then use those variables unconditionally in the code to read the file and write the response. Listing 20-9 shows the resulting code after replacing the large \"if\" and \"else\" blocks.\nFilename: src/main.rs\n// --snip--\n\nfn handle_connection(mut stream: TcpStream) {\n    // --snip--\n\n    let (status_line, filename) = if request_line == \"GET / HTTP/1.1\" {\n        (\"HTTP/1.1 200 OK\", \"hello.html\")\n    } else {\n        (\"HTTP/1.1 404 NOT FOUND\", \"404.html\")\n    };\n    \n    let contents = fs::read_to_string(filename).unwrap();\n    let length = contents.len();\n    \n    let response =\n        format!(\"{status_line}\\r\\nContent-Length: {length}\\r\\n\\r\\n{contents}\");\n    \n    stream.write_all(response.as_bytes()).unwrap();\n}\n\nListing 20-9: Refactoring the \"if\" and \"else\" blocks to contain only the code that differs between the two cases\nNow the \"if\" and \"else\" blocks only return the appropriate values for the status line and filename in a tuple; we then use destructuring to assign these two values to \"status_line\" and \"filename\" using a pattern in the \"let\" statement, as discussed in Chapter 18.\nThe previously duplicated code is now outside the \"if\" and \"else\" blocks and uses the \"status_line\" and \"filename\" variables. This makes it easier to see the difference between the two cases, and it means we have only one place to update the code if we want to change how the file reading and response writing work. The behavior of the code in Listing 20-9 will be the same as that in Listing 20-8.\nAwesome! We now have a simple web server in approximately 40 lines of Rust code that responds to one request with a page of content and responds to all other requests with a 404 response.\nCurrently, our server runs in a single thread, meaning it can only serve one request at a time. Let’s examine how that can be a problem by simulating some slow requests. Then we’ll fix it so our server can handle multiple requests at once.\n\nTurning Our Single-Threaded Server into a Multithreaded Server\nRight now, the server will process each request in turn, meaning it won’t process a second connection until the first is finished processing. If the server received more and more requests, this serial execution would be less and less optimal. If the server receives a request that takes a long time to process, subsequent requests will have to wait until the long request is finished, even if the new requests can be processed quickly. We’ll need to fix this, but first, we’ll look at the problem in action.\nSimulating a Slow Request in the Current Server Implementation\nWe’ll look at how a slow-processing request can affect other requests made to our current server implementation. Listing 20-10 implements handling a request to /sleep with a simulated slow response that will cause the server to sleep for 5 seconds before responding.\nFilename: src/main.rs\nuse std::{\n    fs,\n    io::{prelude::*, BufReader},\n    net::{TcpListener, TcpStream},\n    thread,\n    time::Duration,\n};\n// --snip--\n\nfn handle_connection(mut stream: TcpStream) {\n    // --snip--\n\n    let (status_line, filename) = match &amp;request_line[..] {\n        \"GET / HTTP/1.1\" =&gt; (\"HTTP/1.1 200 OK\", \"hello.html\"),\n        \"GET /sleep HTTP/1.1\" =&gt; {\n            thread::sleep(Duration::from_secs(5));\n            (\"HTTP/1.1 200 OK\", \"hello.html\")\n        }\n        _ =&gt; (\"HTTP/1.1 404 NOT FOUND\", \"404.html\"),\n    };\n    \n    // --snip--\n}\n\nListing 20-10: Simulating a slow request by sleeping for 5 seconds\nWe switched from \"if\" to \"match\" now that we have three cases. We need to explicitly match on a slice of \"request_line\" to pattern match against the string literal values; \"match\" doesn’t do automatic referencing and dereferencing like the equality method does.\nThe first arm is the same as the \"if\" block from Listing 20-9. The second arm matches a request to /sleep. When that request is received, the server will sleep for 5 seconds before rendering the successful HTML page. The third arm is the same as the \"else\" block from Listing 20-9.\nYou can see how primitive our server is: real libraries would handle the recognition of multiple requests in a much less verbose way!\nStart the server using \"cargo run\". Then open two browser windows: one for http://127.0.0.1:7878/ and the other for http://127.0.0.1:7878/sleep. If you enter the / URI a few times, as before, you’ll see it respond quickly. But if you enter /sleep and then load /, you’ll see that / waits until \"sleep\" has slept for its full 5 seconds before loading.\nThere are multiple techniques we could use to avoid requests backing up behind a slow request; the one we’ll implement is a thread pool.\nImproving Throughput with a Thread Pool\nA thread pool is a group of spawned threads that are waiting and ready to handle a task. When the program receives a new task, it assigns one of the threads in the pool to the task, and that thread will process the task. The remaining threads in the pool are available to handle any other tasks that come in while the first thread is processing. When the first thread is done processing its task, it’s returned to the pool of idle threads, ready to handle a new task. A thread pool allows you to process connections concurrently, increasing the throughput of your server.\nWe’ll limit the number of threads in the pool to a small number to protect us from Denial of Service (DoS) attacks; if we had our program create a new thread for each request as it came in, someone making 10 million requests to our server could create havoc by using up all our server’s resources and grinding the processing of requests to a halt.\nRather than spawning unlimited threads, then, we’ll have a fixed number of threads waiting in the pool. Requests that come in are sent to the pool for processing. The pool will maintain a queue of incoming requests. Each of the threads in the pool will pop off a request from this queue, handle the request, and then ask the queue for another request. With this design, we can process up to \"N\" requests concurrently, where \"N\" is the number of threads. If each thread is responding to a long-running request, subsequent requests can still back up in the queue, but we’ve increased the number of long-running requests we can handle before reaching that point.\nThis technique is just one of many ways to improve the throughput of a web server. Other options you might explore are the fork/join model, the single-threaded async I/O model, or the multi-threaded async I/O model. If you’re interested in this topic, you can read more about other solutions and try to implement them; with a low-level language like Rust, all of these options are possible.\nBefore we begin implementing a thread pool, let’s talk about what using the pool should look like. When you’re trying to design code, writing the client interface first can help guide your design. Write the API of the code so it’s structured in the way you want to call it; then implement the functionality within that structure rather than implementing the functionality and then designing the public API.\nSimilar to how we used test-driven development in the project in Chapter 12, we’ll use compiler-driven development here. We’ll write the code that calls the functions we want, and then we’ll look at errors from the compiler to determine what we should change next to get the code to work. Before we do that, however, we’ll explore the technique we’re not going to use as a starting point.\nSpawning a Thread for Each Request\nFirst, let’s explore how our code might look if it did create a new thread for every connection. As mentioned earlier, this isn’t our final plan due to the problems with potentially spawning an unlimited number of threads, but it is a starting point to get a working multithreaded server first. Then we’ll add the thread pool as an improvement, and contrasting the two solutions will be easier. Listing 20-11 shows the changes to make to \"main\" to spawn a new thread to handle each stream within the \"for\" loop.\nFilename: src/main.rs\nfn main() {\n    let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n\n    for stream in listener.incoming() {\n        let stream = stream.unwrap();\n    \n        thread::spawn(|| {\n            handle_connection(stream);\n        });\n    }\n}\n\nListing 20-11: Spawning a new thread for each stream\nAs you learned in Chapter 16, \"thread::spawn\" will create a new thread and then run the code in the closure in the new thread. If you run this code and load /sleep in your browser, then / in two more browser tabs, you’ll indeed see that the requests to / don’t have to wait for /sleep to finish. However, as we mentioned, this will eventually overwhelm the system because you’d be making new threads without any limit.\nCreating a Finite Number of Threads\nWe want our thread pool to work in a similar, familiar way so switching from threads to a thread pool doesn’t require large changes to the code that uses our API. Listing 20-12 shows the hypothetical interface for a \"ThreadPool\" struct we want to use instead of \"thread::spawn\".\nFilename: src/main.rs\nfn main() {\n    let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n    let pool = ThreadPool::new(4);\n\n    for stream in listener.incoming() {\n        let stream = stream.unwrap();\n    \n        pool.execute(|| {\n            handle_connection(stream);\n        });\n    }\n}\n\nListing 20-12: Our ideal \"ThreadPool\" interface\nWe use \"ThreadPool::new\" to create a new thread pool with a configurable number of threads, in this case four. Then, in the \"for\" loop, \"pool.execute\" has a similar interface as \"thread::spawn\" in that it takes a closure the pool should run for each stream. We need to implement \"pool.execute\" so it takes the closure and gives it to a thread in the pool to run. This code won’t yet compile, but we’ll try so the compiler can guide us in how to fix it.\nBuilding \"ThreadPool\" Using Compiler Driven Development\nMake the changes in Listing 20-12 to src/main.rs, and then let’s use the compiler errors from \"cargo check\" to drive our development. Here is the first error we get:\n$ cargo check\n    Checking hello v0.1.0 (file:///projects/hello)\nerror[E0433]: failed to resolve: use of undeclared type \"ThreadPool\"\n  --&gt; src/main.rs:11:16\n   |\n11 |     let pool = ThreadPool::new(4);\n   |                ^^^^^^^^^^ use of undeclared type \"ThreadPool\"\n\nFor more information about this error, try \"rustc --explain E0433\".\nerror: could not compile \"hello\" due to previous error\n\nGreat! This error tells us we need a \"ThreadPool\" type or module, so we’ll build one now. Our \"ThreadPool\" implementation will be independent of the kind of work our web server is doing. So, let’s switch the \"hello\" crate from a binary crate to a library crate to hold our \"ThreadPool\" implementation. After we change to a library crate, we could also use the separate thread pool library for any work we want to do using a thread pool, not just for serving web requests.\nCreate a src/lib.rs that contains the following, which is the simplest definition of a \"ThreadPool\" struct that we can have for now:\nFilename: src/lib.rs\npub struct ThreadPool;\n\nThen edit main.rs file to bring \"ThreadPool\" into scope from the library crate by adding the following code to the top of src/main.rs:\nFilename: src/main.rs\nuse hello::ThreadPool;\n\nThis code still won’t work, but let’s check it again to get the next error that we need to address:\n$ cargo check\n    Checking hello v0.1.0 (file:///projects/hello)\nerror[E0599]: no function or associated item named \"new\" found for struct \"ThreadPool\" in the current scope\n  --&gt; src/main.rs:12:28\n   |\n12 |     let pool = ThreadPool::new(4);\n   |                            ^^^ function or associated item not found in \"ThreadPool\"\n\nFor more information about this error, try \"rustc --explain E0599\".\nerror: could not compile \"hello\" due to previous error\n\nThis error indicates that next we need to create an associated function named \"new\" for \"ThreadPool\". We also know that \"new\" needs to have one parameter that can accept \"4\" as an argument and should return a \"ThreadPool\" instance. Let’s implement the simplest \"new\" function that will have those characteristics:\nFilename: src/lib.rs\npub struct ThreadPool;\n\nimpl ThreadPool {\n    pub fn new(size: usize) -&gt; ThreadPool {\n        ThreadPool\n    }\n}\n\nWe chose \"usize\" as the type of the \"size\" parameter, because we know that a negative number of threads doesn’t make any sense. We also know we’ll use this 4 as the number of elements in a collection of threads, which is what the \"usize\" type is for, as discussed in the “Integer Types” section of Chapter 3.\nLet’s check the code again:\n$ cargo check\n    Checking hello v0.1.0 (file:///projects/hello)\nerror[E0599]: no method named \"execute\" found for struct \"ThreadPool\" in the current scope\n  --&gt; src/main.rs:17:14\n   |\n17 |         pool.execute(|| {\n   |              ^^^^^^^ method not found in \"ThreadPool\"\n\nFor more information about this error, try \"rustc --explain E0599\".\nerror: could not compile \"hello\" due to previous error\n\nNow the error occurs because we don’t have an \"execute\" method on \"ThreadPool\". Recall from the “Creating a Finite Number of Threads” section that we decided our thread pool should have an interface similar to \"thread::spawn\". In addition, we’ll implement the \"execute\" function so it takes the closure it’s given and gives it to an idle thread in the pool to run.\nWe’ll define the \"execute\" method on \"ThreadPool\" to take a closure as a parameter. Recall from the “Moving Captured Values Out of the Closure and the \"Fn\" Traits” section in Chapter 13 that we can take closures as parameters with three different traits: \"Fn\", \"FnMut\", and \"FnOnce\". We need to decide which kind of closure to use here. We know we’ll end up doing something similar to the standard library \"thread::spawn\" implementation, so we can look at what bounds the signature of \"thread::spawn\" has on its parameter. The documentation shows us the following:\npub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;\n    where\n        F: FnOnce() -&gt; T,\n        F: Send + \"static,\n        T: Send + \"static,\n\nThe \"F\" type parameter is the one we’re concerned with here; the \"T\" type parameter is related to the return value, and we’re not concerned with that. We can see that \"spawn\" uses \"FnOnce\" as the trait bound on \"F\". This is probably what we want as well, because we’ll eventually pass the argument we get in \"execute\" to \"spawn\". We can be further confident that \"FnOnce\" is the trait we want to use because the thread for running a request will only execute that request’s closure one time, which matches the \"Once\" in \"FnOnce\".\nThe \"F\" type parameter also has the trait bound \"Send\" and the lifetime bound \"\"static\", which are useful in our situation: we need \"Send\" to transfer the closure from one thread to another and \"\"static\" because we don’t know how long the thread will take to execute. Let’s create an \"execute\" method on \"ThreadPool\" that will take a generic parameter of type \"F\" with these bounds:\nFilename: src/lib.rs\nimpl ThreadPool {\n    // --snip--\n    pub fn execute&lt;F&gt;(&amp;self, f: F)\n    where\n        F: FnOnce() + Send + \"static,\n    {\n    }\n}\n\nWe still use the \"()\" after \"FnOnce\" because this \"FnOnce\" represents a closure that takes no parameters and returns the unit type \"()\". Just like function definitions, the return type can be omitted from the signature, but even if we have no parameters, we still need the parentheses.\nAgain, this is the simplest implementation of the \"execute\" method: it does nothing, but we’re trying only to make our code compile. Let’s check it again:\n$ cargo check\n    Checking hello v0.1.0 (file:///projects/hello)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.24s\n\nIt compiles! But note that if you try \"cargo run\" and make a request in the browser, you’ll see the errors in the browser that we saw at the beginning of the chapter. Our library isn’t actually calling the closure passed to \"execute\" yet!\n\nNote: A saying you might hear about languages with strict compilers, such as Haskell and Rust, is “if the code compiles, it works.” But this saying is not universally true. Our project compiles, but it does absolutely nothing! If we were building a real, complete project, this would be a good time to start writing unit tests to check that the code compiles and has the behavior we want.\n\nValidating the Number of Threads in \"new\"\nWe aren’t doing anything with the parameters to \"new\" and \"execute\". Let’s implement the bodies of these functions with the behavior we want. To start, let’s think about \"new\". Earlier we chose an unsigned type for the \"size\" parameter, because a pool with a negative number of threads makes no sense. However, a pool with zero threads also makes no sense, yet zero is a perfectly valid \"usize\". We’ll add code to check that \"size\" is greater than zero before we return a \"ThreadPool\" instance and have the program panic if it receives a zero by using the \"assert!\" macro, as shown in Listing 20-13.\nFilename: src/lib.rs\nimpl ThreadPool {\n    /// Create a new ThreadPool.\n    ///\n    /// The size is the number of threads in the pool.\n    ///\n    /// # Panics\n    ///\n    /// The \"new\" function will panic if the size is zero.\n    pub fn new(size: usize) -&gt; ThreadPool {\n        assert!(size &gt; 0);\n\n        ThreadPool\n    }\n    \n    // --snip--\n}\n\nListing 20-13: Implementing \"ThreadPool::new\" to panic if \"size\" is zero\nWe’ve also added some documentation for our \"ThreadPool\" with doc comments. Note that we followed good documentation practices by adding a section that calls out the situations in which our function can panic, as discussed in Chapter 14. Try running \"cargo doc --open\" and clicking the \"ThreadPool\" struct to see what the generated docs for \"new\" look like!\nInstead of adding the \"assert!\" macro as we’ve done here, we could change \"new\" into \"build\" and return a \"Result\" like we did with \"Config::build\" in the I/O project in Listing 12-9. But we’ve decided in this case that trying to create a thread pool without any threads should be an unrecoverable error. If you’re feeling ambitious, try to write a function named \"build\" with the following signature to compare with the \"new\" function:\npub fn build(size: usize) -&gt; Result&lt;ThreadPool, PoolCreationError&gt; {\n\nCreating Space to Store the Threads\nNow that we have a way to know we have a valid number of threads to store in the pool, we can create those threads and store them in the \"ThreadPool\" struct before returning the struct. But how do we “store” a thread? Let’s take another look at the \"thread::spawn\" signature:\npub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;\n    where\n        F: FnOnce() -&gt; T,\n        F: Send + \"static,\n        T: Send + \"static,\n\nThe \"spawn\" function returns a \"JoinHandle\", where \"T\" is the type that the closure returns. Let’s try using \"JoinHandle\" too and see what happens. In our case, the closures we’re passing to the thread pool will handle the connection and not return anything, so \"T\" will be the unit type \"()\".\nThe code in Listing 20-14 will compile but doesn’t create any threads yet. We’ve changed the definition of \"ThreadPool\" to hold a vector of \"thread::JoinHandle&lt;()&gt;\" instances, initialized the vector with a capacity of \"size\", set up a \"for\" loop that will run some code to create the threads, and returned a \"ThreadPool\" instance containing them.\nFilename: src/lib.rs\nuse std::thread;\n\npub struct ThreadPool {\n    threads: Vec&lt;thread::JoinHandle&lt;()&gt;&gt;,\n}\n\nimpl ThreadPool {\n    // --snip--\n    pub fn new(size: usize) -&gt; ThreadPool {\n        assert!(size &gt; 0);\n\n        let mut threads = Vec::with_capacity(size);\n    \n        for _ in 0..size {\n            // create some threads and store them in the vector\n        }\n    \n        ThreadPool { threads }\n    }\n    // --snip--\n}\n\nListing 20-14: Creating a vector for \"ThreadPool\" to hold the threads\nWe’ve brought \"std::thread\" into scope in the library crate, because we’re using \"thread::JoinHandle\" as the type of the items in the vector in \"ThreadPool\".\nOnce a valid size is received, our \"ThreadPool\" creates a new vector that can hold \"size\" items. The \"with_capacity\" function performs the same task as \"Vec::new\" but with an important difference: it preallocates space in the vector. Because we know we need to store \"size\" elements in the vector, doing this allocation up front is slightly more efficient than using \"Vec::new\", which resizes itself as elements are inserted.\nWhen you run \"cargo check\" again, it should succeed.\nA \"Worker\" Struct Responsible for Sending Code from the \"ThreadPool\" to a Thread\nWe left a comment in the \"for\" loop in Listing 20-14 regarding the creation of threads. Here, we’ll look at how we actually create threads. The standard library provides \"thread::spawn\" as a way to create threads, and \"thread::spawn\" expects to get some code the thread should run as soon as the thread is created. However, in our case, we want to create the threads and have them wait for code that we’ll send later. The standard library’s implementation of threads doesn’t include any way to do that; we have to implement it manually.\nWe’ll implement this behavior by introducing a new data structure between the \"ThreadPool\" and the threads that will manage this new behavior. We’ll call this data structure Worker, which is a common term in pooling implementations. The Worker picks up code that needs to be run and runs the code in the Worker’s thread. Think of people working in the kitchen at a restaurant: the workers wait until orders come in from customers, and then they’re responsible for taking those orders and fulfilling them.\nInstead of storing a vector of \"JoinHandle&lt;()&gt;\" instances in the thread pool, we’ll store instances of the \"Worker\" struct. Each \"Worker\" will store a single \"JoinHandle&lt;()&gt;\" instance. Then we’ll implement a method on \"Worker\" that will take a closure of code to run and send it to the already running thread for execution. We’ll also give each worker an \"id\" so we can distinguish between the different workers in the pool when logging or debugging.\nHere is the new process that will happen when we create a \"ThreadPool\". We’ll implement the code that sends the closure to the thread after we have \"Worker\" set up in this way:\n\nDefine a \"Worker\" struct that holds an \"id\" and a \"JoinHandle&lt;()&gt;\".\nChange \"ThreadPool\" to hold a vector of \"Worker\" instances.\nDefine a \"Worker::new\" function that takes an \"id\" number and returns a \"Worker\" instance that holds the \"id\" and a thread spawned with an empty closure.\nIn \"ThreadPool::new\", use the \"for\" loop counter to generate an \"id\", create a new \"Worker\" with that \"id\", and store the worker in the vector.\n\nIf you’re up for a challenge, try implementing these changes on your own before looking at the code in Listing 20-15.\nReady? Here is Listing 20-15 with one way to make the preceding modifications.\nFilename: src/lib.rs\nuse std::thread;\n\npub struct ThreadPool {\n    workers: Vec&lt;Worker&gt;,\n}\n\nimpl ThreadPool {\n    // --snip--\n    pub fn new(size: usize) -&gt; ThreadPool {\n        assert!(size &gt; 0);\n\n        let mut workers = Vec::with_capacity(size);\n    \n        for id in 0..size {\n            workers.push(Worker::new(id));\n        }\n    \n        ThreadPool { workers }\n    }\n    // --snip--\n}\n\nstruct Worker {\n    id: usize,\n    thread: thread::JoinHandle&lt;()&gt;,\n}\n\nimpl Worker {\n    fn new(id: usize) -&gt; Worker {\n        let thread = thread::spawn(|| {});\n\n        Worker { id, thread }\n    }\n}\n\nListing 20-15: Modifying \"ThreadPool\" to hold \"Worker\" instances instead of holding threads directly\nWe’ve changed the name of the field on \"ThreadPool\" from \"threads\" to \"workers\" because it’s now holding \"Worker\" instances instead of \"JoinHandle&lt;()&gt;\" instances. We use the counter in the \"for\" loop as an argument to \"Worker::new\", and we store each new \"Worker\" in the vector named \"workers\".\nExternal code (like our server in src/main.rs) doesn’t need to know the implementation details regarding using a \"Worker\" struct within \"ThreadPool\", so we make the \"Worker\" struct and its \"new\" function private. The \"Worker::new\" function uses the \"id\" we give it and stores a \"JoinHandle&lt;()&gt;\" instance that is created by spawning a new thread using an empty closure.\n\nNote: If the operating system can’t create a thread because there aren’t enough system resources, \"thread::spawn\" will panic. That will cause our whole server to panic, even though the creation of some threads might succeed. For simplicity’s sake, this behavior is fine, but in a production thread pool implementation, you’d likely want to use \"std:🧵:Builder\" and its \"spawn\" method that returns \"Result\" instead.\n\nThis code will compile and will store the number of \"Worker\" instances we specified as an argument to \"ThreadPool::new\". But we’re still not processing the closure that we get in \"execute\". Let’s look at how to do that next.\nSending Requests to Threads via Channels\nThe next problem we’ll tackle is that the closures given to \"thread::spawn\" do absolutely nothing. Currently, we get the closure we want to execute in the \"execute\" method. But we need to give \"thread::spawn\" a closure to run when we create each \"Worker\" during the creation of the \"ThreadPool\".\nWe want the \"Worker\" structs that we just created to fetch the code to run from a queue held in the \"ThreadPool\" and send that code to its thread to run.\nThe channels we learned about in Chapter 16—a simple way to communicate between two threads—would be perfect for this use case. We’ll use a channel to function as the queue of jobs, and \"execute\" will send a job from the \"ThreadPool\" to the \"Worker\" instances, which will send the job to its thread. Here is the plan:\n\nThe \"ThreadPool\" will create a channel and hold on to the sender.\nEach \"Worker\" will hold on to the receiver.\nWe’ll create a new \"Job\" struct that will hold the closures we want to send down the channel.\nThe \"execute\" method will send the job it wants to execute through the sender.\nIn its thread, the \"Worker\" will loop over its receiver and execute the closures of any jobs it receives.\n\nLet’s start by creating a channel in \"ThreadPool::new\" and holding the sender in the \"ThreadPool\" instance, as shown in Listing 20-16. The \"Job\" struct doesn’t hold anything for now but will be the type of item we’re sending down the channel.\nFilename: src/lib.rs\nuse std::{sync::mpsc, thread};\n\npub struct ThreadPool {\n    workers: Vec&lt;Worker&gt;,\n    sender: mpsc::Sender&lt;Job&gt;,\n}\n\nstruct Job;\n\nimpl ThreadPool {\n    // --snip--\n    pub fn new(size: usize) -&gt; ThreadPool {\n        assert!(size &gt; 0);\n\n        let (sender, receiver) = mpsc::channel();\n    \n        let mut workers = Vec::with_capacity(size);\n    \n        for id in 0..size {\n            workers.push(Worker::new(id));\n        }\n    \n        ThreadPool { workers, sender }\n    }\n    // --snip--\n}\n\nListing 20-16: Modifying \"ThreadPool\" to store the sender of a channel that transmits \"Job\" instances\nIn \"ThreadPool::new\", we create our new channel and have the pool hold the sender. This will successfully compile.\nLet’s try passing a receiver of the channel into each worker as the thread pool creates the channel. We know we want to use the receiver in the thread that the workers spawn, so we’ll reference the \"receiver\" parameter in the closure. The code in Listing 20-17 won’t quite compile yet.\nFilename: src/lib.rs\nimpl ThreadPool {\n    // --snip--\n    pub fn new(size: usize) -&gt; ThreadPool {\n        assert!(size &gt; 0);\n\n        let (sender, receiver) = mpsc::channel();\n    \n        let mut workers = Vec::with_capacity(size);\n    \n        for id in 0..size {\n            workers.push(Worker::new(id, receiver));\n        }\n    \n        ThreadPool { workers, sender }\n    }\n    // --snip--\n}\n\n// --snip--\n\nimpl Worker {\n    fn new(id: usize, receiver: mpsc::Receiver&lt;Job&gt;) -&gt; Worker {\n        let thread = thread::spawn(|| {\n            receiver;\n        });\n\n        Worker { id, thread }\n    }\n}\n\nListing 20-17: Passing the receiver to the workers\nWe’ve made some small and straightforward changes: we pass the receiver into \"Worker::new\", and then we use it inside the closure.\nWhen we try to check this code, we get this error:\n$ cargo check\n    Checking hello v0.1.0 (file:///projects/hello)\nerror[E0382]: use of moved value: \"receiver\"\n  --&gt; src/lib.rs:26:42\n   |\n21 |         let (sender, receiver) = mpsc::channel();\n   |                      -------- move occurs because \"receiver\" has type \"std::sync::mpsc::Receiver&lt;Job&gt;\", which does not implement the \"Copy\" trait\n...\n26 |             workers.push(Worker::new(id, receiver));\n   |                                          ^^^^^^^^ value moved here, in previous iteration of loop\n\nFor more information about this error, try \"rustc --explain E0382\".\nerror: could not compile \"hello\" due to previous error\n\nThe code is trying to pass \"receiver\" to multiple \"Worker\" instances. This won’t work, as you’ll recall from Chapter 16: the channel implementation that Rust provides is multiple producer, single consumer. This means we can’t just clone the consuming end of the channel to fix this code. We also don’t want to send a message multiple times to multiple consumers; we want one list of messages with multiple workers such that each message gets processed once.\nAdditionally, taking a job off the channel queue involves mutating the \"receiver\", so the threads need a safe way to share and modify \"receiver\"; otherwise, we might get race conditions (as covered in Chapter 16).\nRecall the thread-safe smart pointers discussed in Chapter 16: to share ownership across multiple threads and allow the threads to mutate the value, we need to use \"Arc&lt;Mutex&gt;\". The \"Arc\" type will let multiple workers own the receiver, and \"Mutex\" will ensure that only one worker gets a job from the receiver at a time. Listing 20-18 shows the changes we need to make.\nFilename: src/lib.rs\nuse std::{\n    sync::{mpsc, Arc, Mutex},\n    thread,\n};\n// --snip--\n\nimpl ThreadPool {\n    // --snip--\n    pub fn new(size: usize) -&gt; ThreadPool {\n        assert!(size &gt; 0);\n\n        let (sender, receiver) = mpsc::channel();\n    \n        let receiver = Arc::new(Mutex::new(receiver));\n    \n        let mut workers = Vec::with_capacity(size);\n    \n        for id in 0..size {\n            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));\n        }\n    \n        ThreadPool { workers, sender }\n    }\n    \n    // --snip--\n}\n\n// --snip--\n\nimpl Worker {\n    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {\n        // --snip--\n    }\n}\n\nListing 20-18: Sharing the receiver among the workers using \"Arc\" and \"Mutex\"\nIn \"ThreadPool::new\", we put the receiver in an \"Arc\" and a \"Mutex\". For each new worker, we clone the \"Arc\" to bump the reference count so the workers can share ownership of the receiver.\nWith these changes, the code compiles! We’re getting there!\nImplementing the \"execute\" Method\nLet’s finally implement the \"execute\" method on \"ThreadPool\". We’ll also change \"Job\" from a struct to a type alias for a trait object that holds the type of closure that \"execute\" receives. As discussed in the “Creating Type Synonyms with Type Aliases” section of Chapter 19, type aliases allow us to make long types shorter for ease of use. Look at Listing 20-19.\nFilename: src/lib.rs\n// --snip--\n\ntype Job = Box&lt;dyn FnOnce() + Send + \"static&gt;;\n\nimpl ThreadPool {\n    // --snip--\n\n    pub fn execute&lt;F&gt;(&amp;self, f: F)\n    where\n        F: FnOnce() + Send + \"static,\n    {\n        let job = Box::new(f);\n    \n        self.sender.send(job).unwrap();\n    }\n}\n\n// --snip--\n\nListing 20-19: Creating a \"Job\" type alias for a \"Box\" that holds each closure and then sending the job down the channel\nAfter creating a new \"Job\" instance using the closure we get in \"execute\", we send that job down the sending end of the channel. We’re calling \"unwrap\" on \"send\" for the case that sending fails. This might happen if, for example, we stop all our threads from executing, meaning the receiving end has stopped receiving new messages. At the moment, we can’t stop our threads from executing: our threads continue executing as long as the pool exists. The reason we use \"unwrap\" is that we know the failure case won’t happen, but the compiler doesn’t know that.\nBut we’re not quite done yet! In the worker, our closure being passed to \"thread::spawn\" still only references the receiving end of the channel. Instead, we need the closure to loop forever, asking the receiving end of the channel for a job and running the job when it gets one. Let’s make the change shown in Listing 20-20 to \"Worker::new\".\nFilename: src/lib.rs\n// --snip--\n\nimpl Worker {\n    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {\n        let thread = thread::spawn(move || loop {\n            let job = receiver.lock().unwrap().recv().unwrap();\n\n            println!(\"Worker {id} got a job; executing.\");\n    \n            job();\n        });\n    \n        Worker { id, thread }\n    }\n}\n\nListing 20-20: Receiving and executing the jobs in the worker’s thread\nHere, we first call \"lock\" on the \"receiver\" to acquire the mutex, and then we call \"unwrap\" to panic on any errors. Acquiring a lock might fail if the mutex is in a poisoned state, which can happen if some other thread panicked while holding the lock rather than releasing the lock. In this situation, calling \"unwrap\" to have this thread panic is the correct action to take. Feel free to change this \"unwrap\" to an \"expect\" with an error message that is meaningful to you.\nIf we get the lock on the mutex, we call \"recv\" to receive a \"Job\" from the channel. A final \"unwrap\" moves past any errors here as well, which might occur if the thread holding the sender has shut down, similar to how the \"send\" method returns \"Err\" if the receiver shuts down.\nThe call to \"recv\" blocks, so if there is no job yet, the current thread will wait until a job becomes available. The \"Mutex\" ensures that only one \"Worker\" thread at a time is trying to request a job.\nOur thread pool is now in a working state! Give it a \"cargo run\" and make some requests:\n$ cargo run\n   Compiling hello v0.1.0 (file:///projects/hello)\nwarning: field is never read: \"workers\"\n --&gt; src/lib.rs:7:5\n  |\n7 |     workers: Vec&lt;Worker&gt;,\n  |     ^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: \"#[warn(dead_code)]\" on by default\n\nwarning: field is never read: \"id\"\n  --&gt; src/lib.rs:48:5\n   |\n48 |     id: usize,\n   |     ^^^^^^^^^\n\nwarning: field is never read: \"thread\"\n  --&gt; src/lib.rs:49:5\n   |\n49 |     thread: thread::JoinHandle&lt;()&gt;,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: \"hello\" (lib) generated 3 warnings\n    Finished dev [unoptimized + debuginfo] target(s) in 1.40s\n     Running \"target/debug/hello\"\nWorker 0 got a job; executing.\nWorker 2 got a job; executing.\nWorker 1 got a job; executing.\nWorker 3 got a job; executing.\nWorker 0 got a job; executing.\nWorker 2 got a job; executing.\nWorker 1 got a job; executing.\nWorker 3 got a job; executing.\nWorker 0 got a job; executing.\nWorker 2 got a job; executing.\n\nSuccess! We now have a thread pool that executes connections asynchronously. There are never more than four threads created, so our system won’t get overloaded if the server receives a lot of requests. If we make a request to /sleep, the server will be able to serve other requests by having another thread run them.\n\nNote: if you open /sleep in multiple browser windows simultaneously, they might load one at a time in 5 second intervals. Some web browsers execute multiple instances of the same request sequentially for caching reasons. This limitation is not caused by our web server.\n\nAfter learning about the \"while let\" loop in Chapter 18, you might be wondering why we didn’t write the worker thread code as shown in Listing 20-21.\nFilename: src/lib.rs\n// --snip--\n\nimpl Worker {\n    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {\n        let thread = thread::spawn(move || {\n            while let Ok(job) = receiver.lock().unwrap().recv() {\n                println!(\"Worker {id} got a job; executing.\");\n\n                job();\n            }\n        });\n    \n        Worker { id, thread }\n    }\n}\n\nListing 20-21: An alternative implementation of \"Worker::new\" using \"while let\"\nThis code compiles and runs but doesn’t result in the desired threading behavior: a slow request will still cause other requests to wait to be processed. The reason is somewhat subtle: the \"Mutex\" struct has no public \"unlock\" method because the ownership of the lock is based on the lifetime of the \"MutexGuard\" within the \"LockResult&lt;MutexGuard&gt;\" that the \"lock\" method returns. At compile time, the borrow checker can then enforce the rule that a resource guarded by a \"Mutex\" cannot be accessed unless we hold the lock. However, this implementation can also result in the lock being held longer than intended if we aren’t mindful of the lifetime of the \"MutexGuard\".\nThe code in Listing 20-20 that uses \"let job = receiver.lock().unwrap().recv().unwrap();\" works because with \"let\", any temporary values used in the expression on the right hand side of the equals sign are immediately dropped when the \"let\" statement ends. However, \"while let\" (and \"if let\" and \"match\") does not drop temporary values until the end of the associated block. In Listing 20-21, the lock remains held for the duration of the call to \"job()\", meaning other workers cannot receive jobs.\n\nGraceful Shutdown and Cleanup\nThe code in Listing 20-20 is responding to requests asynchronously through the use of a thread pool, as we intended. We get some warnings about the \"workers\", \"id\", and \"thread\" fields that we’re not using in a direct way that reminds us we’re not cleaning up anything. When we use the less elegant ctrl-c method to halt the main thread, all other threads are stopped immediately as well, even if they’re in the middle of serving a request.\nNext, then, we’ll implement the \"Drop\" trait to call \"join\" on each of the threads in the pool so they can finish the requests they’re working on before closing. Then we’ll implement a way to tell the threads they should stop accepting new requests and shut down. To see this code in action, we’ll modify our server to accept only two requests before gracefully shutting down its thread pool.\nImplementing the \"Drop\" Trait on \"ThreadPool\"\nLet’s start with implementing \"Drop\" on our thread pool. When the pool is dropped, our threads should all join to make sure they finish their work. Listing 20-22 shows a first attempt at a \"Drop\" implementation; this code won’t quite work yet.\nFilename: src/lib.rs\nimpl Drop for ThreadPool {\n    fn drop(&amp;mut self) {\n        for worker in &amp;mut self.workers {\n            println!(\"Shutting down worker {}\", worker.id);\n\n            worker.thread.join().unwrap();\n        }\n    }\n}\n\nListing 20-22: Joining each thread when the thread pool goes out of scope\nFirst, we loop through each of the thread pool \"workers\". We use \"&amp;mut\" for this because \"self\" is a mutable reference, and we also need to be able to mutate \"worker\". For each worker, we print a message saying that this particular worker is shutting down, and then we call \"join\" on that worker’s thread. If the call to \"join\" fails, we use \"unwrap\" to make Rust panic and go into an ungraceful shutdown.\nHere is the error we get when we compile this code:\n$ cargo check\n    Checking hello v0.1.0 (file:///projects/hello)\nerror[E0507]: cannot move out of \"worker.thread\" which is behind a mutable reference\n  --&gt; src/lib.rs:52:13\n   |\n52 |             worker.thread.join().unwrap();\n   |             ^^^^^^^^^^^^^ ------ \"worker.thread\" moved due to this method call\n   |             |\n   |             move occurs because \"worker.thread\" has type \"JoinHandle&lt;()&gt;\", which does not implement the \"Copy\" trait\n   |\nnote: this function takes ownership of the receiver \"self\", which moves \"worker.thread\"\n  --&gt; /rustc/d5a82bbd26e1ad8b7401f6a718a9c57c96905483/library/std/src/thread/mod.rs:1581:17\n\nFor more information about this error, try \"rustc --explain E0507\".\nerror: could not compile \"hello\" due to previous error\n\nThe error tells us we can’t call \"join\" because we only have a mutable borrow of each \"worker\" and \"join\" takes ownership of its argument. To solve this issue, we need to move the thread out of the \"Worker\" instance that owns \"thread\" so \"join\" can consume the thread. We did this in Listing 17-15: if \"Worker\" holds an \"Option&lt;thread::JoinHandle&lt;()&gt;&gt;\" instead, we can call the \"take\" method on the \"Option\" to move the value out of the \"Some\" variant and leave a \"None\" variant in its place. In other words, a \"Worker\" that is running will have a \"Some\" variant in \"thread\", and when we want to clean up a \"Worker\", we’ll replace \"Some\" with \"None\" so the \"Worker\" doesn’t have a thread to run.\nSo we know we want to update the definition of \"Worker\" like this:\nFilename: src/lib.rs\nstruct Worker {\n    id: usize,\n    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,\n}\n\nNow let’s lean on the compiler to find the other places that need to change. Checking this code, we get two errors:\n$ cargo check\n    Checking hello v0.1.0 (file:///projects/hello)\nerror[E0599]: no method named \"join\" found for enum \"Option\" in the current scope\n  --&gt; src/lib.rs:52:27\n   |\n52 |             worker.thread.join().unwrap();\n   |                           ^^^^ method not found in \"Option&lt;JoinHandle&lt;()&gt;&gt;\"\n   |\nnote: the method \"join\" exists on the type \"JoinHandle&lt;()&gt;\"\n  --&gt; /rustc/d5a82bbd26e1ad8b7401f6a718a9c57c96905483/library/std/src/thread/mod.rs:1581:5\nhelp: consider using \"Option::expect\" to unwrap the \"JoinHandle&lt;()&gt;\" value, panicking if the value is an \"Option::None\"\n   |\n52 |             worker.thread.expect(\"REASON\").join().unwrap();\n   |                          +++++++++++++++++\n\nerror[E0308]: mismatched types\n  --&gt; src/lib.rs:72:22\n   |\n72 |         Worker { id, thread }\n   |                      ^^^^^^ expected enum \"Option\", found struct \"JoinHandle\"\n   |\n   = note: expected enum \"Option&lt;JoinHandle&lt;()&gt;&gt;\"\n            found struct \"JoinHandle&lt;_&gt;\"\nhelp: try wrapping the expression in \"Some\"\n   |\n72 |         Worker { id, thread: Some(thread) }\n   |                      +++++++++++++      +\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try \"rustc --explain E0308\".\nerror: could not compile \"hello\" due to 2 previous errors\n\nLet’s address the second error, which points to the code at the end of \"Worker::new\"; we need to wrap the \"thread\" value in \"Some\" when we create a new \"Worker\". Make the following changes to fix this error:\nFilename: src/lib.rs\nimpl Worker {\n    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {\n        // --snip--\n\n        Worker {\n            id,\n            thread: Some(thread),\n        }\n    }\n}\n\nThe first error is in our \"Drop\" implementation. We mentioned earlier that we intended to call \"take\" on the \"Option\" value to move \"thread\" out of \"worker\". The following changes will do so:\nFilename: src/lib.rs\nimpl Drop for ThreadPool {\n    fn drop(&amp;mut self) {\n        for worker in &amp;mut self.workers {\n            println!(\"Shutting down worker {}\", worker.id);\n\n            if let Some(thread) = worker.thread.take() {\n                thread.join().unwrap();\n            }\n        }\n    }\n}\n\nAs discussed in Chapter 17, the \"take\" method on \"Option\" takes the \"Some\" variant out and leaves \"None\" in its place. We’re using \"if let\" to destructure the \"Some\" and get the thread; then we call \"join\" on the thread. If a worker’s thread is already \"None\", we know that worker has already had its thread cleaned up, so nothing happens in that case.\nSignaling to the Threads to Stop Listening for Jobs\nWith all the changes we’ve made, our code compiles without any warnings. However, the bad news is this code doesn’t function the way we want it to yet. The key is the logic in the closures run by the threads of the \"Worker\" instances: at the moment, we call \"join\", but that won’t shut down the threads because they \"loop\" forever looking for jobs. If we try to drop our \"ThreadPool\" with our current implementation of \"drop\", the main thread will block forever waiting for the first thread to finish.\nTo fix this problem, we’ll need a change in the \"ThreadPool\" \"drop\" implementation and then a change in the \"Worker\" loop.\nFirst, we’ll change the \"ThreadPool\" \"drop\" implementation to explicitly drop the \"sender\" before waiting for the threads to finish. Listing 20-23 shows the changes to \"ThreadPool\" to explicitly drop \"sender\". We use the same \"Option\" and \"take\" technique as we did with the thread to be able to move \"sender\" out of \"ThreadPool\":\nFilename: src/lib.rs\npub struct ThreadPool {\n    workers: Vec&lt;Worker&gt;,\n    sender: Option&lt;mpsc::Sender&lt;Job&gt;&gt;,\n}\n// --snip--\nimpl ThreadPool {\n    pub fn new(size: usize) -&gt; ThreadPool {\n        // --snip--\n\n        ThreadPool {\n            workers,\n            sender: Some(sender),\n        }\n    }\n    \n    pub fn execute&lt;F&gt;(&amp;self, f: F)\n    where\n        F: FnOnce() + Send + \"static,\n    {\n        let job = Box::new(f);\n    \n        self.sender.as_ref().unwrap().send(job).unwrap();\n    }\n}\n\nimpl Drop for ThreadPool {\n    fn drop(&amp;mut self) {\n        drop(self.sender.take());\n\n        for worker in &amp;mut self.workers {\n            println!(\"Shutting down worker {}\", worker.id);\n    \n            if let Some(thread) = worker.thread.take() {\n                thread.join().unwrap();\n            }\n        }\n    }\n}\n\nListing 20-23: Explicitly drop \"sender\" before joining the worker threads\nDropping \"sender\" closes the channel, which indicates no more messages will be sent. When that happens, all the calls to \"recv\" that the workers do in the infinite loop will return an error. In Listing 20-24, we change the \"Worker\" loop to gracefully exit the loop in that case, which means the threads will finish when the \"ThreadPool\" \"drop\" implementation calls \"join\" on them.\nFilename: src/lib.rs\nimpl Worker {\n    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {\n        let thread = thread::spawn(move || loop {\n            let message = receiver.lock().unwrap().recv();\n\n            match message {\n                Ok(job) =&gt; {\n                    println!(\"Worker {id} got a job; executing.\");\n    \n                    job();\n                }\n                Err(_) =&gt; {\n                    println!(\"Worker {id} disconnected; shutting down.\");\n                    break;\n                }\n            }\n        });\n    \n        Worker {\n            id,\n            thread: Some(thread),\n        }\n    }\n}\n\nListing 20-24: Explicitly break out of the loop when \"recv\" returns an error\nTo see this code in action, let’s modify \"main\" to accept only two requests before gracefully shutting down the server, as shown in Listing 20-25.\nFilename: src/main.rs\nfn main() {\n    let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n    let pool = ThreadPool::new(4);\n\n    for stream in listener.incoming().take(2) {\n        let stream = stream.unwrap();\n    \n        pool.execute(|| {\n            handle_connection(stream);\n        });\n    }\n    \n    println!(\"Shutting down.\");\n}\n\nListing 20-25: Shut down the server after serving two requests by exiting the loop\nYou wouldn’t want a real-world web server to shut down after serving only two requests. This code just demonstrates that the graceful shutdown and cleanup is in working order.\nThe \"take\" method is defined in the \"Iterator\" trait and limits the iteration to the first two items at most. The \"ThreadPool\" will go out of scope at the end of \"main\", and the \"drop\" implementation will run.\nStart the server with \"cargo run\", and make three requests. The third request should error, and in your terminal you should see output similar to this:\n$ cargo run\n   Compiling hello v0.1.0 (file:///projects/hello)\n    Finished dev [unoptimized + debuginfo] target(s) in 1.0s\n     Running \"target/debug/hello\"\nWorker 0 got a job; executing.\nShutting down.\nShutting down worker 0\nWorker 3 got a job; executing.\nWorker 1 disconnected; shutting down.\nWorker 2 disconnected; shutting down.\nWorker 3 disconnected; shutting down.\nWorker 0 disconnected; shutting down.\nShutting down worker 1\nShutting down worker 2\nShutting down worker 3\n\nYou might see a different ordering of workers and messages printed. We can see how this code works from the messages: workers 0 and 3 got the first two requests. The server stopped accepting connections after the second connection, and the \"Drop\" implementation on \"ThreadPool\" starts executing before worker 3 even starts its job. Dropping the \"sender\" disconnects all the workers and tells them to shut down. The workers each print a message when they disconnect, and then the thread pool calls \"join\" to wait for each worker thread to finish.\nNotice one interesting aspect of this particular execution: the \"ThreadPool\" dropped the \"sender\", and before any worker received an error, we tried to join worker 0. Worker 0 had not yet gotten an error from \"recv\", so the main thread blocked waiting for worker 0 to finish. In the meantime, worker 3 received a job and then all threads received an error. When worker 0 finished, the main thread waited for the rest of the workers to finish. At that point, they had all exited their loops and stopped.\nCongrats! We’ve now completed our project; we have a basic web server that uses a thread pool to respond asynchronously. We’re able to perform a graceful shutdown of the server, which cleans up all the threads in the pool.\nHere’s the full code for reference:\nFilename: src/main.rs\nuse hello::ThreadPool;\nuse std::fs;\nuse std::io::prelude::*;\nuse std::net::TcpListener;\nuse std::net::TcpStream;\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    let listener = TcpListener::bind(\"127.0.0.1:7878\").unwrap();\n    let pool = ThreadPool::new(4);\n\n    for stream in listener.incoming().take(2) {\n        let stream = stream.unwrap();\n    \n        pool.execute(|| {\n            handle_connection(stream);\n        });\n    }\n    \n    println!(\"Shutting down.\");\n}\n\nfn handle_connection(mut stream: TcpStream) {\n    let mut buffer = [0; 1024];\n    stream.read(&amp;mut buffer).unwrap();\n\n    let get = b\"GET / HTTP/1.1\\r\\n\";\n    let sleep = b\"GET /sleep HTTP/1.1\\r\\n\";\n    \n    let (status_line, filename) = if buffer.starts_with(get) {\n        (\"HTTP/1.1 200 OK\", \"hello.html\")\n    } else if buffer.starts_with(sleep) {\n        thread::sleep(Duration::from_secs(5));\n        (\"HTTP/1.1 200 OK\", \"hello.html\")\n    } else {\n        (\"HTTP/1.1 404 NOT FOUND\", \"404.html\")\n    };\n    \n    let contents = fs::read_to_string(filename).unwrap();\n    \n    let response = format!(\n        \"{}\\r\\nContent-Length: {}\\r\\n\\r\\n{}\",\n        status_line,\n        contents.len(),\n        contents\n    );\n    \n    stream.write_all(response.as_bytes()).unwrap();\n    stream.flush().unwrap();\n}\n\nFilename: src/lib.rs\nuse std::{\n    sync::{mpsc, Arc, Mutex},\n    thread,\n};\n\npub struct ThreadPool {\n    workers: Vec&lt;Worker&gt;,\n    sender: Option&lt;mpsc::Sender&lt;Job&gt;&gt;,\n}\n\ntype Job = Box&lt;dyn FnOnce() + Send + \"static&gt;;\n\nimpl ThreadPool {\n    /// Create a new ThreadPool.\n    ///\n    /// The size is the number of threads in the pool.\n    ///\n    /// # Panics\n    ///\n    /// The \"new\" function will panic if the size is zero.\n    pub fn new(size: usize) -&gt; ThreadPool {\n        assert!(size &gt; 0);\n\n        let (sender, receiver) = mpsc::channel();\n    \n        let receiver = Arc::new(Mutex::new(receiver));\n    \n        let mut workers = Vec::with_capacity(size);\n    \n        for id in 0..size {\n            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));\n        }\n    \n        ThreadPool {\n            workers,\n            sender: Some(sender),\n        }\n    }\n    \n    pub fn execute&lt;F&gt;(&amp;self, f: F)\n    where\n        F: FnOnce() + Send + \"static,\n    {\n        let job = Box::new(f);\n    \n        self.sender.as_ref().unwrap().send(job).unwrap();\n    }\n}\n\nimpl Drop for ThreadPool {\n    fn drop(&amp;mut self) {\n        drop(self.sender.take());\n\n        for worker in &amp;mut self.workers {\n            println!(\"Shutting down worker {}\", worker.id);\n    \n            if let Some(thread) = worker.thread.take() {\n                thread.join().unwrap();\n            }\n        }\n    }\n}\n\nstruct Worker {\n    id: usize,\n    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,\n}\n\nimpl Worker {\n    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {\n        let thread = thread::spawn(move || loop {\n            let message = receiver.lock().unwrap().recv();\n\n            match message {\n                Ok(job) =&gt; {\n                    println!(\"Worker {id} got a job; executing.\");\n    \n                    job();\n                }\n                Err(_) =&gt; {\n                    println!(\"Worker {id} disconnected; shutting down.\");\n                    break;\n                }\n            }\n        });\n    \n        Worker {\n            id,\n            thread: Some(thread),\n        }\n    }\n}\n\nWe could do more here! If you want to continue enhancing this project, here are some ideas:\n\nAdd more documentation to \"ThreadPool\" and its public methods.\nAdd tests of the library’s functionality.\nChange calls to \"unwrap\" to more robust error handling.\nUse \"ThreadPool\" to perform some task other than serving web requests.\nFind a thread pool crate on crates.io and implement a similar web server using the crate instead. Then compare its API and robustness to the thread pool we implemented.\n\nSummary\nWell done! You’ve made it to the end of the book! We want to thank you for joining us on this tour of Rust. You’re now ready to implement your own Rust projects and help with other peoples’ projects. Keep in mind that there is a welcoming community of other Rustaceans who would love to help you with any challenges you encounter on your Rust journey.\n\nAppendix\nThe following sections contain reference material you may find useful in your Rust journey.\n\nAppendix A: Keywords\nThe following list contains keywords that are reserved for current or future use by the Rust language. As such, they cannot be used as identifiers (except as raw identifiers as we’ll discuss in the “Raw Identifiers” section). Identifiers are names of functions, variables, parameters, struct fields, modules, crates, constants, macros, static values, attributes, types, traits, or lifetimes.\nKeywords Currently in Use\nThe following is a list of keywords currently in use, with their functionality described.\n\n\"as\" - perform primitive casting, disambiguate the specific trait containing an item, or rename items in \"use\" statements\n\"async\" - return a \"Future\" instead of blocking the current thread\n\"await\" - suspend execution until the result of a \"Future\" is ready\n\"break\" - exit a loop immediately\n\"const\" - define constant items or constant raw pointers\n\"continue\" - continue to the next loop iteration\n\"crate\" - in a module path, refers to the crate root\n\"dyn\" - dynamic dispatch to a trait object\n\"else\" - fallback for \"if\" and \"if let\" control flow constructs\n\"enum\" - define an enumeration\n\"extern\" - link an external function or variable\n\"false\" - Boolean false literal\n\"fn\" - define a function or the function pointer type\n\"for\" - loop over items from an iterator, implement a trait, or specify a higher-ranked lifetime\n\"if\" - branch based on the result of a conditional expression\n\"impl\" - implement inherent or trait functionality\n\"in\" - part of \"for\" loop syntax\n\"let\" - bind a variable\n\"loop\" - loop unconditionally\n\"match\" - match a value to patterns\n\"mod\" - define a module\n\"move\" - make a closure take ownership of all its captures\n\"mut\" - denote mutability in references, raw pointers, or pattern bindings\n\"pub\" - denote public visibility in struct fields, \"impl\" blocks, or modules\n\"ref\" - bind by reference\n\"return\" - return from function\n\"Self\" - a type alias for the type we are defining or implementing\n\"self\" - method subject or current module\n\"static\" - global variable or lifetime lasting the entire program execution\n\"struct\" - define a structure\n\"super\" - parent module of the current module\n\"trait\" - define a trait\n\"true\" - Boolean true literal\n\"type\" - define a type alias or associated type\n\"union\" - define a union; is only a keyword when used in a union declaration\n\"unsafe\" - denote unsafe code, functions, traits, or implementations\n\"use\" - bring symbols into scope\n\"where\" - denote clauses that constrain a type\n\"while\" - loop conditionally based on the result of an expression\n\nKeywords Reserved for Future Use\nThe following keywords do not yet have any functionality but are reserved by Rust for potential future use.\n\n\"abstract\"\n\"become\"\n\"box\"\n\"do\"\n\"final\"\n\"macro\"\n\"override\"\n\"priv\"\n\"try\"\n\"typeof\"\n\"unsized\"\n\"virtual\"\n\"yield\"\n\nRaw Identifiers\nRaw identifiers are the syntax that lets you use keywords where they wouldn’t normally be allowed. You use a raw identifier by prefixing a keyword with \"r#\".\nFor example, \"match\" is a keyword. If you try to compile the following function that uses \"match\" as its name:\nFilename: src/main.rs\nfn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {\n    haystack.contains(needle)\n}\n\nyou’ll get this error:\nerror: expected identifier, found keyword \"match\"\n --&gt; src/main.rs:4:4\n  |\n4 | fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {\n  |    ^^^^^ expected identifier, found keyword\n\nThe error shows that you can’t use the keyword \"match\" as the function identifier. To use \"match\" as a function name, you need to use the raw identifier syntax, like this:\nFilename: src/main.rs\nfn r#match(needle: &amp;str, haystack: &amp;str) -&gt; bool {\n    haystack.contains(needle)\n}\n\nfn main() {\n    assert!(r#match(\"foo\", \"foobar\"));\n}\n\nThis code will compile without any errors. Note the \"r#\" prefix on the function name in its definition as well as where the function is called in \"main\".\nRaw identifiers allow you to use any word you choose as an identifier, even if that word happens to be a reserved keyword. This gives us more freedom to choose identifier names, as well as lets us integrate with programs written in a language where these words aren’t keywords. In addition, raw identifiers allow you to use libraries written in a different Rust edition than your crate uses. For example, \"try\" isn’t a keyword in the 2015 edition but is in the 2018 edition. If you depend on a library that’s written using the 2015 edition and has a \"try\" function, you’ll need to use the raw identifier syntax, \"r#try\" in this case, to call that function from your 2018 edition code. See Appendix E for more information on editions.\n\nAppendix B: Operators and Symbols\nThis appendix contains a glossary of Rust’s syntax, including operators and other symbols that appear by themselves or in the context of paths, generics, trait bounds, macros, attributes, comments, tuples, and brackets.\nOperators\nTable B-1 contains the operators in Rust, an example of how the operator would appear in context, a short explanation, and whether that operator is overloadable. If an operator is overloadable, the relevant trait to use to overload that operator is listed.\nTable B-1: Operators\nOperatorExampleExplanationOverloadable?\n\"!\"\"ident!(...)\", \"ident!{...}\", \"ident![...]\"Macro expansion\n\"!\"\"!expr\"Bitwise or logical complement\"Not\"\n\"!=\"\"expr != expr\"Nonequality comparison\"PartialEq\"\n\"%\"\"expr % expr\"Arithmetic remainder\"Rem\"\n\"%=\"\"var %= expr\"Arithmetic remainder and assignment\"RemAssign\"\n\"&amp;\"\"&amp;expr\", \"&amp;mut expr\"Borrow\n\"&amp;\"\"&amp;type\", \"&amp;mut type\", \"&amp;\"a type\", \"&amp;\"a mut type\"Borrowed pointer type\n\"&amp;\"\"expr &amp; expr\"Bitwise AND\"BitAnd\"\n\"&amp;=\"\"var &amp;= expr\"Bitwise AND and assignment\"BitAndAssign\"\n\"&amp;&amp;\"\"expr &amp;&amp; expr\"Short-circuiting logical AND\n\"*\"\"expr * expr\"Arithmetic multiplication\"Mul\"\n\"*=\"\"var *= expr\"Arithmetic multiplication and assignment\"MulAssign\"\n\"*\"\"*expr\"Dereference\"Deref\"\n\"*\"\"*const type\", \"*mut type\"Raw pointer\n\"+\"\"trait + trait\", \"\"a + trait\"Compound type constraint\n\"+\"\"expr + expr\"Arithmetic addition\"Add\"\n\"+=\"\"var += expr\"Arithmetic addition and assignment\"AddAssign\"\n\",\"\"expr, expr\"Argument and element separator\n\"-\"\"- expr\"Arithmetic negation\"Neg\"\n\"-\"\"expr - expr\"Arithmetic subtraction\"Sub\"\n\"-=\"\"var -= expr\"Arithmetic subtraction and assignment\"SubAssign\"\n\"-&gt;\"\"fn(...) -&gt; type\", \"...-&gt; type\"\n\".\"\"expr.ident\"Member access\n\"..\"\"..\", \"expr..\", \"..expr\", \"expr..expr\"Right-exclusive range literal\"PartialOrd\"\n\"..=\"\"..=expr\", \"expr..=expr\"Right-inclusive range literal\"PartialOrd\"\n\"..\"\"..expr\"Struct literal update syntax\n\"..\"\"variant(x, ..)\", \"struct_type { x, .. }\"“And the rest” pattern binding\n\"...\"\"expr...expr\"(Deprecated, use \"..=\" instead) In a pattern: inclusive range pattern\n\"/\"\"expr / expr\"Arithmetic division\"Div\"\n\"/=\"\"var /= expr\"Arithmetic division and assignment\"DivAssign\"\n\":\"\"pat: type\", \"ident: type\"Constraints\n\":\"\"ident: expr\"Struct field initializer\n\":\"\"\"a: loop {...}\"Loop label\n\";\"\"expr;\"Statement and item terminator\n\";\"\"[...; len]\"Part of fixed-size array syntax\n\"&lt;&lt;\"\"expr &lt;&lt; expr\"Left-shift\"Shl\"\n\"&lt;&lt;=\"\"var &lt;&lt;= expr\"Left-shift and assignment\"ShlAssign\"\n\"&lt;\"\"expr &lt; expr\"Less than comparison\"PartialOrd\"\n\"&lt;=\"\"expr &lt;= expr\"Less than or equal to comparison\"PartialOrd\"\n\"=\"\"var = expr\", \"ident = type\"Assignment/equivalence\n\"==\"\"expr == expr\"Equality comparison\"PartialEq\"\n\"=&gt;\"\"pat =&gt; expr\"Part of match arm syntax\n\"&gt;\"\"expr &gt; expr\"Greater than comparison\"PartialOrd\"\n\"&gt;=\"\"expr &gt;= expr\"Greater than or equal to comparison\"PartialOrd\"\n\"&gt;&gt;\"\"expr &gt;&gt; expr\"Right-shift\"Shr\"\n\"&gt;&gt;=\"\"var &gt;&gt;= expr\"Right-shift and assignment\"ShrAssign\"\n\"@\"\"ident @ pat\"Pattern binding\n\"^\"\"expr ^ expr\"Bitwise exclusive OR\"BitXor\"\n\"^=\"\"var ^= expr\"Bitwise exclusive OR and assignment\"BitXorAssign\"\n\"\"\"patpat\"\n\"\"\"exprexpr\"\n\"=\"\"var= expr\"\n\"\"\"expr\n\"?\"\"expr?\"Error propagation\n\nNon-operator Symbols\nThe following list contains all symbols that don’t function as operators; that is, they don’t behave like a function or method call.\nTable B-2 shows symbols that appear on their own and are valid in a variety of locations.\nTable B-2: Stand-Alone Syntax\nSymbolExplanation\n\"\"ident\"Named lifetime or loop label\n\"...u8\", \"...i32\", \"...f64\", \"...usize\", etc.Numeric literal of specific type\n\"\"...\"\"String literal\n\"r\"...\"\", \"r#\"...\"#\", \"r##\"...\"##\", etc.Raw string literal, escape characters not processed\n\"b\"...\"\"Byte string literal; constructs an array of bytes instead of a string\n\"br\"...\"\", \"br#\"...\"#\", \"br##\"...\"##\", etc.Raw byte string literal, combination of raw and byte string literal\n\"\"...\"\"Character literal\n\"b\"...\"\"ASCII byte literal\n\"...\n\"!\"Always empty bottom type for diverging functions\n\"_\"“Ignored” pattern binding; also used to make integer literals readable\n\nTable B-3 shows symbols that appear in the context of a path through the module hierarchy to an item.\nTable B-3: Path-Related Syntax\nSymbolExplanation\n\"ident::ident\"Namespace path\n\"::path\"Path relative to the crate root (i.e., an explicitly absolute path)\n\"self::path\"Path relative to the current module (i.e., an explicitly relative path).\n\"super::path\"Path relative to the parent of the current module\n\"type::ident\", \"::ident\"Associated constants, functions, and types\n\"::...\"Associated item for a type that cannot be directly named (e.g., \"&lt;&amp;T&gt;::...\", \"&lt;[T]&gt;::...\", etc.)\n\"trait::method(...)\"Disambiguating a method call by naming the trait that defines it\n\"type::method(...)\"Disambiguating a method call by naming the type for which it’s defined\n\"::method(...)\"Disambiguating a method call by naming the trait and type\n\nTable B-4 shows symbols that appear in the context of using generic type parameters.\nTable B-4: Generics\nSymbolExplanation\n\"path&lt;...&gt;\"Specifies parameters to generic type in a type (e.g., \"Vec\")\n\"path::&lt;...&gt;\", \"method::&lt;...&gt;\"Specifies parameters to generic type, function, or method in an expression; often referred to as turbofish (e.g., \"\"42\".parse::()\")\n\"fn ident&lt;...&gt; ...\"Define generic function\n\"struct ident&lt;...&gt; ...\"Define generic structure\n\"enum ident&lt;...&gt; ...\"Define generic enumeration\n\"impl&lt;...&gt; ...\"Define generic implementation\n\"for&lt;...&gt; type\"Higher-ranked lifetime bounds\n\"type&lt;ident=type&gt;\"A generic type where one or more associated types have specific assignments (e.g., \"Iterator&lt;Item=T&gt;\")\n\nTable B-5 shows symbols that appear in the context of constraining generic type parameters with trait bounds.\nTable B-5: Trait Bound Constraints\nSymbolExplanation\n\"T: U\"Generic parameter \"T\" constrained to types that implement \"U\"\n\"T: \"a\"Generic type \"T\" must outlive lifetime \"\"a\" (meaning the type cannot transitively contain any references with lifetimes shorter than \"\"a\")\n\"T: \"static\"Generic type \"T\" contains no borrowed references other than \"\"static\" ones\n\"\"b: \"a\"Generic lifetime \"\"b\" must outlive lifetime \"\"a\"\n\"T: ?Sized\"Allow generic type parameter to be a dynamically sized type\n\"\"a + trait\", \"trait + trait\"Compound type constraint\n\nTable B-6 shows symbols that appear in the context of calling or defining macros and specifying attributes on an item.\nTable B-6: Macros and Attributes\nSymbolExplanation\n\"#[meta]\"Outer attribute\n\"#![meta]\"Inner attribute\n\"$ident\"Macro substitution\n\"$ident:kind\"Macro capture\n\"$(…)…\"Macro repetition\n\"ident!(...)\", \"ident!{...}\", \"ident![...]\"Macro invocation\n\nTable B-7 shows symbols that create comments.\nTable B-7: Comments\nSymbolExplanation\n\"//\"Line comment\n\"//!\"Inner line doc comment\n\"///\"Outer line doc comment\n\"/.../\"Block comment\n\"/!.../\"Inner block doc comment\n\"/**...*/\"Outer block doc comment\n\nTable B-8 shows symbols that appear in the context of using tuples.\nTable B-8: Tuples\nSymbolExplanation\n\"()\"Empty tuple (aka unit), both literal and type\n\"(expr)\"Parenthesized expression\n\"(expr,)\"Single-element tuple expression\n\"(type,)\"Single-element tuple type\n\"(expr, ...)\"Tuple expression\n\"(type, ...)\"Tuple type\n\"expr(expr, ...)\"Function call expression; also used to initialize tuple \"struct\"s and tuple \"enum\" variants\n\"expr.0\", \"expr.1\", etc.Tuple indexing\n\nTable B-9 shows the contexts in which curly braces are used.\nTable B-9: Curly Brackets\nContextExplanation\n\"{...}\"Block expression\n\"Type {...}\"\"struct\" literal\n\nTable B-10 shows the contexts in which square brackets are used.\nTable B-10: Square Brackets\nContextExplanation\n\"[...]\"Array literal\n\"[expr; len]\"Array literal containing \"len\" copies of \"expr\"\n\"[type; len]\"Array type containing \"len\" instances of \"type\"\n\"expr[expr]\"Collection indexing. Overloadable (\"Index\", \"IndexMut\")\n\"expr[..]\", \"expr[a..]\", \"expr[..b]\", \"expr[a..b]\"Collection indexing pretending to be collection slicing, using \"Range\", \"RangeFrom\", \"RangeTo\", or \"RangeFull\" as the “index”\n\n\nAppendix C: Derivable Traits\nIn various places in the book, we’ve discussed the \"derive\" attribute, which you can apply to a struct or enum definition. The \"derive\" attribute generates code that will implement a trait with its own default implementation on the type you’ve annotated with the \"derive\" syntax.\nIn this appendix, we provide a reference of all the traits in the standard library that you can use with \"derive\". Each section covers:\n\nWhat operators and methods deriving this trait will enable\nWhat the implementation of the trait provided by \"derive\" does\nWhat implementing the trait signifies about the type\nThe conditions in which you’re allowed or not allowed to implement the trait\nExamples of operations that require the trait\n\nIf you want different behavior from that provided by the \"derive\" attribute, consult the standard library documentation for each trait for details of how to manually implement them.\nThese traits listed here are the only ones defined by the standard library that can be implemented on your types using \"derive\". Other traits defined in the standard library don’t have sensible default behavior, so it’s up to you to implement them in the way that makes sense for what you’re trying to accomplish.\nAn example of a trait that can’t be derived is \"Display\", which handles formatting for end users. You should always consider the appropriate way to display a type to an end user. What parts of the type should an end user be allowed to see? What parts would they find relevant? What format of the data would be most relevant to them? The Rust compiler doesn’t have this insight, so it can’t provide appropriate default behavior for you.\nThe list of derivable traits provided in this appendix is not comprehensive: libraries can implement \"derive\" for their own traits, making the list of traits you can use \"derive\" with truly open-ended. Implementing \"derive\" involves using a procedural macro, which is covered in the “Macros” section of Chapter 19.\n\"Debug\" for Programmer Output\nThe \"Debug\" trait enables debug formatting in format strings, which you indicate by adding \":?\" within \"{}\" placeholders.\nThe \"Debug\" trait allows you to print instances of a type for debugging purposes, so you and other programmers using your type can inspect an instance at a particular point in a program’s execution.\nThe \"Debug\" trait is required, for example, in use of the \"assert_eq!\" macro. This macro prints the values of instances given as arguments if the equality assertion fails so programmers can see why the two instances weren’t equal.\n\"PartialEq\" and \"Eq\" for Equality Comparisons\nThe \"PartialEq\" trait allows you to compare instances of a type to check for equality and enables use of the \"==\" and \"!=\" operators.\nDeriving \"PartialEq\" implements the \"eq\" method. When \"PartialEq\" is derived on structs, two instances are equal only if all fields are equal, and the instances are not equal if any fields are not equal. When derived on enums, each variant is equal to itself and not equal to the other variants.\nThe \"PartialEq\" trait is required, for example, with the use of the \"assert_eq!\" macro, which needs to be able to compare two instances of a type for equality.\nThe \"Eq\" trait has no methods. Its purpose is to signal that for every value of the annotated type, the value is equal to itself. The \"Eq\" trait can only be applied to types that also implement \"PartialEq\", although not all types that implement \"PartialEq\" can implement \"Eq\". One example of this is floating point number types: the implementation of floating point numbers states that two instances of the not-a-number (\"NaN\") value are not equal to each other.\nAn example of when \"Eq\" is required is for keys in a \"HashMap&lt;K, V&gt;\" so the \"HashMap&lt;K, V&gt;\" can tell whether two keys are the same.\n\"PartialOrd\" and \"Ord\" for Ordering Comparisons\nThe \"PartialOrd\" trait allows you to compare instances of a type for sorting purposes. A type that implements \"PartialOrd\" can be used with the \"&lt;\", \"&gt;\", \"&lt;=\", and \"&gt;=\" operators. You can only apply the \"PartialOrd\" trait to types that also implement \"PartialEq\".\nDeriving \"PartialOrd\" implements the \"partial_cmp\" method, which returns an \"Option\" that will be \"None\" when the values given don’t produce an ordering. An example of a value that doesn’t produce an ordering, even though most values of that type can be compared, is the not-a-number (\"NaN\") floating point value. Calling \"partial_cmp\" with any floating point number and the \"NaN\" floating point value will return \"None\".\nWhen derived on structs, \"PartialOrd\" compares two instances by comparing the value in each field in the order in which the fields appear in the struct definition. When derived on enums, variants of the enum declared earlier in the enum definition are considered less than the variants listed later.\nThe \"PartialOrd\" trait is required, for example, for the \"gen_range\" method from the \"rand\" crate that generates a random value in the range specified by a range expression.\nThe \"Ord\" trait allows you to know that for any two values of the annotated type, a valid ordering will exist. The \"Ord\" trait implements the \"cmp\" method, which returns an \"Ordering\" rather than an \"Option\" because a valid ordering will always be possible. You can only apply the \"Ord\" trait to types that also implement \"PartialOrd\" and \"Eq\" (and \"Eq\" requires \"PartialEq\"). When derived on structs and enums, \"cmp\" behaves the same way as the derived implementation for \"partial_cmp\" does with \"PartialOrd\".\nAn example of when \"Ord\" is required is when storing values in a \"BTreeSet\", a data structure that stores data based on the sort order of the values.\n\"Clone\" and \"Copy\" for Duplicating Values\nThe \"Clone\" trait allows you to explicitly create a deep copy of a value, and the duplication process might involve running arbitrary code and copying heap data. See the “Ways Variables and Data Interact: Clone” section in Chapter 4 for more information on \"Clone\".\nDeriving \"Clone\" implements the \"clone\" method, which when implemented for the whole type, calls \"clone\" on each of the parts of the type. This means all the fields or values in the type must also implement \"Clone\" to derive \"Clone\".\nAn example of when \"Clone\" is required is when calling the \"to_vec\" method on a slice. The slice doesn’t own the type instances it contains, but the vector returned from \"to_vec\" will need to own its instances, so \"to_vec\" calls \"clone\" on each item. Thus, the type stored in the slice must implement \"Clone\".\nThe \"Copy\" trait allows you to duplicate a value by only copying bits stored on the stack; no arbitrary code is necessary. See the “Stack-Only Data: Copy” section in Chapter 4 for more information on \"Copy\".\nThe \"Copy\" trait doesn’t define any methods to prevent programmers from overloading those methods and violating the assumption that no arbitrary code is being run. That way, all programmers can assume that copying a value will be very fast.\nYou can derive \"Copy\" on any type whose parts all implement \"Copy\". A type that implements \"Copy\" must also implement \"Clone\", because a type that implements \"Copy\" has a trivial implementation of \"Clone\" that performs the same task as \"Copy\".\nThe \"Copy\" trait is rarely required; types that implement \"Copy\" have optimizations available, meaning you don’t have to call \"clone\", which makes the code more concise.\nEverything possible with \"Copy\" you can also accomplish with \"Clone\", but the code might be slower or have to use \"clone\" in places.\n\"Hash\" for Mapping a Value to a Value of Fixed Size\nThe \"Hash\" trait allows you to take an instance of a type of arbitrary size and map that instance to a value of fixed size using a hash function. Deriving \"Hash\" implements the \"hash\" method. The derived implementation of the \"hash\" method combines the result of calling \"hash\" on each of the parts of the type, meaning all fields or values must also implement \"Hash\" to derive \"Hash\".\nAn example of when \"Hash\" is required is in storing keys in a \"HashMap&lt;K, V&gt;\" to store data efficiently.\n\"Default\" for Default Values\nThe \"Default\" trait allows you to create a default value for a type. Deriving \"Default\" implements the \"default\" function. The derived implementation of the \"default\" function calls the \"default\" function on each part of the type, meaning all fields or values in the type must also implement \"Default\" to derive \"Default\".\nThe \"Default::default\" function is commonly used in combination with the struct update syntax discussed in the “Creating Instances From Other Instances With Struct Update Syntax” section in Chapter 5. You can customize a few fields of a struct and then set and use a default value for the rest of the fields by using \"..Default::default()\".\nThe \"Default\" trait is required when you use the method \"unwrap_or_default\" on \"Option\" instances, for example. If the \"Option\" is \"None\", the method \"unwrap_or_default\" will return the result of \"Default::default\" for the type \"T\" stored in the \"Option\".\n\nAppendix D - Useful Development Tools\nIn this appendix, we talk about some useful development tools that the Rust project provides. We’ll look at automatic formatting, quick ways to apply warning fixes, a linter, and integrating with IDEs.\nAutomatic Formatting with \"rustfmt\"\nThe \"rustfmt\" tool reformats your code according to the community code style. Many collaborative projects use \"rustfmt\" to prevent arguments about which style to use when writing Rust: everyone formats their code using the tool.\nTo install \"rustfmt\", enter the following:\n$ rustup component add rustfmt\n\nThis command gives you \"rustfmt\" and \"cargo-fmt\", similar to how Rust gives you both \"rustc\" and \"cargo\". To format any Cargo project, enter the following:\n$ cargo fmt\n\nRunning this command reformats all the Rust code in the current crate. This should only change the code style, not the code semantics. For more information on \"rustfmt\", see its documentation.\nFix Your Code with \"rustfix\"\nThe rustfix tool is included with Rust installations and can automatically fix compiler warnings that have a clear way to correct the problem that’s likely what you want. It’s likely you’ve seen compiler warnings before. For example, consider this code:\nFilename: src/main.rs\nfn do_something() {}\n\nfn main() {\n    for i in 0..100 {\n        do_something();\n    }\n}\n\nHere, we’re calling the \"do_something\" function 100 times, but we never use the variable \"i\" in the body of the \"for\" loop. Rust warns us about that:\n$ cargo build\n   Compiling myprogram v0.1.0 (file:///projects/myprogram)\nwarning: unused variable: \"i\"\n --&gt; src/main.rs:4:9\n  |\n4 |     for i in 0..100 {\n  |         ^ help: consider using \"_i\" instead\n  |\n  = note: #[warn(unused_variables)] on by default\n\n    Finished dev [unoptimized + debuginfo] target(s) in 0.50s\n\nThe warning suggests that we use \"_i\" as a name instead: the underscore indicates that we intend for this variable to be unused. We can automatically apply that suggestion using the \"rustfix\" tool by running the command \"cargo fix\":\n$ cargo fix\n    Checking myprogram v0.1.0 (file:///projects/myprogram)\n      Fixing src/main.rs (1 fix)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.59s\n\nWhen we look at src/main.rs again, we’ll see that \"cargo fix\" has changed the code:\nFilename: src/main.rs\nfn do_something() {}\n\nfn main() {\n    for _i in 0..100 {\n        do_something();\n    }\n}\n\nThe \"for\" loop variable is now named \"_i\", and the warning no longer appears.\nYou can also use the \"cargo fix\" command to transition your code between different Rust editions. Editions are covered in Appendix E.\nMore Lints with Clippy\nThe Clippy tool is a collection of lints to analyze your code so you can catch common mistakes and improve your Rust code.\nTo install Clippy, enter the following:\n$ rustup component add clippy\n\nTo run Clippy’s lints on any Cargo project, enter the following:\n$ cargo clippy\n\nFor example, say you write a program that uses an approximation of a mathematical constant, such as pi, as this program does:\nFilename: src/main.rs\nfn main() {\n    let x = 3.1415;\n    let r = 8.0;\n    println!(\"the area of the circle is {}\", x * r * r);\n}\n\nRunning \"cargo clippy\" on this project results in this error:\nerror: approximate value of \"f{32, 64}::consts::PI\" found\n --&gt; src/main.rs:2:13\n  |\n2 |     let x = 3.1415;\n  |             ^^^^^^\n  |\n  = note: \"#[deny(clippy::approx_constant)]\" on by default\n  = help: consider using the constant directly\n  = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#approx_constant\n\nThis error lets you know that Rust already has a more precise \"PI\" constant defined, and that your program would be more correct if you used the constant instead. You would then change your code to use the \"PI\" constant. The following code doesn’t result in any errors or warnings from Clippy:\nFilename: src/main.rs\nfn main() {\n    let x = std::f64::consts::PI;\n    let r = 8.0;\n    println!(\"the area of the circle is {}\", x * r * r);\n}\n\nFor more information on Clippy, see its documentation.\nIDE Integration Using \"rust-analyzer\"\nTo help IDE integration, the Rust community recommends using \"rust-analyzer\". This tool is a set of compiler-centric utilities that speaks the Language Server Protocol, which is a specification for IDEs and programming languages to communicate with each other. Different clients can use \"rust-analyzer\", such as the Rust analyzer plug-in for Visual Studio Code.\nVisit the \"rust-analyzer\" project’s home page for installation instructions, then install the language server support in your particular IDE. Your IDE will gain abilities such as autocompletion, jump to definition, and inline errors.\n\nAppendix E - Editions\nIn Chapter 1, you saw that \"cargo new\" adds a bit of metadata to your Cargo.toml file about an edition. This appendix talks about what that means!\nThe Rust language and compiler have a six-week release cycle, meaning users get a constant stream of new features. Other programming languages release larger changes less often; Rust releases smaller updates more frequently. After a while, all of these tiny changes add up. But from release to release, it can be difficult to look back and say, “Wow, between Rust 1.10 and Rust 1.31, Rust has changed a lot!”\nEvery two or three years, the Rust team produces a new Rust edition. Each edition brings together the features that have landed into a clear package with fully updated documentation and tooling. New editions ship as part of the usual six-week release process.\nEditions serve different purposes for different people:\n\nFor active Rust users, a new edition brings together incremental changes into an easy-to-understand package.\nFor non-users, a new edition signals that some major advancements have landed, which might make Rust worth another look.\nFor those developing Rust, a new edition provides a rallying point for the project as a whole.\n\nAt the time of this writing, three Rust editions are available: Rust 2015, Rust 2018, and Rust 2021. This book is written using Rust 2021 edition idioms.\nThe \"edition\" key in Cargo.toml indicates which edition the compiler should use for your code. If the key doesn’t exist, Rust uses \"2015\" as the edition value for backward compatibility reasons.\nEach project can opt in to an edition other than the default 2015 edition. Editions can contain incompatible changes, such as including a new keyword that conflicts with identifiers in code. However, unless you opt in to those changes, your code will continue to compile even as you upgrade the Rust compiler version you use.\nAll Rust compiler versions support any edition that existed prior to that compiler’s release, and they can link crates of any supported editions together. Edition changes only affect the way the compiler initially parses code. Therefore, if you’re using Rust 2015 and one of your dependencies uses Rust 2018, your project will compile and be able to use that dependency. The opposite situation, where your project uses Rust 2018 and a dependency uses Rust 2015, works as well.\nTo be clear: most features will be available on all editions. Developers using any Rust edition will continue to see improvements as new stable releases are made. However, in some cases, mainly when new keywords are added, some new features might only be available in later editions. You will need to switch editions if you want to take advantage of such features.\nFor more details, the Edition Guide is a complete book about editions that enumerates the differences between editions and explains how to automatically upgrade your code to a new edition via \"cargo fix\".\n\nAppendix F: Translations of the Book\nFor resources in languages other than English. Most are still in progress; see the Translations label to help or let us know about a new translation!\n\nPortuguês (BR)\nPortuguês (PT)\n简体中文\n正體中文\nУкраїнська\nEspañol, alternate\nItaliano\nРусский\n한국어\n日本語\nFrançais\nPolski\nCebuano\nTagalog\nEsperanto\nελληνική\nSvenska\nFarsi\nDeutsch\nहिंदी\nไทย\nDanske\n\n\nAppendix G - How Rust is Made and “Nightly Rust”\nThis appendix is about how Rust is made and how that affects you as a Rust developer.\nStability Without Stagnation\nAs a language, Rust cares a lot about the stability of your code. We want Rust to be a rock-solid foundation you can build on, and if things were constantly changing, that would be impossible. At the same time, if we can’t experiment with new features, we may not find out important flaws until after their release, when we can no longer change things.\nOur solution to this problem is what we call “stability without stagnation”, and our guiding principle is this: you should never have to fear upgrading to a new version of stable Rust. Each upgrade should be painless, but should also bring you new features, fewer bugs, and faster compile times.\nChoo, Choo! Release Channels and Riding the Trains\nRust development operates on a train schedule. That is, all development is done on the \"master\" branch of the Rust repository. Releases follow a software release train model, which has been used by Cisco IOS and other software projects. There are three release channels for Rust:\n\nNightly\nBeta\nStable\n\nMost Rust developers primarily use the stable channel, but those who want to try out experimental new features may use nightly or beta.\nHere’s an example of how the development and release process works: let’s assume that the Rust team is working on the release of Rust 1.5. That release happened in December of 2015, but it will provide us with realistic version numbers. A new feature is added to Rust: a new commit lands on the \"master\" branch. Each night, a new nightly version of Rust is produced. Every day is a release day, and these releases are created by our release infrastructure automatically. So as time passes, our releases look like this, once a night:\nnightly: * - - * - - *\n\nEvery six weeks, it’s time to prepare a new release! The \"beta\" branch of the Rust repository branches off from the \"master\" branch used by nightly. Now, there are two releases:\nnightly: * - - * - - *\n                     |\nbeta:                *\n\nMost Rust users do not use beta releases actively, but test against beta in their CI system to help Rust discover possible regressions. In the meantime, there’s still a nightly release every night:\nnightly: * - - * - - * - - * - - *\n                     |\nbeta:                *\n\nLet’s say a regression is found. Good thing we had some time to test the beta release before the regression snuck into a stable release! The fix is applied to \"master\", so that nightly is fixed, and then the fix is backported to the \"beta\" branch, and a new release of beta is produced:\nnightly: * - - * - - * - - * - - * - - *\n                     |\nbeta:                * - - - - - - - - *\n\nSix weeks after the first beta was created, it’s time for a stable release! The \"stable\" branch is produced from the \"beta\" branch:\nnightly: * - - * - - * - - * - - * - - * - * - *\n                     |\nbeta:                * - - - - - - - - *\n                                       |\nstable:                                *\n\nHooray! Rust 1.5 is done! However, we’ve forgotten one thing: because the six weeks have gone by, we also need a new beta of the next version of Rust, 1.6. So after \"stable\" branches off of \"beta\", the next version of \"beta\" branches off of \"nightly\" again:\nnightly: * - - * - - * - - * - - * - - * - * - *\n                     |                         |\nbeta:                * - - - - - - - - *       *\n                                       |\nstable:                                *\n\nThis is called the “train model” because every six weeks, a release “leaves the station”, but still has to take a journey through the beta channel before it arrives as a stable release.\nRust releases every six weeks, like clockwork. If you know the date of one Rust release, you can know the date of the next one: it’s six weeks later. A nice aspect of having releases scheduled every six weeks is that the next train is coming soon. If a feature happens to miss a particular release, there’s no need to worry: another one is happening in a short time! This helps reduce pressure to sneak possibly unpolished features in close to the release deadline.\nThanks to this process, you can always check out the next build of Rust and verify for yourself that it’s easy to upgrade to: if a beta release doesn’t work as expected, you can report it to the team and get it fixed before the next stable release happens! Breakage in a beta release is relatively rare, but \"rustc\" is still a piece of software, and bugs do exist.\nUnstable Features\nThere’s one more catch with this release model: unstable features. Rust uses a technique called “feature flags” to determine what features are enabled in a given release. If a new feature is under active development, it lands on \"master\", and therefore, in nightly, but behind a feature flag. If you, as a user, wish to try out the work-in-progress feature, you can, but you must be using a nightly release of Rust and annotate your source code with the appropriate flag to opt in.\nIf you’re using a beta or stable release of Rust, you can’t use any feature flags. This is the key that allows us to get practical use with new features before we declare them stable forever. Those who wish to opt into the bleeding edge can do so, and those who want a rock-solid experience can stick with stable and know that their code won’t break. Stability without stagnation.\nThis book only contains information about stable features, as in-progress features are still changing, and surely they’ll be different between when this book was written and when they get enabled in stable builds. You can find documentation for nightly-only features online.\nRustup and the Role of Rust Nightly\nRustup makes it easy to change between different release channels of Rust, on a global or per-project basis. By default, you’ll have stable Rust installed. To install nightly, for example:\n$ rustup toolchain install nightly\n\nYou can see all of the toolchains (releases of Rust and associated components) you have installed with \"rustup\" as well. Here’s an example on one of your authors’ Windows computer:\n&gt; rustup toolchain list\nstable-x86_64-pc-windows-msvc (default)\nbeta-x86_64-pc-windows-msvc\nnightly-x86_64-pc-windows-msvc\n\nAs you can see, the stable toolchain is the default. Most Rust users use stable most of the time. You might want to use stable most of the time, but use nightly on a specific project, because you care about a cutting-edge feature. To do so, you can use \"rustup override\" in that project’s directory to set the nightly toolchain as the one \"rustup\" should use when you’re in that directory:\n$ cd ~/projects/needs-nightly\n$ rustup override set nightly\n\nNow, every time you call \"rustc\" or \"cargo\" inside of ~/projects/needs-nightly, \"rustup\" will make sure that you are using nightly Rust, rather than your default of stable Rust. This comes in handy when you have a lot of Rust projects!\nThe RFC Process and Teams\nSo how do you learn about these new features? Rust’s development model follows a Request For Comments (RFC) process. If you’d like an improvement in Rust, you can write up a proposal, called an RFC.\nAnyone can write RFCs to improve Rust, and the proposals are reviewed and discussed by the Rust team, which is comprised of many topic subteams. There’s a full list of the teams on Rust’s website, which includes teams for each area of the project: language design, compiler implementation, infrastructure, documentation, and more. The appropriate team reads the proposal and the comments, writes some comments of their own, and eventually, there’s consensus to accept or reject the feature.\nIf the feature is accepted, an issue is opened on the Rust repository, and someone can implement it. The person who implements it very well may not be the person who proposed the feature in the first place! When the implementation is ready, it lands on the \"master\" branch behind a feature gate, as we discussed in the “Unstable Features” section.\nAfter some time, once Rust developers who use nightly releases have been able to try out the new feature, team members will discuss the feature, how it’s worked out on nightly, and decide if it should make it into stable Rust or not. If the decision is to move forward, the feature gate is removed, and the feature is now considered stable! It rides the trains into a new stable release of Rust.\n","id":"http://127.0.0.1:1111/rust/chapter17-21/","title":"18-21"},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"body":"18-21\n18\n패턴과 매칭\n패턴은 복잡하고 단순한 유형의 구조와 일치시키기 위한 Rust의 특수 구문입니다. 일치 식 및 기타 구문과 함께 패턴을 사용하면 프로그램의 제어 흐름을 더 잘 제어할 수 있습니다. 패턴은 다음의 일부 조합으로 구성됩니다.\n\n리터럴\n해체된 배열, 열거형, 구조체 또는 튜플\n변수\n와일드카드\n자리 표시자\n\n일부 예제 패턴에는 x, (a, 3) 및 Some(Color::Red)가 포함됩니다. 패턴이 유효한 컨텍스트에서 이러한 구성 요소는 데이터의 모양을 설명합니다. 그런 다음 우리 프로그램은 패턴과 값을 일치시켜 특정 코드 조각을 계속 실행하는 데 올바른 데이터 모양이 있는지 확인합니다.\n패턴을 사용하기 위해 우리는 그것을 어떤 값과 비교합니다. 패턴이 값과 일치하면 코드에서 값 부분을 사용합니다. 동전 분류기 예제와 같이 패턴을 사용했던 6장의 일치 표현을 상기하십시오. 값이 패턴의 모양에 맞으면 명명된 조각을 사용할 수 있습니다. 그렇지 않으면 패턴과 연결된 코드가 실행되지 않습니다.\n이 장은 패턴과 관련된 모든 것에 대한 참조입니다. 패턴을 사용할 수 있는 유효한 위치, 반박할 수 있는 패턴과 반박할 수 없는 패턴의 차이점, 볼 수 있는 다양한 종류의 패턴 구문을 다룰 것입니다. 이 장을 마치면 패턴을 사용하여 많은 개념을 명확한 방식으로 표현하는 방법을 알게 됩니다.\n\n모든 장소 패턴을 사용할 수 있습니다.\n패턴은 Rust의 여러 곳에서 나타나며, 여러분은 그것을 깨닫지 못한 채 패턴을 많이 사용하고 있습니다! 이 섹션에서는 패턴이 유효한 모든 위치에 대해 설명합니다.\n일치 팔\n6장에서 논의한 것처럼 일치 표현식의 팔에 패턴을 사용합니다. 공식적으로 일치 표현식은 키워드 일치, 일치할 값, 패턴으로 구성된 하나 이상의 일치 암과 값이 해당 암의 패턴과 일치하는 경우 실행할 표현식으로 정의됩니다.\nmatch VALUE {\n    PATTERN =&gt; EXPRESSION,\n    PATTERN =&gt; EXPRESSION,\n    PATTERN =&gt; EXPRESSION,\n}\n\n예를 들어, 다음은 옵션에서 일치하는 목록 6-5의 일치 표현식입니다.변수x`의 값:\nmatch x {\n    None =&gt; None,\n    Some(i) =&gt; Some(i + 1),\n}\n\n이 일치 식의 패턴은 각 화살표 왼쪽에 있는 없음 및 Some(i)입니다.\n일치 식에 대한 한 가지 요구 사항 은 일치 식의 값에 대한 모든 가능성을 고려해야 한다는 점에서 철저 해야 한다는 것입니다. 모든 가능성을 다루었는지 확인하는 한 가지 방법은 마지막 팔에 대한 포괄 패턴을 갖는 것입니다. 예를 들어 어떤 값과도 일치하는 변수 이름은 절대 실패할 수 없으므로 나머지 모든 경우를 포함합니다.\n특정 패턴  *은 무엇이든 일치하지만 변수에 바인딩되지 않으므로 마지막 일치 부분에서 자주 사용됩니다. *  패턴은 예를 들어 지정되지 않은 값을 무시하려는 경우에 유용할 수 있습니다. _ 패턴에 대해서는 이 장 뒷부분의 패턴의 값 무시 섹션 에서 자세히 다룰 것입니다.\n조건부 if let 표현식\n6장에서 우리는 주로 하나의 경우에만 일치하는 일치에 해당하는 것을 작성하는 더 짧은 방법으로 if let 표현식을 사용하는 방법에 대해 논의했습니다. 선택적으로 if let은 if let의 패턴이 일치하지 않는 경우 실행할 코드를 포함하는 해당 else를 가질 수 있습니다.\n목록 18-1은 if let, else if 및 else if let 표현식을 혼합하고 일치시키는 것도 가능함을 보여줍니다. 이렇게 하면 패턴과 비교할 하나의 값만 표현할 수 있는 일치 식보다 더 많은 유연성을 얻을 수 있습니다. 또한 Rust는 일련의 if let, else if, else if let 조건이 서로 관련될 것을 요구하지 않습니다.\n목록 18-1의 코드는 여러 조건에 대한 일련의 검사를 기반으로 배경을 만들 색상을 결정합니다. 이 예에서는 실제 프로그램이 사용자 입력에서 수신할 수 있는 하드코딩된 값으로 변수를 만들었습니다.\n파일 이름: src/main.rs\nfn main() {\n    let favorite_color: Option&lt;&amp;str&gt; = None;\n    let is_tuesday = false;\n    let age: Result&lt;u8, _&gt; = `34`.parse();\n\n    if let Some(color) = favorite_color {\n        println!(`Using your favorite color, {color}, as the background`);\n    } else if is_tuesday {\n        println!(`Tuesday is green day!`);\n    } else if let Ok(age) = age {\n        if age &gt; 30 {\n            println!(`Using purple as the background color`);\n        } else {\n            println!(`Using orange as the background color`);\n        }\n    } else {\n        println!(`Using blue as the background color`);\n    }\n}\n\n목록 18-1: if let, else if, else if let 및 else 혼합\n사용자가 좋아하는 색상을 지정하면 해당 색상이 배경으로 사용됩니다. 즐겨찾기 색상을 지정하지 않고 오늘이 화요일인 경우 배경색은 녹색입니다. 그렇지 않고 사용자가 나이를 문자열로 지정하고 이를 숫자로 성공적으로 구문 분석할 수 있으면 숫자 값에 따라 색상이 보라색 또는 주황색이 됩니다. 이러한 조건이 적용되지 않는 경우 배경색은 파란색입니다.\n이 조건부 구조를 통해 복잡한 요구 사항을 지원할 수 있습니다. 여기에 있는 하드코딩된 값을 사용하여 이 예제는 배경색으로 보라색 사용을 인쇄합니다.\nif let도 match 팔이 할 수 있는 것과 같은 방식으로 숨겨진 변수를 도입할 수 있음을 볼 수 있습니다. if let Ok(age) = age 줄은 확인 변형. 즉, 해당 블록 내에 if age &gt; 30 조건을 배치해야 합니다. 이 두 조건을 if let Ok(age) = age &amp;&amp; age &gt; 30으로 결합할 수 없습니다. 새 범위가 중괄호로 시작될 때까지 30과 비교하려는 숨겨진 나이는 유효하지 않습니다.\nif let 식 사용의 단점은 컴파일러가 철저함을 확인하지 않는 반면 match 식에서는 확인한다는 것입니다. 마지막 else 블록을 생략하여 일부 사례 처리를 놓친 경우 컴파일러는 가능한 논리 버그에 대해 경고하지 않습니다.\nwhile let 조건 루프\nif let 구조와 유사하게 while let 조건 루프를 사용하면 패턴이 계속 일치하는 동안 while 루프가 실행될 수 있습니다. 목록 18-2에서 우리는 벡터를 스택으로 사용하고 푸시된 반대 순서로 벡터의 값을 인쇄하는 while let 루프를 코딩합니다.\n    let mut stack = Vec::new();\n\n    stack.push(1);\n    stack.push(2);\n    stack.push(3);\n    \n    while let Some(top) = stack.pop() {\n        println!(`{}`, top);\n    }\n\n목록 18-2: stack.pop()이 Some을 반환하는 한 값을 인쇄하기 위해 while let 루프 사용\n이 예제는 3, 2, 1을 인쇄합니다. pop 메서드는 벡터에서 마지막 요소를 가져와 Some(value)를 반환합니다. 벡터가 비어 있으면 pop은 없음을 반환합니다. while 루프는 pop이 Some을 반환하는 한 해당 블록에서 코드를 계속 실행합니다. pop이 None을 반환하면 루프가 중지됩니다. while let을 사용하여 스택에서 모든 요소를 꺼낼 수 있습니다.\nfor 루프\nfor 루프에서 키워드 for 바로 뒤에 오는 값은 패턴입니다. 예를 들어 for x in y에서 x는 패턴입니다. Listing 18-3은 for 루프에서 패턴을 사용하여 for 루프의 일부로 튜플을 분해하거나 분해하는 방법을 보여줍니다.\n    let v = vec![`a`, `b`, `c`];\n\n    for (index, value) in v.iter().enumerate() {\n        println!(`{} is at index {}`, value, index);\n    }\n\nListing 18-3: for 루프의 패턴을 사용하여 튜플을 분해합니다.\n목록 18-3의 코드는 다음을 인쇄합니다:\n$ cargo run\n   Compiling patterns v0.1.0 (file:///projects/patterns)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.52s\n     Running `target/debug/patterns`\na is at index 0\nb is at index 1\nc is at index 2\n\n우리는 열거 방법을 사용하여 반복자를 조정하여 튜플에 배치된 값과 해당 값에 대한 인덱스를 생성합니다. 생성된 첫 번째 값은 튜플 (0, a)입니다. 이 값이 (인덱스, 값) 패턴과 일치하면 인덱스는 0이 되고 값은 a가 되어 출력의 첫 번째 줄을 인쇄합니다.\n하자 문\n이 장 이전에는 match 및 if let과 함께 패턴 사용에 대해 명시적으로만 논의했지만 실제로는 let 문을 포함하여 다른 위치에서도 패턴을 사용했습니다. 예를 들어 let을 사용한 다음과 같은 간단한 변수 할당을 고려하십시오.\nlet x = 5;\n\n이와 같은 let 문을 사용할 때마다 패턴을 사용하고 있는 것입니다. 비록 깨닫지 못했을 수도 있지만요! 보다 공식적으로 let 문은 다음과 같습니다.\nlet PATTERN = EXPRESSION;\n\nlet x = 5;와 같은 문장에서 PATTERN 슬롯에 변수 이름이 있는 경우 변수 이름은 특히 단순한 패턴 형식입니다. Rust는 표현식을 패턴과 비교하고 찾은 이름을 할당합니다. 그래서 let x = 5; 예를 들어, x는 여기에서 일치하는 것을 변수 x에 바인딩한다는 의미의 패턴입니다. x라는 이름이 전체 패턴이기 때문에 이 패턴은 사실상 값이 무엇이든 모든 것을 변수 x에 바인딩합니다.를 의미합니다.\nlet의 패턴 일치 측면을 더 명확하게 보려면 let과 함께 패턴을 사용하여 튜플을 분해하는 목록 18-4를 고려하십시오.\n    let (x, y, z) = (1, 2, 3);\n\n목록 18-4: 패턴을 사용하여 튜플을 분해하고 세 개의 변수를 한 번에 생성\n여기에서 튜플을 패턴과 일치시킵니다. Rust는 값 (1, 2, 3)을 패턴 (x, y, z)와 비교하고 값이 패턴과 일치하는지 확인하므로 Rust는 1을 x에, 2를 에 바인딩합니다. y 및 3에서 z까지. 이 튜플 패턴은 내부에 세 개의 개별 변수 패턴을 중첩하는 것으로 생각할 수 있습니다.\n패턴의 요소 수가 튜플의 요소 수와 일치하지 않으면 전체 유형이 일치하지 않고 컴파일러 오류가 발생합니다. 예를 들어, Listing 18-5는 3개의 요소를 가진 튜플을 2개의 변수로 분해하려는 시도를 보여줍니다. 이것은 작동하지 않을 것입니다.\n    let (x, y) = (1, 2, 3);\n\n목록 18-5: 변수가 튜플의 요소 수와 일치하지 않는 패턴을 잘못 생성\n이 코드를 컴파일하려고 하면 다음 유형 오류가 발생합니다.\n$ cargo run\n   Compiling patterns v0.1.0 (file:///projects/patterns)\nerror[E0308]: mismatched types\n --&gt; src/main.rs:2:9\n  |\n2 |     let (x, y) = (1, 2, 3);\n  |         ^^^^^^   --------- this expression has type `({integer}, {integer}, {integer})`\n  |         |\n  |         expected a tuple with 3 elements, found one with 2 elements\n  |\n  = note: expected tuple `({integer}, {integer}, {integer})`\n             found tuple `(_, _)`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `patterns` due to previous error\n\n오류를 수정하기 위해 _ 또는 ..를 사용하여 튜플의 값 중 하나 이상을 무시할 수 있습니다. 패턴의 값 무시 섹션에서 볼 수 있습니다. 문제가 패턴에 너무 많은 변수가 있다는 것이라면 솔루션은 변수를 제거하여 유형을 일치시켜 변수의 수가 튜플의 요소 수와 같도록 하는 것입니다.\n함수 매개변수\n함수 매개변수는 패턴일 수도 있습니다. i32 유형의 x라는 이름의 매개변수 하나를 받는 foo라는 이름의 함수를 선언하는 Listing 18-6의 코드는 이제 익숙해 보일 것입니다.\nfn foo(x: i32) {\n    // code goes here\n}\n\n목록 18-6: 함수 시그니처는 매개변수의 패턴을 사용합니다.\nx 부분은 패턴입니다! let에서 했던 것처럼 함수의 인수에 있는 튜플을 패턴에 일치시킬 수 있습니다. 목록 18-7은 튜플의 값을 함수에 전달할 때 값을 분할합니다.\n파일 이름: src/main.rs\nfn print_coordinates(&amp;(x, y): &amp;(i32, i32)) {\n    println!(`Current location: ({}, {})`, x, y);\n}\n\nfn main() {\n    let point = (3, 5);\n    print_coordinates(&amp;point);\n}\n\n목록 18-7: 튜플을 분해하는 매개변수가 있는 함수\n이 코드는 현재 위치: (3, 5)를 인쇄합니다. &amp;(3, 5) 값은 &amp;(x, y) 패턴과 일치하므로 x는 값 3이고 y는 값 5입니다.\n13장에서 논의한 바와 같이 클로저는 함수와 유사하기 때문에 함수 매개변수 목록에서와 같은 방식으로 클로저 매개변수 목록에서 패턴을 사용할 수 있습니다.\n지금까지 패턴을 사용하는 여러 가지 방법을 보았지만 패턴은 사용할 수 있는 모든 위치에서 동일하게 작동하지 않습니다. 어떤 곳에서는 패턴이 반박할 수 없어야 합니다. 다른 상황에서는 반박할 수 있습니다. 이 두 가지 개념에 대해서는 다음에 설명하겠습니다.\n\n반박 가능성: 패턴이 일치하지 않을 수 있는지 여부\n패턴은 반박 가능과 반박 불가의 두 가지 형태로 나타납니다. 전달된 모든 가능한 값과 일치하는 패턴은 반박할 수 없습니다 . 예를 들어 let x = 5; 문에서 x가 있습니다. x는 어떤 것과도 일치하므로 일치하지 않을 수 없기 때문입니다. 일부 가능한 값과 일치하지 않을 수 있는 패턴은 반박 할 수 있습니다. a_value 변수의 값이 Some이 아니라 None인 경우 Some(x) 패턴이 일치하지 않습니다.\n함수 매개변수, let 문 및 for 루프는 값이 일치하지 않으면 프로그램이 의미 있는 작업을 수행할 수 없기 때문에 반박할 수 없는 패턴만 허용할 수 있습니다. if let 및 while let 식은 반박할 수 있는 패턴과 반박할 수 없는 패턴을 허용하지만, 컴파일러는 반박할 수 없는 패턴에 대해 경고합니다. 정의에 따라 이러한 패턴은 가능한 실패를 처리하도록 의도되었기 때문입니다. 성공 또는 실패.\n일반적으로 반박 가능한 패턴과 반박 불가능한 패턴의 구분에 대해 걱정할 필요가 없습니다. 그러나 오류 메시지에 표시될 때 대응할 수 있도록 반박 가능성의 개념에 익숙해야 합니다. 이러한 경우 코드의 의도된 동작에 따라 패턴 또는 패턴을 사용하는 구조를 변경해야 합니다.\nRust가 반박할 수 없는 패턴을 요구하고 그 반대의 경우도 있을 때 우리가 반박할 수 있는 패턴을 사용하려고 할 때 어떤 일이 일어나는지 예를 살펴보겠습니다. 목록 18-8은 let 문을 보여주지만 패턴에 대해 반박 가능한 패턴인 Some(x)를 지정했습니다. 예상하셨겠지만 이 코드는 컴파일되지 않습니다.\n    let Some(x) = some_option_value;\n\nListing 18-8: let과 함께 반박 가능한 패턴 사용 시도\nsome_option_value가 None 값인 경우 Some(x) 패턴과 일치하지 않으므로 패턴이 반박 가능함을 의미합니다. 그러나 코드가 None 값으로 수행할 수 있는 유효한 작업이 없기 때문에 let 문은 반박할 수 없는 패턴만 허용할 수 있습니다. 컴파일 시간에 Rust는 우리가 반박할 수 없는 패턴이 필요한 곳에 반박할 수 있는 패턴을 사용하려고 시도했다고 불평할 것입니다:\n$ cargo run\n   Compiling patterns v0.1.0 (file:///projects/patterns)\nerror[E0005]: refutable pattern in local binding: `None` not covered\n --&gt; src/main.rs:3:9\n  |\n3 |     let Some(x) = some_option_value;\n  |         ^^^^^^^ pattern `None` not covered\n  |\n  = note: `let` bindings require an `irrefutable pattern`, like a `struct` or an `enum` with only one variant\n  = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\nnote: `Option&lt;i32&gt;` defined here\n --&gt; /rustc/d5a82bbd26e1ad8b7401f6a718a9c57c96905483/library/core/src/option.rs:518:1\n  |\n  = note: \n/rustc/d5a82bbd26e1ad8b7401f6a718a9c57c96905483/library/core/src/option.rs:522:5: not covered\n  = note: the matched value is of type `Option&lt;i32&gt;`\nhelp: you might want to use `if let` to ignore the variant that isn`t matched\n  |\n3 |     let x = if let Some(x) = some_option_value { x } else { todo!() };\n  |     ++++++++++                                 ++++++++++++++++++++++\nhelp: alternatively, you might want to use let else to handle the variant that isn`t matched\n  |\n3 |     let Some(x) = some_option_value else { todo!() };\n  |                                     ++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0005`.\nerror: could not compile `patterns` due to previous error\n\nSome(x) 패턴으로 모든 유효한 값을 다루지 않았기 때문에 (그리고 덮을 수도 없었습니다!) Rust는 당연히 컴파일러 오류를 생성합니다.\n반박할 수 없는 패턴이 필요한 경우 패턴을 사용하는 코드를 변경하여 수정할 수 있습니다. let을 사용하는 대신 if let을 사용할 수 있습니다. 그런 다음 패턴이 일치하지 않으면 코드는 중괄호 안의 코드를 건너뛰어 유효하게 계속할 수 있는 방법을 제공합니다. 목록 18-9는 목록 18-8의 코드를 수정하는 방법을 보여줍니다.\n    if let Some(x) = some_option_value {\n        println!(`{}`, x);\n    }\n\nListing 18-9: let 대신 if let과 반박 가능한 패턴이 있는 블록 사용\n우리는 코드를 출력했습니다! 이 코드는 오류를 수신하지 않고 반박할 수 없는 패턴을 사용할 수 없음을 의미하지만 완벽하게 유효합니다. Listing 18-10과 같이 x와 같이 항상 일치하는 패턴을 if let에 지정하면 컴파일러에서 경고를 표시합니다.\n    if let x = 5 {\n        println!(`{}`, x);\n    };\n\nListing 18-10: if let으로 반박할 수 없는 패턴 사용 시도\nRust는 반박할 수 없는 패턴으로 if let을 사용하는 것이 이치에 맞지 않는다고 불평합니다:\n$ cargo run\n   Compiling patterns v0.1.0 (file:///projects/patterns)\nwarning: irrefutable `if let` pattern\n --&gt; src/main.rs:2:8\n  |\n2 |     if let x = 5 {\n  |        ^^^^^^^^^\n  |\n  = note: this pattern will always match, so the `if let` is useless\n  = help: consider replacing the `if let` with a `let`\n  = note: `#[warn(irrefutable_let_patterns)]` on by default\n\nwarning: `patterns` (bin `patterns`) generated 1 warning\n    Finished dev [unoptimized + debuginfo] target(s) in 0.39s\n     Running `target/debug/patterns`\n5\n\n이러한 이유로 매치 암은 반박할 수 없는 패턴을 가진 나머지 값과 일치해야 하는 마지막 암을 제외하고 반박할 수 있는 패턴을 사용해야 합니다. Rust를 사용하면 하나의 팔만 있는 일치에서 반박할 수 없는 패턴을 사용할 수 있지만 이 구문은 특별히 유용하지 않으며 더 간단한 let 문으로 대체될 수 있습니다.\n이제 패턴을 사용하는 위치와 반박 가능한 패턴과 반박 불가능한 패턴의 차이점을 알았으므로 패턴을 만드는 데 사용할 수 있는 모든 구문을 살펴보겠습니다.\n\n패턴 구문\n이 섹션에서는 패턴에 유효한 모든 구문을 수집하고 각 구문을 사용해야 하는 이유와 시기에 대해 논의합니다.\n일치하는 리터럴\n6장에서 보았듯이 패턴을 리터럴과 직접 일치시킬 수 있습니다. 다음 코드는 몇 가지 예를 제공합니다.\n    let x = 1;\n\n    match x {\n        1 =&gt; println!(`one`),\n        2 =&gt; println!(`two`),\n        3 =&gt; println!(`three`),\n        _ =&gt; println!(`anything`),\n    }\n\n이 코드는 x의 값이 1이기 때문에 one을 인쇄합니다. 이 구문은 특정 구체적인 값을 가져오는 경우 코드에서 작업을 수행하려는 경우에 유용합니다.\n명명된 변수 일치\n명명된 변수는 모든 값과 일치하는 반박할 수 없는 패턴이며 책에서 여러 번 사용했습니다. 그러나 일치 식에서 명명된 변수를 사용하면 복잡해집니다. 일치는 새로운 범위를 시작하기 때문에 일치 식 내부에서 패턴의 일부로 선언된 변수는 모든 변수의 경우와 마찬가지로 일치 구문 외부에서 동일한 이름을 가진 변수를 가리게 됩니다. 목록 18-11에서 Some(5) 값을 가진 x라는 이름의 변수와 10 값을 가진 변수 y를 선언합니다. 그런 다음 값 x에 대해 일치 식을 만듭니다. 성냥 팔의 패턴을 보고 println! 마지막에 이 코드를 실행하거나 더 읽기 전에 코드가 무엇을 인쇄할지 알아내십시오.\n파일 이름: src/main.rs\n    let x = Some(5);\n    let y = 10;\n\n    match x {\n        Some(50) =&gt; println!(`Got 50`),\n        Some(y) =&gt; println!(`Matched, y = {y}`),\n        _ =&gt; println!(`Default case, x = {:?}`, x),\n    }\n    \n    println!(`at the end: x = {:?}, y = {y}`, x);\n\n목록 18-11: 그림자 변수 y를 도입하는 팔이 있는 일치 표현식\n일치 표현식이 실행될 때 어떤 일이 발생하는지 살펴보겠습니다. 첫 번째 일치 부분의 패턴이 정의된 x 값과 일치하지 않으므로 코드가 계속됩니다.\n두 번째 일치 부분의 패턴은 Some 값 내의 모든 값과 일치하는 y라는 새 변수를 도입합니다. 우리는 일치 식 내부의 새로운 범위에 있기 때문에 이것은 새로운 y 변수이며 처음에 값 10으로 선언한 y가 아닙니다. 이 새로운 y 바인딩은 내부의 모든 값과 일치합니다. X에 있는 Some입니다. 따라서 이 새로운 y는 x의 Some의 내부 값에 바인딩됩니다. 해당 값은 5이므로 해당 암에 대한 표현식이 실행되고 Matched, y = 5가 인쇄됩니다.\nx가 Some(5)가 아니라 없음 값이었다면 처음 두 팔의 패턴이 일치하지 않았기 때문에 값이 밑줄과 일치했을 것입니다. 밑줄 암의 패턴에 x 변수를 도입하지 않았으므로 표현식의 x는 여전히 음영 처리되지 않은 외부 x입니다. 이 가상의 경우 일치는 기본 사례, x = 없음을 인쇄합니다.\n일치 표현식이 완료되면 해당 범위가 종료되고 내부 y의 범위도 종료됩니다. 마지막 println! 끝에: x = Some(5), y = 10을 생성합니다.\n숨겨진 변수를 도입하는 대신 외부 x 및 y 값을 비교하는 일치 식을 만들려면 대신 일치 가드 조건을 사용해야 합니다. 매치 가드에 대해서는 나중에 매치 가드가 있는 추가 조건 섹션 에서 이야기하겠습니다.\n여러 패턴\n일치 식에서 | 기호를 사용하여 여러 패턴을 일치시킬 수 있습니다. 패턴 또는 연산자인 구문입니다. 예를 들어, 다음 코드에서 x 값을 일치 항목과 일치시킵니다. 첫 번째 항목에는 or 옵션 이 있습니다. 즉, x 값이 해당 항목의 값 중 하나와 일치하면 해당 항목의 코드는 달리다:\n    let x = 1;\n\n    match x {\n        1 | 2 =&gt; println!(`one or two`),\n        3 =&gt; println!(`three`),\n        _ =&gt; println!(`anything`),\n    }\n\n이 코드는 one or two를 출력합니다.\n..=를 사용하여 일치하는 값 범위\n..= 구문을 사용하면 포괄적인 범위의 값과 일치시킬 수 있습니다. 다음 코드에서 패턴이 주어진 범위 내의 값과 일치하면 해당 암이 실행됩니다.\n    let x = 5;\n\n    match x {\n        1..=5 =&gt; println!(`one through five`),\n        _ =&gt; println!(`something else`),\n    }\n\nx가 1, 2, 3, 4 또는 5이면 첫 번째 팔이 일치합니다. 이 구문은 |를 사용하는 것보다 여러 일치 값에 더 편리합니다. 같은 생각을 표현하는 연산자; |를 사용한다면 1 | 2 | 3 | 4 | 5를 지정해야 합니다. 범위를 지정하는 것은 훨씬 짧습니다. 특히 1에서 1,000 사이의 숫자를 일치시키려는 경우 더욱 그렇습니다!\n컴파일러는 컴파일 시간에 범위가 비어 있지 않은지 확인하고 Rust가 범위가 비어 있는지 여부를 알 수 있는 유일한 유형이 char 및 숫자 값이기 때문에 범위는 숫자 또는 char 값에만 허용됩니다. .\n다음은 char 값의 범위를 사용하는 예입니다.\n    let x = `c`;\n\n    match x {\n        `a`..=`j` =&gt; println!(`early ASCII letter`),\n        `k`..=`z` =&gt; println!(`late ASCII letter`),\n        _ =&gt; println!(`something else`),\n    }\n\nRust는 c가 첫 번째 패턴의 범위 내에 있고 초기 ASCII 문자를 인쇄한다고 말할 수 있습니다.\n가치를 분리하기 위한 파괴\n또한 패턴을 사용하여 구조체, 열거형 및 튜플을 분해하여 이러한 값의 다른 부분을 사용할 수 있습니다. 각 값을 살펴보겠습니다.\n구조 파괴\n목록 18-12는 let 문이 있는 패턴을 사용하여 분리할 수 있는 x와 y의 두 필드가 있는 Point 구조체를 보여줍니다.\n파일 이름: src/main.rs\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let p = Point { x: 0, y: 7 };\n\n    let Point { x: a, y: b } = p;\n    assert_eq!(0, a);\n    assert_eq!(7, b);\n}\n\n목록 18-12: 구조체의 필드를 별도의 변수로 분해\n이 코드는 p 구조체의 x 및 y 필드 값과 일치하는 변수 a 및 b를 만듭니다. 이 예는 패턴의 변수 이름이 구조체의 필드 이름과 일치할 필요가 없음을 보여줍니다. 그러나 어떤 변수가 어떤 필드에서 왔는지 쉽게 기억할 수 있도록 변수 이름을 필드 이름과 일치시키는 것이 일반적입니다. 이러한 일반적인 사용법과 let Point { x: x, y: y } = p;라고 쓰기 때문입니다. 많은 중복이 포함되어 있고 Rust에는 구조체 필드와 일치하는 패턴에 대한 약칭이 있습니다. 구조체 필드의 이름만 나열하면 되며 패턴에서 생성된 변수는 동일한 이름을 갖게 됩니다. Listing 18-13은 Listing 18-12의 코드와 동일한 방식으로 동작하지만 let 패턴에서 생성된 변수는 `\n파일 이름: src/main.rs\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nfn main() {\n    let p = Point { x: 0, y: 7 };\n\n    let Point { x, y } = p;\n    assert_eq!(0, x);\n    assert_eq!(7, y);\n}\n\nListing 18-13: struct field 속기를 사용하여 구조체 필드 분해\n이 코드는 p 변수의 x 및 y 필드와 일치하는 변수 x 및 y를 생성합니다. 결과는 변수 x 및 y가 p 구조체의 값을 포함한다는 것입니다.\n모든 필드에 대한 변수를 생성하는 대신 구조체 패턴의 일부로 리터럴 값을 사용하여 구조를 분해할 수도 있습니다. 이렇게 하면 특정 값에 대한 일부 필드를 테스트하는 동시에 다른 필드를 해체하는 변수를 생성할 수 있습니다.\nListing 18-14에는 Point 값을 세 가지 경우로 구분하는 일치 표현식이 있습니다. x 축(y = 0일 때 참)에 바로 있는 점, y 축에 있는 점 축(x = 0)이거나 둘 다 아닙니다.\n파일 이름: src/main.rs\nfn main() {\n    let p = Point { x: 0, y: 7 };\n\n    match p {\n        Point { x, y: 0 } =&gt; println!(`On the x axis at {x}`),\n        Point { x: 0, y } =&gt; println!(`On the y axis at {y}`),\n        Point { x, y } =&gt; {\n            println!(`On neither axis: ({x}, {y})`);\n        }\n    }\n}\n\n목록 18-14: 하나의 패턴에서 리터럴 값을 분해하고 일치시키기\n첫 번째 팔은 값이 리터럴 0과 일치하는 경우 y 필드가 일치하도록 지정하여 x축에 있는 모든 지점과 일치합니다. 패턴은 여전히 이 팔의 코드에서 사용할 수 있는 x 변수를 생성합니다.\n마찬가지로 두 번째 팔은 값이 0인 경우 x 필드가 일치하도록 지정하고 y 필드 값에 대해 변수 y를 생성하여 y 축의 모든 지점과 일치시킵니다. 세 번째 팔은 리터럴을 지정하지 않으므로 다른 모든 포인트와 일치하고 x 및 y 필드 모두에 대한 변수를 만듭니다.\n이 예제에서 값 p는 0을 포함하는 x 덕분에 두 번째 팔과 일치하므로 이 코드는 7에서 y축에를 인쇄합니다.\n일치 식은 일치하는 첫 번째 패턴을 찾으면 암 검사를 중지하므로 점 { x: 0, y: 0}이 x축과 y축에 있더라도 이 코드는 0의 x 축에서만 인쇄합니다.\n열거형 분해\n우리는 이 책에서 열거형을 해체했지만(예를 들어 6장의 Listing 6-5) 열거형을 해체하는 패턴이 열거형 내에 저장된 데이터가 정의되는 방식과 일치하는지 아직 명시적으로 논의하지 않았습니다. 예를 들어, 목록 18-15에서 우리는 목록 6-2의 Message 열거형을 사용하고 각 내부 값을 분해할 패턴으로 일치를 작성합니다.\n파일 이름: src/main.rs\nenum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n}\n\nfn main() {\n    let msg = Message::ChangeColor(0, 160, 255);\n\n    match msg {\n        Message::Quit =&gt; {\n            println!(`The Quit variant has no data to destructure.`);\n        }\n        Message::Move { x, y } =&gt; {\n            println!(`Move in the x direction {x} and in the y direction {y}`);\n        }\n        Message::Write(text) =&gt; {\n            println!(`Text message: {text}`);\n        }\n        Message::ChangeColor(r, g, b) =&gt; {\n            println!(`Change the color to red {r}, green {g}, and blue {b}`,)\n        }\n    }\n}\n\nListing 18-15: 다른 종류의 값을 보유하는 enum 변형 분해\n이 코드는 색상을 빨간색 0, 녹색 160 및 파란색 255로 변경을 인쇄합니다. msg 값을 변경하여 다른 팔 실행의 코드를 확인하십시오.\nMessage::Quit와 같이 데이터가 없는 열거형 변형의 경우 더 이상 값을 분해할 수 없습니다. 리터럴 Message::Quit 값에서만 일치시킬 수 있으며 해당 패턴에는 변수가 없습니다.\nMessage::Move와 같은 구조체와 유사한 열거형 변형의 경우 구조체를 일치시키기 위해 지정하는 패턴과 유사한 패턴을 사용할 수 있습니다. 변형 이름 뒤에 중괄호를 넣은 다음 변수가 있는 필드를 나열하여 이 팔의 코드에서 사용할 조각을 나눕니다. 여기서 우리는 Listing 18-13에서 했던 것처럼 속기 형식을 사용합니다.\n하나의 요소가 있는 튜플을 보유하는 Message::Write 및 세 개의 요소가 있는 튜플을 보유하는 Message::ChangeColor와 같은 튜플과 같은 열거형 변형의 경우 패턴은 튜플을 일치시키기 위해 지정하는 패턴과 유사합니다. 패턴의 변수 수는 일치하는 변형의 요소 수와 일치해야 합니다.\n중첩된 구조체 및 열거형 분해\n지금까지 우리의 예제는 모두 한 수준 깊이의 구조체 또는 열거형을 일치시켰지만 일치는 중첩된 항목에서도 작동할 수 있습니다! 예를 들어, 목록 18-16에 표시된 것처럼 ChangeColor 메시지에서 RGB 및 HSV 색상을 지원하도록 목록 18-15의 코드를 리팩터링할 수 있습니다.\nenum Color {\n    Rgb(i32, i32, i32),\n    Hsv(i32, i32, i32),\n}\n\nenum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(Color),\n}\n\nfn main() {\n    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));\n\n    match msg {\n        Message::ChangeColor(Color::Rgb(r, g, b)) =&gt; {\n            println!(`Change color to red {r}, green {g}, and blue {b}`);\n        }\n        Message::ChangeColor(Color::Hsv(h, s, v)) =&gt; {\n            println!(`Change color to hue {h}, saturation {s}, value {v}`)\n        }\n        _ =&gt; (),\n    }\n}\n\nListing 18-16: 중첩 열거형에 대한 일치\n일치 식의 첫 번째 암 패턴은 Color::Rgb 변형을 포함하는 Message::ChangeColor 열거형 변형과 일치합니다. 그런 다음 패턴은 세 개의 내부 i32 값에 바인딩됩니다. 두 번째 팔의 패턴도 Message::ChangeColor 열거형 변형과 일치하지만 내부 열거형은 대신 Color::Hsv와 일치합니다. 두 개의 열거형이 포함되어 있어도 하나의 일치 식으로 이러한 복잡한 조건을 지정할 수 있습니다.\n구조체와 튜플의 구조 분해\n훨씬 더 복잡한 방식으로 구조 분해 패턴을 혼합, 일치 및 중첩할 수 있습니다. 다음 예제는 튜플 내부에 구조체와 튜플을 중첩하고 모든 기본 값을 분해하는 복잡한 분해를 보여줍니다.\n    let ((feet, inches), Point { x, y }) = ((3, 10), Point { x: 3, y: -10 });\n\n이 코드를 사용하면 복잡한 유형을 구성 요소 부분으로 나눌 수 있으므로 관심 있는 값을 별도로 사용할 수 있습니다.\n패턴을 사용한 구조 분해는 구조체의 각 필드 값과 같은 값 조각을 서로 별도로 사용하는 편리한 방법입니다.\n패턴의 값 무시\n일치의 마지막 부분과 같은 패턴의 값을 무시하여 실제로 아무 작업도 수행하지 않고 나머지 가능한 모든 값을 설명하는 포괄적인 값을 얻는 것이 때때로 유용하다는 것을 확인했습니다. 패턴에서 전체 값 또는 값의 일부를 무시하는 몇 가지 방법이 있습니다.  * 패턴 사용,* 다른 패턴 내에서   패턴 사용, 밑줄로 시작하는 이름 사용 또는 .. 값의 나머지 부분을 무시합니다. 이러한 각 패턴을 사용하는 방법과 이유를 살펴보겠습니다.\n_로 전체 값 무시\n모든 값과 일치하지만 값에 바인딩되지 않는 와일드카드 패턴으로 밑줄을 사용했습니다. 이것은 일치 표현식의 마지막 팔로 특히 유용하지만 목록 18-17에 표시된 것처럼 함수 매개변수를 포함하여 모든 패턴에서 사용할 수도 있습니다.\n파일 이름: src/main.rs\nfn foo(_: i32, y: i32) {\n    println!(`This code only uses the y parameter: {}`, y);\n}\n\nfn main() {\n    foo(3, 4);\n}\n\nListing 18-17: 함수 서명에서 _ 사용하기\n이 코드는 첫 번째 인수로 전달된 값 3을 완전히 무시하고 이 코드는 y 매개변수만 사용합니다: 4를 인쇄합니다.\n특정 함수 매개변수가 더 이상 필요하지 않은 대부분의 경우 사용하지 않는 매개변수를 포함하지 않도록 서명을 변경합니다. 함수 매개변수를 무시하는 것은 예를 들어 특정 유형 서명이 필요할 때 특성을 구현하는 경우에 특히 유용할 수 있지만 구현의 함수 본문에는 매개변수 중 하나가 필요하지 않습니다. 그러면 컴파일러를 가져오는 것을 피할 수 있습니다. 이름을 대신 사용한 경우처럼 사용하지 않는 함수 매개변수에 대한 경고.\n중첩된 _가 있는 값의 일부 무시\n예를 들어 값의 일부만 테스트하고 실행하려는 해당 코드의 다른 부분은 사용하지 않으려는 경우와 같이 다른 패턴 내부에서 _를 사용하여 값의 일부만 무시할 수 있습니다. 목록 18-18은 설정 값 관리를 담당하는 코드를 보여줍니다. 비즈니스 요구 사항은 사용자가 설정의 기존 사용자 지정을 덮어쓸 수 없어야 하지만 현재 설정이 해제된 경우 설정을 해제하고 값을 지정할 수 있어야 한다는 것입니다.\n    let mut setting_value = Some(5);\n    let new_setting_value = Some(10);\n\n    match (setting_value, new_setting_value) {\n        (Some(_), Some(_)) =&gt; {\n            println!(`Can`t overwrite an existing customized value`);\n        }\n        _ =&gt; {\n            setting_value = new_setting_value;\n        }\n    }\n    \n    println!(`setting is {:?}`, setting_value);\n\n목록 18-18: Some 내부의 값을 사용할 필요가 없을 때 Some 변형과 일치하는 패턴 내에서 밑줄 사용\n이 코드는 기존 사용자 지정 값을 덮어쓸 수 없습니다를 인쇄한 다음 설정이 Some(5)입니다를 인쇄합니다. 첫 번째 일치 항목에서는 Some 변형 내부의 값을 일치시키거나 사용할 필요가 없습니다. 하지만 setting_value와 new_setting_value가 Some 변종인 경우에 대한 테스트가 필요합니다. 이 경우 setting_value를 변경하지 않은 이유를 인쇄하고 변경되지 않습니다.\n두 번째 팔의 _ 패턴으로 표현되는 다른 모든 경우(setting_value 또는 new_setting_value가 None인 경우)에서는 new_setting_value가 setting_value가 되도록 허용하려고 합니다.\n특정 값을 무시하기 위해 하나의 패턴 내 여러 위치에서 밑줄을 사용할 수도 있습니다. 목록 18-19는 5개 항목의 튜플에서 두 번째 및 네 번째 값을 무시하는 예를 보여줍니다.\n    let numbers = (2, 4, 8, 16, 32);\n\n    match numbers {\n        (first, _, third, _, fifth) =&gt; {\n            println!(`Some numbers: {first}, {third}, {fifth}`)\n        }\n    }\n\nListing 18-19: 튜플의 여러 부분 무시하기\n이 코드는 일부 숫자: 2, 8, 32를 인쇄하고 값 4와 16은 무시합니다.\n이름을 _로 시작하여 사용하지 않는 변수 무시\n변수를 생성했지만 어디에도 사용하지 않으면 Rust는 일반적으로 사용하지 않는 변수가 버그일 수 있으므로 경고를 발행합니다. 그러나 프로토타입을 만들거나 프로젝트를 시작할 때와 같이 아직 사용하지 않을 변수를 만들 수 있는 것이 유용한 경우도 있습니다. 이 상황에서 변수 이름을 밑줄로 시작하여 사용하지 않는 변수에 대해 경고하지 않도록 Rust에 지시할 수 있습니다. 목록 18-20에서 우리는 두 개의 사용하지 않는 변수를 생성하지만 이 코드를 컴파일할 때 그 중 하나에 대한 경고만 받아야 합니다.\n파일 이름: src/main.rs\nfn main() {\n    let _x = 5;\n    let y = 10;\n}\n\nListing 18-20: 사용하지 않는 변수 경고를 피하기 위해 변수 이름을 밑줄로 시작\n여기에서 변수 y를 사용하지 않는다는 경고가 표시되지만 _x를 사용하지 않는다는 경고는 표시되지 않습니다.\n_만 사용하는 것과 밑줄로 시작하는 이름을 사용하는 것 사이에는 미묘한 차이가 있습니다. 구문  *x는 여전히 값을 변수에 바인딩하지만 * 는 전혀 바인딩하지 않습니다. 이 구분이 중요한 경우를 보여주기 위해 Listing 18-21에 오류가 표시됩니다.\n    let s = Some(String::from(`Hello!`));\n\n    if let Some(_s) = s {\n        println!(`found a string`);\n    }\n    \n    println!(`{:?}`, s);\n\nListing 18-21: 밑줄로 시작하는 사용되지 않은 변수는 여전히 값을 바인딩하며 값의 소유권을 가질 수 있습니다.\ns 값이 여전히  s로 이동되어 s를 다시 사용할 수 없기 때문에 오류가 발생합니다. 그러나 밑줄 자체를 사용하면 값에 바인딩되지 않습니다. 목록 18-22는 s가  로 이동되지 않기 때문에 오류 없이 컴파일됩니다 .\n    let s = Some(String::from(`Hello!`));\n\n    if let Some(_) = s {\n        println!(`found a string`);\n    }\n    \n    println!(`{:?}`, s);\n\nListing 18-22: 밑줄을 사용해도 값이 바인딩되지 않습니다.\n이 코드는 s를 어떤 것에 바인딩하지 않기 때문에 잘 작동합니다. 이동되지 않습니다.\n..로 값의 나머지 부분 무시\n많은 부분이 있는 값의 경우 .. 구문을 사용하여 특정 부분을 사용하고 나머지는 무시할 수 있으므로 무시된 각 값에 대해 밑줄을 나열할 필요가 없습니다. .. 패턴은 패턴의 나머지 부분에서 명시적으로 일치하지 않은 값의 일부를 무시합니다. 목록 18-23에는 3차원 공간에서 좌표를 보유하는 Point 구조체가 있습니다. 일치 표현식에서 x 좌표에서만 작동하고 y 및 z 필드의 값은 무시하려고 합니다.\n    struct Point {\n        x: i32,\n        y: i32,\n        z: i32,\n    }\n\n    let origin = Point { x: 0, y: 0, z: 0 };\n    \n    match origin {\n        Point { x, .. } =&gt; println!(`x is {}`, x),\n    }\n\n목록 18-23: ..를 사용하여 x를 제외한 Point의 모든 필드 무시\nx 값을 나열한 다음 .. 패턴만 포함합니다. 이것은 y: _ 및 z: _를 나열하는 것보다 빠릅니다. 특히 하나 또는 두 개의 필드만 관련된 상황에서 많은 필드가 있는 구조체로 작업할 때 그렇습니다.\n.. 구문은 필요한 만큼 많은 값으로 확장됩니다. 목록 18-24는 튜플과 함께 ..를 사용하는 방법을 보여줍니다.\n파일 이름: src/main.rs\nfn main() {\n    let numbers = (2, 4, 8, 16, 32);\n\n    match numbers {\n        (first, .., last) =&gt; {\n            println!(`Some numbers: {first}, {last}`);\n        }\n    }\n}\n\n목록 18-24: 튜플의 첫 번째 값과 마지막 값만 일치시키고 다른 모든 값은 무시\n이 코드에서 첫 번째 값과 마지막 값은 first 및 last와 일치합니다. ..는 중간에 있는 모든 항목을 일치시키고 무시합니다.\n그러나 ..를 사용하는 것은 모호하지 않아야 합니다. 일치를 위한 값과 무시해야 하는 값이 명확하지 않은 경우 Rust는 오류를 표시합니다. 목록 18-25는 ..를 모호하게 사용하는 예를 보여주므로 컴파일되지 않습니다.\n파일 이름: src/main.rs\nfn main() {\n    let numbers = (2, 4, 8, 16, 32);\n\n    match numbers {\n        (.., second, ..) =&gt; {\n            println!(`Some numbers: {}`, second)\n        },\n    }\n}\n\nListing 18-25: 모호한 방식으로 ..를 사용하려는 시도\n이 예제를 컴파일하면 다음 오류가 발생합니다.\n$ cargo run\n   Compiling patterns v0.1.0 (file:///projects/patterns)\nerror: `..` can only be used once per tuple pattern\n --&gt; src/main.rs:5:22\n  |\n5 |         (.., second, ..) =&gt; {\n  |          --          ^^ can only be used once per tuple pattern\n  |          |\n  |          previously used here\n\nerror: could not compile `patterns` due to previous error\n\nRust가 값을 second와 일치시키기 전에 무시할 튜플의 값 수와 그 이후에 무시할 추가 값 수를 결정하는 것은 불가능합니다. 이 코드는 2를 무시하고 second를 4에 바인딩한 다음 8, 16 및 32를 무시하려는 것을 의미할 수 있습니다. 또는 2와 4를 무시하고 second를 8에 바인딩한 다음 16과 32를 무시하려고 합니다. 기타 등등. 변수 이름 second는 Rust에 특별한 의미가 없으므로 이렇게 두 위치에 ..를 사용하는 것이 모호하기 때문에 컴파일러 오류가 발생합니다.\n매치 가드가 있는 추가 조건부\n일치 가드는 일치 암의 패턴 뒤에 지정되는 추가 if 조건으로, 해당 암이 선택되도록 일치해야 합니다. 매치 가드는 패턴만으로 허용되는 것보다 더 복잡한 아이디어를 표현하는 데 유용합니다.\n조건은 패턴에서 생성된 변수를 사용할 수 있습니다. Listing 18-26은 첫 번째 팔이 Some(x) 패턴을 갖고 if x % 2 == 0(숫자가 짝수이면 참일 것임)의 일치 가드를 갖는 일치를 보여줍니다.\n    let num = Some(4);\n\n    match num {\n        Some(x) if x % 2 == 0 =&gt; println!(`The number {} is even`, x),\n        Some(x) =&gt; println!(`The number {} is odd`, x),\n        None =&gt; (),\n    }\n\nListing 18-26: 패턴에 매치 가드 추가하기\n이 예는 The number 4 is even을 인쇄합니다. num이 첫 번째 팔의 패턴과 비교될 때 Some(4)가 Some(x)와 일치하기 때문에 일치합니다. 그런 다음 매치 가드는 x를 2로 나눈 나머지가 0인지 확인하고 그렇기 때문에 첫 번째 팔을 선택합니다.\n대신 num이 Some(5)인 경우 첫 번째 팔의 매치 가드는 5를 2로 나눈 나머지가 1이고 0이 아니기 때문에 거짓이 됩니다. 그런 다음 Rust는 두 번째 팔로 이동합니다. 두 번째 팔에는 매치 가드가 없으므로 모든 일부 변형과 일치하기 때문에 일치합니다.\n패턴 내에서 if x % 2 == 0 조건을 표현할 방법이 없으므로 매치 가드는 이 논리를 표현할 수 있는 기능을 제공합니다. 이 추가적인 표현력의 단점은 컴파일러가 매치 가드 표현식이 포함될 때 철저함을 확인하려고 시도하지 않는다는 것입니다.\n목록 18-11에서 우리는 패턴 그림자 문제를 해결하기 위해 매치 가드를 사용할 수 있다고 언급했습니다. 일치 외부의 변수를 사용하는 대신 일치 표현식의 패턴 내부에 새 변수를 생성했음을 기억하십시오. 새 변수는 외부 변수의 값에 대해 테스트할 수 없음을 의미했습니다. 목록 18-27은 매치 가드를 사용하여 이 문제를 해결하는 방법을 보여줍니다.\n파일 이름: src/main.rs\nfn main() {\n    let x = Some(5);\n    let y = 10;\n\n    match x {\n        Some(50) =&gt; println!(`Got 50`),\n        Some(n) if n == y =&gt; println!(`Matched, n = {n}`),\n        _ =&gt; println!(`Default case, x = {:?}`, x),\n    }\n    \n    println!(`at the end: x = {:?}, y = {y}`, x);\n}\n\nListing 18-27: 매치 가드를 사용하여 외부 변수와의 동등성 테스트\n이 코드는 이제 Default case, x = Some(5)를 인쇄합니다. 두 번째 매치 암의 패턴은 외부 y를 가리는 새 변수 y를 도입하지 않습니다. 즉, 매치 가드에서 외부 y를 사용할 수 있습니다. 외부 y를 가리는 Some(y)로 패턴을 지정하는 대신 Some(n)을 지정합니다. 이렇게 하면 일치 외부에 n 변수가 없기 때문에 아무 것도 숨기지 않는 새 변수 n이 생성됩니다.\n매치 가드 if n == y는 패턴이 아니므로 새 변수를 도입하지 않습니다. 이 y 는 음영 처리된 새로운 y가 아닌 외부 y이며 n과 y를 비교하여 외부 y와 동일한 값을 갖는 값을 찾을 수 있습니다.\n또는 연산자 |를 사용할 수도 있습니다. 매치 가드에서 여러 패턴을 지정합니다. 매치 가드 조건은 모든 패턴에 적용됩니다. 목록 18-28은 |를 사용하는 패턴을 결합할 때의 우선 순위를 보여줍니다. 매치 가드와 함께. 이 예제의 중요한 부분은 if y가 6에만 적용되는 것처럼 보일 수 있지만 if y 일치 가드가 4, 5 및 6에 적용된다는 것입니다.\n    let x = 4;\n    let y = false;\n\n    match x {\n        4 | 5 | 6 if y =&gt; println!(`yes`),\n        _ =&gt; println!(`no`),\n    }\n\nListing 18-28: 매치 가드로 여러 패턴 결합하기\n일치 조건은 x 값이 4, 5 또는 6과 같고 y가 true인 경우 에만 팔이 일치한다고 명시합니다. 이 코드를 실행하면 x가 4이므로 첫 번째 팔의 패턴이 일치하지만 일치 가드 if y가 false이므로 첫 번째 팔이 선택되지 않습니다. 코드는 일치하는 두 번째 팔로 이동하고 이 프로그램은 no를 인쇄합니다. 그 이유는 if 조건이 마지막 값 6뿐만 아니라 패턴 4 | 5 | 6 전체에 적용되기 때문입니다. 즉, 패턴과 관련하여 매치 가드의 우선 순위는 다음과 같이 작동합니다.\n(4 | 5 | 6) if y =&gt; ...\n\n이것보다는:\n4 | 5 | (6 if y) =&gt; ...\n\n코드를 실행한 후 우선 순위 동작이 분명합니다. 일치 가드가 |를 사용하여 지정된 값 목록의 최종 값에만 적용된 경우 연산자를 사용하면 암이 일치하고 프로그램이 예를 인쇄했을 것입니다.\n@ 바인딩\nat 연산자 @를 사용하면 패턴 일치를 위해 해당 값을 테스트하는 동시에 값을 보유하는 변수를 만들 수 있습니다 . 목록 18-29에서 Message::Hello id 필드가 3..=7 범위 내에 있는지 테스트하고 싶습니다. 또한 팔과 관련된 코드에서 사용할 수 있도록 변수 id_variable에 값을 바인딩하려고 합니다. 이 변수의 이름을 필드와 동일하게 id로 지정할 수 있지만 이 예에서는 다른 이름을 사용합니다.\n    enum Message {\n        Hello { id: i32 },\n    }\n\n    let msg = Message::Hello { id: 5 };\n    \n    match msg {\n        Message::Hello {\n            id: id_variable @ 3..=7,\n        } =&gt; println!(`Found an id in range: {}`, id_variable),\n        Message::Hello { id: 10..=12 } =&gt; {\n            println!(`Found an id in another range`)\n        }\n        Message::Hello { id } =&gt; println!(`Found some other id: {}`, id),\n    }\n\nListing 18-29: @를 사용하여 테스트하는 동안 패턴의 값에 바인딩\n이 예는 Found an id in range: 5를 인쇄합니다. 3..=7 범위 앞에 id_variable @를 지정하면 값이 범위 패턴과 일치하는지 테스트하면서 범위와 일치하는 모든 값을 캡처합니다.\n패턴에 지정된 범위만 있는 두 번째 팔에서 팔과 연결된 코드에는 id 필드의 실제 값을 포함하는 변수가 없습니다. id 필드의 값은 10, 11 또는 12일 수 있지만 해당 패턴과 관련된 코드는 그것이 무엇인지 모릅니다. id 값을 변수에 저장하지 않았기 때문에 패턴 코드는 id 필드의 값을 사용할 수 없습니다.\n범위 없이 변수를 지정한 마지막 단계에서 id라는 변수의 단계 코드에서 사용할 수 있는 값이 있습니다. 그 이유는 우리가 구조체 필드 속기 구문을 사용했기 때문입니다. 그러나 처음 두 개의 팔에서 했던 것처럼 이 팔의 id 필드 값에 어떤 테스트도 적용하지 않았습니다. 모든 값이 이 패턴과 일치합니다.\n@를 사용하면 값을 테스트하고 한 패턴 내의 변수에 저장할 수 있습니다.\n요약\nRust의 패턴은 서로 다른 종류의 데이터를 구별하는 데 매우 유용합니다. 일치 표현식에 사용될 때 Rust는 패턴이 가능한 모든 값을 포함하도록 보장합니다. 그렇지 않으면 프로그램이 컴파일되지 않습니다. let 문과 함수 매개변수의 패턴은 이러한 구조를 더 유용하게 만들어 변수에 할당하는 동시에 값을 더 작은 부분으로 분해할 수 있도록 합니다. 필요에 따라 간단하거나 복잡한 패턴을 만들 수 있습니다.\n다음으로, 이 책의 끝에서 두 번째 장에서는 다양한 Rust 기능의 몇 가지 고급 측면을 살펴보겠습니다.\n\n19\n고급 기능\n지금까지 Rust 프로그래밍 언어에서 가장 일반적으로 사용되는 부분을 배웠습니다. 20장에서 프로젝트를 하나 더 수행하기 전에 가끔 접할 수 있지만 매일 사용하지는 않는 언어의 몇 가지 측면을 살펴보겠습니다. 미지수를 만났을 때 이 장을 참조로 사용할 수 있습니다. 여기서 다루는 기능은 매우 특정한 상황에서 유용합니다. 자주 접할 수는 없지만 Rust가 제공하는 모든 기능을 이해하고 있는지 확인하고 싶습니다.\n이 장에서는 다음을 다룰 것입니다.\n\n안전하지 않은 Rust: Rust의 보증 중 일부를 거부하고 이러한 보증을 수동으로 유지하는 책임을 지는 방법\n고급 특성: 연관 유형, 기본 유형 매개변수, 정규화된 구문, 상위 특성 및 특성과 관련된 새로운 유형 패턴\n고급 유형: newtype 패턴, 유형 별칭, 절대 유형 및 동적 크기 유형에 대한 추가 정보\n고급 함수 및 클로저: 함수 포인터 및 반환 클로저\n매크로: 컴파일 시간에 더 많은 코드를 정의하는 코드를 정의하는 방법\n\n모든 사람을 위한 Rust 기능의 웅장함입니다! 다이빙하자!\n\n안전하지 않은 녹\n지금까지 우리가 논의한 모든 코드는 컴파일 타임에 러스트의 메모리 안전 보장을 시행했습니다. 그러나 Rust에는 이러한 메모리 안전 보장을 시행하지 않는 두 번째 언어가 숨겨져 있습니다. 안전하지 않은 Rust 라고 하며 일반 Rust처럼 작동하지만 추가 초능력을 제공합니다.\nUnsafe Rust가 존재하는 이유는 본질적으로 정적 분석이 보수적이기 때문입니다. 컴파일러가 코드가 보증을 유지하는지 여부를 결정하려고 할 때 일부 유효하지 않은 프로그램을 허용하는 것보다 일부 유효한 프로그램을 거부하는 것이 좋습니다. 코드는 괜찮을 수 있지만 Rust 컴파일러가 확신할 수 있는 충분한 정보가 없으면 코드를 거부합니다. 이 경우 안전하지 않은 코드를 사용하여 컴파일러에 날 믿어, 내가 뭘 하는지 알아.라고 말할 수 있습니다. 그러나 안전하지 않은 Rust를 사용하는 데 따른 위험은 사용자가 감수해야 합니다. 안전하지 않은 코드를 잘못 사용하면 널 포인터 역참조와 같은 메모리 안전하지 않은 문제가 발생할 수 있습니다.\nRust가 안전하지 않은 분신을 갖는 또 다른 이유는 기본 컴퓨터 하드웨어가 본질적으로 안전하지 않기 때문입니다. Rust가 안전하지 않은 작업을 허용하지 않으면 특정 작업을 수행할 수 없습니다. Rust는 운영 체제와 직접 상호 작용하거나 심지어 자신의 운영 체제를 작성하는 것과 같은 저수준 시스템 프로그래밍을 수행할 수 있도록 허용해야 합니다. 저수준 시스템 프로그래밍 작업은 언어의 목표 중 하나입니다. 안전하지 않은 Rust로 무엇을 할 수 있고 어떻게 하는지 탐구해 봅시다.\n안전하지 않은 초능력\n안전하지 않은 Rust로 전환하려면 unsafe 키워드를 사용한 다음 안전하지 않은 코드를 포함하는 새 블록을 시작하세요. 안전하지 않은 Rust에서는 할 수 없는 다섯 가지 조치를 취할 수 있습니다 . 이러한 초능력에는 다음과 같은 기능이 포함됩니다.\n\n원시 포인터 역참조\n안전하지 않은 함수 또는 메서드 호출\n변경 가능한 정적 변수 액세스 또는 수정\n안전하지 않은 특성 구현\nunion의 액세스 필드\n\nunsafe는 빌림 검사기를 끄거나 Rust의 다른 안전 검사를 비활성화하지 않는다는 것을 이해하는 것이 중요합니다. 안전하지 않은 코드에서 참조를 사용하는 경우에도 여전히 검사됩니다. unsafe 키워드는 메모리 안전을 위해 컴파일러에서 검사하지 않는 이 다섯 가지 기능에 대한 액세스만 제공합니다. 안전하지 않은 블록 내부에서도 어느 정도의 안전을 확보할 수 있습니다.\n또한 안전하지 않음은 블록 내부의 코드가 반드시 위험하거나 메모리 안전 문제가 있음을 의미하지 않습니다. 의도는 프로그래머로서 안전하지 않은 블록 내부의 코드가 메모리에 액세스하도록 보장하는 것입니다. 유효한 방법으로.\n사람들은 오류를 범할 수 있고 실수가 발생할 수 있지만 이러한 다섯 가지 안전하지 않은 작업이 안전하지 않음으로 주석이 달린 블록 내부에 있어야 하므로 메모리 안전과 관련된 모든 오류가 안전하지 않은 블록 내에 있어야 함을 알 수 있습니다. 안전하지 않은 블록을 작게 유지하십시오. 나중에 메모리 버그를 조사하면 감사하게 될 것입니다.\n안전하지 않은 코드를 최대한 격리하려면 안전한 추상화 내에서 안전하지 않은 코드를 묶고 안전한 API를 제공하는 것이 가장 좋습니다. 이 장의 뒷부분에서 안전하지 않은 함수와 메서드를 검토할 때 이에 대해 논의할 것입니다. 표준 라이브러리의 일부는 감사된 안전하지 않은 코드에 대한 안전한 추상화로 구현됩니다. 안전하지 않은 코드를 안전한 추상화로 래핑하면 안전한 추상화를 사용하는 것이 안전하기 때문에 귀하 또는 귀하의 사용자가 안전하지 않은 코드로 구현된 기능을 사용하려는 모든 위치로 안전하지 않은 사용이 누출되는 것을 방지할 수 있습니다.\n5가지 안전하지 않은 초강대국을 차례로 살펴보겠습니다. 또한 안전하지 않은 코드에 안전한 인터페이스를 제공하는 몇 가지 추상화에 대해서도 살펴보겠습니다.\n원시 포인터 역참조\n4장의 댕글링 참조 섹션에서 우리는 컴파일러가 참조가 항상 유효한지 확인한다고 언급했습니다. Unsafe Rust 에는 참조와 유사한 원시 포인터 라는 두 가지 새로운 유형이 있습니다. 참조와 마찬가지로 원시 포인터는 변경할 수 없거나 변경할 수 있으며 각각 *const T 및 *mut T로 작성됩니다. 별표는 역참조 연산자가 아닙니다. 유형 이름의 일부입니다. 원시 포인터의 맥락에서 불변이란 포인터가 역참조된 후에 직접 할당될 수 없음을 의미합니다.\n참조 및 스마트 포인터와 달리 원시 포인터는 다음과 같습니다.\n\n불변 및 가변 포인터 또는 동일한 위치에 대한 여러 가변 포인터를 가짐으로써 차용 규칙을 무시할 수 있습니다.\n유효한 메모리를 가리키도록 보장되지 않음\nnull이 허용됨\n자동 정리를 구현하지 마십시오.\n\nRust가 이러한 보증을 적용하지 않도록 선택하면 더 나은 성능 또는 Rust의 보증이 적용되지 않는 다른 언어 또는 하드웨어와의 인터페이스 기능을 대가로 보장된 안전성을 포기할 수 있습니다.\n목록 19-1은 참조에서 불변 및 가변 원시 포인터를 만드는 방법을 보여줍니다.\n    let mut num = 5;\n\n    let r1 = &amp;num as *const i32;\n    let r2 = &amp;mut num as *mut i32;\n\n목록 19-1: 참조에서 원시 포인터 만들기\n이 코드에는 안전하지 않은 키워드가 포함되어 있지 않습니다. 안전한 코드에서 원시 포인터를 만들 수 있습니다. 곧 알게 되겠지만 안전하지 않은 블록 외부의 원시 포인터를 역참조할 수 없습니다.\nas를 사용하여 불변 참조와 가변 참조를 해당 원시 포인터 유형으로 변환하여 원시 포인터를 만들었습니다. 유효하다고 보장된 참조에서 직접 생성했기 때문에 이러한 특정 원시 포인터가 유효하다는 것을 알고 있지만 모든 원시 포인터에 대해 그런 가정을 할 수는 없습니다.\n이를 증명하기 위해 다음으로 유효성을 확신할 수 없는 원시 포인터를 만듭니다. 목록 19-2는 메모리의 임의 위치에 대한 원시 포인터를 만드는 방법을 보여줍니다. 임의의 메모리를 사용하려는 시도는 정의되지 않습니다. 해당 주소에 데이터가 있을 수도 있고 없을 수도 있고, 컴파일러가 코드를 최적화하여 메모리 액세스가 없거나 프로그램이 분할 오류로 오류가 발생할 수 있습니다. 일반적으로 이와 같은 코드를 작성할 타당한 이유는 없지만 가능합니다.\n    let address = 0x012345usize;\n    let r = address as *const i32;\n\n목록 19-2: 임의의 메모리 주소에 대한 원시 포인터 생성\n안전한 코드에서 원시 포인터를 만들 수 있지만 원시 포인터를 역참조 하고 가리키는 데이터를 읽을 수는 없습니다. 목록 19-3에서 우리는 안전하지 않은 블록이 필요한 원시 포인터에 대해 역참조 연산자 *를 사용합니다.\n    let mut num = 5;\n\n    let r1 = &amp;num as *const i32;\n    let r2 = &amp;mut num as *mut i32;\n    \n    unsafe {\n        println!(`r1 is: {}`, *r1);\n        println!(`r2 is: {}`, *r2);\n    }\n\n목록 19-3: 안전하지 않은 블록 내에서 원시 포인터 역참조\n포인터를 생성해도 아무런 문제가 없습니다. 유효하지 않은 값을 처리하게 될 수도 있는 것은 그것이 가리키는 값에 액세스하려고 할 때만입니다.\n또한 Listing 19-1과 19-3에서 num이 저장된 동일한 메모리 위치를 가리키는 *const i32 및 *mut i32 원시 포인터를 만들었습니다. 대신 num에 대한 변경 불가능한 참조와 변경 가능한 참조를 만들려고 시도했다면 Rust의 소유권 규칙이 변경 불가능한 참조와 동시에 변경 가능한 참조를 허용하지 않기 때문에 코드가 컴파일되지 않았을 것입니다. 원시 포인터를 사용하면 동일한 위치에 대한 가변 포인터와 불변 포인터를 생성하고 가변 포인터를 통해 데이터를 변경하여 잠재적으로 데이터 경합을 일으킬 수 있습니다. 조심하세요!\n이러한 모든 위험이 있는 상황에서 원시 포인터를 사용하는 이유는 무엇입니까? 한 가지 주요 사용 사례는 다음 섹션인 안전하지 않은 함수 또는 메서드 호출 에서 볼 수 있듯이 C 코드와 인터페이스할 때입니다. 또 다른 경우는 차용 검사기가 이해하지 못하는 안전한 추상화를 구축하는 경우입니다. 안전하지 않은 함수를 소개하고 안전하지 않은 코드를 사용하는 안전한 추상화의 예를 살펴보겠습니다.\n안전하지 않은 함수 또는 메서드 호출\n안전하지 않은 블록에서 수행할 수 있는 두 번째 작업 유형은 안전하지 않은 함수를 호출하는 것입니다. 안전하지 않은 함수 및 메서드는 일반 함수 및 메서드와 똑같이 생겼지만 나머지 정의 앞에 추가 unsafe가 있습니다. 이 문맥에서 안전하지 않은 키워드는 이 함수를 호출할 때 유지해야 하는 요구 사항이 함수에 있음을 나타냅니다. 왜냐하면 Rust는 우리가 이러한 요구 사항을 충족했다고 보장할 수 없기 때문입니다. 안전하지 않은 블록 내에서 안전하지 않은 함수를 호출함으로써 우리는 이 함수의 문서를 읽었으며 함수의 계약을 유지할 책임이 있음을 의미합니다.\n다음은 본문에서 아무 작업도 수행하지 않는 위험한이라는 이름의 안전하지 않은 함수입니다.\n    unsafe fn dangerous() {}\n\n    unsafe {\n        dangerous();\n    }\n\n별도의 안전하지 않은 블록 내에서 위험한 함수를 호출해야 합니다. unsafe 블록 없이 dangerous를 호출하려고 하면 오류가 발생합니다.\n$ cargo run\n   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)\nerror[E0133]: call to unsafe function is unsafe and requires unsafe function or block\n --&gt; src/main.rs:4:5\n  |\n4 |     dangerous();\n  |     ^^^^^^^^^^^ call to unsafe function\n  |\n  = note: consult the function`s documentation for information on how to avoid undefined behavior\n\nFor more information about this error, try `rustc --explain E0133`.\nerror: could not compile `unsafe-example` due to previous error\n\n안전하지 않은 블록을 사용하여 우리는 함수의 문서를 읽었고 함수를 올바르게 사용하는 방법을 이해했으며 함수의 계약을 이행하고 있음을 확인했다고 Rust에 주장합니다.\n안전하지 않은 함수의 본문은 사실상 안전하지 않은 블록이므로 안전하지 않은 함수 내에서 다른 안전하지 않은 작업을 수행하기 위해 다른 안전하지 않은 블록을 추가할 필요가 없습니다.\n안전하지 않은 코드에 대한 안전한 추상화 만들기\n함수에 안전하지 않은 코드가 포함되어 있다고 해서 전체 함수를 안전하지 않은 것으로 표시해야 한다는 의미는 아닙니다. 실제로 안전하지 않은 코드를 안전한 함수로 래핑하는 것은 일반적인 추상화입니다. 예를 들어 안전하지 않은 코드가 필요한 표준 라이브러리의 split_at_mut 함수를 살펴보겠습니다. 구현 방법에 대해 알아보겠습니다. 이 안전한 방법은 변경 가능한 슬라이스에 정의되어 있습니다. 하나의 슬라이스를 가져와 인수로 주어진 인덱스에서 슬라이스를 분할하여 두 개로 만듭니다. 목록 19-4는 split_at_mut을 사용하는 방법을 보여줍니다.\n    let mut v = vec![1, 2, 3, 4, 5, 6];\n\n    let r = &amp;mut v[..];\n    \n    let (a, b) = r.split_at_mut(3);\n    \n    assert_eq!(a, &amp;mut [1, 2, 3]);\n    assert_eq!(b, &amp;mut [4, 5, 6]);\n\n목록 19-4: 안전한 split_at_mut 함수 사용하기\n안전한 Rust만으로는 이 기능을 구현할 수 없습니다. 컴파일되지 않는 Listing 19-5와 같은 시도가 있을 수 있습니다. 단순화를 위해 split_at_mut을 메서드가 아닌 함수로 구현하고 일반 유형 T가 아닌 i32 값의 조각에 대해서만 구현합니다.\nfn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {\n    let len = values.len();\n\n    assert!(mid &lt;= len);\n    \n    (&amp;mut values[..mid], &amp;mut values[mid..])\n}\n\n목록 19-5: 안전한 Rust만 사용하여 시도한 split_at_mut 구현\n이 함수는 먼저 슬라이스의 전체 길이를 가져옵니다. 그런 다음 매개변수로 주어진 인덱스가 길이보다 작거나 같은지 확인하여 슬라이스 내에 있다고 주장합니다. 어설션은 슬라이스를 분할할 길이보다 큰 인덱스를 전달하면 해당 인덱스를 사용하려고 시도하기 전에 함수가 패닉 상태가 된다는 것을 의미합니다.\n그런 다음 두 개의 변경 가능한 슬라이스를 튜플로 반환합니다. 하나는 원래 슬라이스의 시작부터 mid 인덱스까지, 다른 하나는 mid부터 슬라이스 끝까지입니다.\n목록 19-5의 코드를 컴파일하려고 하면 오류가 발생합니다.\n$ cargo run\n   Compiling unsafe-example v0.1.0 (file:///projects/unsafe-example)\nerror[E0499]: cannot borrow `*values` as mutable more than once at a time\n --&gt; src/main.rs:6:31\n  |\n1 | fn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {\n  |                         - let`s call the lifetime of this reference ``1`\n...\n6 |     (&amp;mut values[..mid], &amp;mut values[mid..])\n  |     --------------------------^^^^^^--------\n  |     |     |                   |\n  |     |     |                   second mutable borrow occurs here\n  |     |     first mutable borrow occurs here\n  |     returning this value requires that `*values` is borrowed for ``1`\n\nFor more information about this error, try `rustc --explain E0499`.\nerror: could not compile `unsafe-example` due to previous error\n\nRust의 차용 검사기는 우리가 슬라이스의 다른 부분을 차용하고 있다는 것을 이해할 수 없습니다. 동일한 조각에서 두 번 빌리고 있다는 것만 알고 있습니다. 슬라이스의 다른 부분을 빌리는 것은 두 슬라이스가 겹치지 않기 때문에 근본적으로 괜찮지만 Rust는 이것을 알 만큼 똑똑하지 않습니다. 우리는 코드가 괜찮다는 것을 알지만 Rust는 그렇지 않을 때 안전하지 않은 코드에 도달할 때입니다.\n목록 19-6은 안전하지 않은 블록, 원시 포인터 및 안전하지 않은 함수에 대한 일부 호출을 사용하여 split_at_mut 작업을 구현하는 방법을 보여줍니다.\nuse std::slice;\n\nfn split_at_mut(values: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {\n    let len = values.len();\n    let ptr = values.as_mut_ptr();\n\n    assert!(mid &lt;= len);\n    \n    unsafe {\n        (\n            slice::from_raw_parts_mut(ptr, mid),\n            slice::from_raw_parts_mut(ptr.add(mid), len - mid),\n        )\n    }\n}\n\nListing 19-6: split_at_mut 함수 구현에 안전하지 않은 코드 사용\n4장의 슬라이스 유형 섹션에서 슬라이스는 일부 데이터 및 슬라이스 길이에 대한 포인터임을 상기하십시오 . len 메서드를 사용하여 슬라이스 길이를 가져오고 as_mut_ptr 메서드를 사용하여 슬라이스의 원시 포인터에 액세스합니다. 이 경우 i32 값에 대한 가변 슬라이스가 있기 때문에 as_mut_ptr은 변수 ptr에 저장한 *mut i32 유형의 원시 포인터를 반환합니다.\nmid 인덱스가 슬라이스 내에 있다는 주장을 유지합니다. 그런 다음 안전하지 않은 코드에 도달합니다. slice::from_raw_parts_mut 함수는 원시 포인터와 길이를 가져와 슬라이스를 생성합니다. 이 함수를 사용하여 ptr에서 시작하고 mid 항목 길이인 조각을 만듭니다. 그런 다음 mid를 인수로 사용하여 ptr에서 add 메서드를 호출하여 mid에서 시작하는 원시 포인터를 가져오고 해당 포인터와 mid 이후의 나머지 항목 수를 사용하여 조각을 만듭니다. 길이.\nslice::from_raw_parts_mut 함수는 원시 포인터를 사용하고 이 포인터가 유효하다고 신뢰해야 하기 때문에 안전하지 않습니다. 원시 포인터의 add 메서드도 오프셋 위치가 유효한 포인터임을 신뢰해야 하기 때문에 안전하지 않습니다. 따라서 slice::from_raw_parts_mut 및 add에 대한 호출 주위에 안전하지 않은 블록을 넣어 호출할 수 있도록 해야 했습니다. 코드를 살펴보고 mid가 len보다 작거나 같아야 한다는 주장을 추가하면 unsafe 블록 내에서 사용되는 모든 원시 포인터가 슬라이스 내 데이터에 대한 유효한 포인터임을 알 수 있습니다. 이것은 안전하지 않은의 허용 가능하고 적절한 사용입니다.\n결과 split_at_mut 함수를 unsafe로 표시할 필요가 없으며 안전한 Rust에서 이 함수를 호출할 수 있습니다. 안전한 방식으로 안전하지 않은 코드를 사용하는 함수 구현으로 안전하지 않은 코드에 대한 안전한 추상화를 만들었습니다. 이 함수가 액세스할 수 있는 데이터에서 유효한 포인터만 생성하기 때문입니다.\n대조적으로, Listing 19-7에서 slice::from_raw_parts_mut의 사용은 슬라이스가 사용될 때 충돌할 가능성이 있습니다. 이 코드는 임의의 메모리 위치를 사용하여 10,000개 항목 길이의 슬라이스를 만듭니다.\n    use std::slice;\n\n    let address = 0x01234usize;\n    let r = address as *mut i32;\n    \n    let values: &amp;[i32] = unsafe { slice::from_raw_parts_mut(r, 10000) };\n\n목록 19-7: 임의의 메모리 위치에서 슬라이스 생성\n우리는 이 임의의 위치에 있는 메모리를 소유하지 않으며 이 코드가 생성하는 슬라이스에 유효한 i32 값이 포함된다는 보장이 없습니다. 유효한 슬라이스인 것처럼 값을 사용하려고 하면 정의되지 않은 동작이 발생합니다.\nextern 함수를 사용하여 외부 코드 호출\n때로는 Rust 코드가 다른 언어로 작성된 코드와 상호 작용해야 할 수도 있습니다. 이를 위해 Rust에는 외부 기능 인터페이스(FFI) 의 생성 및 사용을 용이하게 하는 키워드 extern이 있습니다. FFI는 프로그래밍 언어가 함수를 정의하고 다른(외국) 프로그래밍 언어가 해당 함수를 호출할 수 있도록 하는 방법입니다.\n목록 19-8은 C 표준 라이브러리에서 abs 함수와 통합을 설정하는 방법을 보여줍니다. extern 블록 내에서 선언된 함수는 Rust 코드에서 호출하기에 항상 안전하지 않습니다. 그 이유는 다른 언어는 Rust의 규칙과 보장을 강제하지 않으며 Rust는 이를 확인할 수 없기 때문에 안전을 보장할 책임은 프로그래머에게 있습니다.\n파일 이름: src/main.rs\nextern `C` {\n    fn abs(input: i32) -&gt; i32;\n}\n\nfn main() {\n    unsafe {\n        println!(`Absolute value of -3 according to C: {}`, abs(-3));\n    }\n}\n\nListing 19-8: 다른 언어로 정의된 extern 함수 선언 및 호출\nextern C블록 내에서 호출하려는 다른 언어의 외부 함수 이름과 서명을 나열합니다.C부분은 외부 함수가 사용하는 *애플리케이션 바이너리 인터페이스(ABI)를* 정의합니다. ABI는 어셈블리 수준에서 함수를 호출하는 방법을 정의합니다.C`` ABI는 가장 일반적이며 C 프로그래밍 언어의 ABI를 따릅니다.\n\n다른 언어에서 Rust 함수 호출하기\n또한 extern을 사용하여 다른 언어에서 Rust 함수를 호출할 수 있는 인터페이스를 만들 수 있습니다. 전체 extern 블록을 생성하는 대신 extern 키워드를 추가하고 관련 기능에 대한 fn 키워드 바로 앞에 사용할 ABI를 지정합니다. 또한 #[no_mangle] 주석을 추가하여 Rust 컴파일러가 이 함수의 이름을 변경하지 않도록 해야 합니다. 맹글링은 컴파일러가 우리가 함수에 부여한 이름을 컴파일 프로세스의 다른 부분에서 사용할 더 많은 정보를 포함하지만 사람이 읽을 수 없는 다른 이름으로 변경하는 경우입니다. 모든 프로그래밍 언어 컴파일러는 이름을 조금씩 다르게 변환하므로 다른 언어에서 Rust 함수의 이름을 지정할 수 있으려면 Rust 컴파일러의 이름 변환을 비활성화해야 합니다.\n다음 예제에서는 공유 라이브러리로 컴파일되고 C에서 링크된 후 C 코드에서 call_from_c 함수에 액세스할 수 있도록 합니다.\n#[no_mangle]\npub extern `C` fn call_from_c() {\n    println!(`Just called a Rust function from C!`);\n}\n\n이 extern 사용에는 unsafe가 필요하지 않습니다.\n\n변경 가능한 정적 변수 액세스 또는 수정\n이 책에서 우리는 Rust가 지원하지만 Rust의 소유권 규칙에 문제가 될 수 있는 전역 변수 에 대해 아직 이야기하지 않았습니다. 두 스레드가 동일한 변경 가능한 전역 변수에 액세스하는 경우 데이터 경합이 발생할 수 있습니다.\nRust에서는 전역 변수를 정적 변수라고 합니다. Listing 19-9는 문자열 슬라이스를 값으로 갖는 정적 변수의 예제 선언 및 사용을 보여줍니다.\n파일 이름: src/main.rs\nstatic HELLO_WORLD: &amp;str = `Hello, world!`;\n\nfn main() {\n    println!(`name is: {}`, HELLO_WORLD);\n}\n\n목록 19-9: 불변 정적 변수 정의 및 사용\n정적 변수는 3장의 변수와 상수의 차이점 섹션 에서 논의한 상수와 유사합니다. 정적 변수의 이름은 규칙에 따라 SCREAMING_SNAKE_CASE에 있습니다. 정적 변수는 ``정적` 수명이 있는 참조만 저장할 수 있습니다. 이는 Rust 컴파일러가 수명을 파악할 수 있고 명시적으로 주석을 달 필요가 없다는 것을 의미합니다. 불변 정적 변수에 액세스하는 것은 안전합니다.\n상수와 불변 정적 변수의 미묘한 차이점은 정적 변수의 값이 메모리에 고정된 주소를 갖는다는 것입니다. 값을 사용하면 항상 동일한 데이터에 액세스합니다. 반면에 상수는 사용될 때마다 데이터를 복제할 수 있습니다. 또 다른 차이점은 정적 변수는 변경 가능하다는 것입니다. 변경 가능한 정적 변수에 액세스하고 수정하는 것은 안전하지 않습니다 . 목록 19-10은 COUNTER라는 가변 정적 변수를 선언, 액세스 및 수정하는 방법을 보여줍니다.\n파일 이름: src/main.rs\nstatic mut COUNTER: u32 = 0;\n\nfn add_to_count(inc: u32) {\n    unsafe {\n        COUNTER += inc;\n    }\n}\n\nfn main() {\n    add_to_count(3);\n\n    unsafe {\n        println!(`COUNTER: {}`, COUNTER);\n    }\n}\n\n목록 19-10: 변경 가능한 정적 변수에서 읽거나 쓰는 것은 안전하지 않습니다.\n일반 변수와 마찬가지로 mut 키워드를 사용하여 가변성을 지정합니다. COUNTER에서 읽거나 쓰는 모든 코드는 안전하지 않은 블록 내에 있어야 합니다. 이 코드는 단일 스레드이기 때문에 예상한 대로 COUNTER: 3을 컴파일하고 인쇄합니다. 여러 스레드가 COUNTER에 액세스하면 데이터 경합이 발생할 수 있습니다.\n전역적으로 액세스할 수 있는 변경 가능한 데이터를 사용하면 데이터 경합이 없는지 확인하기 어렵습니다. 이것이 Rust가 변경 가능한 정적 변수를 안전하지 않은 것으로 간주하는 이유입니다. 가능한 경우 16장에서 논의한 동시성 기술과 스레드로부터 안전한 스마트 포인터를 사용하여 컴파일러가 다른 스레드에서 액세스한 데이터가 안전하게 수행되었는지 확인하는 것이 좋습니다.\n안전하지 않은 특성 구현\nunsafe를 사용하여 안전하지 않은 특성을 구현할 수 있습니다. 해당 메서드 중 적어도 하나에 컴파일러가 확인할 수 없는 불변성이 있는 경우 특성은 안전하지 않습니다. Listing 19-11과 같이 trait 앞에 unsafe 키워드를 추가하고 트레이트 구현도 unsafe로 표시하여 트레이트가 unsafe임을 선언합니다.\nunsafe trait Foo {\n    // methods go here\n}\n\nunsafe impl Foo for i32 {\n    // method implementations go here\n}\n\nfn main() {}\n\n목록 19-11: 안전하지 않은 특성 정의 및 구현\nunsafe impl을 사용함으로써 우리는 컴파일러가 확인할 수 없는 불변성을 유지할 것이라고 약속합니다.\n예를 들어, 16장의 동기화 및 전송 특성을 사용한 확장 가능한 동시성 섹션에서 논의한  [동기화 및 전송](https://doc.rust-lang.org/book/ch16-04-extensible-concurrency-sync-and-send.html#extensible-concurrency-with-the-sync-and-send-traits) 마커 특성을 기억하십시오. 유형이 완전히 구성된 경우 컴파일러는 이러한 특성을 자동으로 구현합니다. 보내기 및 동기화 유형. 원시 포인터와 같이 Send 또는 Sync가 아닌 유형을 포함하는 유형을 구현하고 해당 유형을 Send 또는 Sync로 표시하려는 경우 unsafe를 사용해야 합니다. Rust는 우리의 유형이 스레드 간에 안전하게 전송되거나 여러 스레드에서 액세스될 수 있다는 보장을 유지하는지 확인할 수 없습니다. 따라서 이러한 검사를 수동으로 수행하고 안전하지 않음으로 표시해야 합니다.\nUnion의 필드에 접근하기\nunsafe에서만 작동하는 마지막 작업은 union 의 필드에 액세스하는 것입니다. 공용체는 구조체와 유사하지만 특정 인스턴스에서 한 번에 하나의 선언된 필드만 사용됩니다. 공용체는 주로 C 코드의 공용체와 인터페이스하는 데 사용됩니다. 러스트가 현재 유니온 인스턴스에 저장되고 있는 데이터의 유형을 보장할 수 없기 때문에 유니온 필드에 접근하는 것은 안전하지 않습니다. Rust Reference 에서 공용체에 대해 자세히 알아볼 수 있습니다.\n안전하지 않은 코드를 사용해야 하는 경우\n방금 논의한 5가지 조치(초강대국) 중 하나를 수행하기 위해 안전하지 않은을 사용하는 것은 잘못되거나 눈살을 찌푸리게 하지 않습니다. 그러나 컴파일러가 메모리 안전을 유지하는 데 도움을 줄 수 없기 때문에 안전하지 않은 코드를 수정하는 것이 더 까다롭습니다. 안전하지 않은 코드를 사용할 이유가 있을 때 그렇게 할 수 있으며 명시적인 안전하지 않은 주석이 있으면 문제가 발생할 때 문제의 원인을 쉽게 추적할 수 있습니다.\n\n고급 특성\n10장의 특성: 공유 행동 정의 섹션 에서 특성을 처음 다루었 지만 더 자세한 내용은 다루지 않았습니다. Rust에 대해 더 많이 알게 되었으니 핵심으로 들어갈 수 있습니다.\n관련 유형을 사용하여 특성 정의에서 자리 표시자 유형 지정\n연관된 유형은 특성 메소드 정의가 서명에서 이러한 자리 표시자 유형을 사용할 수 있도록 특성과 유형 자리 표시자를 연결합니다. 특성의 구현자는 특정 구현에 대한 자리 표시자 유형 대신 사용할 구체적인 유형을 지정합니다. 그렇게 하면 특성이 구현될 때까지 해당 유형이 무엇인지 정확히 알 필요 없이 일부 유형을 사용하는 특성을 정의할 수 있습니다.\n이 장에서는 대부분의 고급 기능이 거의 필요하지 않은 것으로 설명했습니다. 연관된 유형은 중간 어딘가에 있습니다. 이들은 책의 나머지 부분에서 설명하는 기능보다 드물게 사용되지만 이 장에서 논의하는 다른 많은 기능보다 더 일반적으로 사용됩니다.\n관련 유형이 있는 특성의 한 가지 예는 표준 라이브러리에서 제공하는 반복자 특성입니다. 연관된 유형의 이름은 항목이며 반복자 특성을 구현하는 유형이 반복하는 값의 유형을 나타냅니다. 반복자 특성의 정의는 Listing 19-12와 같습니다.\npub trait Iterator {\n    type Item;\n\n    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;\n}\n\nListing 19-12: 연관 유형 Item이 있는 Iterator 특성의 정의\n[Item 유형은 자리 표시자이며 next 메서드의 정의는 Option Self::Item](self::Item)  유형의 값을 반환할 것임을 보여줍니다. Iterator 특성의 구현자는 Item에 대한 구체적인 유형을 지정하고 next 메서드는 해당 구체적인 유형의 값을 포함하는 Option을 반환합니다.\n연관 유형은 처리할 수 있는 유형을 지정하지 않고 함수를 정의할 수 있다는 점에서 제네릭과 유사한 개념처럼 보일 수 있습니다. 두 개념의 차이점을 살펴보기 위해 항목 유형을 u32로 지정하는 카운터라는 유형의 반복자 특성 구현을 살펴보겠습니다.\n파일 이름: src/lib.rs\nimpl Iterator for Counter {\n    type Item = u32;\n\n    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {\n        // --snip--\n\n이 구문은 제네릭의 구문과 비슷해 보입니다. 그렇다면 Listing 19-13과 같이 제네릭으로 Iterator 트레잇을 정의하지 않는 이유는 무엇입니까?\npub trait Iterator&lt;T&gt; {\n    fn next(&amp;mut self) -&gt; Option&lt;T&gt;;\n}\n\nListing 19-13: 제네릭을 사용한 반복자 특성의 가상 정의\n차이점은 목록 19-13에서와 같이 제네릭을 사용할 때 각 구현의 유형에 주석을 달아야 한다는 것입니다. 반복자를 구현할 수도 있기 때문입니다.카운터 또는 다른 유형에 대해 카운터에 대해 반복자를 여러 번 구현할 수 있습니다. 매번 제네릭 유형 매개변수 카운터에서 다음 메소드를 사용할 때 사용할 반복자의 구현을 나타내기 위해 유형 주석을 제공해야 합니다.\n연관된 유형을 사용하면 유형에 특성을 여러 번 구현할 수 없기 때문에 유형에 주석을 달 필요가 없습니다. 연관 유형을 사용하는 정의가 있는 Listing 19-12에서 Impl Iterator for Counter는 하나만 있을 수 있기 때문에 항목의 유형이 한 번만 될지 선택할 수 있습니다. 우리는 카운터에서 다음이라고 부르는 모든 곳에서 u32 값의 반복자를 원한다고 지정할 필요가 없습니다.\n관련 유형도 특성 계약의 일부가 됩니다. 특성의 구현자는 관련 유형 자리 표시자를 대신할 유형을 제공해야 합니다. 연관된 유형에는 유형이 사용되는 방법을 설명하는 이름이 있는 경우가 많으며 API 설명서에 연관된 유형을 문서화하는 것이 좋습니다.\n기본 일반 유형 매개변수 및 연산자 오버로딩\n제네릭 형식 매개 변수를 사용할 때 제네릭 형식에 대한 기본 구체적인 형식을 지정할 수 있습니다. 이렇게 하면 기본 유형이 작동하는 경우 구체적인 유형을 지정하기 위해 특성 구현자가 필요하지 않습니다. &lt;PlaceholderType=ConcreteType&gt; 구문을 사용하여 제네릭 형식을 선언할 때 기본 형식을 지정합니다.\n이 기술이 유용한 상황의 좋은 예는 특정 상황에서 연산자(예: +)의 동작을 사용자 지정하는 연산자 오버로딩을 사용하는 것입니다.\nRust는 자신만의 연산자를 만들거나 임의의 연산자를 오버로드하는 것을 허용하지 않습니다. 그러나 연산자와 관련된 특성을 구현하여 std::ops에 나열된 작업 및 해당 특성을 오버로드할 수 있습니다. 예를 들어 Listing 19-14에서 + 연산자를 오버로드하여 두 개의 Point 인스턴스를 함께 추가합니다. Point 구조체에 Add 특성을 구현하여 이를 수행합니다.\n파일 이름: src/main.rs\nuse std::ops::Add;\n\n#[derive(Debug, Copy, Clone, PartialEq)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nimpl Add for Point {\n    type Output = Point;\n\n    fn add(self, other: Point) -&gt; Point {\n        Point {\n            x: self.x + other.x,\n            y: self.y + other.y,\n        }\n    }\n}\n\nfn main() {\n    assert_eq!(\n        Point { x: 1, y: 0 } + Point { x: 2, y: 3 },\n        Point { x: 3, y: 3 }\n    );\n}\n\n목록 19-14: Point 인스턴스에 대한 + 연산자를 오버로드하기 위해 Add 특성 구현\nadd 메서드는 두 Point 인스턴스의 x 값과 두 Point 인스턴스의 y 값을 추가하여 새 Point를 만듭니다. 추가 특성에는 추가 메서드에서 반환된 유형을 결정하는 출력이라는 관련 유형이 있습니다.\n이 코드의 기본 제네릭 형식은 추가 특성 내에 있습니다. 정의는 다음과 같습니다.\ntrait Add&lt;Rhs=Self&gt; {\n    type Output;\n\n    fn add(self, rhs: Rhs) -&gt; Self::Output;\n}\n\n이 코드는 일반적으로 친숙해 보일 것입니다. 하나의 메서드와 관련 유형이 있는 특성입니다. 새 부분은 Rhs=Self입니다. 이 구문을 기본 유형 매개변수 라고 합니다. Rhs 일반 유형 매개변수(오른쪽의 줄임말)는 add 메소드에서 rhs 매개변수의 유형을 정의합니다. Add 트레이트를 구현할 때 Rhs에 대한 구체적인 유형을 지정하지 않으면 Rhs 유형은 Add를 구현하는 유형인 Self로 기본 설정됩니다.\nPoint에 대해 Add를 구현할 때 두 개의 Point 인스턴스를 추가하려고 했기 때문에 Rhs에 대한 기본값을 사용했습니다. 기본값을 사용하는 대신 Rhs 유형을 사용자 지정하려는 추가 특성을 구현하는 예를 살펴보겠습니다.\n밀리미터와 미터라는 두 개의 구조체가 있으며 서로 다른 단위로 값을 보유합니다. 다른 구조체에 있는 기존 유형의 이 얇은 래핑은 newtype 패턴 으로 알려져 있으며 Newtype 패턴을 사용하여 외부 유형에 외부 특성 구현 섹션 에서 자세히 설명합니다. 밀리미터 값을 미터 값에 추가하고 추가 구현이 변환을 올바르게 수행하도록 하려고 합니다. 목록 19-15에 표시된 것처럼 Rhs로 미터를 사용하여 밀리미터에 대해 추가를 구현할 수 있습니다.\n파일 이름: src/lib.rs\nuse std::ops::Add;\n\nstruct Millimeters(u32);\nstruct Meters(u32);\n\nimpl Add&lt;Meters&gt; for Millimeters {\n    type Output = Millimeters;\n\n    fn add(self, other: Meters) -&gt; Millimeters {\n        Millimeters(self.0 + (other.0 * 1000))\n    }\n}\n\n목록 19-15: 미터에 밀리미터를 추가하기 위해 밀리미터에 추가 특성 구현\n밀리미터와 미터를 추가하려면 impl 추가를 지정합니다.를 사용하여 기본값인 Self를 사용하는 대신 Rhs` 유형 매개변수의 값을 설정합니다.\n다음 두 가지 주요 방법으로 기본 유형 매개변수를 사용합니다.\n\n기존 코드를 중단하지 않고 유형을 확장하려면\n특정 경우에 사용자 지정을 허용하려면 대부분의 사용자에게 필요하지 않습니다.\n\n표준 라이브러리의 추가 특성은 두 번째 목적의 예입니다. 일반적으로 유사한 두 가지 유형을 추가하지만 추가 특성은 그 이상을 사용자 지정할 수 있는 기능을 제공합니다. 추가 특성 정의에서 기본 유형 매개변수를 사용하면 대부분의 경우 추가 매개변수를 지정할 필요가 없습니다. 즉, 약간의 구현 상용구가 필요하지 않으므로 특성을 더 쉽게 사용할 수 있습니다.\n첫 번째 목적은 두 번째 목적과 비슷하지만 그 반대입니다. 기존 트레이트에 유형 매개변수를 추가하려는 경우 기존 구현 코드를 중단하지 않고 트레이트의 기능을 확장할 수 있도록 기본값을 지정할 수 있습니다.\n명확성을 위한 정규화된 구문: 동일한 이름으로 메서드 호출\nRust의 어떤 것도 특성이 다른 특성의 메서드와 같은 이름을 가진 메서드를 갖는 것을 막지 않으며, Rust는 한 유형에 두 특성을 구현하는 것을 막지 않습니다. 특성의 메서드와 동일한 이름을 가진 형식에 직접 메서드를 구현하는 것도 가능합니다.\n같은 이름을 가진 메서드를 호출할 때 어느 것을 사용하고 싶은지 러스트에게 알려줘야 합니다. Listing 19-16에서 fly라는 메서드가 있는 Pilot과 Wizard의 두 가지 특성을 정의한 코드를 고려하십시오. 그런 다음 이미 구현된 fly라는 메서드가 있는 Human 유형에 두 특성을 모두 구현합니다. 각각의 비행 방법은 다른 작업을 수행합니다.\n파일 이름: src/main.rs\ntrait Pilot {\n    fn fly(&amp;self);\n}\n\ntrait Wizard {\n    fn fly(&amp;self);\n}\n\nstruct Human;\n\nimpl Pilot for Human {\n    fn fly(&amp;self) {\n        println!(`This is your captain speaking.`);\n    }\n}\n\nimpl Wizard for Human {\n    fn fly(&amp;self) {\n        println!(`Up!`);\n    }\n}\n\nimpl Human {\n    fn fly(&amp;self) {\n        println!(`*waving arms furiously*`);\n    }\n}\n\nListing 19-16: fly 메서드를 갖도록 정의된 두 가지 특성이 Human 유형에 구현되고 fly 메서드가 Human에 직접 구현됩니다.\nHuman의 인스턴스에서 fly를 호출하면 컴파일러는 기본적으로 Listing 19-17에 표시된 대로 유형에 직접 구현된 메서드를 호출합니다.\n파일 이름: src/main.rs\nfn main() {\n    let person = Human;\n    person.fly();\n}\n\nListing 19-17: Human 인스턴스에서 fly 호출하기\n*이 코드를 실행하면 waving arms furiously*가 인쇄되어 Rust가 Human에 직접 구현된 fly 메서드를 호출했음을 보여줍니다.\nPilot 특성 또는 Wizard 특성에서 fly 메서드를 호출하려면 의미하는 fly 메서드를 지정하기 위해 보다 명시적인 구문을 사용해야 합니다. 목록 19-18은 이 구문을 보여줍니다.\n파일 이름: src/main.rs\nfn main() {\n    let person = Human;\n    Pilot::fly(&amp;person);\n    Wizard::fly(&amp;person);\n    person.fly();\n}\n\nListing 19-18: 호출하려는 특성의 fly 메서드 지정하기\n메서드 이름 앞에 특성 이름을 지정하면 호출하려는 fly 구현이 Rust에 명확해집니다. Listing 19-18에서 사용한 person.fly()와 동일한 Human::fly(&amp;person)을 작성할 수도 있지만, 필요하지 않은 경우 작성하는 데 조금 더 깁니다. 명확하다.\n이 코드를 실행하면 다음이 인쇄됩니다.\n$ cargo run\n   Compiling traits-example v0.1.0 (file:///projects/traits-example)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.46s\n     Running `target/debug/traits-example`\nThis is your captain speaking.\nUp!\n*waving arms furiously*\n\nfly 메서드는 self 매개변수를 취하기 때문에, 둘 다 하나의 특성을 구현하는 두 가지 유형이 있는 경우 러스트는 self 유형에 따라 사용할 특성 구현을 알아낼 수 있습니다.\n그러나 메소드가 아닌 관련 함수에는 self 매개변수가 없습니다. 함수 이름이 같은 비메소드 함수를 정의하는 여러 유형이나 특성이 있을 때 Rust는 완전한 구문을 사용하지 않는 한 어떤 유형을 의미하는지 항상 알 수 없습니다. 예를 들어 목록 19-19에서 우리는 모든 아기 강아지의 이름을 Spot 으로 지정하려는 동물 보호소. 메소드가 아닌 함수 baby_name과 연결된 Animal 특성을 만듭니다. Animal 특성은 구조체 Dog에 대해 구현되며 관련 메서드가 아닌 함수 baby_name 직접.\n파일 이름: src/main.rs\ntrait Animal {\n    fn baby_name() -&gt; String;\n}\n\nstruct Dog;\n\nimpl Dog {\n    fn baby_name() -&gt; String {\n        String::from(`Spot`)\n    }\n}\n\nimpl Animal for Dog {\n    fn baby_name() -&gt; String {\n        String::from(`puppy`)\n    }\n}\n\nfn main() {\n    println!(`A baby dog is called a {}`, Dog::baby_name());\n}\n\nListing 19-19: 연관된 함수가 있는 트레이트 및 해당 트레이트를 구현하는 동일한 이름의 연관된 함수가 있는 유형\nDog에 정의된 baby_name 관련 함수에서 모든 강아지 Spot의 이름을 지정하는 코드를 구현합니다. Dog 유형은 또한 모든 동물이 가지고 있는 특성을 설명하는 특성 Animal을 구현합니다. 아기 개는 강아지라고 불리며 Animal 특성과 연결된 baby_name 함수의 Dog에 대한 Animal 특성 구현으로 표현됩니다.\nmain에서 우리는 Dog에 정의된 관련 함수를 직접 호출하는 Dog::baby_name 함수를 호출합니다. 이 코드는 다음을 인쇄합니다.\n$ cargo run\n   Compiling traits-example v0.1.0 (file:///projects/traits-example)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.54s\n     Running `target/debug/traits-example`\nA baby dog is called a Spot\n\n이 출력은 우리가 원하는 것이 아닙니다. Dog에 구현한 Animal 특성의 일부인 baby_name 함수를 호출하여 코드가 A baby dog is called a puppy를 인쇄하도록 합니다. Listing 19-18에서 사용한 특성 이름을 지정하는 기술은 여기서 도움이 되지 않습니다. main을 목록 19-20의 코드로 변경하면 컴파일 오류가 발생합니다.\n파일 이름: src/main.rs\nfn main() {\n    println!(`A baby dog is called a {}`, Animal::baby_name());\n}\n\nListing 19-20: Animal 트레이트에서 baby_name 함수를 호출하려고 시도하지만 Rust는 어떤 구현을 사용해야 할지 모릅니다.\nAnimal::baby_name에는 self 매개변수가 없고 Animal 특성을 구현하는 다른 유형이 있을 수 있기 때문에 Rust는 우리가 원하는 Animal::baby_name 구현을 파악할 수 없습니다. 다음 컴파일러 오류가 발생합니다.\n$ cargo run\n   Compiling traits-example v0.1.0 (file:///projects/traits-example)\nerror[E0790]: cannot call associated function on trait without specifying the corresponding `impl` type\n  --&gt; src/main.rs:20:43\n   |\n2  |     fn baby_name() -&gt; String;\n   |     ------------------------- `Animal::baby_name` defined here\n...\n20 |     println!(`A baby dog is called a {}`, Animal::baby_name());\n   |                                           ^^^^^^^^^^^^^^^^^ cannot call associated function of trait\n   |\nhelp: use the fully-qualified path to the only available implementation\n   |\n20 |     println!(`A baby dog is called a {}`, &lt;Dog as Animal&gt;::baby_name());\n   |                                           +++++++       +\n\nFor more information about this error, try `rustc --explain E0790`.\nerror: could not compile `traits-example` due to previous error\n\n일부 다른 유형에 대한 Animal 구현과 반대로 Dog에 대한 Animal 구현을 사용하고 싶다고 Rust에게 명확하게 알리려면 정규화된 구문을 사용해야 합니다. 목록 19-21은 정규화된 구문을 사용하는 방법을 보여줍니다.\n파일 이름: src/main.rs\nfn main() {\n    println!(`A baby dog is called a {}`, &lt;Dog as Animal&gt;::baby_name());\n}\n\nListing 19-21: Dog에 구현된 Animal 특성에서 baby_name 함수를 호출하도록 지정하기 위해 정규화된 구문 사용\n우리는 Rust에 꺾쇠 괄호 안에 유형 주석을 제공하고 있습니다. 이는 Dog 유형을 이 함수 호출에 대한 동물. 이 코드는 이제 우리가 원하는 것을 인쇄합니다.\n$ cargo run\n   Compiling traits-example v0.1.0 (file:///projects/traits-example)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.48s\n     Running `target/debug/traits-example`\nA baby dog is called a puppy\n\n일반적으로 정규화된 구문은 다음과 같이 정의됩니다.\n&lt;Type as Trait&gt;::function(receiver_if_method, next_arg, ...);\n\n메서드가 아닌 관련 함수의 경우 수신자가 없습니다. 다른 인수 목록만 있습니다. 함수나 메서드를 호출하는 모든 곳에서 정규화된 구문을 사용할 수 있습니다. 그러나 Rust가 프로그램의 다른 정보에서 알아낼 수 있는 이 구문의 일부를 생략할 수 있습니다. 동일한 이름을 사용하는 구현이 여러 개 있고 Rust가 호출하려는 구현을 식별하는 데 도움이 필요한 경우에만 이 더 장황한 구문을 사용하면 됩니다.\nSupertraits를 사용하여 다른 특성 내에서 한 특성의 기능을 요구\n경우에 따라 다른 특성에 의존하는 특성 정의를 작성할 수 있습니다. 첫 번째 특성을 구현하는 유형의 경우 해당 유형이 두 번째 특성도 구현하도록 요구할 수 있습니다. 이렇게 하면 트레이트 정의가 두 번째 트레이트의 관련 항목을 사용할 수 있습니다. 특성 정의가 의존하는 특성을 특성의 수퍼 특성 이라고 합니다.\n예를 들어, outline_print 메소드로 OutlinePrint 특성을 만들고 싶다고 가정해 보겠습니다. 이 특성은 별표로 프레임이 지정되도록 형식이 지정된 주어진 값을 인쇄합니다. 즉, 표준 라이브러리를 구현하는 Point 구조체가 제공됩니다. X에 1, y에 3이 있는 Point 인스턴스에서 outline_print를 호출하면 다음과 같이 인쇄되어야 합니다. :\n**********\n*        *\n* (1, 3) *\n*        *\n**********\n\noutline_print 메서드 구현에서 Display 특성의 기능을 사용하려고 합니다. 따라서 OutlinePrint 특성이 Display도 구현하고 OutlinePrint에 필요한 기능을 제공하는 유형에 대해서만 작동하도록 지정해야 합니다. OutlinePrint: Display를 지정하여 특성 정의에서 이를 수행할 수 있습니다. 이 기술은 특성에 결합된 특성을 추가하는 것과 유사합니다. 목록 19-22는 OutlinePrint 특성의 구현을 보여줍니다.\n파일 이름: src/main.rs\nuse std::fmt;\n\ntrait OutlinePrint: fmt::Display {\n    fn outline_print(&amp;self) {\n        let output = self.to_string();\n        let len = output.len();\n        println!(`{}`, `*`.repeat(len + 4));\n        println!(`*{}*`, ` `.repeat(len + 2));\n        println!(`* {} *`, output);\n        println!(`*{}*`, ` `.repeat(len + 2));\n        println!(`{}`, `*`.repeat(len + 4));\n    }\n}\n\nListing 19-22: Display의 기능을 필요로 하는 OutlinePrint 특성 구현\nOutlinePrint에 Display 특성이 필요하다고 지정했기 때문에 Display를 구현하는 모든 유형에 대해 자동으로 구현되는 to_string 함수를 사용할 수 있습니다. 콜론을 추가하지 않고 특성 이름 뒤에 Display 특성을 지정하지 않고 to_string을 사용하려고 하면 현재 범위에서 &amp;Self 유형에 대해 to_string이라는 이름의 메서드를 찾을 수 없다는 오류가 발생합니다. .\nPoint 구조체와 같이 Display를 구현하지 않는 유형에서 OutlinePrint를 구현하려고 할 때 어떤 일이 발생하는지 살펴보겠습니다.\n파일 이름: src/main.rs\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nimpl OutlinePrint for Point {}\n\n디스플레이가 필요하지만 구현되지 않았다는 오류가 발생합니다.\n$ cargo run\n   Compiling traits-example v0.1.0 (file:///projects/traits-example)\nerror[E0277]: `Point` doesn`t implement `std::fmt::Display`\n  --&gt; src/main.rs:20:6\n   |\n20 | impl OutlinePrint for Point {}\n   |      ^^^^^^^^^^^^ `Point` cannot be formatted with the default formatter\n   |\n   = help: the trait `std::fmt::Display` is not implemented for `Point`\n   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\nnote: required by a bound in `OutlinePrint`\n  --&gt; src/main.rs:3:21\n   |\n3  | trait OutlinePrint: fmt::Display {\n   |                     ^^^^^^^^^^^^ required by this bound in `OutlinePrint`\n\nFor more information about this error, try `rustc --explain E0277`.\nerror: could not compile `traits-example` due to previous error\n\n이 문제를 해결하기 위해 Point에 Display를 구현하고 OutlinePrint에 필요한 제약 조건을 다음과 같이 충족합니다.\n파일 이름: src/main.rs\nuse std::fmt;\n\nimpl fmt::Display for Point {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {\n        write!(f, `({}, {})`, self.x, self.y)\n    }\n}\n\n그런 다음 Point에서 OutlinePrint 특성을 구현하면 성공적으로 컴파일되고 Point 인스턴스에서 outline_print를 호출하여 별표 윤곽선 안에 표시할 수 있습니다.\nNewtype 패턴을 사용하여 외부 유형에 외부 특성 구현\n10장 유형에 대한 특성 구현 섹션에서 우리는 특성이나 유형이 크레이트에 로컬인 경우에만 유형에 특성을 구현할 수 있다는 고아 규칙을 언급했습니다. 튜플 구조체에서 새 유형을 생성하는 것과 관련된 newtype 패턴을 사용하여 이 제한을 우회하는 것이 가능합니다. (튜플 구조체는 5장의 명명된 필드 없이 튜플 구조체를 사용하여 다른 유형 생성 섹션 에서 다루었 습니다.) 튜플 구조체는 하나의 필드를 가지며 특성을 구현하려는 유형을 감싸는 얇은 래퍼가 됩니다. 그런 다음 래퍼 유형은 크레이트에 로컬이며 래퍼에서 특성을 구현할 수 있습니다. 뉴타입Haskell 프로그래밍 언어에서 유래한 용어입니다. 이 패턴을 사용해도 런타임 성능이 저하되지 않으며 래퍼 유형이 컴파일 시간에 제거됩니다.\n예를 들어 Vec에 Display를 구현하고 싶다고 가정해 보겠습니다., 고아 규칙은 Display특성과Vec유형은 크레이트 외부에서 정의됩니다.Vec인스턴스를 보유하는Wrapper 구조체를 만들 수 있습니다.; 그런 다음 Wrapper에 Display를 구현하고 Vec 값을 Listing 19-23에서 볼 수 있습니다.\n파일 이름: src/main.rs\nuse std::fmt;\n\nstruct Wrapper(Vec&lt;String&gt;);\n\nimpl fmt::Display for Wrapper {\n    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {\n        write!(f, `[{}]`, self.0.join(`, `))\n    }\n}\n\nfn main() {\n    let w = Wrapper(vec![String::from(`hello`), String::from(`world`)]);\n    println!(`w = {}`, w);\n}\n\nListing 19-23: Vec 주위에 Wrapper 유형 만들기 디스플레이` 구현\n디스플레이의 구현은 self.0을 사용하여 내부 Vec에 액세스합니다., Wrapper는 튜플 구조체이고 Vec는 튜플에서 인덱스 0에 있는 항목입니다. 그러면 래퍼에서 디스플레이` 유형의 기능을 사용할 수 있습니다.\n이 기술을 사용할 때의 단점은 Wrapper가 새로운 유형이므로 보유한 값의 메소드가 없다는 것입니다. Vec의 모든 메서드를 구현해야 합니다.메서드가self.0에 위임되도록 Wrapper에 직접 Wrapper를 Vec처럼 취급할 수 있습니다.. 새 유형이 내부 유형이 가진 모든 메소드를 가지도록 하려면 Deref 특성(15장 `` Deref 특성이 있는 일반 참조와 같은 스마트 포인터 처리 섹션에서 설명)을 래퍼에 구현합니다. 내부 유형을 반환하는 것이 해결책이 될 것입니다. 예를 들어Wrapper유형의 동작을 제한하기 위해Wrapper` 유형이 내부 유형의 모든 메소드를 가지지 않도록 하려면 다음과 같이 구현해야 합니다. 수동으로 원하는 방법.\n이 뉴타입 패턴은 특성이 관련되지 않은 경우에도 유용합니다. 초점을 전환하고 Rust의 유형 시스템과 상호 작용하는 몇 가지 고급 방법을 살펴보겠습니다.\n\n고급 유형\nRust 유형 시스템에는 지금까지 언급했지만 아직 논의하지 않은 몇 가지 기능이 있습니다. 뉴타입이 유형으로서 유용한 이유를 조사하면서 일반적으로 뉴타입에 대해 논의하는 것으로 시작할 것입니다. 그런 다음 newtypes와 유사하지만 의미 체계가 약간 다른 기능인 유형 별칭으로 이동합니다. 우리는 또한 !에 대해 논의할 것입니다. 유형 및 동적 크기 유형.\n유형 안전 및 추상화를 위한 Newtype 패턴 사용\n\n참고: 이 섹션에서는 이전 섹션인 Newtype 패턴을 사용하여 외부 유형에 외부 특성 구현을 읽었다고 가정합니다.\n\nnewtype 패턴은 값이 절대 혼동되지 않도록 정적으로 적용하고 값의 단위를 표시하는 등 지금까지 논의한 작업 이외의 작업에도 유용합니다. Listing 19-15에서 단위를 나타내기 위해 newtypes를 사용하는 예를 보았습니다. 밀리미터 유형의 매개변수를 사용하여 함수를 작성하면 실수로 미터 또는 일반 u32 유형의 값으로 해당 함수를 호출하려고 시도하는 프로그램을 컴파일할 수 없습니다.\n또한 newtype 패턴을 사용하여 유형의 일부 구현 세부 정보를 추상화할 수 있습니다. 새 유형은 비공개 내부 유형의 API와 다른 공개 API를 노출할 수 있습니다.\n뉴타입은 또한 내부 구현을 숨길 수 있습니다. 예를 들어 이름과 연결된 사람의 ID를 저장하는 HashMap&lt;i32, String&gt;을 래핑하기 위해 People 유형을 제공할 수 있습니다. People을 사용하는 코드는 People 컬렉션에 이름 문자열을 추가하는 방법과 같이 우리가 제공하는 공개 API와만 상호 작용합니다. 해당 코드는 내부적으로 이름에 i32 ID를 할당한다는 사실을 알 필요가 없습니다. 뉴타입 패턴은 17장의 구현 세부 사항을 숨기는 캡슐화 섹션 에서 논의한 구현 세부 사항을 숨기기 위해 캡슐화를 달성하는 가벼운 방법입니다.\n유형 별칭으로 유형 동의어 만들기\nRust는 기존 유형에 다른 이름을 부여하기 위해 유형 별칭을 선언하는 기능을 제공합니다. 이를 위해 type 키워드를 사용합니다. 예를 들어 다음과 같이 Kilometers라는 별칭을 i32로 만들 수 있습니다.\n    type Kilometers = i32;\n\n이제 Kilometers라는 별칭은 i32와 동의어 입니다. 목록 19-15에서 생성한 밀리미터 및 미터 유형과 달리 킬로미터는 별도의 새로운 유형이 아닙니다. Kilometers 유형의 값은 i32 유형의 값과 동일하게 처리됩니다.\n    type Kilometers = i32;\n\n    let x: i32 = 5;\n    let y: Kilometers = 5;\n    \n    println!(`x + y = {}`, x + y);\n\nKilometers와 i32는 동일한 유형이므로 두 유형의 값을 모두 추가할 수 있으며 Kilometers 값을 i32 매개변수를 사용하는 함수에 전달할 수 있습니다. 그러나 이 방법을 사용하면 이전에 논의한 newtype 패턴에서 얻은 유형 검사 이점을 얻지 못합니다. 즉, 어딘가에서 Kilometers와 i32 값을 섞어도 컴파일러에서 오류가 발생하지 않습니다.\n유형 동의어의 주요 사용 사례는 반복을 줄이는 것입니다. 예를 들어 다음과 같은 긴 유형이 있을 수 있습니다.\nBox&lt;dyn Fn() + Send + `static&gt;\n\n이 긴 유형을 함수 서명에 작성하고 코드 전체에 유형 주석을 작성하는 것은 번거롭고 오류가 발생하기 쉽습니다. 목록 19-24와 같은 코드로 가득 찬 프로젝트가 있다고 상상해 보십시오.\n    let f: Box&lt;dyn Fn() + Send + `static&gt; = Box::new(|| println!(`hi`));\n\n    fn takes_long_type(f: Box&lt;dyn Fn() + Send + `static&gt;) {\n        // --snip--\n    }\n    \n    fn returns_long_type() -&gt; Box&lt;dyn Fn() + Send + `static&gt; {\n        // --snip--\n    }\n\nListing 19-24: 여러 곳에서 long 유형 사용하기\n유형 별칭은 반복을 줄여서 이 코드를 더 관리하기 쉽게 만듭니다. Listing 19-25에서 우리는 verbose 타입에 대해 Thunk라는 별칭을 도입했으며 이 유형의 모든 사용을 더 짧은 별칭인 Thunk로 대체할 수 있습니다.\n    type Thunk = Box&lt;dyn Fn() + Send + `static&gt;;\n\n    let f: Thunk = Box::new(|| println!(`hi`));\n    \n    fn takes_long_type(f: Thunk) {\n        // --snip--\n    }\n    \n    fn returns_long_type() -&gt; Thunk {\n        // --snip--\n    }\n\n목록 19-25: 반복을 줄이기 위해 유형 별칭 Thunk 도입\n이 코드는 읽고 쓰기가 훨씬 쉽습니다! 유형 별칭에 의미 있는 이름을 선택하면 의도를 전달하는 데 도움이 될 수 있습니다( thunk 는 나중에 평가할 코드의 단어이므로 저장되는 클로저에 적합한 이름입니다).\n유형 별칭은 반복을 줄이기 위해 일반적으로 Result&lt;T, E&gt; 유형과 함께 사용됩니다. 표준 라이브러리의 std::io 모듈을 고려하십시오. I/O 작업은 종종 Result&lt;T, E&gt;를 반환하여 작업이 작동하지 않는 상황을 처리합니다. 이 라이브러리에는 가능한 모든 I/O 오류를 나타내는 std::io::Error 구조체가 있습니다. std::io의 많은 함수는 E가 std::io::Error인 Result&lt;T, E&gt;를 반환합니다. 예를 들어 Write 특성의 다음 함수와 같습니다.\nuse std::fmt;\nuse std::io::Error;\n\npub trait Write {\n    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize, Error&gt;;\n    fn flush(&amp;mut self) -&gt; Result&lt;(), Error&gt;;\n\n    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;(), Error&gt;;\n    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;(), Error&gt;;\n}\n\n결과&lt;..., 오류&gt;가 많이 반복됩니다. 따라서 std::io에는 다음 유형 별칭 선언이 있습니다.\ntype Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;\n\n이 선언은 std::io 모듈에 있으므로 정규화된 별칭 std::io::Result를 사용할 수 있습니다.; 즉, E가 std::io::Error로 채워진 Result&lt;T, E&gt;입니다. Write` 특성 함수 시그니처는 다음과 같이 표시됩니다.\npub trait Write {\n    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;\n    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;\n\n    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;\n    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;()&gt;;\n}\n\n유형 별칭은 두 가지 방식으로 도움 이 됩니다. 코드 작성을 더 쉽게 만들고 모든 std::io에서 일관된 인터페이스를 제공합니다. 이는 별칭이기 때문에 또 다른 Result&lt;T, E&gt;일 뿐이며 Result&lt;T, E&gt;에서 작동하는 모든 메서드와 ? 운영자.\n돌아오지 않는 Never Type\nRust에는 !라는 특별한 유형이 있습니다. 값이 없기 때문에 유형 이론 용어로는 빈 유형 으로 알려져 있습니다. 우리는 함수가 절대 반환하지 않을 때 반환 유형을 대신하기 때문에 never 유형 이라고 부르는 것을 선호합니다. 다음은 예입니다.\nfn bar() -&gt; ! {\n    // --snip--\n}\n\n이 코드는 ``bar 함수가 절대 반환하지 않음으로 읽힙니다. 절대 반환하지 않는 함수를 발산 함수 라고 합니다. ! 유형의 값을 만들 수 없습니다. 따라서 바는 절대 반환할 수 없습니다.\n그러나 절대 값을 생성할 수 없는 유형이 무슨 소용이 있습니까? 숫자 추측 게임의 일부인 목록 2-5의 코드를 상기하십시오. 우리는 Listing 19-26에서 그것의 일부를 재생산했습니다.\n        let guess: u32 = match guess.trim().parse() {\n            Ok(num) =&gt; num,\n            Err(_) =&gt; continue,\n        };\n\nListing 19-26: continue로 끝나는 arm이 있는 match\n당시 우리는 이 코드의 일부 세부 사항을 건너뛰었습니다. 6장 ``일치 제어 흐름 연산자 섹션에서 일치 항목은 모두 동일한 유형을 반환해야 한다고 설명했습니다. 예를 들어 다음 코드는 작동하지 않습니다.\n    let guess = match guess.trim().parse() {\n        Ok(_) =&gt; 5,\n        Err(_) =&gt; `hello`,\n    };\n\n이 코드에서 guess의 유형은 정수 와 문자열 이어야 하고 Rust는 guess가 한 가지 유형만 가질 것을 요구합니다. 그렇다면 계속은 무엇을 반환합니까? 목록 19-26에서 어떻게 한 팔에서 u32를 반환하고 계속으로 끝나는 다른 팔을 가질 수 있었습니까?\n짐작하셨겠지만 계속에는 !가 있습니다. 값. 즉, Rust가 guess의 유형을 계산할 때 두 매치 암을 살펴봅니다. 전자는 u32 값을, 후자는 ! 값. 왜냐하면 ! 값을 가질 수 없는 경우 Rust는 guess 유형을 u32로 결정합니다.\n이 동작을 설명하는 공식적인 방법은 ! 유형의 표현식입니다. 다른 유형으로 강제 변환될 수 있습니다. 계속은 값을 반환하지 않기 때문에 계속으로 이 일치 암을 종료할 수 있습니다. 대신 루프의 맨 위로 제어를 이동하므로 Err의 경우 guess에 값을 할당하지 않습니다.\nnever 유형은 panic!과 함께 유용합니다. 매크로도. 옵션에서 호출하는 unwrap 함수를 기억하십시오.` 이 정의를 사용하여 값 또는 패닉을 생성하는 값:\nimpl&lt;T&gt; Option&lt;T&gt; {\n    pub fn unwrap(self) -&gt; T {\n        match self {\n            Some(val) =&gt; val,\n            None =&gt; panic!(`called `Option::unwrap()` on a `None` value`),\n        }\n    }\n}\n\n이 코드에서 Listing 19-26의 match에서와 같은 일이 발생합니다. Rust는 val에 T 유형이 있고 panic! 유형이 !이므로 전체 일치 표현식의 결과는 T입니다. 이 코드는 패닉! 때문에 작동합니다. 값을 생성하지 않습니다. 프로그램을 종료합니다. None의 경우 unwrap에서 값을 반환하지 않으므로 이 코드는 유효합니다.\n유형이 !인 마지막 표현식 루프입니다.\n    print!(`forever `);\n\n    loop {\n        print!(`and ever `);\n    }\n\n여기서는 루프가 끝나지 않으므로 ! 표현의 값입니다. 그러나 break를 포함하면 루프가 break에 도달하면 종료되기 때문에 이것은 사실이 아닙니다.\n동적으로 크기가 조정된 유형 및 크기 조정 특성\nRust는 특정 유형의 값에 할당할 공간과 같은 유형에 대한 특정 세부 정보를 알아야 합니다. 이로 인해 유형 시스템의 한 구석이 처음에는 약간 혼란스러워집니다. 즉, 동적으로 크기가 조정되는 유형 의 개념입니다. DST 또는 크기가 지정되지 않은 유형 이라고도 하는 이러한 유형을 사용하면 런타임에만 크기를 알 수 있는 값을 사용하여 코드를 작성할 수 있습니다.\n책 전체에서 사용한 str이라는 동적으로 크기가 조정되는 유형에 대해 자세히 살펴보겠습니다. 맞습니다. &amp;str이 아니라 str 자체가 DST입니다. 문자열이 런타임까지 얼마나 걸리는지 알 수 없습니다. 즉, str 유형의 변수를 생성할 수 없으며 str 유형의 인수를 사용할 수도 없습니다. 작동하지 않는 다음 코드를 고려하십시오.\n    let s1: str = `Hello there!`;\n    let s2: str = `How`s it going?`;\n\nRust는 특정 유형의 값에 할당할 메모리 양을 알아야 하며 유형의 모든 값은 동일한 양의 메모리를 사용해야 합니다. Rust가 이 코드를 작성할 수 있도록 허용했다면 이 두 str 값은 같은 양의 공간을 차지해야 합니다. 그러나 길이가 다릅니다. s1은 12바이트의 저장 공간이 필요하고 s2는 15바이트가 필요합니다. 이것이 동적으로 크기가 조정된 유형을 보유하는 변수를 생성할 수 없는 이유입니다.\n그래서 우리는 무엇을 해야 합니까? 이 경우, 당신은 이미 답을 알고 있습니다: 우리는 s1과 s2의 타입을 str이 아닌 &amp;str로 만듭니다. 4장의 스트링 슬라이스 섹션 에서 슬라이스 데이터 구조는 슬라이스의 시작 위치와 길이만 저장한다는 점을 상기하십시오. 따라서 &amp;T는 T가 있는 메모리 주소를 저장하는 단일 값이지만 &amp;str은 *2개 입니다.*값: str의 주소와 길이. 따라서 컴파일 시간에 &amp;str 값의 크기를 알 수 있습니다. usize 길이의 두 배입니다. 즉, 참조하는 문자열의 길이에 관계없이 &amp;str의 크기를 항상 알고 있습니다. 일반적으로 이것은 Rust에서 동적으로 크기가 조정된 유형이 사용되는 방식입니다. 유형에는 동적 정보의 크기를 저장하는 추가 메타데이터가 있습니다. 동적으로 크기가 조정되는 유형의 황금률은 항상 동적으로 크기가 조정되는 유형의 값을 어떤 종류의 포인터 뒤에 두어야 한다는 것입니다.\nstr을 모든 종류의 포인터와 결합할 수 있습니다. 예를 들어 Box 또는 Rc[. 사실, 이전에 본 적이 있지만 동적으로 크기가 조정되는 다른 유형인 특성이 있습니다. 모든 특성은 특성](https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types) 의 이름을 사용하여 참조할 수 있는 동적으로 크기가 조정되는 유형입니다. 다른 유형의 값 허용” 섹션에서 특성을 특성 개체로 사용하려면 &amp;dyn Trait 또는 Box와 같은 포인터 뒤에 배치해야 한다고 언급했습니다. (RC`도 작동합니다).\nDST와 함께 작업하기 위해 Rust는 컴파일 시간에 유형의 크기를 알 수 있는지 여부를 결정하는 Sized 특성을 제공합니다. 이 특성은 컴파일 시간에 크기가 알려진 모든 것에 대해 자동으로 구현됩니다. 또한 Rust는 모든 일반 함수에 Sized에 대한 경계를 암묵적으로 추가합니다. 즉, 다음과 같은 일반적인 함수 정의입니다.\nfn generic&lt;T&gt;(t: T) {\n    // --snip--\n}\n\n실제로 다음과 같이 작성한 것처럼 처리됩니다.\nfn generic&lt;T: Sized&gt;(t: T) {\n    // --snip--\n}\n\n기본적으로 제네릭 함수는 컴파일 타임에 크기가 알려진 유형에서만 작동합니다. 그러나 다음 특수 구문을 사용하여 이 제한을 완화할 수 있습니다.\nfn generic&lt;T: ?Sized&gt;(t: &amp;T) {\n    // --snip--\n}\n\n?Sized에 바인딩된 특성은 ``T가 Sized일 수도 있고 아닐 수도 있음을 의미합니다. 이 표기법은 일반 유형이 컴파일 시간에 알려진 크기를 가져야 한다는 기본값을 재정의합니다. 이 의미를 가진 ?Trait구문은Sized`에만 사용할 수 있으며 다른 특성에는 사용할 수 없습니다.\n또한 t 매개변수의 유형을 T에서 &amp;T로 전환했습니다. 유형이 크기 조정되지 않을 수 있기 때문에 일종의 포인터 뒤에 유형을 사용해야 합니다. 이 경우 참조를 선택했습니다.\n다음으로 함수와 클로저에 대해 이야기하겠습니다!\n\n고급 기능 및 클로저\n이 섹션에서는 함수 포인터 및 반환 클로저를 포함하여 함수 및 클로저와 관련된 일부 고급 기능을 살펴봅니다.\n함수 포인터\n클로저를 함수에 전달하는 방법에 대해 이야기했습니다. 일반 함수를 함수에 전달할 수도 있습니다! 이 기술은 새 클로저를 정의하는 대신 이미 정의한 함수를 전달하려는 경우에 유용합니다. 함수는 Fn 클로저 특성과 혼동하지 않도록 fn(소문자 f 포함) 유형으로 강제 변환합니다. fn 유형을 함수 포인터 라고 합니다. 함수 포인터와 함께 함수를 전달하면 함수를 다른 함수의 인수로 사용할 수 있습니다.\n매개변수가 함수 포인터임을 지정하는 구문은 목록 19-27에 표시된 것처럼 클로저의 구문과 유사합니다. 여기에서 매개변수에 1을 더하는 add_one 함수를 정의했습니다. 함수 do_twice는 i32 매개변수를 취하고 i32를 반환하는 함수에 대한 함수 포인터와 i32 값이라는 두 개의 매개변수를 사용합니다. do_twice 함수는 f 함수를 두 번 호출하여 arg 값을 전달한 다음 두 함수 호출 결과를 함께 더합니다. main 함수는 add_one 및 5 인수를 사용하여 do_twice를 호출합니다.\n파일 이름: src/main.rs\nfn add_one(x: i32) -&gt; i32 {\n    x + 1\n}\n\nfn do_twice(f: fn(i32) -&gt; i32, arg: i32) -&gt; i32 {\n    f(arg) + f(arg)\n}\n\nfn main() {\n    let answer = do_twice(add_one, 5);\n\n    println!(`The answer is: {}`, answer);\n}\n\n목록 19-27: fn 유형을 사용하여 함수 포인터를 인수로 수락\n이 코드는 답은 12를 출력합니다. 우리는 do_twice의 매개변수 f가 i32 유형의 매개변수 하나를 취하고 i32를 반환하는 fn이라고 지정합니다. 그런 다음 do_twice의 본문에서 f를 호출할 수 있습니다. main에서 함수 이름 add_one을 do_twice의 첫 번째 인수로 전달할 수 있습니다.\n클로저와 달리 fn은 특성이 아닌 유형이므로 Fn 특성 중 하나를 특성 바인딩으로 사용하여 제네릭 유형 매개변수를 선언하는 대신 fn을 매개변수 유형으로 직접 지정합니다.\n함수 포인터는 세 가지 클로저 특성(Fn, FnMut 및 FnOnce)을 모두 구현합니다. 즉, 클로저를 예상하는 함수의 인수로 함수 포인터를 항상 전달할 수 있습니다. 함수가 함수 또는 클로저를 허용할 수 있도록 제네릭 유형과 클로저 특성 중 하나를 사용하여 함수를 작성하는 것이 가장 좋습니다.\n즉, 클로저가 아닌 fn만 허용하려는 경우의 한 가지 예는 클로저가 없는 외부 코드와 인터페이스할 때입니다. C 함수는 함수를 인수로 허용할 수 있지만 C에는 클로저가 없습니다.\n인라인으로 정의된 클로저 또는 명명된 함수를 사용할 수 있는 경우의 예로 표준 라이브러리의 Iterator 특성에서 제공하는 map 메서드의 사용을 살펴보겠습니다. map 함수를 사용하여 숫자 벡터를 문자열 벡터로 바꾸려면 다음과 같이 클로저를 사용할 수 있습니다.\n    let list_of_numbers = vec![1, 2, 3];\n    let list_of_strings: Vec&lt;String&gt; =\n        list_of_numbers.iter().map(|i| i.to_string()).collect();\n\n또는 다음과 같이 클로저 대신 map에 대한 인수로 함수의 이름을 지정할 수 있습니다.\n    let list_of_numbers = vec![1, 2, 3];\n    let list_of_strings: Vec&lt;String&gt; =\n        list_of_numbers.iter().map(ToString::to_string).collect();\n\nto_string이라는 이름으로 사용할 수 있는 여러 함수가 있으므로 고급 특성 섹션 에서 앞서 언급한 정규화된 구문을 사용해야 합니다. 여기서 우리는 표준 라이브러리가 Display를 구현하는 모든 유형에 대해 구현한 ToString 특성에 정의된 to_string 함수를 사용하고 있습니다.\n6장의 열거형 값 섹션에서 우리가 정의하는 각 열거형 변형의 이름도 초기화 함수가 된다는 점을 상기하십시오 . 이 초기화 함수를 클로저 특성을 구현하는 함수 포인터로 사용할 수 있습니다. 즉, 다음과 같이 클로저를 취하는 메서드의 인수로 초기화 함수를 지정할 수 있습니다.\n    enum Status {\n        Value(u32),\n        Stop,\n    }\n\n    let list_of_statuses: Vec&lt;Status&gt; = (0u32..20).map(Status::Value).collect();\n\n여기에서 Status::Value의 초기화 함수를 사용하여 map이 호출되는 범위의 각 u32 값을 사용하여 Status::Value 인스턴스를 생성합니다. 이 스타일을 선호하는 사람도 있고 클로저를 선호하는 사람도 있습니다. 동일한 코드로 컴파일되므로 더 명확한 스타일을 사용하십시오.\n반환 폐쇄\n클로저는 특성으로 표현되며 이는 클로저를 직접 반환할 수 없음을 의미합니다. 트레이트를 반환하려는 대부분의 경우 트레이트를 구현하는 구체적인 유형을 함수의 반환 값으로 대신 사용할 수 있습니다. 그러나 반환 가능한 구체적인 유형이 없기 때문에 클로저로는 그렇게 할 수 없습니다. 예를 들어 함수 포인터 fn을 반환 유형으로 사용할 수 없습니다.\n다음 코드는 클로저를 직접 반환하려고 시도하지만 컴파일되지는 않습니다.\nfn returns_closure() -&gt; dyn Fn(i32) -&gt; i32 {\n    |x| x + 1\n}\n\n컴파일러 오류는 다음과 같습니다.\n$ cargo build\n   Compiling functions-example v0.1.0 (file:///projects/functions-example)\nerror[E0746]: return type cannot have an unboxed trait object\n --&gt; src/lib.rs:1:25\n  |\n1 | fn returns_closure() -&gt; dyn Fn(i32) -&gt; i32 {\n  |                         ^^^^^^^^^^^^^^^^^^ doesn`t have a size known at compile-time\n  |\n  = note: for information on `impl Trait`, see &lt;https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits&gt;\nhelp: use `impl Fn(i32) -&gt; i32` as the return type, as all return paths are of type `[closure@src/lib.rs:2:5: 2:8]`, which implements `Fn(i32) -&gt; i32`\n  |\n1 | fn returns_closure() -&gt; impl Fn(i32) -&gt; i32 {\n  |                         ~~~~~~~~~~~~~~~~~~~\n\nFor more information about this error, try `rustc --explain E0746`.\nerror: could not compile `functions-example` due to previous error\n\n오류는 Sized 특성을 다시 참조합니다! Rust는 클로저를 저장하는 데 얼마나 많은 공간이 필요한지 모릅니다. 우리는 앞서 이 문제에 대한 해결책을 보았습니다. 특성 개체를 사용할 수 있습니다.\nfn returns_closure() -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {\n    Box::new(|x| x + 1)\n}\n\n이 코드는 잘 컴파일됩니다. 특성 개체에 대한 자세한 내용은 17장의 다른 유형의 값을 허용하는 특성 개체 사용 섹션을 참조하세요 .\n다음으로 매크로를 살펴보겠습니다!\n\n매크로\n우리는 println!과 같은 매크로를 사용했습니다. 이 책 전체에서 매크로가 무엇이고 어떻게 작동하는지 완전히 탐구하지는 않았습니다. 매크로 라는 용어는 macro_rules!가 있는 선언적 매크로 와 같은 Rust의 기능 계열을 나타냅니다. 세 가지 종류의 절차 적 매크로:\n\n구조체 및 열거형에 사용되는 derive 특성으로 추가된 코드를 지정하는 사용자 지정 #[derive] 매크로\n모든 항목에서 사용할 수 있는 사용자 정의 속성을 정의하는 속성 유사 매크로\n함수 호출처럼 보이지만 인수로 지정된 토큰에서 작동하는 함수형 매크로\n\n이들 각각에 대해 차례로 이야기하겠지만 먼저 이미 함수가 있는데 왜 매크로가 필요한지 살펴보겠습니다.\n매크로와 함수의 차이점\n기본적으로 매크로는 다른 코드를 작성하는 코드를 작성하는 방법으로, 이를 메타프로그래밍 이라고 합니다. 부록 C에서는 다양한 트레이트 구현을 생성하는 파생 특성에 대해 설명합니다. 우리는 또한 println! 그리고 벡! 책 전체의 매크로. 이러한 모든 매크로는 확장되어 수동으로 작성한 코드보다 더 많은 코드를 생성합니다.\n메타 프로그래밍은 작성하고 유지해야 하는 코드의 양을 줄이는 데 유용하며, 이는 함수의 역할 중 하나이기도 합니다. 그러나 매크로에는 기능에는 없는 몇 가지 추가 기능이 있습니다.\n함수 시그니처는 함수가 가지고 있는 매개변수의 수와 유형을 선언해야 합니다. 반면에 매크로는 가변 개수의 매개변수를 사용할 수 있습니다. 하나의 인수로 println!(hello)를 호출하거나 두 개의 인수로 println!(hello {}, name)을 호출할 수 있습니다. 또한 매크로는 컴파일러가 코드의 의미를 해석하기 전에 확장되므로 매크로는 예를 들어 주어진 유형에 특성을 구현할 수 있습니다. 함수는 실행 시간에 호출되고 특성은 컴파일 시간에 구현되어야 하기 때문에 불가능합니다.\n함수 대신 매크로를 구현하는 단점은 Rust 코드를 작성하는 Rust 코드를 작성하기 때문에 매크로 정의가 함수 정의보다 더 복잡하다는 것입니다. 이러한 간접 참조로 인해 매크로 정의는 일반적으로 함수 정의보다 읽고 이해하고 유지하기가 더 어렵습니다.\n매크로와 함수의 또 다른 중요한 차이점 은 어디에서나 정의하고 호출할 수 있는 함수와 달리 파일에서 매크로를 호출하기 전에 매크로를 정의하거나 범위로 가져와야 한다는 것입니다.\nmacro_rules!가 포함된 선언적 매크로 일반 메타프로그래밍용\nRust에서 가장 널리 사용되는 매크로 형식은 선언적 매크로 입니다.. 이들은 또한 예제에 의한 매크로, ``macro_rules! 매크로 또는 그냥 일반 매크로입니다. 본질적으로 선언적 매크로는 Rust 일치 식과 유사한 것을 작성할 수 있도록 합니다. 6장에서 설명한 것처럼 일치 식은 식을 가져와서 식의 결과 값을 패턴과 비교한 다음 일치하는 패턴과 관련된 코드를 실행하는 제어 구조입니다. 매크로는 또한 값을 특정 코드와 관련된 패턴과 비교합니다. 이 상황에서 값은 매크로에 전달된 리터럴 Rust 소스 코드입니다. 패턴은 해당 소스 코드의 구조와 비교됩니다. 각 패턴과 관련된 코드는 일치할 때 매크로에 전달된 코드를 대체합니다. 이 모든 것은 컴파일 중에 발생합니다.\n매크로를 정의하려면 macro_rules! 건설하다. macro_rules!를 사용하는 방법을 살펴보겠습니다. vec! 매크로가 정의됩니다. 8장에서는 vec! 매크로를 사용하여 특정 값으로 새 벡터를 만듭니다. 예를 들어 다음 매크로는 세 개의 정수를 포함하는 새 벡터를 만듭니다.\nlet v: Vec&lt;u32&gt; = vec![1, 2, 3];\n\nvec! 두 개의 정수로 구성된 벡터 또는 다섯 개의 스트링 슬라이스로 구성된 벡터를 만드는 매크로입니다. 값의 수나 유형을 미리 알 수 없기 때문에 함수를 사용하여 동일한 작업을 수행할 수 없습니다.\n목록 19-28은 vec!의 약간 단순화된 정의를 보여줍니다. 매크로.\n파일 이름: src/lib.rs\n#[macro_export]\nmacro_rules! vec {\n    ( $( $x:expr ),* ) =&gt; {\n        {\n            let mut temp_vec = Vec::new();\n            $(\n                temp_vec.push($x);\n            )*\n            temp_vec\n        }\n    };\n}\n\n목록 19-28: vec! 매크로 정의\n\n참고: vec! 표준 라이브러리의 매크로에는 올바른 양의 메모리를 미리 할당하는 코드가 포함되어 있습니다. 해당 코드는 예제를 더 간단하게 만들기 위해 여기에 포함하지 않는 최적화입니다.\n\n#[macro_export] 주석은 매크로가 정의된 상자가 범위에 들어올 때마다 이 매크로를 사용할 수 있어야 함을 나타냅니다. 이 주석이 없으면 매크로를 범위로 가져올 수 없습니다.\n그런 다음 macro_rules!로 매크로 정의를 시작합니다. 느낌표 없이 정의할 매크로의 이름입니다. 이름(이 경우 vec) 뒤에는 매크로 정의의 본문을 나타내는 중괄호가 옵니다.\nvec! 본문은 일치 식의 구조와 비슷합니다. 여기에 ( $( $x:expr ),* ) 패턴과 =&gt; 및 이 패턴과 관련된 코드 블록이 있는 하나의 팔이 있습니다. 패턴이 일치하면 연결된 코드 블록이 방출됩니다. 이것이 이 매크로의 유일한 패턴이라는 점을 감안할 때 유효한 일치 방법은 하나뿐입니다. 다른 패턴은 오류가 발생합니다. 더 복잡한 매크로에는 둘 이상의 팔이 있습니다.\n매크로 정의의 유효한 패턴 구문은 18장에서 다룬 패턴 구문과 다릅니다. 매크로 패턴은 값이 아닌 Rust 코드 구조와 일치하기 때문입니다. 목록 19-28의 패턴 조각이 무엇을 의미하는지 살펴보겠습니다. 전체 매크로 패턴 구문은 Rust 참조 문서를 참조하세요 .\n먼저 전체 패턴을 포함하기 위해 일련의 괄호를 사용합니다. 패턴과 일치하는 Rust 코드를 포함할 변수를 매크로 시스템에서 선언하기 위해 달러 기호($)를 사용합니다. 달러 기호는 이것이 일반 Rust 변수가 아닌 매크로 변수임을 분명히 합니다. 다음으로 대체 코드에서 사용하기 위해 괄호 안의 패턴과 일치하는 값을 캡처하는 일련의 괄호가 나옵니다. $() 안에는 $x:expr이 있는데, 이는 Rust 표현식과 일치하고 표현식에 $x라는 이름을 부여합니다.\n$() 다음의 쉼표는 리터럴 쉼표 구분 문자가 $()의 코드와 일치하는 코드 뒤에 선택적으로 나타날 수 있음을 나타냅니다.  *는 패턴이 *  앞에 있는 것과 0개 이상 일치함을 지정합니다.\nvec![1, 2, 3];로 이 매크로를 호출하면 $x 패턴이 1, 2 및 3 세 개의 표현식과 세 번 일치합니다.\n이제 이 팔과 관련된 코드 본문의 패턴을 살펴보겠습니다. $()* 내의 temp_vec.push()는 패턴의 $()와 0번 이상 일치하는 각 부분에 대해 생성됩니다. 패턴이 일치하는 횟수에 따라 다릅니다. $x는 일치하는 각 표현식으로 대체됩니다. 이 매크로를 vec![1, 2, 3];으로 호출하면 이 매크로 호출을 대체하는 생성된 코드는 다음과 같습니다.\n{\n    let mut temp_vec = Vec::new();\n    temp_vec.push(1);\n    temp_vec.push(2);\n    temp_vec.push(3);\n    temp_vec\n}\n\n우리는 모든 유형의 인수를 얼마든지 취할 수 있고 지정된 요소를 포함하는 벡터를 생성하는 코드를 생성할 수 있는 매크로를 정의했습니다.\n매크로를 작성하는 방법에 대해 자세히 알아보려면 온라인 문서나 Daniel Keep이 시작하고 Lukas Wirth가 이어가는 The Little Book of Rust Macros 와 같은 기타 리소스를 참조하십시오 .\n속성에서 코드를 생성하기 위한 절차적 매크로\n매크로의 두 번째 형태는 프로시저 매크로 로 , 함수처럼 작동하며 프로시저의 한 유형입니다. 절차적 매크로는 일부 코드를 입력으로 받아들이고, 해당 코드에서 작동하며, 선언적 매크로처럼 패턴과 일치시키고 코드를 다른 코드로 대체하는 대신 일부 코드를 출력으로 생성합니다. 세 가지 종류의 절차적 매크로는 사용자 지정 파생, 속성 유사 및 함수 유사이며 모두 비슷한 방식으로 작동합니다.\n절차적 매크로를 만들 때 정의는 특수 크레이트 유형이 있는 자체 크레이트에 있어야 합니다. 이것은 우리가 미래에 제거하기를 희망하는 복잡한 기술적인 이유 때문입니다. 목록 19-29에서 절차적 매크로를 정의하는 방법을 보여줍니다. 여기서 some_attribute는 특정 매크로 종류를 사용하기 위한 자리 표시자입니다.\n파일 이름: src/lib.rs\nuse proc_macro;\n\n#[some_attribute]\npub fn some_name(input: TokenStream) -&gt; TokenStream {\n}\n\nListing 19-29: 절차적 매크로를 정의하는 예\n절차적 매크로를 정의하는 함수는 TokenStream을 입력으로 사용하고 TokenStream을 출력으로 생성합니다. TokenStream 유형은 Rust에 포함된 proc_macro 크레이트에 의해 정의되며 일련의 토큰을 나타냅니다. 이것이 매크로의 핵심입니다. 매크로가 작동하는 소스 코드는 입력 TokenStream을 구성하고 매크로가 생성하는 코드는 출력 TokenStream입니다. 이 함수에는 우리가 만들고 있는 절차적 매크로의 종류를 지정하는 속성이 첨부되어 있습니다. 동일한 크레이트에 여러 종류의 절차적 매크로가 있을 수 있습니다.\n다른 종류의 절차적 매크로를 살펴보겠습니다. 사용자 정의 파생 매크로로 시작한 다음 다른 양식을 다르게 만드는 작은 차이점을 설명합니다.\n사용자 지정 파생 매크로를 작성하는 방법\nhello_macro라는 하나의 관련 함수와 함께 HelloMacro라는 특성을 정의하는 hello_macro라는 크레이트를 만들어 봅시다. 사용자가 각 유형에 대해 HelloMacro 특성을 구현하도록 하는 대신 절차적 매크로를 제공하여 사용자가 hello_macro의 기본 구현을 얻기 위해 #[derive(HelloMacro)]로 유형에 주석을 달 수 있도록 합니다. 기능. 기본 구현은 Hello, Macro! My name is TypeName!을 인쇄합니다. 여기서 TypeName은 이 특성이 정의된 유형의 이름입니다. 다른 말로, 우리는 다른 프로그래머가 우리 크레이트를 사용하여 목록 19-30과 같은 코드를 작성할 수 있도록 하는 크레이트를 작성할 것입니다.\n파일 이름: src/main.rs\nuse hello_macro::HelloMacro;\nuse hello_macro_derive::HelloMacro;\n\n#[derive(HelloMacro)]\nstruct Pancakes;\n\nfn main() {\n    Pancakes::hello_macro();\n}\n\nListing 19-30: 프로시저 매크로를 사용할 때 크레이트 사용자가 작성할 수 있는 코드\n이 코드는 Hello, Macro! My name is Pancakes!를 인쇄합니다. 우리가 끝나면. 첫 번째 단계는 다음과 같이 새 라이브러리 크레이트를 만드는 것입니다.\n$ cargo new hello_macro --lib\n\n다음으로 HelloMacro 특성 및 관련 함수를 정의합니다.\n파일 이름: src/lib.rs\npub trait HelloMacro {\n    fn hello_macro();\n}\n\n우리에게는 특성과 기능이 있습니다. 이 시점에서 크레이트 사용자는 다음과 같이 원하는 기능을 달성하기 위해 특성을 구현할 수 있습니다.\nuse hello_macro::HelloMacro;\n\nstruct Pancakes;\n\nimpl HelloMacro for Pancakes {\n    fn hello_macro() {\n        println!(`Hello, Macro! My name is Pancakes!`);\n    }\n}\n\nfn main() {\n    Pancakes::hello_macro();\n}\n\n그러나 hello_macro와 함께 사용하려는 각 유형에 대한 구현 블록을 작성해야 합니다. 우리는 그들이 이 일을 하지 않아도 되기를 원합니다.\n추가로, 우리는 트레이트가 구현된 타입의 이름을 인쇄할 기본 구현으로 hello_macro 함수를 아직 제공할 수 없습니다: Rust에는 리플렉션 기능이 없으므로 런타임에 타입의 이름을 조회할 수 없습니다. . 컴파일 타임에 코드를 생성하려면 매크로가 필요합니다.\n다음 단계는 절차적 매크로를 정의하는 것입니다. 이 글을 쓰는 시점에서 절차적 매크로는 자체 크레이트에 있어야 합니다. 결국 이 제한이 해제될 수 있습니다. 크레이트와 매크로 크레이트를 구성하는 규칙은 다음과 같습니다: foo라는 이름의 크레이트의 경우 사용자 정의 파생 절차 매크로 크레이트를 foo_derive라고 합니다. hello_macro 프로젝트 내에서 hello_macro_derive라는 새 크레이트를 시작하겠습니다.\n$ cargo new hello_macro_derive --lib\n\n우리의 두 크레이트는 밀접하게 관련되어 있으므로 hello_macro 크레이트의 디렉토리 내에 절차적 매크로 크레이트를 만듭니다. hello_macro에서 특성 정의를 변경하면 hello_macro_derive에서 절차적 매크로의 구현도 변경해야 합니다. 두 크레이트는 별도로 게시해야 하며, 이러한 크레이트를 사용하는 프로그래머는 두 크레이트를 종속성으로 추가하고 둘 다 범위로 가져와야 합니다. 대신 hello_macro 크레이트가 hello_macro_derive를 종속성으로 사용하고 절차적 매크로 코드를 다시 내보낼 수 있습니다. 그러나 우리가 프로젝트를 구성한 방식은 프로그래머가 파생 기능을 원하지 않는 경우에도 hello_macro를 사용할 수 있도록 합니다.\nhello_macro_derive 크레이트를 절차적 매크로 크레이트로 선언해야 합니다. 잠시 후에 보게 되겠지만 syn 및 quote 크레이트의 기능도 필요하므로 종속 항목으로 추가해야 합니다. hello_macro_derive에 대한 Cargo.toml 파일 에 다음을 추가합니다.\n파일 이름: hello_macro_derive/Cargo.toml\n[lib]\nproc-macro = true\n\n[dependencies]\nsyn = `1.0`\nquote = `1.0`\n\n절차적 매크로 정의를 시작하려면 Listing 19-31의 코드를 hello_macro_derive 크레이트에 대한 src/lib.rs 파일에 넣습니다. 이 코드는 impl_hello_macro 함수에 대한 정의를 추가할 때까지 컴파일되지 않습니다.\n파일 이름: hello_macro_derive/src/lib.rs\nuse proc_macro::TokenStream;\nuse quote::quote;\nuse syn;\n\n#[proc_macro_derive(HelloMacro)]\npub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {\n    // Construct a representation of Rust code as a syntax tree\n    // that we can manipulate\n    let ast = syn::parse(input).unwrap();\n\n    // Build the trait implementation\n    impl_hello_macro(&amp;ast)\n}\n\nListing 19-31: Rust 코드를 처리하기 위해 대부분의 절차적 매크로 크레이트에 필요한 코드\n코드를 TokenStream 구문 분석을 담당하는 hello_macro_derive 함수와 구문 트리 변환을 담당하는 impl_hello_macro 함수로 분할했습니다. 이렇게 하면 절차 매크로를 더 편리하게 작성할 수 있습니다. 외부 함수의 코드(이 경우 hello_macro_derive)는 보거나 생성하는 거의 모든 절차적 매크로 크레이트에 대해 동일합니다. 내부 함수의 본문에 지정하는 코드(이 경우 impl_hello_macro)는 절차 매크로의 목적에 따라 달라집니다.\nproc_macro, syn 및 quote 의 세 가지 새로운 크레이트를 도입했습니다. proc_macro 크레이트는 Rust와 함께 제공되므로 Cargo.toml 의 종속성에 추가할 필요가 없습니다. proc_macro 크레이트는 우리 코드에서 Rust 코드를 읽고 조작할 수 있게 해주는 컴파일러의 API입니다.\nsyn 크레이트는 문자열의 Rust 코드를 작업을 수행할 수 있는 데이터 구조로 구문 분석합니다. quote 크레이트는 syn 데이터 구조를 Rust 코드로 되돌립니다. 이러한 크레이트는 우리가 처리하고자 하는 모든 종류의 Rust 코드를 파싱하는 것을 훨씬 더 간단하게 만듭니다. Rust 코드에 대한 전체 파서를 작성하는 것은 간단한 작업이 아닙니다.\nhello_macro_derive 함수는 라이브러리 사용자가 유형에 #[derive(HelloMacro)]를 지정하면 호출됩니다. 이는 여기에서 proc_macro_derive로 hello_macro_derive 함수에 주석을 달고 특성 이름과 일치하는 HelloMacro라는 이름을 지정했기 때문에 가능합니다. 이것은 대부분의 절차적 매크로가 따르는 규칙입니다.\nhello_macro_derive 함수는 먼저 TokenStream의 입력을 우리가 해석하고 작업을 수행할 수 있는 데이터 구조로 변환합니다. 여기에서 syn이 작동합니다. syn의 parse 함수는 TokenStream을 취하고 구문 분석된 Rust 코드를 나타내는 DeriveInput 구조체를 반환합니다. 목록 19-32는 struct Pancakes를 구문 분석하여 얻은 DeriveInput 구조체의 관련 부분을 보여줍니다. 끈:\nDeriveInput {\n    // --snip--\n\n    ident: Ident {\n        ident: `Pancakes`,\n        span: #0 bytes(95..103)\n    },\n    data: Struct(\n        DataStruct {\n            struct_token: Struct,\n            fields: Unit,\n            semi_token: Some(\n                Semi\n            )\n        }\n    )\n}\n\nListing 19-32: Listing 19-30에서 매크로 속성을 가진 코드를 구문 분석할 때 얻는 DeriveInput 인스턴스\n이 구조체의 필드는 우리가 파싱한 Rust 코드가 Pancakes의 ident(식별자, 이름을 의미)가 있는 단위 구조체임을 보여줍니다. 이 구조체에는 모든 종류의 Rust 코드를 설명하기 위한 더 많은 필드가 있습니다. 자세한 내용은 DeriveInput에 대한 syn 문서를 확인하십시오 .\n곧 우리는 impl_hello_macro 함수를 정의할 것입니다. 여기서 우리는 포함하고 싶은 새로운 Rust 코드를 만들 것입니다. 그러나 그 전에 파생 매크로의 출력도 TokenStream이라는 점에 유의하십시오. 반환된 TokenStream은 크레이트 사용자가 작성하는 코드에 추가되므로 크레이트를 컴파일할 때 수정된 TokenStream에서 제공하는 추가 기능을 얻게 됩니다.\n여기에서 syn::parse 함수에 대한 호출이 실패하면 hello_macro_derive 함수가 패닉 상태가 되도록 unwrap을 호출하고 있음을 알아차렸을 것입니다. 절차적 매크로 API를 준수하려면 proc_macro_derive 함수가 결과가 아닌 TokenStream을 반환해야 하므로 오류 시 절차적 매크로가 패닉 상태가 되어야 합니다. unwrap을 사용하여 이 예제를 단순화했습니다. 프로덕션 코드에서는 패닉!을 사용하여 무엇이 잘못되었는지에 대한 보다 구체적인 오류 메시지를 제공해야 합니다. 또는 기대.\n주석이 달린 Rust 코드를 TokenStream에서 DeriveInput 인스턴스로 전환하는 코드가 있으므로 Listing 19-33과 같이 주석이 달린 유형에 HelloMacro 특성을 구현하는 코드를 생성해 보겠습니다.\n파일 이름: hello_macro_derive/src/lib.rs\nfn impl_hello_macro(ast: &amp;syn::DeriveInput) -&gt; TokenStream {\n    let name = &amp;ast.ident;\n    let gen = quote! {\n        impl HelloMacro for #name {\n            fn hello_macro() {\n                println!(`Hello, Macro! My name is {}!`, stringify!(#name));\n            }\n        }\n    };\n    gen.into()\n}\n\n목록 19-33: 파싱된 Rust 코드를 사용하여 HelloMacro 특성 구현하기\nast.ident를 사용하여 주석이 달린 유형의 이름(식별자)을 포함하는 Ident 구조체 인스턴스를 얻습니다. 목록 19-32의 구조체는 우리가 목록 19-30의 코드에서 impl_hello_macro 함수를 실행할 때 우리가 얻는 ident가 Pancakes 값을 가진 ident 필드를 가질 것임을 보여줍니다. 따라서 Listing 19-33의 name 변수는 인쇄될 때 Listing 19-30의 구조체 이름인 Pancakes 문자열이 될 Ident 구조체 인스턴스를 포함합니다.\n인용구!매크로를 사용하면 반환하려는 Rust 코드를 정의할 수 있습니다. 컴파일러는quote!의 직접적인 결과와 다른 결과를 기대합니다. 매크로의 실행이므로 TokenStream으로 변환해야 합니다. 이 중간 표현을 사용하고 필요한 TokenStream유형의 값을 반환하는into` 메서드를 호출하여 이를 수행합니다.\n인용구!매크로는 또한 몇 가지 매우 멋진 템플릿 메커니즘을 제공합니다.#name및quote!를 입력할 수 있습니다. 변수 name의 값으로 대체합니다. 일반 매크로가 작동하는 방식과 유사한 반복 작업을 수행할 수도 있습니다. 자세한 소개는 [quote` 크레이트의 문서를](https://docs.rs/quote) 확인하세요 .\n우리는 절차적 매크로가 사용자가 주석을 추가한 유형에 대한 HelloMacro 특성의 구현을 생성하기를 원합니다. #name을 사용하여 얻을 수 있습니다. 특성 구현에는 하나의 함수 hello_macro가 있으며, 그 본문에는 우리가 제공하려는 기능이 포함되어 있습니다. Hello, Macro! My name is를 인쇄한 다음 주석이 달린 유형의 이름을 인쇄합니다.\n문자열화! 여기에 사용된 매크로는 Rust에 내장되어 있습니다. 이것은 1 + 2와 같은 Rust 표현식을 취하며 컴파일 타임에 표현식을 1 + 2와 같은 문자열 리터럴로 바꿉니다. 이것은 포맷!과는 다릅니다. 또는 println!, 식을 평가한 다음 결과를 문자열로 변환하는 매크로. #name 입력은 문자 그대로 출력하는 표현식일 가능성이 있으므로 stringify!를 사용합니다. 문자열화! 사용 또한 컴파일 시간에 #name을 문자열 리터럴로 변환하여 할당을 저장합니다.\n이 시점에서 cargo build는 hello_macro와 hello_macro_derive 모두에서 성공적으로 완료되어야 합니다. 이 크레이트를 Listing 19-30의 코드에 연결하여 절차적 매크로가 작동하는 것을 봅시다! cargo new 팬케이크를 사용하여 프로젝트 디렉토리 에 새 바이너리 프로젝트를 만듭니다. hello_macro 및 hello_macro_derive를 pancakes 크레이트의 Cargo.toml 에 종속 항목으로 추가해야 합니다. hello_macro 및 hello_macro_derive 버전을 crates.io 에 게시하는 경우 일반 종속성이 됩니다. 그렇지 않은 경우 다음과 같이 경로 종속성으로 지정할 수 있습니다.\nhello_macro = { path = `../hello_macro` }\nhello_macro_derive = { path = `../hello_macro/hello_macro_derive` }\n\nListing 19-30의 코드를 src/main.rs 에 넣고 cargo run을 실행합니다: Hello, Macro! My name is Pancakes!를 출력해야 합니다. 절차적 매크로의 HelloMacro 특성 구현은 이를 구현할 필요가 있는 팬케이크 상자 없이 포함되었습니다. #[derive(HelloMacro)]는 특성 구현을 추가했습니다.\n다음으로 다른 종류의 절차적 매크로가 사용자 지정 파생 매크로와 어떻게 다른지 살펴보겠습니다.\n속성과 같은 매크로\n특성 유사 매크로는 사용자 지정 파생 매크로와 유사하지만 파생 특성에 대한 코드를 생성하는 대신 새 특성을 만들 수 있습니다. 또한 더 유연합니다. 파생은 구조체 및 열거형에 대해서만 작동합니다. 속성은 기능과 같은 다른 항목에도 적용될 수 있습니다. 다음은 속성과 유사한 매크로를 사용하는 예입니다. 웹 애플리케이션 프레임워크를 사용할 때 함수에 주석을 추가하는 route라는 속성이 있다고 가정해 보겠습니다.\n#[route(GET, `/`)]\nfn index() {\n\n이 #[route] 속성은 프레임워크에서 절차적 매크로로 정의됩니다. 매크로 정의 함수의 서명은 다음과 같습니다.\n#[proc_macro_attribute]\npub fn route(attr: TokenStream, item: TokenStream) -&gt; TokenStream {\n\n여기에 TokenStream 유형의 두 매개변수가 있습니다. 첫 번째는 속성의 내용인 GET, /`` 부분입니다. 두 번째는 속성이 첨부된 항목의 본문입니다. 이 경우 fn index() {} 및 나머지 함수 본문입니다.\n그 외에 속성 유사 매크로는 사용자 정의 파생 매크로와 동일한 방식으로 작동합니다. proc-macro 크레이트 유형으로 크레이트를 생성하고 원하는 코드를 생성하는 함수를 구현합니다!\n함수형 매크로\n함수형 매크로는 함수 호출처럼 보이는 매크로를 정의합니다. macro_rules!와 유사합니다. 매크로는 함수보다 더 유연합니다. 예를 들어 알 수 없는 수의 인수를 사용할 수 있습니다. 그러나 macro_rules! 매크로는 macro_rules를 사용한 선언적 매크로 섹션에서 논의한 일치 유사 구문을 사용해서만 정의할 수 있습니다. 일반 메타프로그래밍용”을 참조하십시오 . 함수와 같은 매크로는 TokenStream 매개변수를 사용하며 그 정의는 다른 두 가지 유형의 절차적 매크로가 수행하는 것처럼 Rust 코드를 사용하여 해당 TokenStream을 조작합니다. 함수와 유사한 매크로의 예는 sql! 다음과 같이 호출될 수 있는 매크로:\nlet sql = sql!(SELECT * FROM posts WHERE id=1);\n\n이 매크로는 내부의 SQL 문을 구문 분석하고 구문이 올바른지 확인합니다. 이는 macro_rules!보다 훨씬 복잡한 처리입니다. 매크로는 할 수 있습니다. SQL! 매크로는 다음과 같이 정의됩니다.\n#[proc_macro]\npub fn sql(input: TokenStream) -&gt; TokenStream {\n\n이 정의는 사용자 지정 파생 매크로의 서명과 유사합니다. 괄호 안에 있는 토큰을 받고 생성하려는 코드를 반환합니다.\n요약\n아휴! 이제 도구 상자에 자주 사용하지 않을 것 같은 일부 Rust 기능이 있지만 매우 특정한 상황에서 사용할 수 있다는 것을 알게 될 것입니다. 오류 메시지 제안 또는 다른 사람의 코드에서 이러한 개념과 구문을 인식할 수 있도록 몇 가지 복잡한 항목을 도입했습니다. 솔루션을 안내하는 참조로 이 장을 사용하십시오.\n다음으로 책 전체에서 논의한 모든 내용을 실행에 옮기고 프로젝트를 하나 더 수행합니다!\n\n20\n최종 프로젝트: 다중 스레드 웹 서버 구축\n긴 여정이었지만 책의 끝에 도달했습니다. 이 장에서는 마지막 장에서 다룬 개념 중 일부를 시연하고 이전 학습 내용을 요약하기 위해 함께 프로젝트를 하나 더 빌드합니다.\n최종 프로젝트를 위해 웹 브라우저에서 hello라고 말하고 그림 20-1처럼 보이는 웹 서버를 만들 것입니다.\n\n그림 20-1: 최종 공유 프로젝트\n다음은 웹 서버 구축 계획입니다.\n\nTCP와 HTTP에 대해 조금 알아보세요.\n소켓에서 TCP 연결을 수신합니다.\n소수의 HTTP 요청을 구문 분석합니다.\n적절한 HTTP 응답을 만듭니다.\n스레드 풀로 서버의 처리량을 향상시킵니다.\n\n시작하기 전에 한 가지 세부 사항을 언급해야 합니다. 우리가 사용할 방법은 Rust로 웹 서버를 구축하는 최선의 방법이 아닙니다. 커뮤니티 회원들은 우리가 구축할 것보다 더 완벽한 웹 서버 및 스레드 풀 구현을 제공하는 crates.io 에서 사용할 수 있는 생산 준비가 된 여러 크레이트를 게시했습니다. 그러나 이 장에서 우리의 의도는 쉬운 길을 택하는 것이 아니라 학습을 돕는 것입니다. Rust는 시스템 프로그래밍 언어이기 때문에 작업하려는 추상화 수준을 선택할 수 있고 다른 언어에서 가능하거나 실용적인 수준보다 낮은 수준으로 이동할 수 있습니다. 따라서 기본 HTTP 서버와 스레드 풀을 수동으로 작성하여 향후 사용할 크레이트의 일반적인 아이디어와 기술을 배울 수 있습니다.\n\n단일 스레드 웹 서버 구축\n단일 스레드 웹 서버를 작동시키는 것으로 시작하겠습니다. 시작하기 전에 웹 서버 구축과 관련된 프로토콜에 대한 간략한 개요를 살펴보겠습니다. 이러한 프로토콜에 대한 자세한 내용은 이 책의 범위를 벗어나지만 간략한 개요를 통해 필요한 정보를 얻을 수 있습니다.\n웹 서버와 관련된 두 가지 주요 프로토콜은 HTTP( Hypertext Transfer Protocol ) 와 TCP( Transmission Control Protocol )입니다. 두 프로토콜 모두 요청-응답 프로토콜입니다. 즉, 클라이언트가 요청을 시작하고 서버가 요청을 듣고 클라이언트에 응답을 제공합니다. 이러한 요청 및 응답의 내용은 프로토콜에 의해 정의됩니다.\nTCP는 한 서버에서 다른 서버로 정보를 가져오는 방법에 대한 세부 정보를 설명하지만 해당 정보가 무엇인지는 지정하지 않는 하위 수준 프로토콜입니다. HTTP는 요청 및 응답의 내용을 정의하여 TCP 위에 구축됩니다. HTTP를 다른 프로토콜과 함께 사용하는 것은 기술적으로 가능하지만 대부분의 경우 HTTP는 TCP를 통해 데이터를 보냅니다. 우리는 TCP 및 HTTP 요청과 응답의 원시 바이트로 작업할 것입니다.\nTCP 연결 듣기\n웹 서버는 TCP 연결을 수신해야 하므로 이것이 우리가 작업할 첫 번째 부분입니다. 표준 라이브러리는 이를 가능하게 하는 std::net 모듈을 제공합니다. 일반적인 방식으로 새 프로젝트를 만들어 봅시다.\n$ cargo new hello\n     Created binary (application) `hello` project\n$ cd hello\n\n이제 시작하려면 src/main.rs 에 목록 20-1의 코드를 입력하십시오 . 이 코드는 들어오는 TCP 스트림에 대해 로컬 주소 127.0.0.1:7878에서 수신 대기합니다. 들어오는 스트림을 받으면 연결 설정!을 인쇄합니다.\n파일 이름: src/main.rs\nuse std::net::TcpListener;\n\nfn main() {\n    let listener = TcpListener::bind(`127.0.0.1:7878`).unwrap();\n\n    for stream in listener.incoming() {\n        let stream = stream.unwrap();\n    \n        println!(`Connection established!`);\n    }\n}\n\nListing 20-1: 들어오는 스트림을 듣고 스트림을 받으면 메시지 출력하기\nTcpListener를 사용하여 주소 127.0.0.1:7878에서 TCP 연결을 수신할 수 있습니다. 주소에서 콜론 앞의 섹션은 컴퓨터를 나타내는 IP 주소(이는 모든 컴퓨터에서 동일하며 작성자의 컴퓨터를 구체적으로 나타내지 않음)이고 7878은 포트입니다. 우리는 두 가지 이유로 이 포트를 선택했습니다. HTTP는 일반적으로 이 포트에서 허용되지 않으므로 우리 서버는 컴퓨터에서 실행 중인 다른 웹 서버와 충돌할 가능성이 없으며 7878은 전화기에 녹슬게 입력 됩니다 .\n이 시나리오의 bind 함수는 새 TcpListener 인스턴스를 반환한다는 점에서 new 함수처럼 작동합니다. 이 기능을 바인딩이라고 부르는 이유는 네트워킹에서 수신할 포트에 연결하는 것을 포트에 바인딩하는 것으로 알려져 있기 때문입니다.\nbind 함수는 바인딩이 실패할 수 있음을 나타내는 Result&lt;T, E&gt;를 반환합니다. 예를 들어 포트 80에 연결하려면 관리자 권한이 필요하므로(관리자가 아닌 사용자는 1023보다 높은 포트에서만 수신할 수 있음) 관리자가 아닌 상태에서 포트 80에 연결하려고 하면 바인딩이 작동하지 않습니다. 예를 들어 프로그램의 두 인스턴스를 실행하여 동일한 포트를 수신하는 두 개의 프로그램이 있는 경우 바인딩도 작동하지 않습니다. 학습 목적으로 기본 서버를 작성하고 있기 때문에 이러한 종류의 오류 처리에 대해 걱정하지 않습니다. 대신 오류가 발생하면 unwrap을 사용하여 프로그램을 중지합니다.\nTcpListener의 incoming 메서드는 일련의 스트림(더 구체적으로는 TcpStream 유형의 스트림)을 제공하는 반복자를 반환합니다. 단일 스트림은 클라이언트와 서버 간의 열린 연결을 나타냅니다. 연결 은 클라이언트가 서버에 연결하고 서버가 응답을 생성하며 서버가 연결을 닫는 전체 요청 및 응답 프로세스의 이름입니다. 따라서 TcpStream에서 읽어 클라이언트가 보낸 내용을 확인한 다음 스트림에 대한 응답을 작성하여 데이터를 다시 클라이언트로 보냅니다. 전반적으로 이 for 루프는 각 연결을 차례로 처리하고 처리할 일련의 스트림을 생성합니다.\n현재 스트림 처리는 스트림에 오류가 있는 경우 프로그램을 종료하기 위해 unwrap을 호출하는 것으로 구성됩니다. 오류가 없으면 프로그램은 메시지를 인쇄합니다. 다음 목록에서 성공 사례에 대한 기능을 더 추가할 것입니다. 클라이언트가 서버에 연결할 때 수신 방법에서 오류가 발생할 수 있는 이유는 실제로 연결을 반복하지 않기 때문입니다. 대신 연결 시도를 반복합니다. 여러 가지 이유로 연결에 실패할 수 있으며 그 중 대부분은 운영 체제에 따라 다릅니다. 예를 들어, 많은 운영 체제는 지원할 수 있는 동시 개방 연결 수에 제한이 있습니다. 해당 숫자를 초과하는 새 연결 시도는 열려 있는 연결 중 일부가 닫힐 때까지 오류를 생성합니다.\n이 코드를 실행해 봅시다! 터미널에서 cargo run을 호출한 다음 웹 브라우저에서 127.0.0.1:7878을 로드합니다. 서버가 현재 데이터를 다시 전송하지 않기 때문에 브라우저에 연결 재설정과 같은 오류 메시지가 표시되어야 합니다. 그러나 터미널을 보면 브라우저가 서버에 연결될 때 인쇄된 여러 메시지가 표시되어야 합니다!\n     Running `target/debug/hello`\nConnection established!\nConnection established!\nConnection established!\n\n때로는 하나의 브라우저 요청에 대해 여러 메시지가 인쇄되는 것을 볼 수 있습니다. 그 이유는 브라우저가 브라우저 탭에 표시되는 favicon.ico 아이콘 과 같은 다른 리소스에 대한 요청뿐만 아니라 페이지에 대한 요청을 하기 때문일 수 있습니다.\n서버가 어떤 데이터로도 응답하지 않기 때문에 브라우저가 서버에 여러 번 연결을 시도하는 것일 수도 있습니다. stream이 범위를 벗어나 루프 끝에서 삭제되면 drop 구현의 일부로 연결이 닫힙니다. 문제가 일시적일 수 있기 때문에 브라우저는 때때로 재시도를 통해 닫힌 연결을 처리합니다. 중요한 요소는 TCP 연결에 대한 핸들을 성공적으로 얻었다는 것입니다!\n특정 버전의 코드 실행이 완료되면 ctrl-c를 눌러 프로그램을 중지해야 합니다. 그런 다음 최신 코드를 실행하고 있는지 확인하기 위해 각 코드 세트를 변경한 후 cargo run 명령을 호출하여 프로그램을 다시 시작하십시오.\n요청 읽기\n브라우저에서 요청을 읽는 기능을 구현해 봅시다! 먼저 연결을 얻은 다음 연결에 대해 몇 가지 작업을 수행하는 문제를 분리하기 위해 연결을 처리하는 새 기능을 시작합니다. 이 새로운 handle_connection 함수에서는 TCP 스트림에서 데이터를 읽고 인쇄하여 브라우저에서 전송되는 데이터를 볼 수 있습니다. 목록 20-2와 같이 코드를 변경합니다.\n파일 이름: src/main.rs\nuse std::{\n    io::{prelude::*, BufReader},\n    net::{TcpListener, TcpStream},\n};\n\nfn main() {\n    let listener = TcpListener::bind(`127.0.0.1:7878`).unwrap();\n\n    for stream in listener.incoming() {\n        let stream = stream.unwrap();\n    \n        handle_connection(stream);\n    }\n}\n\nfn handle_connection(mut stream: TcpStream) {\n    let buf_reader = BufReader::new(&amp;mut stream);\n    let http_request: Vec&lt;_&gt; = buf_reader\n        .lines()\n        .map(|result| result.unwrap())\n        .take_while(|line| !line.is_empty())\n        .collect();\n\n    println!(`Request: {:#?}`, http_request);\n}\n\n목록 20-2: TcpStream에서 읽고 데이터 인쇄\nstd::io::prelude 및 std::io::BufReader를 범위로 가져와 스트림에서 읽고 쓸 수 있는 특성 및 유형에 액세스합니다. main 함수의 for 루프에서 우리가 연결했다는 메시지를 인쇄하는 대신 이제 새로운 handle_connection 함수를 호출하고 stream을 전달합니다.\nhandle_connection 함수에서 스트림에 대한 변경 가능한 참조를 래핑하는 새 BufReader 인스턴스를 만듭니다. BufReader는 std::io::Read 특성 메서드에 대한 호출을 관리하여 버퍼링을 추가합니다.\n브라우저가 서버로 보내는 요청 라인을 수집하기 위해 http_request라는 변수를 생성합니다. Vec&lt;_&gt; 유형 주석을 추가하여 벡터에서 이러한 라인을 수집하고 싶다는 것을 나타냅니다.\nBufReader는 lines 메소드를 제공하는 std::io::BufRead 특성을 구현합니다. lines 메서드는 개행 바이트를 볼 때마다 데이터 스트림을 분할하여 Result&lt;String, std::io::Error&gt;의 반복자를 반환합니다. 각 문자열을 얻기 위해 각 결과를 매핑하고 언래핑합니다. 데이터가 유효한 UTF-8이 아니거나 스트림에서 읽는 데 문제가 있는 경우 결과는 오류일 수 있습니다. 다시 말하지만 프로덕션 프로그램은 이러한 오류를 보다 우아하게 처리해야 하지만 단순성을 위해 오류 사례에서 프로그램을 중지하도록 선택했습니다.\n브라우저는 줄 바꿈 문자 두 개를 연속으로 전송하여 HTTP 요청의 끝을 알립니다. 따라서 스트림에서 하나의 요청을 얻으려면 빈 문자열인 줄을 얻을 때까지 줄을 섭니다. 라인을 벡터로 수집하면 웹 브라우저가 서버로 보내는 명령을 볼 수 있도록 예쁜 디버그 형식을 사용하여 라인을 인쇄합니다.\n이 코드를 사용해 봅시다! 프로그램을 시작하고 웹 브라우저에서 다시 요청하십시오. 여전히 브라우저에 오류 페이지가 표시되지만 터미널의 프로그램 출력은 이제 다음과 유사하게 표시됩니다.\n$ cargo run\n   Compiling hello v0.1.0 (file:///projects/hello)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.42s\n     Running `target/debug/hello`\nRequest: [\n    `GET / HTTP/1.1`,\n    `Host: 127.0.0.1:7878`,\n    `User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:99.0) Gecko/20100101 Firefox/99.0`,\n    `Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8`,\n    `Accept-Language: en-US,en;q=0.5`,\n    `Accept-Encoding: gzip, deflate, br`,\n    `DNT: 1`,\n    `Connection: keep-alive`,\n    `Upgrade-Insecure-Requests: 1`,\n    `Sec-Fetch-Dest: document`,\n    `Sec-Fetch-Mode: navigate`,\n    `Sec-Fetch-Site: none`,\n    `Sec-Fetch-User: ?1`,\n    `Cache-Control: max-age=0`,\n]\n\n브라우저에 따라 출력이 약간 다를 수 있습니다. 이제 요청 데이터를 인쇄하고 있으므로 요청의 첫 번째 줄에서 GET 뒤에 있는 경로를 보면 하나의 브라우저 요청에서 여러 연결을 얻는 이유를 알 수 있습니다. 반복되는 연결이 모두 / 를 요청하는 경우 프로그램에서 응답을 받지 못하기 때문에 브라우저가 / 반복적으로 가져오려고 시도하고 있음을 알 수 있습니다.\n브라우저가 우리 프로그램에 무엇을 요구하는지 이해하기 위해 이 요청 데이터를 분석해 봅시다.\nHTTP 요청 자세히 살펴보기\nHTTP는 텍스트 기반 프로토콜이며 요청은 다음 형식을 사용합니다.\nMethod Request-URI HTTP-Version CRLF\nheaders CRLF\nmessage-body\n\n첫 번째 줄은 클라이언트가 요청한 내용에 대한 정보를 담고 있는 요청 줄 입니다. 요청 줄의 첫 번째 부분은 클라이언트가 이 요청을 만드는 방법을 설명하는 GET 또는 POST와 같이 사용 중인 메서드를 나타냅니다. 우리 클라이언트는 정보를 요청하는 GET 요청을 사용했습니다.\n요청 줄의 다음 부분은 / 로, 클라이언트가 요청하는 URI( Uniform Resource Identifier )를 나타냅니다. URI는 URL( Uniform Resource Locator ) 과 거의 동일하지만 완전하지는 않습니다. URI와 URL의 차이는 이 장의 목적에 중요하지 않지만 HTTP 사양은 URI라는 용어를 사용하므로 여기서는 정신적으로 URL을 URI로 대체할 수 있습니다.\n마지막 부분은 클라이언트가 사용하는 HTTP 버전이며 요청 라인은 CRLF 시퀀스 로 끝납니다. (CRLF는 캐리지 리턴 과 줄 바꿈을 의미하며 타자기 시대의 용어입니다!) CRLF 시퀀스는 \\r\\n으로도 쓸 수 있습니다. 여기서 \\r은 캐리지 리턴이고 \\n은 줄 바꿈. CRLF 시퀀스는 나머지 요청 데이터에서 요청 라인을 분리합니다. CRLF가 인쇄될 때 \\r\\n이 아닌 새 줄 시작이 표시됩니다.\n지금까지 프로그램을 실행하여 받은 요청 라인 데이터를 보면 GET이 메서드이고 / 가 요청 URI이고 HTTP/1.1이 버전임을 알 수 있습니다.\n요청 줄 다음에 Host:부터 시작하여 나머지 줄은 헤더입니다. GET 요청에는 본문이 없습니다.\n다른 브라우저에서 요청하거나 127.0.0.1:7878/test 와 같은 다른 주소를 요청하여 요청 데이터가 어떻게 변경되는지 확인하십시오.\n이제 브라우저가 무엇을 요청하는지 알았으므로 일부 데이터를 다시 보내겠습니다!\n응답 작성\n클라이언트 요청에 대한 응답으로 데이터 전송을 구현할 것입니다. 응답의 형식은 다음과 같습니다.\nHTTP-Version Status-Code Reason-Phrase CRLF\nheaders CRLF\nmessage-body\n\n첫 번째 줄은 응답에 사용된 HTTP 버전, 요청 결과를 요약하는 숫자 상태 코드 및 상태 코드에 대한 텍스트 설명을 제공하는 이유 문구를 포함하는 상태 줄입니다 . CRLF 시퀀스 뒤에는 헤더, 다른 CRLF 시퀀스 및 응답 본문이 있습니다.\n다음은 HTTP 버전 1.1을 사용하고 상태 코드 200, OK 이유 문구, 헤더 및 본문이 없는 예제 응답입니다.\nHTTP/1.1 200 OK\\r\\n\\r\\n\n\n상태 코드 200은 표준 성공 응답입니다. 텍스트는 아주 작은 성공적인 HTTP 응답입니다. 성공적인 요청에 대한 응답으로 이것을 스트림에 작성해 봅시다! handle_connection 함수에서 println! 요청 데이터를 인쇄하고 Listing 20-3의 코드로 대체합니다.\n파일 이름: src/main.rs\nfn handle_connection(mut stream: TcpStream) {\n    let buf_reader = BufReader::new(&amp;mut stream);\n    let http_request: Vec&lt;_&gt; = buf_reader\n        .lines()\n        .map(|result| result.unwrap())\n        .take_while(|line| !line.is_empty())\n        .collect();\n\n    let response = `HTTP/1.1 200 OK\\r\\n\\r\\n`;\n    \n    stream.write_all(response.as_bytes()).unwrap();\n}\n\nListing 20-3: 스트림에 작은 성공 HTTP 응답 쓰기\n첫 번째 줄은 성공 메시지의 데이터를 보유하는 response 변수를 정의합니다. 그런 다음 응답에서 as_bytes를 호출하여 문자열 데이터를 바이트로 변환합니다. stream의 write_all 메서드는 &amp;[u8]을 사용하여 해당 바이트를 연결 아래로 직접 보냅니다. write_all 작업이 실패할 수 있으므로 이전과 같이 모든 오류 결과에 대해 unwrap을 사용합니다. 다시 말하지만 실제 애플리케이션에서는 여기에 오류 처리를 추가합니다.\n이러한 변경 사항을 사용하여 코드를 실행하고 요청해 보겠습니다. 더 이상 터미널에 데이터를 인쇄하지 않으므로 Cargo의 출력 외에는 출력이 표시되지 않습니다. 웹 브라우저에서 127.0.0.1:7878을 로드하면 오류 대신 빈 페이지가 표시됩니다. HTTP 요청 수신 및 응답 전송을 직접 코딩했습니다!\n실제 HTML 반환\n빈 페이지 이상을 반환하는 기능을 구현해 봅시다. src 디렉터리 가 아니라 프로젝트 디렉터리의 루트에 새 파일 hello.html을 만듭니다. 원하는 HTML을 입력할 수 있습니다. 목록 20-4는 한 가지 가능성을 보여줍니다.\n파일명: hello.html\n&lt;!DOCTYPE html&gt;\n&lt;html lang=`en`&gt;\n  &lt;head&gt;\n    &lt;meta charset=`utf-8`&gt;\n    &lt;title&gt;Hello!&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;Hello!&lt;/h1&gt;\n    &lt;p&gt;Hi from Rust&lt;/p&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n\n목록 20-4: 응답으로 반환할 샘플 HTML 파일\n이것은 제목과 일부 텍스트가 있는 최소한의 HTML5 문서입니다. 요청을 받았을 때 서버에서 이를 반환하기 위해 Listing 20-5와 같이 handle_connection을 수정하여 HTML 파일을 읽고 본문으로 응답에 추가하여 보냅니다.\n파일 이름: src/main.rs\nuse std::{\n    fs,\n    io::{prelude::*, BufReader},\n    net::{TcpListener, TcpStream},\n};\n// --snip--\n\nfn handle_connection(mut stream: TcpStream) {\n    let buf_reader = BufReader::new(&amp;mut stream);\n    let http_request: Vec&lt;_&gt; = buf_reader\n        .lines()\n        .map(|result| result.unwrap())\n        .take_while(|line| !line.is_empty())\n        .collect();\n\n    let status_line = `HTTP/1.1 200 OK`;\n    let contents = fs::read_to_string(`hello.html`).unwrap();\n    let length = contents.len();\n    \n    let response =\n        format!(`{status_line}\\r\\nContent-Length: {length}\\r\\n\\r\\n{contents}`);\n    \n    stream.write_all(response.as_bytes()).unwrap();\n}\n\n목록 20-5: 응답 본문으로 hello.html 의 내용 보내기\n표준 라이브러리의 파일 시스템 모듈을 범위로 가져오기 위해 use 문에 fs를 추가했습니다. 파일의 내용을 문자열로 읽는 코드는 익숙할 것입니다. Listing 12-4의 I/O 프로젝트에 대한 파일 내용을 읽을 때 12장에서 사용했습니다.\n다음으로 포맷!을 사용합니다. 파일의 내용을 성공 응답의 본문으로 추가합니다. 유효한 HTTP 응답을 보장하기 위해 응답 본문의 크기(이 경우 hello.html 크기)로 설정된 Content-Length 헤더를 추가합니다.\ncargo run으로 이 코드를 실행하고 브라우저에서 127.0.0.1:7878을 로드합니다. HTML이 렌더링되는 것을 볼 수 있습니다!\n현재는 http_request의 요청 데이터를 무시하고 무조건 HTML 파일의 내용만 되돌려 보내고 있습니다. 즉, 브라우저에서 127.0.0.1:7878/something-else를 요청하면 여전히 동일한 HTML 응답을 받게 됩니다. 현재 저희 서버는 매우 제한적이며 대부분의 웹 서버가 하는 일을 하지 않습니다. 우리는 요청에 따라 응답을 사용자 지정하고 / 에 대한 올바른 형식의 요청에 대한 HTML 파일만 다시 보내길 원합니다.\n요청 확인 및 선택적으로 응답\n지금 우리 웹 서버는 클라이언트가 무엇을 요청하든 파일에 HTML을 반환합니다. HTML 파일을 반환하기 전에 브라우저가 요청하고 있는지 확인하고 브라우저가 다른 것을 요청하면 오류를 반환하는 기능을 추가해 봅시다 . 이를 위해 Listing 20-6에 표시된 것처럼 handle_connection을 수정해야 합니다. 이 새로운 코드는 우리가 알고 있는 요청의 모양 과 수신된 요청의 내용을 확인 하고 if 및 else 블록을 추가하여 요청을 다르게 처리합니다.\n파일 이름: src/main.rs\n// --snip--\n\nfn handle_connection(mut stream: TcpStream) {\n    let buf_reader = BufReader::new(&amp;mut stream);\n    let request_line = buf_reader.lines().next().unwrap().unwrap();\n\n    if request_line == `GET / HTTP/1.1` {\n        let status_line = `HTTP/1.1 200 OK`;\n        let contents = fs::read_to_string(`hello.html`).unwrap();\n        let length = contents.len();\n    \n        let response = format!(\n            `{status_line}\\r\\nContent-Length: {length}\\r\\n\\r\\n{contents}`\n        );\n    \n        stream.write_all(response.as_bytes()).unwrap();\n    } else {\n        // some other request\n    }\n}\n\nListing 20-6: 다른 요청에 대한 / 다른 요청 처리\nHTTP 요청의 첫 번째 줄만 볼 것이므로 전체 요청을 벡터로 읽는 대신 반복자에서 첫 번째 항목을 가져오기 위해 next를 호출합니다. 첫 번째 unwrap은 Option을 처리하고 반복자에 항목이 없으면 프로그램을 중지합니다. 두 번째 unwrap은 Result를 처리하며 Listing 20-2에 추가된 map에 있던 unwrap과 동일한 효과를 가집니다.\n다음으로 request_line을 확인하여 / 경로에 대한 GET 요청의 요청 라인과 동일한지 확인합니다. 그렇다면 if 블록은 HTML 파일의 내용을 반환합니다.\nrequest_line이 / 경로 에 대한 GET 요청과 같지 않으면 다른 요청을 수신했음을 의미합니다. 잠시 후 else 블록에 코드를 추가하여 다른 모든 요청에 응답합니다.\n지금 이 코드를 실행하고 127.0.0.1:7878을 요청하십시오 . hello.html 에서 HTML을 가져와야 합니다. 127.0.0.1:7878/something-else 와 같은 다른 요청을 하면 Listing 20-1 및 Listing 20-2에서 코드를 실행할 때 본 것과 같은 연결 오류가 발생합니다.\n이제 Listing 20-7의 코드를 else 블록에 추가하여 상태 코드 404와 함께 응답을 반환하도록 합시다. 이 코드는 요청 내용을 찾을 수 없다는 신호입니다. 또한 최종 사용자에게 응답을 나타내는 브라우저에서 렌더링할 페이지에 대한 일부 HTML을 반환합니다.\n파일 이름: src/main.rs\n    // --snip--\n    } else {\n        let status_line = `HTTP/1.1 404 NOT FOUND`;\n        let contents = fs::read_to_string(`404.html`).unwrap();\n        let length = contents.len();\n\n        let response = format!(\n            `{status_line}\\r\\nContent-Length: {length}\\r\\n\\r\\n{contents}`\n        );\n    \n        stream.write_all(response.as_bytes()).unwrap();\n    }\n\n목록 20-7: / 이외의 것이 요청된 경우 상태 코드 404 및 오류 페이지로 응답\n여기에서 응답에는 상태 코드 404와 이유 문구 NOT FOUND가 있는 상태 표시줄이 있습니다. 응답 본문은 404.html 파일의 HTML입니다. 오류 페이지에 대한 hello.html 옆에 404.html 파일을 만들어야 합니다. 원하는 HTML을 자유롭게 사용하거나 Listing 20-8에 있는 예제 HTML을 다시 사용하십시오.\n파일 이름: 404.html\n&lt;!DOCTYPE html&gt;\n&lt;html lang=`en`&gt;\n  &lt;head&gt;\n    &lt;meta charset=`utf-8`&gt;\n    &lt;title&gt;Hello!&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;h1&gt;Oops!&lt;/h1&gt;\n    &lt;p&gt;Sorry, I don`t know what you`re asking for.&lt;/p&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n\n목록 20-8: 404 응답과 함께 다시 보낼 페이지의 샘플 콘텐츠\n이러한 변경 사항으로 서버를 다시 실행하십시오. 127.0.0.1:7878을 요청하면 hello.html 의 내용이 반환되어야 하며 127.0.0.1:7878/foo 와 같은 다른 요청은 404.html 에서 오류 HTML을 반환해야 합니다.\n리팩토링의 손길\n현재 if 및 else 블록은 반복되는 부분이 많습니다. 둘 다 파일을 읽고 파일 내용을 스트림에 씁니다. 유일한 차이점은 상태 표시줄과 파일 이름입니다. 상태 표시줄의 값과 파일 이름을 변수에 할당하는 별도의 if 및 else 줄로 이러한 차이점을 제거하여 코드를 더 간결하게 만들어 보겠습니다. 그런 다음 코드에서 해당 변수를 무조건 사용하여 파일을 읽고 응답을 작성할 수 있습니다. 목록 20-9는 큰 if 및 else 블록을 교체한 후의 결과 코드를 보여줍니다.\n파일 이름: src/main.rs\n// --snip--\n\nfn handle_connection(mut stream: TcpStream) {\n    // --snip--\n\n    let (status_line, filename) = if request_line == `GET / HTTP/1.1` {\n        (`HTTP/1.1 200 OK`, `hello.html`)\n    } else {\n        (`HTTP/1.1 404 NOT FOUND`, `404.html`)\n    };\n    \n    let contents = fs::read_to_string(filename).unwrap();\n    let length = contents.len();\n    \n    let response =\n        format!(`{status_line}\\r\\nContent-Length: {length}\\r\\n\\r\\n{contents}`);\n    \n    stream.write_all(response.as_bytes()).unwrap();\n}\n\n목록 20-9: if 및 else 블록을 리팩터링하여 두 경우 사이에 다른 코드만 포함\n이제 if 및 else 블록은 튜플의 상태 표시줄 및 파일 이름에 대한 적절한 값만 반환합니다. 그런 다음 18장에서 설명한 대로 let 문의 패턴을 사용하여 이 두 값을 status_line 및 filename에 할당하기 위해 구조 분해를 사용합니다.\n이전에 복제된 코드는 이제 if 및 else 블록 외부에 있으며 status_line 및 filename 변수를 사용합니다. 이렇게 하면 두 경우의 차이를 더 쉽게 볼 수 있으며 파일 읽기 및 응답 쓰기 작동 방식을 변경하려는 경우 코드를 업데이트할 위치가 한 곳뿐이라는 의미입니다. Listing 20-9의 코드 동작은 Listing 20-8과 동일합니다.\n엄청난! 이제 우리는 콘텐츠 페이지로 한 요청에 응답하고 404 응답으로 다른 모든 요청에 응답하는 약 40줄의 Rust 코드로 된 간단한 웹 서버를 갖게 되었습니다.\n현재 우리 서버는 단일 스레드에서 실행되므로 한 번에 하나의 요청만 처리할 수 있습니다. 일부 느린 요청을 시뮬레이트하여 이것이 어떻게 문제가 될 수 있는지 살펴보겠습니다. 그런 다음 서버가 한 번에 여러 요청을 처리할 수 있도록 수정합니다.\n\n단일 스레드 서버를 다중 스레드 서버로 전환\n현재 서버는 각 요청을 차례로 처리합니다. 즉, 첫 번째 연결이 완료될 때까지 두 번째 연결을 처리하지 않습니다. 서버가 점점 더 많은 요청을 받으면 이 직렬 실행은 점점 더 최적이 되지 않습니다. 서버가 처리하는 데 시간이 오래 걸리는 요청을 받으면 후속 요청은 새 요청을 빠르게 처리할 수 있더라도 긴 요청이 완료될 때까지 기다려야 합니다. 이 문제를 해결해야 하지만 먼저 작동 중인 문제를 살펴보겠습니다.\n현재 서버 구현에서 느린 요청 시뮬레이션\n처리 속도가 느린 요청이 현재 서버 구현에 대한 다른 요청에 어떤 영향을 미칠 수 있는지 살펴보겠습니다. 목록 20-10 은 서버가 응답하기 전에 5초 동안 휴면 상태가 되게 하는 시뮬레이션된 느린 응답으로 /sleep 에 대한 요청 처리를 구현합니다.\n파일 이름: src/main.rs\nuse std::{\n    fs,\n    io::{prelude::*, BufReader},\n    net::{TcpListener, TcpStream},\n    thread,\n    time::Duration,\n};\n// --snip--\n\nfn handle_connection(mut stream: TcpStream) {\n    // --snip--\n\n    let (status_line, filename) = match &amp;request_line[..] {\n        `GET / HTTP/1.1` =&gt; (`HTTP/1.1 200 OK`, `hello.html`),\n        `GET /sleep HTTP/1.1` =&gt; {\n            thread::sleep(Duration::from_secs(5));\n            (`HTTP/1.1 200 OK`, `hello.html`)\n        }\n        _ =&gt; (`HTTP/1.1 404 NOT FOUND`, `404.html`),\n    };\n    \n    // --snip--\n}\n\n목록 20-10: 5초 동안 휴면하여 느린 요청 시뮬레이션\n이제 세 가지 경우가 있으므로 if에서 match로 전환했습니다. 문자열 리터럴 값에 대한 패턴 일치를 위해 request_line 조각에서 명시적으로 일치해야 합니다. match는 같음 메서드처럼 자동 참조 및 역참조를 수행하지 않습니다.\n첫 번째 팔은 목록 20-9의 if 블록과 동일합니다. 두 번째 팔은 /sleep 에 대한 요청과 일치합니다. 해당 요청이 수신되면 서버는 성공적인 HTML 페이지를 렌더링하기 전에 5초 동안 휴면 상태가 됩니다. 세 번째 팔은 목록 20-9의 else 블록과 동일합니다.\n우리 서버가 얼마나 원시적인지 알 수 있습니다. 실제 라이브러리는 훨씬 덜 장황한 방식으로 여러 요청의 인식을 처리합니다!\ncargo run을 사용하여 서버를 시작하십시오. 그런 다음 두 개의 브라우저 창을 엽니다. 하나는 http://127.0.0.1:7878/ 용 이고 다른 하나는 http://127.0.0.1:7878/sleep 용입니다. 이전처럼 / URI를 몇 번 입력하면 빠르게 응답하는 것을 볼 수 있습니다. 그러나 /sleep을 입력한 다음 /를 로드하면 로드하기 전에 sleep이 전체 5초 동안 절전 모드로 전환될 때까지 / 가 대기하는 것을 볼 수 있습니다.\n느린 요청 뒤에 요청이 백업되는 것을 방지하기 위해 사용할 수 있는 여러 기술이 있습니다. 우리가 구현할 것은 스레드 풀입니다.\n스레드 풀로 처리량 향상\n스레드 풀은 작업을 처리할 준비가 되어 대기 중인 생성된 스레드 그룹입니다. 프로그램이 새 작업을 수신하면 풀의 스레드 중 하나를 작업에 할당하고 해당 스레드가 작업을 처리합니다. 풀의 나머지 스레드는 첫 번째 스레드가 처리되는 동안 들어오는 다른 작업을 처리하는 데 사용할 수 있습니다. 첫 번째 스레드가 작업 처리를 완료하면 새 작업을 처리할 준비가 된 유휴 스레드 풀로 반환됩니다. 스레드 풀을 사용하면 연결을 동시에 처리하여 서버의 처리량을 높일 수 있습니다.\n서비스 거부(DoS) 공격으로부터 보호하기 위해 풀의 스레드 수를 적은 수로 제한합니다. 프로그램이 요청이 들어올 때마다 새 스레드를 생성하도록 하면 서버에 천만 건의 요청을 하는 누군가가 서버의 리소스를 모두 사용하고 요청 처리를 중단시켜 대혼란을 일으킬 수 있습니다.\n그러면 무제한 스레드를 생성하는 대신 풀에서 대기 중인 고정된 수의 스레드를 갖게 됩니다. 들어오는 요청은 처리를 위해 풀로 전송됩니다. 풀은 들어오는 요청의 대기열을 유지합니다. 풀의 각 스레드는 이 큐에서 요청을 팝 오프하고 요청을 처리한 다음 큐에 다른 요청을 요청합니다. 이 디자인을 사용하면 최대 N개의 요청을 동시에 처리할 수 있습니다. 여기서 N은 스레드 수입니다. 각 스레드가 장기 실행 요청에 응답하는 경우 후속 요청은 여전히 대기열에 백업될 수 있지만 해당 지점에 도달하기 전에 처리할 수 있는 장기 실행 요청의 수를 늘렸습니다.\n이 기술은 웹 서버의 처리량을 향상시키는 여러 방법 중 하나일 뿐입니다. 탐색할 수 있는 다른 옵션은 fork/join 모델 , 단일 스레드 비동기 I/O 모델 또는 다중 스레드 비동기 I/O 모델 입니다 . 이 항목에 관심이 있는 경우 다른 솔루션에 대해 자세히 읽고 구현해 볼 수 있습니다. Rust와 같은 저수준 언어를 사용하면 이러한 모든 옵션이 가능합니다.\n스레드 풀 구현을 시작하기 전에 풀을 사용하는 모습에 대해 이야기해 봅시다. 코드를 디자인하려고 할 때 클라이언트 인터페이스를 먼저 작성하면 디자인을 안내하는 데 도움이 될 수 있습니다. 호출하려는 방식으로 구조화되도록 코드의 API를 작성합니다. 그런 다음 기능을 구현한 다음 공용 API를 설계하는 대신 해당 구조 내에서 기능을 구현합니다.\n12장에서 프로젝트에서 테스트 기반 개발을 사용한 방법과 유사하게 여기서는 컴파일러 기반 개발을 사용합니다. 원하는 함수를 호출하는 코드를 작성한 다음 컴파일러의 오류를 살펴보고 코드가 작동하도록 하기 위해 다음에 무엇을 변경해야 하는지 결정합니다. 그러나 그 전에 시작점으로 사용하지 않을 기술을 살펴보겠습니다.\n각 요청에 대한 스레드 생성\n먼저 모든 연결에 대해 새 스레드를 생성한 경우 코드가 어떻게 표시되는지 살펴보겠습니다. 앞에서 언급한 바와 같이 잠재적으로 무제한의 스레드를 생성할 수 있는 문제로 인해 이것이 우리의 최종 계획은 아니지만 작동하는 다중 스레드 서버를 먼저 얻는 출발점입니다. 그런 다음 스레드 풀을 개선 사항으로 추가하고 두 솔루션을 대조하는 것이 더 쉬울 것입니다. 목록 20-11은 for 루프 내에서 각 스트림을 처리하기 위해 새 스레드를 생성하기 위해 main에 대한 변경 사항을 보여줍니다.\n파일 이름: src/main.rs\nfn main() {\n    let listener = TcpListener::bind(`127.0.0.1:7878`).unwrap();\n\n    for stream in listener.incoming() {\n        let stream = stream.unwrap();\n    \n        thread::spawn(|| {\n            handle_connection(stream);\n        });\n    }\n}\n\nListing 20-11: 각 스트림에 대한 새 스레드 생성\n16장에서 배운 것처럼 thread::spawn은 새 스레드를 생성한 다음 클로저의 코드를 새 스레드에서 실행합니다. 이 코드를 실행하고 브라우저에서 /sleep을 로드하면 두 개의 추가 브라우저 탭에서 / 에 대한 요청이 /sleep이 완료될 때까지 기다릴 필요가 없음 을 실제로 확인할 수 있습니다. 그러나 우리가 언급한 것처럼 제한 없이 새 스레드를 만들게 되므로 결국 시스템을 압도할 것입니다.\n한정된 수의 스레드 생성\n우리는 스레드 풀이 유사하고 친숙한 방식으로 작동하기를 원하므로 스레드에서 스레드 풀로 전환할 때 API를 사용하는 코드를 크게 변경할 필요가 없습니다. 목록 20-12는 thread::spawn 대신 사용하려는 ThreadPool 구조체에 대한 가상 인터페이스를 보여줍니다.\n파일 이름: src/main.rs\nfn main() {\n    let listener = TcpListener::bind(`127.0.0.1:7878`).unwrap();\n    let pool = ThreadPool::new(4);\n\n    for stream in listener.incoming() {\n        let stream = stream.unwrap();\n    \n        pool.execute(|| {\n            handle_connection(stream);\n        });\n    }\n}\n\n목록 20-12: 이상적인 ThreadPool 인터페이스\nThreadPool::new를 사용하여 구성 가능한 수의 스레드(이 경우에는 4개)로 새 스레드 풀을 만듭니다. 그런 다음 for 루프에서 pool.execute는 풀이 각 스트림에 대해 실행되어야 하는 클로저를 취한다는 점에서 thread::spawn과 유사한 인터페이스를 가집니다. pool.execute를 구현해야 클로저를 가져와 풀의 스레드에 제공하여 실행할 수 있습니다. 이 코드는 아직 컴파일되지 않지만 컴파일러가 수정 방법을 안내할 수 있도록 노력하겠습니다.\n컴파일러 기반 개발을 사용하여 ThreadPool 구축\nListing 20-12에서 src/main.rs 로 변경한 다음 cargo check의 컴파일러 오류를 사용하여 개발을 추진해 봅시다. 다음은 첫 번째 오류입니다.\n$ cargo check\n    Checking hello v0.1.0 (file:///projects/hello)\nerror[E0433]: failed to resolve: use of undeclared type `ThreadPool`\n  --&gt; src/main.rs:11:16\n   |\n11 |     let pool = ThreadPool::new(4);\n   |                ^^^^^^^^^^ use of undeclared type `ThreadPool`\n\nFor more information about this error, try `rustc --explain E0433`.\nerror: could not compile `hello` due to previous error\n\n엄청난! 이 오류는 ThreadPool 유형 또는 모듈이 필요하다는 것을 알려주므로 지금 빌드하겠습니다. 우리의 ThreadPool 구현은 웹 서버가 수행하는 작업 종류와 독립적입니다. 따라서 hello 크레이트를 바이너리 크레이트에서 라이브러리 크레이트로 전환하여 ThreadPool 구현을 유지해 보겠습니다. 라이브러리 크레이트로 변경한 후에는 웹 요청을 제공하는 것뿐만 아니라 스레드 풀을 사용하여 수행하려는 모든 작업에 대해 별도의 스레드 풀 라이브러리를 사용할 수도 있습니다.\n다음을 포함하는 src/lib.rs를 생성합니다. 이것은 현재 우리가 가질 수 있는 ThreadPool 구조체의 가장 간단한 정의입니다.\n파일 이름: src/lib.rs\npub struct ThreadPool;\n\n그런 다음 src/main.rs 맨 위에 다음 코드를 추가하여 라이브러리 크레이트에서 ThreadPool을 범위로 가져오도록 main.rs 파일을 편집합니다.\n파일 이름: src/main.rs\nuse hello::ThreadPool;\n\n이 코드는 여전히 작동하지 않지만 다시 확인하여 해결해야 할 다음 오류를 가져옵니다.\n$ cargo check\n    Checking hello v0.1.0 (file:///projects/hello)\nerror[E0599]: no function or associated item named `new` found for struct `ThreadPool` in the current scope\n  --&gt; src/main.rs:12:28\n   |\n12 |     let pool = ThreadPool::new(4);\n   |                            ^^^ function or associated item not found in `ThreadPool`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `hello` due to previous error\n\n이 오류는 다음에 ThreadPool에 대해 new라는 관련 함수를 만들어야 함을 나타냅니다. 또한 new에는 4를 인수로 허용하고 ThreadPool 인스턴스를 반환할 수 있는 매개 변수가 하나 있어야 한다는 것도 알고 있습니다. 이러한 특성을 갖는 가장 간단한 새 함수를 구현해 보겠습니다.\n파일 이름: src/lib.rs\npub struct ThreadPool;\n\nimpl ThreadPool {\n    pub fn new(size: usize) -&gt; ThreadPool {\n        ThreadPool\n    }\n}\n\n크기 매개변수의 유형으로 usize를 선택했습니다. 스레드 수가 음수인 것은 의미가 없다는 것을 알고 있기 때문입니다. 우리는 또한 3장의 정수 유형 섹션에서 논의한 것처럼 usize 유형이 필요한 스레드 모음의 요소 수로 이 4를 사용할 것임을 알고 있습니다.\n코드를 다시 확인해 보겠습니다.\n$ cargo check\n    Checking hello v0.1.0 (file:///projects/hello)\nerror[E0599]: no method named `execute` found for struct `ThreadPool` in the current scope\n  --&gt; src/main.rs:17:14\n   |\n17 |         pool.execute(|| {\n   |              ^^^^^^^ method not found in `ThreadPool`\n\nFor more information about this error, try `rustc --explain E0599`.\nerror: could not compile `hello` due to previous error\n\n이제 ThreadPool에 execute 메서드가 없기 때문에 오류가 발생합니다. 스레드 풀이 thread::spawn과 유사한 인터페이스를 가져야 한다고 결정한 유한한 수의 스레드 만들기 섹션을 기억하십시오 . 또한 실행 기능을 구현하여 주어진 클로저를 가져와 풀의 유휴 스레드에 제공하여 실행할 수 있도록 합니다.\nThreadPool에 execute 메소드를 정의하여 클로저를 매개변수로 사용합니다. Fn, FnMut 및 FnOnce의 세 가지 다른 특성을 사용하여 클로저를 매개변수로 사용할 수 있는 13장의 [캡처된 값을 클로저 외부로 이동 및 Fn특성](https://doc.rust-lang.org/book/ch13-01-closures.html#moving-captured-values-out-of-the-closure-and-the-fn-traits) 섹션 에서 기억하십시오 . 여기서 어떤 종류의 클로저를 사용할지 결정해야 합니다. 우리는 표준 라이브러리 thread::spawn 구현과 유사한 작업을 수행하게 될 것임을 알고 있으므로 thread::spawn의 서명이 해당 매개 변수에 어떤 범위를 갖는지 확인할 수 있습니다. 문서는 다음을 보여줍니다.\npub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;\n    where\n        F: FnOnce() -&gt; T,\n        F: Send + `static,\n        T: Send + `static,\n\nF 유형 매개변수는 여기서 우리가 관심을 갖는 매개변수입니다. T 유형 매개변수는 반환 값과 관련이 있으며 우리는 그것에 관심이 없습니다. spawn이 F에 바인딩된 특성으로 FnOnce를 사용하는 것을 볼 수 있습니다. execute에서 얻은 인수를 spawn으로 전달할 것이기 때문에 이것은 아마도 우리가 원하는 것일 수도 있습니다. FnOnce는 요청을 실행하는 스레드가 해당 요청의 클로저를 한 번만 실행하므로 FnOnce의 Once와 일치하기 때문에 FnOnce가 우리가 사용하려는 특성임을 확신할 수 있습니다.\nF 유형 매개변수에는 특성 바인딩 Send와 수명 바인딩 ``정적이 있으며 이는 우리 상황에서 유용합니다. 클로저를 한 스레드에서 다른 스레드로 전송하려면 Send가 필요하고 정적은 정적이기 때문입니다. 우리는 스레드가 실행되는 데 얼마나 오래 걸릴지 모릅니다. F유형의 일반 매개변수를 사용하는ThreadPool에서 execute` 메서드를 만들어 보겠습니다.\n파일 이름: src/lib.rs\nimpl ThreadPool {\n    // --snip--\n    pub fn execute&lt;F&gt;(&amp;self, f: F)\n    where\n        F: FnOnce() + Send + `static,\n    {\n    }\n}\n\n이 FnOnce는 매개변수를 받지 않고 단위 유형 ()을 반환하는 클로저를 나타내기 때문에 여전히 FnOnce 뒤에 ()를 사용합니다. 함수 정의와 마찬가지로 서명에서 반환 유형을 생략할 수 있지만 매개 변수가 없더라도 여전히 괄호가 필요합니다.\n다시 말하지만 이것은 execute 메서드의 가장 간단한 구현입니다. 아무 작업도 수행하지 않지만 우리는 코드를 컴파일하려고만 합니다. 다시 확인해 봅시다:\n$ cargo check\n    Checking hello v0.1.0 (file:///projects/hello)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.24s\n\n컴파일됩니다! 그러나 cargo run을 시도하고 브라우저에서 요청을 하면 이 장의 시작 부분에서 보았던 오류가 브라우저에서 표시됩니다. 우리 라이브러리는 아직 실행으로 전달된 클로저를 실제로 호출하지 않습니다!\n\n참고: Haskell 및 Rust와 같이 엄격한 컴파일러를 사용하는 언어에 대해 들을 수 있는 말은 코드가 컴파일되면 작동합니다.입니다. 그러나 이 말은 보편적인 사실이 아니다. 우리 프로젝트는 컴파일되지만 아무것도 하지 않습니다! 실제 완전한 프로젝트를 구축하고 있다면 코드가 컴파일되고 원하는 동작이 있는지 확인하기 위해 단위 테스트 작성을 시작하기에 좋은 시기 입니다 .\n\nnew의 스레드 수 유효성 검사\n우리는 new와 execute에 대한 매개변수로 아무것도 하지 않습니다. 원하는 동작으로 이러한 함수의 본문을 구현해 보겠습니다. 시작하려면 새로운에 대해 생각해 봅시다. 이전에는 크기 매개변수에 대해 부호 없는 유형을 선택했습니다. 스레드 수가 음수인 풀은 의미가 없기 때문입니다. 그러나 스레드가 0인 풀도 의미가 없지만 0은 완벽하게 유효한 사용입니다. ThreadPool 인스턴스를 반환하기 전에 크기가 0보다 큰지 확인하는 코드를 추가하고 assert! 목록 20-13에 표시된 대로 매크로.\n파일 이름: src/lib.rs\nimpl ThreadPool {\n    /// Create a new ThreadPool.\n    ///\n    /// The size is the number of threads in the pool.\n    ///\n    /// # Panics\n    ///\n    /// The `new` function will panic if the size is zero.\n    pub fn new(size: usize) -&gt; ThreadPool {\n        assert!(size &gt; 0);\n\n        ThreadPool\n    }\n    \n    // --snip--\n}\n\n목록 20-13: 크기가 0인 경우 ThreadPool::new 패닉 구현\n문서 주석과 함께 ThreadPool에 대한 일부 문서도 추가했습니다. 14장에서 설명한 것처럼 함수가 패닉할 수 있는 상황을 호출하는 섹션을 추가하여 좋은 문서화 방법을 따랐습니다. cargo doc --open을 실행하고 ThreadPool 구조체를 클릭하여 신규에 대한 문서는 다음과 같습니다!\nassert!를 추가하는 대신 여기에서 수행한 것처럼 new를 build로 변경하고 Listing 12-9의 I/O 프로젝트에서 Config::build로 수행한 것처럼 Result를 반환할 수 있습니다. 그러나 이 경우 스레드 없이 스레드 풀을 만들려고 하면 복구할 수 없는 오류가 발생한다고 결정했습니다. 야망이 있다면 new 함수와 비교하기 위해 다음 서명을 사용하여 build라는 함수를 작성해 보십시오.\npub fn build(size: usize) -&gt; Result&lt;ThreadPool, PoolCreationError&gt; {\n\n스레드를 저장할 공간 만들기\n이제 풀에 저장할 유효한 수의 스레드가 있는지 알 수 있는 방법이 있으므로 해당 스레드를 만들고 구조체를 반환하기 전에 ThreadPool 구조체에 저장할 수 있습니다. 하지만 스레드를 어떻게 저장합니까? thread::spawn 서명을 다시 살펴보겠습니다.\npub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;\n    where\n        F: FnOnce() -&gt; T,\n        F: Send + `static,\n        T: Send + `static,\n\nspawn 함수는 JoinHandle을 반환합니다., 여기서 T는 클로저가 반환하는 유형입니다. JoinHandle도 사용해보고 무슨 일이 일어나는지 봅시다. 우리의 경우 스레드 풀에 전달하는 클로저는 연결을 처리하고 아무 것도 반환하지 않으므로 T는 단위 유형 ()`이 됩니다.\n목록 20-14의 코드는 컴파일되지만 아직 스레드를 생성하지는 않습니다. 우리는 thread::JoinHandle&lt;()&gt; 인스턴스의 벡터를 보유하도록 ThreadPool의 정의를 변경했고, 크기 용량으로 벡터를 초기화했으며, 일부 코드를 실행할 for 루프를 설정했습니다. 스레드를 생성하고 이를 포함하는 ThreadPool 인스턴스를 반환했습니다.\n파일 이름: src/lib.rs\nuse std::thread;\n\npub struct ThreadPool {\n    threads: Vec&lt;thread::JoinHandle&lt;()&gt;&gt;,\n}\n\nimpl ThreadPool {\n    // --snip--\n    pub fn new(size: usize) -&gt; ThreadPool {\n        assert!(size &gt; 0);\n\n        let mut threads = Vec::with_capacity(size);\n    \n        for _ in 0..size {\n            // create some threads and store them in the vector\n        }\n    \n        ThreadPool { threads }\n    }\n    // --snip--\n}\n\n목록 20-14: 스레드를 보관할 ThreadPool용 벡터 생성\nThreadPool의 벡터 항목 유형으로 thread::JoinHandle을 사용하고 있기 때문에 std::thread를 라이브러리 크레이트의 범위로 가져왔습니다.\n유효한 크기가 수신되면 ThreadPool은 크기 항목을 저장할 수 있는 새 벡터를 생성합니다. with_capacity 함수는 Vec::new와 같은 작업을 수행하지만 중요한 차이점이 있습니다. 벡터에 공간을 미리 할당합니다. 벡터에 크기 요소를 저장해야 한다는 것을 알고 있기 때문에 이 할당을 미리 수행하는 것이 요소가 삽입될 때 자체 크기를 조정하는 Vec::new를 사용하는 것보다 약간 더 효율적입니다.\ncargo check를 다시 실행하면 성공해야 합니다.\nThreadPool에서 스레드로 코드 전송을 담당하는 작업자 구조체\n스레드 생성과 관련하여 Listing 20-14의 for 루프에 주석을 남겼습니다. 여기서는 실제로 스레드를 만드는 방법을 살펴보겠습니다. 표준 라이브러리는 스레드를 생성하는 방법으로 thread::spawn을 제공하고 thread::spawn은 스레드가 생성되자마자 스레드가 실행해야 하는 일부 코드를 얻을 것으로 예상합니다. 그러나 우리의 경우에는 스레드를 만들고 나중에 보낼 코드를 기다리게 하려고 합니다. 표준 라이브러리의 스레드 구현에는 이를 수행하는 방법이 포함되어 있지 않습니다. 수동으로 구현해야 합니다.\nThreadPool과 이 새로운 동작을 관리할 스레드 사이에 새로운 데이터 구조를 도입하여 이 동작을 구현할 것입니다. 우리는 이 데이터 구조를 Worker 라고 부를 것입니다. 이는 풀링 구현에서 일반적인 용어입니다. Worker는 실행해야 하는 코드를 선택하고 Worker의 스레드에서 코드를 실행합니다. 식당의 주방에서 일하는 사람들을 생각해 보십시오. 직원들은 고객의 주문이 들어올 때까지 기다렸다가 주문을 받고 처리하는 일을 담당합니다.\n스레드 풀에 JoinHandle&lt;()&gt; 인스턴스의 벡터를 저장하는 대신 Worker 구조체의 인스턴스를 저장합니다. 각 작업자는 단일 JoinHandle&lt;()&gt; 인스턴스를 저장합니다. 그런 다음 실행할 코드의 클로저를 가져와 실행을 위해 이미 실행 중인 스레드로 보내는 메서드를 Worker에 구현합니다. 또한 각 작업자에게 id를 부여하여 로깅 또는 디버깅할 때 풀의 서로 다른 작업자를 구별할 수 있습니다.\n다음은 ThreadPool을 만들 때 발생하는 새로운 프로세스입니다. 다음과 같은 방식으로 Worker를 설정한 후 클로저를 스레드로 보내는 코드를 구현합니다.\n\nid와 JoinHandle&lt;()&gt;을 보유하는 Worker 구조체를 정의합니다.\n작업자 인스턴스의 벡터를 보유하도록 ThreadPool을 변경합니다.\nid 번호를 사용하고 id를 보유하는 Worker 인스턴스와 빈 클로저로 생성된 스레드를 반환하는 Worker::new 함수를 정의합니다.\nThreadPool::new에서 for 루프 카운터를 사용하여 id를 생성하고 해당 id로 새 Worker를 만들고 작업자를 벡터에 저장합니다.\n\n도전하고 싶다면 목록 20-15의 코드를 보기 전에 이러한 변경 사항을 직접 구현해 보십시오.\n준비가 된? 다음은 이전 수정을 수행하는 한 가지 방법이 있는 목록 20-15입니다.\n파일 이름: src/lib.rs\nuse std::thread;\n\npub struct ThreadPool {\n    workers: Vec&lt;Worker&gt;,\n}\n\nimpl ThreadPool {\n    // --snip--\n    pub fn new(size: usize) -&gt; ThreadPool {\n        assert!(size &gt; 0);\n\n        let mut workers = Vec::with_capacity(size);\n    \n        for id in 0..size {\n            workers.push(Worker::new(id));\n        }\n    \n        ThreadPool { workers }\n    }\n    // --snip--\n}\n\nstruct Worker {\n    id: usize,\n    thread: thread::JoinHandle&lt;()&gt;,\n}\n\nimpl Worker {\n    fn new(id: usize) -&gt; Worker {\n        let thread = thread::spawn(|| {});\n\n        Worker { id, thread }\n    }\n}\n\n목록 20-15: 스레드를 직접 보유하는 대신 Worker 인스턴스를 보유하도록 ThreadPool 수정\n이제 JoinHandle&lt;()&gt; 인스턴스 대신 Worker 인스턴스를 보유하고 있기 때문에 ThreadPool의 필드 이름을 threads에서 workers로 변경했습니다. 우리는 Worker::new에 대한 인수로 for 루프의 카운터를 사용하고 각각의 새로운 Worker를 workers라는 벡터에 저장합니다.\n외부 코드( src/main.rs 의 서버와 같은 )는 ThreadPool 내에서 Worker 구조체 사용에 관한 구현 세부 정보를 알 필요가 없으므로 Worker 구조체와 해당 new 함수를 비공개로 만듭니다. Worker::new 함수는 우리가 제공한 id를 사용하고 빈 클로저를 사용하여 새 스레드를 생성하여 생성된 JoinHandle&lt;()&gt; 인스턴스를 저장합니다.\n\n참고: 시스템 리소스가 부족하여 운영 체제에서 스레드를 생성할 수 없는 경우 thread::spawn이 패닉 상태가 됩니다. 그러면 일부 스레드 생성이 성공하더라도 전체 서버가 패닉 상태가 됩니다. 단순함을 위해 이 동작은 괜찮지만 프로덕션 스레드 풀 구현에서는 std:🧵:Builder 및 Result를 반환하는 spawn 메서드를 대신 사용할 수 있습니다.\n\n이 코드는 ThreadPool::new에 대한 인수로 지정한 Worker 인스턴스의 수를 컴파일하고 저장합니다. 그러나 우리는 여전히 실행에서 얻은 클로저를 처리하지 않습니다. 다음에 그 방법을 살펴보겠습니다.\n채널을 통해 스레드에 요청 보내기\n우리가 다룰 다음 문제는 thread::spawn에 주어진 클로저가 아무것도 하지 않는다는 것입니다. 현재 execute 메서드에서 실행하려는 클로저를 얻습니다. 그러나 ThreadPool을 생성하는 동안 각 Worker를 생성할 때 실행할 클로저를 thread::spawn에 제공해야 합니다.\n방금 생성한 Worker 구조체가 ThreadPool에 보관된 대기열에서 실행할 코드를 가져오고 해당 코드를 스레드로 전송하여 실행하기를 원합니다.\n16장에서 배운 채널(두 스레드 간에 통신하는 간단한 방법)은 이 사용 사례에 적합합니다. 채널을 사용하여 작업 큐로 작동하고 execute는 작업을 ThreadPool에서 Worker 인스턴스로 보내고 작업을 해당 스레드로 보냅니다. 계획은 다음과 같습니다.\n\nThreadPool은 채널을 만들고 발신자를 유지합니다.\n각 작업자는 수신자를 붙잡습니다.\n우리는 채널 아래로 보내려는 클로저를 보유할 새로운 Job 구조체를 생성할 것입니다.\nexecute 메소드는 송신자를 통해 실행하려는 작업을 송신합니다.\n스레드에서 작업자는 수신자를 반복하고 수신한 모든 작업의 클로저를 실행합니다.\n\nThreadPool::new에 채널을 생성하고 Listing 20-16과 같이 ThreadPool 인스턴스에 발신자를 유지하는 것으로 시작하겠습니다. Job 구조체는 지금은 아무 것도 담지 않지만 채널 아래로 보내는 항목 유형이 됩니다.\n파일 이름: src/lib.rs\nuse std::{sync::mpsc, thread};\n\npub struct ThreadPool {\n    workers: Vec&lt;Worker&gt;,\n    sender: mpsc::Sender&lt;Job&gt;,\n}\n\nstruct Job;\n\nimpl ThreadPool {\n    // --snip--\n    pub fn new(size: usize) -&gt; ThreadPool {\n        assert!(size &gt; 0);\n\n        let (sender, receiver) = mpsc::channel();\n    \n        let mut workers = Vec::with_capacity(size);\n    \n        for id in 0..size {\n            workers.push(Worker::new(id));\n        }\n    \n        ThreadPool { workers, sender }\n    }\n    // --snip--\n}\n\nListing 20-16: Job 인스턴스를 전송하는 채널의 발신자를 저장하도록 ThreadPool 수정\nThreadPool::new에서 새 채널을 만들고 풀이 발신자를 보유하도록 합니다. 이것은 성공적으로 컴파일됩니다.\n스레드 풀이 채널을 생성할 때 채널의 수신자를 각 작업자에게 전달해 봅시다. 작업자가 생성하는 스레드에서 리시버를 사용하기를 원하므로 클로저에서 receiver 매개변수를 참조할 것입니다. 목록 20-17의 코드는 아직 제대로 컴파일되지 않습니다.\n파일 이름: src/lib.rs\nimpl ThreadPool {\n    // --snip--\n    pub fn new(size: usize) -&gt; ThreadPool {\n        assert!(size &gt; 0);\n\n        let (sender, receiver) = mpsc::channel();\n    \n        let mut workers = Vec::with_capacity(size);\n    \n        for id in 0..size {\n            workers.push(Worker::new(id, receiver));\n        }\n    \n        ThreadPool { workers, sender }\n    }\n    // --snip--\n}\n\n// --snip--\n\nimpl Worker {\n    fn new(id: usize, receiver: mpsc::Receiver&lt;Job&gt;) -&gt; Worker {\n        let thread = thread::spawn(|| {\n            receiver;\n        });\n\n        Worker { id, thread }\n    }\n}\n\nListing 20-17: 리시버를 워커에게 넘기기\n우리는 몇 가지 작고 간단한 변경을 했습니다. 수신기를 Worker::new로 전달한 다음 클로저 내부에서 사용합니다.\n이 코드를 확인하려고 하면 다음 오류가 발생합니다.\n$ cargo check\n    Checking hello v0.1.0 (file:///projects/hello)\nerror[E0382]: use of moved value: `receiver`\n  --&gt; src/lib.rs:26:42\n   |\n21 |         let (sender, receiver) = mpsc::channel();\n   |                      -------- move occurs because `receiver` has type `std::sync::mpsc::Receiver&lt;Job&gt;`, which does not implement the `Copy` trait\n...\n26 |             workers.push(Worker::new(id, receiver));\n   |                                          ^^^^^^^^ value moved here, in previous iteration of loop\n\nFor more information about this error, try `rustc --explain E0382`.\nerror: could not compile `hello` due to previous error\n\n코드는 수신자를 여러 작업자 인스턴스에 전달하려고 합니다. 이것은 작동하지 않을 것입니다. 16장에서 기억할 것입니다: Rust가 제공하는 채널 구현은 다중 생산자 , 단일 소비자 입니다. 즉, 이 코드를 수정하기 위해 채널의 소비측 끝을 복제할 수 없습니다. 또한 여러 소비자에게 메시지를 여러 번 보내고 싶지 않습니다. 우리는 각 메시지가 한 번 처리되도록 여러 작업자가 있는 하나의 메시지 목록을 원합니다.\n또한 채널 대기열에서 작업을 가져오려면 수신자를 변경해야 하므로 스레드는 수신자를 공유하고 수정할 수 있는 안전한 방법이 필요합니다. 그렇지 않으면 경쟁 조건이 발생할 수 있습니다(16장에서 설명).\n16장에서 논의한 스레드 안전 스마트 포인터를 상기하십시오. 여러 스레드 간에 소유권을 공유하고 스레드가 값을 변경할 수 있도록 하려면 Arc&lt;Mutex를 사용해야 합니다.&gt;. Arc유형은 여러 작업자가 수신기를 소유하도록 하고Mutex`는 한 번에 한 작업자만 수신기에서 작업을 가져오도록 합니다. 목록 20-18은 우리가 만들어야 하는 변경 사항을 보여줍니다.\n파일 이름: src/lib.rs\nuse std::{\n    sync::{mpsc, Arc, Mutex},\n    thread,\n};\n// --snip--\n\nimpl ThreadPool {\n    // --snip--\n    pub fn new(size: usize) -&gt; ThreadPool {\n        assert!(size &gt; 0);\n\n        let (sender, receiver) = mpsc::channel();\n    \n        let receiver = Arc::new(Mutex::new(receiver));\n    \n        let mut workers = Vec::with_capacity(size);\n    \n        for id in 0..size {\n            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));\n        }\n    \n        ThreadPool { workers, sender }\n    }\n    \n    // --snip--\n}\n\n// --snip--\n\nimpl Worker {\n    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {\n        // --snip--\n    }\n}\n\nListing 20-18: Arc 및 Mutex를 사용하여 작업자 간에 수신기 공유\nThreadPool::new에서 수신기를 Arc 및 Mutex에 넣습니다. 각각의 새 작업자에 대해 Arc를 복제하여 참조 횟수를 늘리면 작업자가 수신기의 소유권을 공유할 수 있습니다.\n이러한 변경으로 코드가 컴파일됩니다! 우리는 거기에 도달하고 있습니다!\n실행 방법 구현\n마지막으로 ThreadPool에 execute 메서드를 구현해 봅시다. 또한 구조체에서 실행이 받는 클로저 유형을 보유하는 특성 개체의 유형 별칭으로 Job을 변경할 것입니다. 19장의 유형 별칭으로 유형 동의어 만들기 섹션 에서 설명한 것처럼 유형 별칭을 사용하면 긴 유형을 사용하기 쉽도록 더 짧게 만들 수 있습니다. 목록 20-19를 보십시오.\n파일 이름: src/lib.rs\n// --snip--\n\ntype Job = Box&lt;dyn FnOnce() + Send + `static&gt;;\n\nimpl ThreadPool {\n    // --snip--\n\n    pub fn execute&lt;F&gt;(&amp;self, f: F)\n    where\n        F: FnOnce() + Send + `static,\n    {\n        let job = Box::new(f);\n    \n        self.sender.send(job).unwrap();\n    }\n}\n\n// --snip--\n\n목록 20-19: 각 클로저를 보유하고 있는 Box에 대한 Job 유형 별칭을 생성한 다음 작업을 채널 아래로 전송\n클로저를 사용하여 새 Job 인스턴스를 생성한 후 실행에서 해당 작업을 채널의 전송 끝으로 보냅니다. 전송에 실패한 경우를 위해 send에서 unwrap을 호출합니다. 예를 들어 모든 스레드의 실행을 중지하면 수신 측에서 새 메시지 수신을 중지한 경우에 이러한 상황이 발생할 수 있습니다. 현재로서는 스레드 실행을 중지할 수 없습니다. 풀이 존재하는 한 스레드는 계속 실행됩니다. unwrap을 사용하는 이유는 실패 사례가 발생하지 않는다는 것을 알고 있지만 컴파일러는 이를 알지 못하기 때문입니다.\n하지만 아직 끝나지 않았습니다! 작업자에서 thread::spawn으로 전달되는 클로저는 여전히 채널의 수신측만 참조합니다. 대신에 우리는 채널의 수신 측에 작업을 요청하고 작업을 받으면 작업을 실행하면서 영원히 반복되는 클로저가 필요합니다. 목록 20-20에 표시된 Worker::new로 변경해 보겠습니다.\n파일 이름: src/lib.rs\n// --snip--\n\nimpl Worker {\n    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {\n        let thread = thread::spawn(move || loop {\n            let job = receiver.lock().unwrap().recv().unwrap();\n\n            println!(`Worker {id} got a job; executing.`);\n    \n            job();\n        });\n    \n        Worker { id, thread }\n    }\n}\n\n목록 20-20: 작업자의 스레드에서 작업 수신 및 실행\n여기에서 먼저 수신기에서 잠금을 호출하여 뮤텍스를 획득한 다음 unwrap을 호출하여 오류가 있을 때 당황하게 합니다. 뮤텍스가 오염된 상태 인 경우 잠금 획득이 실패할 수 있습니다. 이는 잠금을 해제하지 않고 잠금을 유지하는 동안 다른 스레드가 패닉 상태가 된 경우 발생할 수 있습니다. 이 상황에서 unwrap을 호출하여 이 스레드를 패닉 상태로 만드는 것이 올바른 조치입니다. 이 unwrap을 의미 있는 오류 메시지와 함께 expect로 자유롭게 변경하십시오.\n뮤텍스를 잠그면 채널에서 작업을 수신하기 위해 recv를 호출합니다. 최종 unwrap은 여기서도 모든 오류를 지나서 이동합니다. 이는 보낸 사람을 보유하고 있는 스레드가 종료된 경우 발생할 수 있습니다. 이는 받는 사람이 종료된 경우 send 메서드가 Err를 반환하는 방식과 유사합니다.\nrecv에 대한 호출이 차단되므로 아직 작업이 없으면 현재 스레드는 작업을 사용할 수 있을 때까지 대기합니다. 뮤텍스는 한 번에 하나의 작업자 스레드만 작업 요청을 시도하도록 합니다.\n이제 스레드 풀이 작동 상태에 있습니다! 화물 실행을 제공하고 몇 가지 요청을 합니다.\n$ cargo run\n   Compiling hello v0.1.0 (file:///projects/hello)\nwarning: field is never read: `workers`\n --&gt; src/lib.rs:7:5\n  |\n7 |     workers: Vec&lt;Worker&gt;,\n  |     ^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(dead_code)]` on by default\n\nwarning: field is never read: `id`\n  --&gt; src/lib.rs:48:5\n   |\n48 |     id: usize,\n   |     ^^^^^^^^^\n\nwarning: field is never read: `thread`\n  --&gt; src/lib.rs:49:5\n   |\n49 |     thread: thread::JoinHandle&lt;()&gt;,\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nwarning: `hello` (lib) generated 3 warnings\n    Finished dev [unoptimized + debuginfo] target(s) in 1.40s\n     Running `target/debug/hello`\nWorker 0 got a job; executing.\nWorker 2 got a job; executing.\nWorker 1 got a job; executing.\nWorker 3 got a job; executing.\nWorker 0 got a job; executing.\nWorker 2 got a job; executing.\nWorker 1 got a job; executing.\nWorker 3 got a job; executing.\nWorker 0 got a job; executing.\nWorker 2 got a job; executing.\n\n성공! 이제 연결을 비동기적으로 실행하는 스레드 풀이 있습니다. 4개 이상의 스레드가 생성되지 않으므로 서버가 많은 요청을 수신하더라도 시스템이 과부하되지 않습니다. /sleep 에 요청을 하면 서버는 다른 스레드가 요청을 실행하도록 하여 다른 요청을 처리할 수 있습니다.\n\n참고: 여러 브라우저 창에서 동시에 /sleep을 열면 5초 간격으로 한 번에 하나씩 로드될 수 있습니다. 일부 웹 브라우저는 캐싱을 이유로 동일한 요청의 여러 인스턴스를 순차적으로 실행합니다. 이 제한은 웹 서버에 의해 발생하지 않습니다.\n\n18장에서 while let 루프에 대해 배운 후 목록 20-21에 표시된 것처럼 작업자 스레드 코드를 작성하지 않은 이유가 궁금할 수 있습니다.\n파일 이름: src/lib.rs\n// --snip--\n\nimpl Worker {\n    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {\n        let thread = thread::spawn(move || {\n            while let Ok(job) = receiver.lock().unwrap().recv() {\n                println!(`Worker {id} got a job; executing.`);\n\n                job();\n            }\n        });\n    \n        Worker { id, thread }\n    }\n}\n\n목록 20-21: while let을 사용한 Worker::new의 대체 구현\n이 코드는 컴파일되고 실행되지만 원하는 스레딩 동작이 발생하지 않습니다. 느린 요청으로 인해 다른 요청이 처리되기를 기다리게 됩니다. 그 이유는 다소 미묘합니다. 잠금 소유권이 MutexGuard의 수명을 기반으로 하기 때문에 Mutex 구조체에는 공용 잠금 해제 메서드가 없습니다.내의LockResult&lt;MutexGuard잠금 메서드가 반환하는 &gt;입니다. 컴파일 시간에 차용 검사기는 잠금을 보유하지 않는 한 Mutex로 보호되는 리소스에 액세스할 수 없다는 규칙을 적용할 수 있습니다. 그러나 이 구현으로 인해 잠금이 발생할 수도 있습니다. MutexGuard의 수명을 염두에 두지 않으면 의도한 것보다 오래 유지됩니다..\nlet job = receiver.lock().unwrap().recv().unwrap();을 사용하는 Listing 20-20의 코드 let을 사용하면 등호 오른쪽에 있는 표현식에 사용된 모든 임시 값이 let 문이 끝날 때 즉시 삭제되기 때문에 작동합니다. 그러나 while let(및 if let 및 match)은 연결된 블록이 끝날 때까지 임시 값을 삭제하지 않습니다. 목록 20-21에서 잠금은 job() 호출 기간 동안 유지되며 이는 다른 작업자가 작업을 받을 수 없음을 의미합니다.\n\n정상적인 종료 및 정리\n목록 20-20의 코드는 우리가 의도한 대로 스레드 풀을 사용하여 비동기적으로 요청에 응답합니다. 사용하지 않는 workers, id 및 thread 필드에 대한 경고가 표시되어 아무것도 정리하지 않는다는 것을 상기시켜 줍니다. 덜 우아한 ctrl-c 방법을 사용하여 기본 스레드를 중지하면 요청을 처리하는 중이더라도 다른 모든 스레드도 즉시 중지됩니다.\n그런 다음 풀의 각 스레드에서 연결을 호출하는 삭제 특성을 구현하여 닫히기 전에 작업 중인 요청을 완료할 수 있도록 합니다. 그런 다음 새 요청 수락을 중지하고 종료해야 한다고 스레드에 알리는 방법을 구현할 것입니다. 이 코드가 실제로 작동하는지 확인하기 위해 스레드 풀을 정상적으로 종료하기 전에 두 개의 요청만 수락하도록 서버를 수정합니다.\nThreadPool에서 Drop 특성 구현\n스레드 풀에서 Drop을 구현하는 것부터 시작하겠습니다. 풀이 삭제되면 스레드가 모두 합류하여 작업을 완료했는지 확인해야 합니다. 목록 20-22는 Drop 구현의 첫 번째 시도를 보여줍니다. 이 코드는 아직 작동하지 않습니다.\n파일 이름: src/lib.rs\nimpl Drop for ThreadPool {\n    fn drop(&amp;mut self) {\n        for worker in &amp;mut self.workers {\n            println!(`Shutting down worker {}`, worker.id);\n\n            worker.thread.join().unwrap();\n        }\n    }\n}\n\n목록 20-22: 스레드 풀이 범위를 벗어날 때 각 스레드 조인\n먼저 각 스레드 풀 작업자를 반복합니다. self는 변경 가능한 참조이고 worker도 변경할 수 있어야 하기 때문에 &amp;mut를 사용합니다. 각 작업자에 대해 이 특정 작업자가 종료된다는 메시지를 인쇄한 다음 해당 작업자의 스레드에서 join을 호출합니다. join 호출이 실패하면 unwrap을 사용하여 Rust를 패닉 상태로 만들고 부적절하게 종료합니다.\n다음은 이 코드를 컴파일할 때 발생하는 오류입니다.\n$ cargo check\n    Checking hello v0.1.0 (file:///projects/hello)\nerror[E0507]: cannot move out of `worker.thread` which is behind a mutable reference\n  --&gt; src/lib.rs:52:13\n   |\n52 |             worker.thread.join().unwrap();\n   |             ^^^^^^^^^^^^^ ------ `worker.thread` moved due to this method call\n   |             |\n   |             move occurs because `worker.thread` has type `JoinHandle&lt;()&gt;`, which does not implement the `Copy` trait\n   |\nnote: this function takes ownership of the receiver `self`, which moves `worker.thread`\n  --&gt; /rustc/d5a82bbd26e1ad8b7401f6a718a9c57c96905483/library/std/src/thread/mod.rs:1581:17\n\nFor more information about this error, try `rustc --explain E0507`.\nerror: could not compile `hello` due to previous error\n\n이 오류는 각 작업자의 변경 가능한 빌림만 있고 조인이 해당 인수의 소유권을 가지기 때문에 조인을 호출할 수 없음을 알려줍니다. 이 문제를 해결하려면 조인이 스레드를 사용할 수 있도록 스레드를 소유한 작업자 인스턴스 밖으로 스레드를 이동해야 합니다. Listing 17-15에서 이를 수행했습니다. Worker가 Option&lt;thread::JoinHandle&lt;()&gt;&gt;를 보유하는 경우 Option에서 take 메소드를 호출하여 값을 외부로 이동할 수 있습니다. 일부 변형을 선택하고 그 자리에 없음 변형을 남겨둡니다. 즉, 실행 중인 Worker는 thread에 Some 변형을 가지며 Worker를 정리하려는 경우 Some을 None으로 대체하므로 `\n따라서 우리는 Worker의 정의를 다음과 같이 업데이트하고 싶다는 것을 알고 있습니다.\n파일 이름: src/lib.rs\nstruct Worker {\n    id: usize,\n    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,\n}\n\n이제 변경해야 할 다른 위치를 찾기 위해 컴파일러에 의존해 봅시다. 이 코드를 확인하면 두 가지 오류가 발생합니다.\n$ cargo check\n    Checking hello v0.1.0 (file:///projects/hello)\nerror[E0599]: no method named `join` found for enum `Option` in the current scope\n  --&gt; src/lib.rs:52:27\n   |\n52 |             worker.thread.join().unwrap();\n   |                           ^^^^ method not found in `Option&lt;JoinHandle&lt;()&gt;&gt;`\n   |\nnote: the method `join` exists on the type `JoinHandle&lt;()&gt;`\n  --&gt; /rustc/d5a82bbd26e1ad8b7401f6a718a9c57c96905483/library/std/src/thread/mod.rs:1581:5\nhelp: consider using `Option::expect` to unwrap the `JoinHandle&lt;()&gt;` value, panicking if the value is an `Option::None`\n   |\n52 |             worker.thread.expect(`REASON`).join().unwrap();\n   |                          +++++++++++++++++\n\nerror[E0308]: mismatched types\n  --&gt; src/lib.rs:72:22\n   |\n72 |         Worker { id, thread }\n   |                      ^^^^^^ expected enum `Option`, found struct `JoinHandle`\n   |\n   = note: expected enum `Option&lt;JoinHandle&lt;()&gt;&gt;`\n            found struct `JoinHandle&lt;_&gt;`\nhelp: try wrapping the expression in `Some`\n   |\n72 |         Worker { id, thread: Some(thread) }\n   |                      +++++++++++++      +\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\nerror: could not compile `hello` due to 2 previous errors\n\nWorker::new 끝에 있는 코드를 가리키는 두 번째 오류를 해결해 보겠습니다. 새 Worker를 만들 때 Some에 thread 값을 래핑해야 합니다. 이 오류를 수정하려면 다음과 같이 변경하십시오.\n파일 이름: src/lib.rs\nimpl Worker {\n    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {\n        // --snip--\n\n        Worker {\n            id,\n            thread: Some(thread),\n        }\n    }\n}\n\n첫 번째 오류는 Drop 구현에 있습니다. 앞에서 작업자에서 스레드를 이동하기 위해 옵션 값에서 테이크를 호출하려고 한다고 언급했습니다. 다음과 같은 변경 사항이 적용됩니다.\n파일 이름: src/lib.rs\nimpl Drop for ThreadPool {\n    fn drop(&amp;mut self) {\n        for worker in &amp;mut self.workers {\n            println!(`Shutting down worker {}`, worker.id);\n\n            if let Some(thread) = worker.thread.take() {\n                thread.join().unwrap();\n            }\n        }\n    }\n}\n\n17장에서 설명한 것처럼 Option의 take 메소드는 Some 변형을 제거하고 그 자리에 None을 남겨둡니다. 우리는 Some을 분해하고 스레드를 얻기 위해 if let을 사용하고 있습니다. 그런 다음 스레드에서 join을 호출합니다. 작업자의 스레드가 이미 None인 경우 작업자가 이미 스레드를 정리한 것을 알고 있으므로 이 경우 아무 일도 일어나지 않습니다.\n작업 수신을 중지하도록 스레드에 신호 보내기\n모든 변경 사항을 적용하면 코드가 경고 없이 컴파일됩니다. 그러나 나쁜 소식은 이 코드가 아직 우리가 원하는 방식으로 작동하지 않는다는 것입니다. 핵심은 Worker 인스턴스의 스레드에 의해 실행되는 클로저의 논리입니다. 현재 우리는 join을 호출하지만 작업을 영원히 루프하기 때문에 스레드를 종료하지 않습니다. 현재 구현된 drop으로 ThreadPool을 삭제하려고 하면 메인 스레드는 첫 번째 스레드가 완료될 때까지 영원히 차단됩니다.\n이 문제를 해결하려면 ThreadPool drop 구현을 변경한 다음 Worker 루프를 변경해야 합니다.\n먼저 ThreadPool drop 구현을 변경하여 스레드가 완료되기를 기다리기 전에 sender를 명시적으로 삭제합니다. 목록 20-23은 sender를 명시적으로 삭제하기 위해 ThreadPool에 대한 변경 사항을 보여줍니다. ThreadPool에서 sender를 이동할 수 있도록 스레드에서 사용한 것과 동일한 Option 및 take 기술을 사용합니다.\n파일 이름: src/lib.rs\npub struct ThreadPool {\n    workers: Vec&lt;Worker&gt;,\n    sender: Option&lt;mpsc::Sender&lt;Job&gt;&gt;,\n}\n// --snip--\nimpl ThreadPool {\n    pub fn new(size: usize) -&gt; ThreadPool {\n        // --snip--\n\n        ThreadPool {\n            workers,\n            sender: Some(sender),\n        }\n    }\n    \n    pub fn execute&lt;F&gt;(&amp;self, f: F)\n    where\n        F: FnOnce() + Send + `static,\n    {\n        let job = Box::new(f);\n    \n        self.sender.as_ref().unwrap().send(job).unwrap();\n    }\n}\n\nimpl Drop for ThreadPool {\n    fn drop(&amp;mut self) {\n        drop(self.sender.take());\n\n        for worker in &amp;mut self.workers {\n            println!(`Shutting down worker {}`, worker.id);\n    \n            if let Some(thread) = worker.thread.take() {\n                thread.join().unwrap();\n            }\n        }\n    }\n}\n\n목록 20-23: 작업자 스레드를 결합하기 전에 sender를 명시적으로 삭제합니다.\n발신자를 삭제하면 채널이 닫히고 메시지가 더 이상 전송되지 않음을 나타냅니다. 이 경우 작업자가 무한 루프에서 수행하는 recv에 대한 모든 호출은 오류를 반환합니다. 목록 20-24에서 Worker 루프를 변경하여 이 경우 루프를 정상적으로 종료합니다. 즉, ThreadPool drop 구현이 join을 호출할 때 스레드가 완료됩니다.\n파일 이름: src/lib.rs\nimpl Worker {\n    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {\n        let thread = thread::spawn(move || loop {\n            let message = receiver.lock().unwrap().recv();\n\n            match message {\n                Ok(job) =&gt; {\n                    println!(`Worker {id} got a job; executing.`);\n    \n                    job();\n                }\n                Err(_) =&gt; {\n                    println!(`Worker {id} disconnected; shutting down.`);\n                    break;\n                }\n            }\n        });\n    \n        Worker {\n            id,\n            thread: Some(thread),\n        }\n    }\n}\n\n목록 20-24: recv가 오류를 반환할 때 루프에서 명시적으로 중단\n이 코드가 동작하는 것을 보기 위해 Listing 20-25와 같이 서버를 정상적으로 종료하기 전에 두 개의 요청만 수락하도록 main을 수정해 보겠습니다.\n파일 이름: src/main.rs\nfn main() {\n    let listener = TcpListener::bind(`127.0.0.1:7878`).unwrap();\n    let pool = ThreadPool::new(4);\n\n    for stream in listener.incoming().take(2) {\n        let stream = stream.unwrap();\n    \n        pool.execute(|| {\n            handle_connection(stream);\n        });\n    }\n    \n    println!(`Shutting down.`);\n}\n\n목록 20-25: 루프를 종료하여 두 개의 요청을 처리한 후 서버 종료\n두 개의 요청만 처리한 후 실제 웹 서버가 종료되는 것을 원하지 않을 것입니다. 이 코드는 정상적인 종료 및 정리가 제대로 작동하고 있음을 보여줍니다.\ntake 메서드는 Iterator 특성에 정의되어 있으며 반복을 최대 처음 두 항목으로 제한합니다. ThreadPool은 main의 끝에서 범위를 벗어나고 drop 구현이 실행됩니다.\ncargo run으로 서버를 시작하고 세 가지 요청을 합니다. 세 번째 요청은 오류가 발생하고 터미널에 다음과 유사한 출력이 표시되어야 합니다.\n$ cargo run\n   Compiling hello v0.1.0 (file:///projects/hello)\n    Finished dev [unoptimized + debuginfo] target(s) in 1.0s\n     Running `target/debug/hello`\nWorker 0 got a job; executing.\nShutting down.\nShutting down worker 0\nWorker 3 got a job; executing.\nWorker 1 disconnected; shutting down.\nWorker 2 disconnected; shutting down.\nWorker 3 disconnected; shutting down.\nWorker 0 disconnected; shutting down.\nShutting down worker 1\nShutting down worker 2\nShutting down worker 3\n\n작업자 및 메시지의 다른 순서가 인쇄되는 것을 볼 수 있습니다. 메시지에서 이 코드가 어떻게 작동하는지 확인할 수 있습니다. 작업자 0과 3은 처음 두 요청을 받았습니다. 서버는 두 번째 연결 후 연결 수락을 중지했으며 ThreadPool의 Drop 구현은 작업자 3이 작업을 시작하기도 전에 실행을 시작합니다. 발신자를 삭제하면 모든 작업자의 연결이 끊어지고 종료하라는 메시지가 표시됩니다. 작업자는 연결을 끊을 때 각각 메시지를 인쇄하고 스레드 풀은 join을 호출하여 각 작업자 스레드가 완료될 때까지 기다립니다.\n이 특정 실행의 한 가지 흥미로운 측면에 주목하십시오. ThreadPool은 sender를 삭제하고 작업자가 오류를 수신하기 전에 작업자 0에 조인하려고 시도했습니다. 작업자 0은 아직 recv에서 오류를 수신하지 않았으므로 기본 작업자 0이 완료되기를 기다리는 스레드가 차단되었습니다. 그동안 작업자 3이 작업을 수신한 후 모든 스레드에서 오류를 수신했습니다. 작업자 0이 완료되면 기본 스레드는 나머지 작업자가 완료될 때까지 기다렸습니다. 그 시점에서 그들은 모두 루프를 종료하고 멈췄습니다.\n축하해요! 이제 프로젝트를 완료했습니다. 스레드 풀을 사용하여 비동기적으로 응답하는 기본 웹 서버가 있습니다. 풀의 모든 스레드를 정리하는 서버의 정상적인 종료를 수행할 수 있습니다.\n참조를 위한 전체 코드는 다음과 같습니다.\n파일 이름: src/main.rs\nuse hello::ThreadPool;\nuse std::fs;\nuse std::io::prelude::*;\nuse std::net::TcpListener;\nuse std::net::TcpStream;\nuse std::thread;\nuse std::time::Duration;\n\nfn main() {\n    let listener = TcpListener::bind(`127.0.0.1:7878`).unwrap();\n    let pool = ThreadPool::new(4);\n\n    for stream in listener.incoming().take(2) {\n        let stream = stream.unwrap();\n    \n        pool.execute(|| {\n            handle_connection(stream);\n        });\n    }\n    \n    println!(`Shutting down.`);\n}\n\nfn handle_connection(mut stream: TcpStream) {\n    let mut buffer = [0; 1024];\n    stream.read(&amp;mut buffer).unwrap();\n\n    let get = b`GET / HTTP/1.1\\r\\n`;\n    let sleep = b`GET /sleep HTTP/1.1\\r\\n`;\n    \n    let (status_line, filename) = if buffer.starts_with(get) {\n        (`HTTP/1.1 200 OK`, `hello.html`)\n    } else if buffer.starts_with(sleep) {\n        thread::sleep(Duration::from_secs(5));\n        (`HTTP/1.1 200 OK`, `hello.html`)\n    } else {\n        (`HTTP/1.1 404 NOT FOUND`, `404.html`)\n    };\n    \n    let contents = fs::read_to_string(filename).unwrap();\n    \n    let response = format!(\n        `{}\\r\\nContent-Length: {}\\r\\n\\r\\n{}`,\n        status_line,\n        contents.len(),\n        contents\n    );\n    \n    stream.write_all(response.as_bytes()).unwrap();\n    stream.flush().unwrap();\n}\n\n파일 이름: src/lib.rs\nuse std::{\n    sync::{mpsc, Arc, Mutex},\n    thread,\n};\n\npub struct ThreadPool {\n    workers: Vec&lt;Worker&gt;,\n    sender: Option&lt;mpsc::Sender&lt;Job&gt;&gt;,\n}\n\ntype Job = Box&lt;dyn FnOnce() + Send + `static&gt;;\n\nimpl ThreadPool {\n    /// Create a new ThreadPool.\n    ///\n    /// The size is the number of threads in the pool.\n    ///\n    /// # Panics\n    ///\n    /// The `new` function will panic if the size is zero.\n    pub fn new(size: usize) -&gt; ThreadPool {\n        assert!(size &gt; 0);\n\n        let (sender, receiver) = mpsc::channel();\n    \n        let receiver = Arc::new(Mutex::new(receiver));\n    \n        let mut workers = Vec::with_capacity(size);\n    \n        for id in 0..size {\n            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));\n        }\n    \n        ThreadPool {\n            workers,\n            sender: Some(sender),\n        }\n    }\n    \n    pub fn execute&lt;F&gt;(&amp;self, f: F)\n    where\n        F: FnOnce() + Send + `static,\n    {\n        let job = Box::new(f);\n    \n        self.sender.as_ref().unwrap().send(job).unwrap();\n    }\n}\n\nimpl Drop for ThreadPool {\n    fn drop(&amp;mut self) {\n        drop(self.sender.take());\n\n        for worker in &amp;mut self.workers {\n            println!(`Shutting down worker {}`, worker.id);\n    \n            if let Some(thread) = worker.thread.take() {\n                thread.join().unwrap();\n            }\n        }\n    }\n}\n\nstruct Worker {\n    id: usize,\n    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,\n}\n\nimpl Worker {\n    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {\n        let thread = thread::spawn(move || loop {\n            let message = receiver.lock().unwrap().recv();\n\n            match message {\n                Ok(job) =&gt; {\n                    println!(`Worker {id} got a job; executing.`);\n    \n                    job();\n                }\n                Err(_) =&gt; {\n                    println!(`Worker {id} disconnected; shutting down.`);\n                    break;\n                }\n            }\n        });\n    \n        Worker {\n            id,\n            thread: Some(thread),\n        }\n    }\n}\n\n우리는 여기서 더 많은 것을 할 수 있습니다! 이 프로젝트를 계속 개선하려면 다음과 같은 몇 가지 아이디어가 있습니다.\n\nThreadPool 및 해당 공용 메서드에 더 많은 문서를 추가합니다.\n라이브러리 기능 테스트를 추가합니다.\n보다 강력한 오류 처리를 위해 호출을 unwrap으로 변경합니다.\nThreadPool을 사용하여 웹 요청 제공 이외의 일부 작업을 수행합니다.\ncrates.io 에서 스레드 풀 크레이트를 찾고 대신 크레이트를 사용하여 유사한 웹 서버를 구현합니다. 그런 다음 API 및 견고성을 우리가 구현한 스레드 풀과 비교합니다.\n\n요약\n잘하셨어요! 책을 끝까지 읽으셨습니다! 이 Rust 투어에 참여해 주셔서 감사합니다. 이제 자신만의 Rust 프로젝트를 구현하고 다른 사람들의 프로젝트를 도울 준비가 되었습니다. Rust 여정에서 직면하는 모든 문제를 기꺼이 도와줄 다른 Rustacean 커뮤니티가 있음을 명심하세요.\n\n부록\n다음 섹션에는 Rust 여행에 유용할 수 있는 참조 자료가 포함되어 있습니다.\n\n부록 A: 키워드\n다음 목록에는 Rust 언어에서 현재 또는 미래에 사용하도록 예약된 키워드가 포함되어 있습니다. 따라서 식별자로 사용할 수 없습니다(원시 [식별자](https://doc.rust-lang.org/book/appendix-01-keywords.html#raw-identifiers)  섹션에서 논의할 원시 식별자 제외). 식별자는 함수, 변수, 매개변수, 구조체 필드, 모듈, 크레이트, 상수, 매크로, 정적 값, 속성, 유형, 특성 또는 수명의 이름입니다.\n현재 사용중인 키워드\n다음은 기능이 설명된 현재 사용 중인 키워드 목록입니다.\n\nas - 기본 캐스팅을 수행하거나, 항목을 포함하는 특정 특성을 명확하게 하거나, use 문에서 항목의 이름을 바꿉니다.\nasync - 현재 스레드를 차단하는 대신 Future 반환\nawait - Future의 결과가 준비될 때까지 실행을 일시 중지합니다.\nbreak - 루프를 즉시 종료합니다.\nconst - 상수 항목 또는 상수 원시 포인터를 정의합니다.\n계속 - 다음 루프 반복을 계속합니다.\n크레이트 - 모듈 경로에서 크레이트 루트를 나타냅니다.\ndyn - 특성 개체에 대한 동적 디스패치\nelse - if 및 if let 제어 흐름 구성에 대한 폴백\nenum - 열거형 정의\nextern - 외부 함수 또는 변수 연결\nfalse - 부울 거짓 리터럴\nfn - 함수 또는 함수 포인터 유형 정의\nfor - 반복자의 항목을 반복하거나 특성을 구현하거나 더 높은 순위의 수명을 지정합니다.\nif - 조건식의 결과에 따라 분기\nimpl - 고유 또는 특성 기능 구현\nin - for 루프 구문의 일부\nlet - 변수 바인딩\nloop - 무조건 반복\nmatch - 값을 패턴에 일치\nmod - 모듈 정의\n이동 - 클로저가 모든 캡처의 소유권을 갖도록 합니다.\nmut - 참조, 원시 포인터 또는 패턴 바인딩의 가변성을 나타냅니다.\npub - 구조체 필드, impl 블록 또는 모듈의 공개 가시성을 나타냅니다.\nref - 참조로 바인드\nreturn - 함수에서 반환\nSelf - 정의하거나 구현하는 유형의 유형 별칭\nself - 메소드 주제 또는 현재 모듈\n정적 - 전체 프로그램 실행을 지속하는 전역 변수 또는 수명\nstruct - 구조 정의\nsuper - 현재 모듈의 상위 모듈\ntrait - 특성 정의\ntrue - 부울 true 리터럴\ntype - 유형 별칭 또는 관련 유형을 정의합니다.\n공동체 - 공용체를 정의합니다. 유니온 선언에서 사용되는 경우에만 키워드입니다.\nunsafe - 안전하지 않은 코드, 기능, 특성 또는 구현을 나타냅니다.\nuse - 기호를 범위로 가져오기\nwhere - 유형을 제한하는 절을 나타냅니다.\nwhile - 식의 결과에 따라 조건부 루프\n\n향후 사용을 위해 예약된 키워드\n다음 키워드는 아직 기능이 없지만 잠재적인 향후 사용을 위해 Rust에 예약되어 있습니다.\n\n추상적인\n이 되다\n상자\n하다\n결정적인\n매크로\n우세하다\n개인\n노력하다\n유형\n크기 미정\n가상\n생산하다\n\n원시 식별자\n원시 식별자는 일반적으로 허용되지 않는 키워드를 사용할 수 있게 해주는 구문입니다. 키워드 앞에 r#을 붙여 원시 식별자를 사용합니다.\n예를 들어 일치는 키워드입니다. 이름으로 match를 사용하는 다음 함수를 컴파일하려고 하면:\n파일 이름: src/main.rs\nfn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {\n    haystack.contains(needle)\n}\n\n이 오류가 발생합니다.\nerror: expected identifier, found keyword `match`\n --&gt; src/main.rs:4:4\n  |\n4 | fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {\n  |    ^^^^^ expected identifier, found keyword\n\n오류는 함수 식별자로 키워드 일치를 사용할 수 없음을 보여줍니다. 함수 이름으로 match를 사용하려면 다음과 같이 원시 식별자 구문을 사용해야 합니다.\n파일 이름: src/main.rs\nfn r#match(needle: &amp;str, haystack: &amp;str) -&gt; bool {\n    haystack.contains(needle)\n}\n\nfn main() {\n    assert!(r#match(`foo`, `foobar`));\n}\n\n이 코드는 오류 없이 컴파일됩니다. 정의에서 함수 이름의 r# 접두어와 main에서 함수가 호출되는 위치에 유의하십시오.\n원시 식별자를 사용하면 해당 단어가 예약 키워드인 경우에도 식별자로 선택한 단어를 사용할 수 있습니다. 이렇게 하면 식별자 이름을 더 자유롭게 선택할 수 있을 뿐만 아니라 이러한 단어가 키워드가 아닌 언어로 작성된 프로그램과 통합할 수 있습니다. 또한 원시 식별자를 사용하면 크레이트에서 사용하는 것과 다른 Rust 에디션으로 작성된 라이브러리를 사용할 수 있습니다. 예를 들어 try는 2015년 버전에서는 키워드가 아니지만 2018년 버전에서는 키워드입니다. 2015 에디션을 사용하여 작성되고 try 함수가 있는 라이브러리에 의존하는 경우 원시 식별자 구문(이 경우 r#try)을 사용하여 2018 에디션 코드에서 해당 함수를 호출해야 합니다. 에디션에 대한 자세한 내용은 부록 E를 참조하십시오 .\n\n부록 B: 연산자 및 기호\n이 부록에는 자체적으로 또는 경로, 제네릭, 특성 범위, 매크로, 속성, 주석, 튜플 및 괄호의 맥락에서 나타나는 연산자 및 기타 기호를 포함하여 Rust의 구문에 대한 용어집이 포함되어 있습니다.\n연산자\n표 B-1에는 Rust의 연산자, 컨텍스트에서 연산자가 어떻게 표시되는지에 대한 예, 간단한 설명, 해당 연산자가 오버로드 가능한지 여부가 포함되어 있습니다. 연산자가 오버로드 가능한 경우 해당 연산자를 오버로드하는 데 사용할 관련 특성이 나열됩니다.\n표 B-1: 연산자\n운영자예설명과부하 가능?\n!식별!(...), 식별!{...}, 식별![...]매크로 확장\n!!expr비트 또는 논리 보수아니다\n!=expr != expr비동일성 비교부분 방정식\n%expr % expr산술 나머지렘\n%=변수 %= 경험치산술 나머지 및 할당재할당\n&amp;&amp;expr, &amp;mut expr빌리다\n&amp;&amp;type, &amp;mut 유형, &amp;a 유형, &amp;mut 유형빌린 포인터 유형\n&amp;expr &amp; expr비트 AND비트앤드\n&amp;=var &amp;= expr비트 AND 및 대입BitAndAssign\n&amp;&amp;expr &amp;&amp; expr단락 논리 AND\n*expr * expr산술 곱셈물\n*=var *= expr산술 곱셈 및 대입물할당\n**expr역참조데레프\n**const 유형, *mut 유형원시 포인터\n+특성 + 특성, ``a + 특성`복합 유형 제약\n+expr + expr산술 덧셈추가하다\n+=var += expr산술 덧셈과 대입할당 추가\n,익스프레스인수 및 요소 구분 기호\n-- 특급산술 부정네그\n-expr-expr산술 뺄셈보결\n-=var -= expr산술 뺄셈 및 대입하위 할당\n-&gt;fn(...) -&gt; 유형, `...-&gt; 입력`\n.expr.ident회원 액세스\n...., expr.., ..expr, expr..expr오른쪽 제외 범위 리터럴부분 순서\n..=..=expr, expr..=expr오른쪽 포함 범위 리터럴부분 순서\n....expr구조체 리터럴 업데이트 구문\n..variant(x, ..), struct_type { x, .. }그리고 나머지 패턴 제본\n...expr...expr(더 이상 사용되지 않음, 대신 ..= 사용) 패턴에서: 포함 범위 패턴\n/익스프레스/익스프레스산술 나눗셈사업부\n/=var /= expr산술 나눗셈과 대입사업부 할당\n:pat: 유형, ident: 유형제약\n:식별: expr구조체 필드 이니셜라이저\n:``a: 루프 {...}`루프 라벨\n;익스프레스;문 및 항목 종결자\n;[...; 렌]고정 크기 배열 구문의 일부\n&lt;&lt;expr &lt;&lt; 익스퍼왼쪽 시프트쉬\n&lt;&lt;=var &lt;&lt;= expr왼쪽 시프트 및 할당Shl할당\n&lt;익스프레스 &lt; 엑스프레스비교보다 작음부분 순서\n&lt;=expr &lt;= expr작거나 같음 비교부분 순서\n=var = expr, ident = 유형할당/등가\n==expr == expr평등 비교부분 방정식\n=&gt;팻 =&gt; expr매치 암 구문의 일부\n&gt;익스프레스 &gt; 엑스프레스비교보다 큼부분 순서\n&gt;=expr &gt;= expr비교보다 크거나 같음부분 순서\n&gt;&gt;expr &gt;&gt; expr오른쪽 시프트슈\n&gt;&gt;=변수 &gt;&gt;= 경험치오른쪽 시프트 및 할당ShrAssign\n@식별 @ 팻패턴 바인딩\n^expr ^ expr비트 배타적 ORBitXor\n^=var ^= expr비트 배타적 OR 및 대입BitXorAssign\n```가볍게 두드리기가볍게 두드리기`\n```expr특급`\n`=``var= 경험치`\n```expr\n?익스프레스?오류 전파\n\n비연산자 기호\n다음 목록에는 연산자로 작동하지 않는 모든 기호가 포함되어 있습니다. 즉, 함수 또는 메서드 호출처럼 동작하지 않습니다.\n표 B-2는 자체적으로 나타나고 다양한 위치에서 유효한 기호를 보여줍니다.\n표 B-2: 독립형 구문\n상징설명\n``정체성`명명된 수명 또는 루프 레이블\n...u8, ...i32, ...f64, ...usize 등특정 유형의 숫자 리터럴\n...문자열 리터럴\nr...``, r#...#, r##...##, 등.원시 문자열 리터럴, 이스케이프 문자가 처리되지 않음\n비...``바이트 문자열 리터럴 문자열 대신 바이트 배열을 구성합니다.\nbr...``, br#...#, br##...## 등원시 바이트 문자열 리터럴, 원시 및 바이트 문자열 리터럴의 조합\n...문자 리터럴\n비...``ASCII 바이트 리터럴\n`...\n!발산 기능을 위한 항상 빈 바닥 유형\n_무시된 패턴 바인딩; 또한 정수 리터럴을 읽을 수 있도록 만드는 데 사용됩니다.\n\n표 B-3은 항목에 대한 모듈 계층 구조를 통한 경로 컨텍스트에 나타나는 기호를 보여줍니다.\n표 B-3: 경로 관련 구문\n상징설명\n식별::식별네임스페이스 경로\n::길크레이트 루트에 상대적인 경로(즉, 명시적으로 절대 경로)\n자신::경로현재 모듈에 상대적인 경로(즉, 명시적 상대 경로).\n슈퍼::경로현재 모듈의 부모에 상대적인 경로\n유형::식별자, ::아이덴티티관련 상수, 함수 및 유형\n::...직접 이름을 지정할 수 없는 유형의 관련 항목(예: &lt;&amp;T&gt;::..., &lt;[T]&gt;::... 등)\n특성::방법(...)메서드 호출을 정의하는 트레이트의 이름을 지정하여 메서드 호출 명확화\n유형::방법(...)정의된 유형의 이름을 지정하여 메서드 호출 명확화\n::방법(...)특성과 유형의 이름을 지정하여 메서드 호출 명확화\n\n표 B-4는 제네릭 형식 매개변수를 사용할 때 나타나는 기호를 보여줍니다.\n표 B-4: 제네릭\n상징설명\n경로&lt;...&gt;유형의 제네릭 유형에 대한 매개변수를 지정합니다(예: Vec)\n경로::&lt;...&gt;, 방법::&lt;...&gt;식의 제네릭 형식, 함수 또는 메서드에 대한 매개 변수를 지정합니다. 종종 터보피시라고 합니다(예: ``42.parse::())\nfn ident&lt;...&gt; ...제네릭 함수 정의\n구조체 식별&lt;...&gt; ...일반 구조 정의\n열거 ID&lt;...&gt; ...일반 열거 정의\nimpl&lt;...&gt; ...일반 구현 정의\nfor&lt;...&gt; 유형더 높은 순위의 수명 범위\n유형&lt;식별=유형&gt;하나 이상의 관련 유형에 특정 할당이 있는 일반 유형(예: Iterator&lt;Item=T&gt;)\n\n표 B-5는 특성 범위를 사용하여 일반 유형 매개변수를 제한하는 컨텍스트에서 나타나는 기호를 보여줍니다.\n표 B-5: 특성 바운드 제약\n상징설명\n티: 유U를 구현하는 유형으로 제한되는 일반 매개변수 T\n티: 아`일반 유형 T는 수명 a`보다 오래 지속되어야 합니다(유형은 수명이 a`보다 짧은 참조를 전이적으로 포함할 수 없음을 의미).\nT: 정적`제네릭 유형 T에는 ``정적` 참조 이외의 빌린 참조가 없습니다.\n``b: 아일반 수명 b`는 수명 a`보다 오래 지속되어야 합니다.\nT: ?크기일반 유형 매개변수가 동적으로 크기가 조정되는 유형이 되도록 허용\n``a + 특성, 특성 + 특성`복합 유형 제약\n\n표 B-6은 매크로를 호출하거나 정의하고 항목에 대한 속성을 지정하는 상황에서 나타나는 기호를 보여줍니다.\n표 B-6: 매크로 및 속성\n상징설명\n#[메타]외부 속성\n#![메타]내부 속성\n$ident매크로 대체\n$ident:종류매크로 캡처\n$(…)…매크로 반복\n식별!(...), 식별!{...}, 식별![...]매크로 호출\n\n표 B-7은 주석을 만드는 기호를 보여줍니다.\n표 B-7: 설명\n상징설명\n//라인 코멘트\n//!내부 라인 문서 주석\n///외곽선 문서 주석\n/ *...* /댓글 차단\n/ *!...* /내부 블록 문서 주석\n/**...*/외부 블록 문서 주석\n\n표 B-8은 튜플 사용과 관련하여 나타나는 기호를 보여줍니다.\n표 B-8: 튜플\n상징설명\n()빈 튜플(일명 단위), 리터럴 및 유형 모두\n(익스프레스)괄호로 묶은 표현\n(익스프레스,)단일 요소 튜플 표현식\n(유형,)단일 요소 튜플 유형\n(익스프레스, ...)튜플 표현식\n(유형, ...)튜플 유형\nexpr(expr, ...)함수 호출 표현; 또한 튜플 struct 및 튜플 enum 변형을 초기화하는 데 사용됩니다.\nexpr.0, expr.1 등튜플 인덱싱\n\n표 B-9는 중괄호가 사용되는 문맥을 보여줍니다.\n표 B-9: 중괄호\n문맥설명\n{...}블록 표현\n유형 {...}구조체 리터럴\n\n표 B-10은 대괄호가 사용되는 문맥을 보여줍니다.\n표 B-10: 대괄호\n문맥설명\n[...]배열 리터럴\n[expr; 렌]expr의 len 복사본을 포함하는 배열 리터럴\n[유형; 렌]type의 len 인스턴스를 포함하는 배열 유형\nexpr[익스프레]컬렉션 인덱싱. 오버로드 가능(Index, IndexMut)\nexpr[..], expr[a..], expr[..b], expr[a..b]Range, RangeFrom, RangeTo 또는 RangeFull을 인덱스로 사용하여 컬렉션 슬라이싱인 척하는 컬렉션 인덱싱\n\n\n부록 C: 파생 특성\n이 책의 여러 곳에서 구조체 또는 열거형 정의에 적용할 수 있는 derive 속성에 대해 논의했습니다. derive 특성은 derive 구문으로 주석을 추가한 유형에 자체 기본 구현을 사용하여 특성을 구현하는 코드를 생성합니다.\n이 부록에서는 파생과 함께 사용할 수 있는 표준 라이브러리의 모든 특성에 대한 참조를 제공합니다. 각 섹션에서는 다음을 다룹니다.\n\n이 트레이트를 유도하는 연산자와 메서드는 무엇을 가능하게 합니까?\n파생에서 제공하는 특성의 구현이 수행하는 작업\n특성을 구현하는 것이 유형에 대해 의미하는 것\n특성을 구현하도록 허용되거나 허용되지 않는 조건\n특성이 필요한 작업의 예\n\nderive 속성에서 제공하는 것과 다른 동작을 원하는 경우 수동으로 구현하는 방법에 대한 자세한 내용은 각 특성에 대한 표준 라이브러리 문서를 참조하세요.\n여기에 나열된 이러한 특성은 derive를 사용하여 유형에 구현할 수 있는 표준 라이브러리에 의해 정의된 유일한 특성입니다. 표준 라이브러리에 정의된 다른 특성에는 합리적인 기본 동작이 없으므로 달성하려는 작업에 적합한 방식으로 구현하는 것은 사용자에게 달려 있습니다.\n파생할 수 없는 트레이트의 예로는 최종 사용자의 서식을 처리하는 디스플레이가 있습니다. 최종 사용자에게 유형을 표시하는 적절한 방법을 항상 고려해야 합니다. 최종 사용자가 볼 수 있도록 유형의 어떤 부분을 허용해야 합니까? 어떤 부분이 관련성이 있다고 생각합니까? 그들에게 가장 관련 있는 데이터 형식은 무엇입니까? Rust 컴파일러에는 이러한 통찰력이 없으므로 적절한 기본 동작을 제공할 수 없습니다.\n이 부록에서 제공되는 파생 가능한 특성 목록은 포괄적이지 않습니다. 라이브러리는 고유한 특성에 대해 파생을 구현할 수 있으므로 진정한 개방형으로 파생할 수 있는 특성 목록을 만들 수 있습니다. 파생 구현에는 19장의 매크로 섹션 에서 다루는 절차적 매크로 사용이 포함됩니다.\n프로그래머 출력을 위한 디버그\n디버그 특성은 :?를 추가하여 표시하는 형식 문자열에서 디버그 형식화를 활성화합니다. {} 자리 표시자 내.\n디버그 특성을 사용하면 디버깅 목적으로 유형의 인스턴스를 인쇄할 수 있으므로 귀하와 귀하의 유형을 사용하는 다른 프로그래머가 프로그램 실행의 특정 지점에서 인스턴스를 검사할 수 있습니다.\n예를 들어 assert_eq!를 사용하려면 디버그 특성이 필요합니다. 매크로. 이 매크로는 같음 주장이 실패하면 인수로 제공된 인스턴스 값을 인쇄하여 프로그래머가 두 인스턴스가 같지 않은 이유를 확인할 수 있습니다.\n등식 비교를 위한 PartialEq 및 Eq\nPartialEq 특성을 사용하면 유형의 인스턴스를 비교하여 동등성을 확인하고 == 및 != 연산자를 사용할 수 있습니다.\nPartialEq 파생은 eq 방법을 구현합니다. 구조체에서 PartialEq가 파생된 경우 모든 필드가 동일한 경우에만 두 인스턴스가 같고 필드가 같지 않은 경우 인스턴스가 같지 않습니다. 열거형에서 파생된 경우 각 변형은 자체와 동일하며 다른 변형과 동일하지 않습니다.\n예를 들어 assert_eq!를 사용하려면 PartialEq 특성이 필요합니다. 같은 유형의 두 인스턴스를 비교할 수 있어야 하는 매크로.\nEq 특성에는 방법이 없습니다. 그 목적은 주석이 달린 유형의 모든 값에 대해 값이 자신과 같다는 신호를 보내는 것입니다. Eq 특성은 PartialEq도 구현하는 유형에만 적용할 수 있지만 PartialEq를 구현하는 모든 유형이 Eq를 구현할 수 있는 것은 아닙니다. 이에 대한 한 가지 예는 부동 소수점 숫자 유형입니다. 부동 소수점 숫자의 구현은 숫자가 아닌(NaN) 값의 두 인스턴스가 서로 같지 않음을 나타냅니다.\nEq가 필요한 경우의 예는 HashMap&lt;K, V&gt;의 키에 대한 것이므로 HashMap&lt;K, V&gt;는 두 키가 동일한지 여부를 알 수 있습니다.\n순서 비교를 위한 PartialOrd 및 Ord\nPartialOrd 특성을 사용하면 정렬 목적으로 유형의 인스턴스를 비교할 수 있습니다. PartialOrd를 구현하는 형식은 &lt;, &gt;, &lt;= 및 &gt;= 연산자와 함께 사용할 수 있습니다. PartialEq도 구현하는 유형에만 PartialOrd 특성을 적용할 수 있습니다.\nPartialOrd 파생은 partial_cmp 메서드를 구현하여 옵션을 반환합니다.해당 유형의 대부분의 값을 비교할 수 있지만 순서를 생성하지 않는 값의 예는 숫자가 아닌(NaN) 부동 소수점 값 임의의 부동 소수점 숫자 및 NaN부동 소수점 값으로partial_cmp를 호출하면 None`이 반환됩니다.\n구조체에서 파생된 경우 PartialOrd는 필드가 구조체 정의에 나타나는 순서대로 각 필드의 값을 비교하여 두 인스턴스를 비교합니다. 열거형에서 파생된 경우 열거형 정의에서 앞서 선언된 열거형의 변형은 나중에 나열된 변형보다 작은 것으로 간주됩니다.\nPartialOrd 특성은 예를 들어 범위 표현식으로 지정된 범위에서 무작위 값을 생성하는 rand 크레이트의 gen_range 메서드에 필요합니다.\nOrd 특성을 사용하면 주석이 달린 유형의 두 값에 대해 유효한 순서가 존재함을 알 수 있습니다. Ord 특성은 Option이 아닌 Ordering을 반환하는 cmp 메서드를 구현합니다.유효한 순서 지정이 항상 가능하기 때문입니다.Ord특성은PartialOrd및Eq(및 Eq에는 PartialEq가 필요함)도 구현하는 유형에만 적용할 수 있습니다. 구조체 및 열거형에서 파생될 때  cmp는 partial_cmp에 대한 파생 구현이 PartialOrd`와 동일한 방식으로 동작합니다.\nOrd가 필요한 경우의 예는 BTreeSet에 값을 저장할 때입니다.`, 값의 정렬 순서에 따라 데이터를 저장하는 데이터 구조입니다.\n값 복제를 위한 복제 및 복사\n복제 특성을 사용하면 값의 깊은 복사본을 명시적으로 만들 수 있으며 복제 프로세스에는 임의 코드 실행 및 힙 데이터 복사가 포함될 수 있습니다. 복제 에 대한 자세한 내용은 4장의 변수와 데이터가 상호 작용하는 방식: 복제 섹션을 참조하십시오 .\nClone 파생은 전체 유형에 대해 구현될 때 유형의 각 부분에서 clone을 호출하는 clone 메소드를 구현합니다. 이는 유형의 모든 필드 또는 값이 복제를 파생시키기 위해 복제도 구현해야 함을 의미합니다.\n복제가 필요한 경우의 예는 슬라이스에서 to_vec 메서드를 호출할 때입니다. 슬라이스는 포함된 유형 인스턴스를 소유하지 않지만 to_vec에서 반환된 벡터는 해당 인스턴스를 소유해야 하므로 to_vec는 각 항목에서 clone을 호출합니다. 따라서 슬라이스에 저장된 유형은 복제를 구현해야 합니다.\n복사 특성을 사용하면 스택에 저장된 비트만 복사하여 값을 복제할 수 있습니다. 임의의 코드가 필요하지 않습니다.  복사에 대한 자세한 내용은 4장의 스택 전용 데이터: 복사 섹션을 참조하십시오 .\n복사 특성은 프로그래머가 해당 메서드를 오버로드하고 임의의 코드가 실행되지 않는다는 가정을 위반하는 것을 방지하는 메서드를 정의하지 않습니다. 그런 식으로 모든 프로그래머는 값 복사가 매우 빠를 것이라고 가정할 수 있습니다.\n부분이 모두 복사를 구현하는 모든 유형에서 복사를 파생시킬 수 있습니다. 복사를 구현하는 유형은 복사도 구현해야 합니다. 복사를 구현하는 유형에는 복사와 동일한 작업을 수행하는 간단한 복제 구현이 있기 때문입니다.\n복사 특성은 거의 필요하지 않습니다. Copy를 구현하는 유형에는 최적화가 가능합니다. 즉, clone을 호출할 필요가 없으므로 코드가 더 간결해집니다.\n복사로 가능한 모든 작업은 복제로도 수행할 수 있지만 코드가 느려지거나 위치에서 복제를 사용해야 할 수 있습니다.\n값을 고정 크기 값에 매핑하기 위한 해시\n해시 특성을 사용하면 임의 크기 유형의 인스턴스를 가져오고 해시 함수를 사용하여 해당 인스턴스를 고정 크기 값에 매핑할 수 있습니다. 해시 파생은 해시 메서드를 구현합니다. 해시 메서드의 파생된 구현은 유형의 각 부분에서 해시를 호출한 결과를 결합합니다. 즉, 모든 필드 또는 값도 해시를 파생하려면 해시를 구현해야 합니다.\nHash가 필요한 경우의 예는 데이터를 효율적으로 저장하기 위해 HashMap&lt;K, V&gt;에 키를 저장하는 것입니다.\n기본값에 대한 기본값\nDefault 특성을 사용하면 유형의 기본값을 만들 수 있습니다. Default 파생은 default 기능을 구현합니다. default 함수의 파생된 구현은 유형의 각 부분에서 default 함수를 호출합니다. 즉, 유형의 모든 필드 또는 값은 Default를 파생시키기 위해 Default도 구현해야 합니다.\nDefault::default 함수는 일반적으로 5장의 구조체 업데이트 구문을 사용하여 다른 인스턴스에서 인스턴스 만들기 섹션 에서 설명한 구조체 업데이트 구문과 함께 사용됩니다. 구조체의 몇 가지 필드를 사용자 정의한 다음 설정할 수 있습니다. ..Default::default()를 사용하여 나머지 필드에 기본값을 사용하십시오.\n기본 특성은 옵션에서 unwrap_or_default 메서드를 사용할 때 필요합니다.인스턴스를 예로 들 수 있습니다.옵션이가 없음인 경우 unwrap_or_default메서드는옵션에 저장된 T유형에 대해Default::default 결과를 반환합니다..\n\n부록 D - 유용한 개발 도구\n이 부록에서는 Rust 프로젝트가 제공하는 몇 가지 유용한 개발 도구에 대해 이야기합니다. 자동 서식 지정, 경고 수정을 적용하는 빠른 방법, linter 및 IDE와의 통합에 대해 살펴보겠습니다.\nrustfmt를 사용한 자동 서식 지정\nrustfmt 도구는 커뮤니티 코드 스타일에 따라 코드 형식을 다시 지정합니다. 많은 협업 프로젝트는 Rust를 작성할 때 사용할 스타일에 대한 논쟁을 방지하기 위해 rustfmt를 사용합니다. 모든 사람이 도구를 사용하여 코드 형식을 지정합니다.\nrustfmt를 설치하려면 다음을 입력하십시오.\n$ rustup component add rustfmt\n\n이 명령은 Rust가 rustc와 cargo를 모두 제공하는 것과 유사하게 rustfmt와 cargo-fmt를 제공합니다. Cargo 프로젝트를 포맷하려면 다음을 입력하십시오:\n$ cargo fmt\n\n이 명령을 실행하면 현재 크레이트의 모든 Rust 코드가 다시 포맷됩니다. 이것은 코드 의미 체계가 아니라 코드 스타일만 변경해야 합니다. rustfmt에 대한 자세한 내용은 해당 설명서를 참조하십시오 .\nrustfix로 코드 수정\nRustfix 도구는 Rust 설치에 포함되어 있으며 원하는 문제일 가능성이 있는 문제를 수정하는 명확한 방법이 있는 컴파일러 경고를 자동으로 수정할 수 있습니다. 이전에 컴파일러 경고를 본 적이 있을 것입니다. 예를 들어 다음 코드를 고려하십시오.\n파일 이름: src/main.rs\nfn do_something() {}\n\nfn main() {\n    for i in 0..100 {\n        do_something();\n    }\n}\n\n여기에서 우리는 do_something 함수를 100번 호출하지만 for 루프 본문에 변수 i를 사용하지 않습니다. Rust는 이에 대해 다음과 같이 경고합니다.\n$ cargo build\n   Compiling myprogram v0.1.0 (file:///projects/myprogram)\nwarning: unused variable: `i`\n --&gt; src/main.rs:4:9\n  |\n4 |     for i in 0..100 {\n  |         ^ help: consider using `_i` instead\n  |\n  = note: #[warn(unused_variables)] on by default\n\n    Finished dev [unoptimized + debuginfo] target(s) in 0.50s\n\n경고는 이름으로 _i를 대신 사용할 것을 제안합니다. 밑줄은 이 변수를 사용하지 않을 것임을 나타냅니다. cargo fix 명령을 실행하여 rustfix 도구를 사용하여 해당 제안을 자동으로 적용할 수 있습니다.\n$ cargo fix\n    Checking myprogram v0.1.0 (file:///projects/myprogram)\n      Fixing src/main.rs (1 fix)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.59s\n\nsrc/main.rs를 다시 보면 cargo fix가 코드를 변경했음을 알 수 있습니다.\n파일 이름: src/main.rs\nfn do_something() {}\n\nfn main() {\n    for _i in 0..100 {\n        do_something();\n    }\n}\n\nfor 루프 변수의 이름은 이제 _i로 지정되고 더 이상 경고가 표시되지 않습니다.\ncargo fix 명령을 사용하여 다른 Rust 버전 간에 코드를 전환할 수도 있습니다. 에디션은 부록 E에서 다룹니다.\nClippy로 더 많은 린트\nClippy 도구는 일반적인 실수를 포착하고 Rust 코드를 개선할 수 있도록 코드를 분석하기 위한 린트 모음입니다.\nClippy를 설치하려면 다음을 입력하십시오.\n$ rustup component add clippy\n\nCargo 프로젝트에서 Clippy의 린트를 실행하려면 다음을 입력하십시오.\n$ cargo clippy\n\n예를 들어, 다음 프로그램처럼 파이와 같은 수학 상수의 근사치를 사용하는 프로그램을 작성한다고 가정해 보겠습니다.\n파일 이름: src/main.rs\nfn main() {\n    let x = 3.1415;\n    let r = 8.0;\n    println!(`the area of the circle is {}`, x * r * r);\n}\n\n이 프로젝트에서 cargo clippy를 실행하면 다음 오류가 발생합니다.\nerror: approximate value of `f{32, 64}::consts::PI` found\n --&gt; src/main.rs:2:13\n  |\n2 |     let x = 3.1415;\n  |             ^^^^^^\n  |\n  = note: `#[deny(clippy::approx_constant)]` on by default\n  = help: consider using the constant directly\n  = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#approx_constant\n\n이 오류는 Rust에 이미 더 정확한 PI 상수가 정의되어 있고 대신 상수를 사용하면 프로그램이 더 정확하다는 것을 알려줍니다. 그런 다음 PI 상수를 사용하도록 코드를 변경합니다. 다음 코드는 Clippy에서 오류나 경고를 발생시키지 않습니다.\n파일 이름: src/main.rs\nfn main() {\n    let x = std::f64::consts::PI;\n    let r = 8.0;\n    println!(`the area of the circle is {}`, x * r * r);\n}\n\nClippy에 대한 자세한 내용은 설명서를 참조하십시오 .\nrust-analyzer를 사용한 IDE 통합\nIDE 통합을 돕기 위해 Rust 커뮤니티는 rust-analyzer 사용을 권장합니다. 이 도구 는 IDE와 프로그래밍 언어가 서로 통신하기 위한 사양인 언어 서버 프로토콜을 말하는 컴파일러 중심 유틸리티 세트입니다. 다른 클라이언트는 Visual Studio Code용 Rust 분석기 플러그인 과 같은 rust-analyzer를 사용할 수 있습니다.\n설치 지침을 보려면 rust-analyzer 프로젝트의 홈 페이지를 방문 하고 특정 IDE에 언어 서버 지원을 설치하십시오. IDE는 자동 완성, 정의로 이동, 인라인 오류와 같은 기능을 얻게 됩니다.\n\n부록 E - 에디션\n1장에서 cargo new가 에디션에 대한 Cargo.toml 파일 에 약간의 메타데이터를 추가하는 것을 보았습니다. 이 부록은 그 의미에 대해 설명합니다!\nRust 언어와 컴파일러는 6주 릴리스 주기를 가지며, 이는 사용자가 새로운 기능을 지속적으로 얻을 수 있음을 의미합니다. 다른 프로그래밍 언어는 더 큰 변경 사항을 덜 자주 릴리스합니다. Rust는 더 작은 업데이트를 더 자주 릴리스합니다. 잠시 후 이러한 모든 작은 변화가 합산됩니다. 그러나 출시마다 와, Rust 1.10과 Rust 1.31 사이에 Rust가 많이 바뀌었어요!라고 되돌아보며 말하기는 어려울 수 있습니다.\nRust 팀은 2년 또는 3년마다 새로운 Rust 에디션을 제작합니다. 각 에디션은 완전히 업데이트된 문서 및 도구와 함께 명확한 패키지에 포함된 기능을 함께 제공합니다. 새 에디션은 일반적인 6주 출시 프로세스의 일부로 배송됩니다.\n에디션은 사람마다 다른 용도로 사용됩니다.\n\n활성 Rust 사용자를 위해 새 에디션은 점진적인 변경 사항을 이해하기 쉬운 패키지로 통합합니다.\n비사용자의 경우 새 에디션은 몇 가지 주요 발전이 이루어졌음을 알리므로 Rust를 다시 살펴볼 가치가 있습니다.\nRust를 개발하는 사람들을 위해 새 에디션은 전체적으로 프로젝트의 집결 지점을 제공합니다.\n\n이 글을 쓰는 시점에 Rust 2015, Rust 2018 및 Rust 2021의 세 가지 Rust 에디션을 사용할 수 있습니다. 이 책은 Rust 2021 에디션 관용구를 사용하여 작성되었습니다.\nCargo.toml 의 edition 키는 컴파일러가 코드에 사용해야 하는 에디션을 나타냅니다. 키가 존재하지 않으면 Rust는 이전 버전과의 호환성을 위해 에디션 값으로 2015를 사용합니다.\n각 프로젝트는 기본 2015 에디션 이외의 에디션을 선택할 수 있습니다. 버전에는 코드의 식별자와 충돌하는 새 키워드를 포함하는 것과 같이 호환되지 않는 변경 사항이 포함될 수 있습니다. 그러나 이러한 변경 사항을 선택하지 않으면 사용하는 Rust 컴파일러 버전을 업그레이드하더라도 코드는 계속 컴파일됩니다.\n모든 Rust 컴파일러 버전은 해당 컴파일러 릴리스 이전에 존재했던 모든 버전을 지원하며 지원되는 모든 버전의 크레이트를 함께 연결할 수 있습니다. 버전 변경은 컴파일러가 처음에 코드를 구문 분석하는 방식에만 영향을 미칩니다. 따라서 Rust 2015를 사용 중이고 종속성 중 하나가 Rust 2018을 사용하는 경우 프로젝트가 컴파일되고 해당 종속성을 사용할 수 있습니다. 프로젝트가 Rust 2018을 사용하고 종속성이 Rust 2015를 사용하는 반대 상황도 작동합니다.\n명확하게 말하면 대부분의 기능은 모든 버전에서 사용할 수 있습니다. Rust 에디션을 사용하는 개발자는 새로운 안정적인 릴리스가 만들어짐에 따라 계속해서 개선 사항을 확인할 수 있습니다. 그러나 경우에 따라 주로 새 키워드가 추가될 때 일부 새 기능은 이후 버전에서만 사용할 수 있습니다. 이러한 기능을 이용하려면 버전을 전환해야 합니다.\n자세한 내용은 에디션 가이드에서 에디션 간의 차이점을 열거하고 cargo fix를 통해 코드를 새 에디션으로 자동 업그레이드하는 방법을 설명하는 에디션에 대한 완전한 책입니다.\n\n부록 F: 책의 번역\n영어 이외의 언어로 된 리소스의 경우. 대부분은 아직 진행 중입니다. 번역 레이블을 참조하여 도움을 받거나 새 번역에 대해 알려주십시오!\n\n포르투갈어 (BR)\n포르투갈어 (PT)\n简體中文\n正體中文\nУкраїнська\n스페인어 , 대체\n이탈리아노\n러시아인\n한국어\n일본어\n프랑세즈\n폴스키\n세부아노어\n타갈로그어\n에스페란토 말\nελληνική\n스벤스카\n페르시아어\n독일어\n힌디어\nไทย\n단스케\n\n\n부록 G - Rust가 만들어지는 방식과 “Nightly Rust”\n이 부록은 Rust가 어떻게 만들어지고 그것이 Rust 개발자로서 당신에게 어떤 영향을 미치는지에 관한 것입니다.\n정체 없는 안정성\n언어로서 Rust는 코드의 안정성에 많은 관심을 기울입니다. 우리는 Rust가 여러분이 구축할 수 있는 견고한 기반이 되기를 원합니다. 상황이 끊임없이 변화한다면 그것은 불가능할 것입니다. 동시에 새로운 기능을 실험할 수 없다면 더 이상 변경할 수 없는 출시 이후까지 중요한 결함을 발견하지 못할 수 있습니다.\n이 문제에 대한 우리의 해결책은 우리가 정체 없는 안정성이라고 부르는 것이며, 우리의 기본 원칙은 다음과 같습니다: 안정적인 Rust의 새 버전으로 업그레이드하는 것을 두려워할 필요가 없습니다. 각 업그레이드는 수월해야 하지만 새로운 기능, 더 적은 버그, 더 빠른 컴파일 시간을 제공해야 합니다.\n추추! 릴리스 채널 및 기차 타기\nRust 개발은 기차 일정 에 따라 운영됩니다. 즉, 모든 개발은 Rust 저장소의 마스터 분기에서 수행됩니다. 릴리스는 Cisco IOS 및 기타 소프트웨어 프로젝트에서 사용된 소프트웨어 릴리스 트레인 모델을 따릅니다. Rust에는 세 가지 릴리스 채널이 있습니다.\n\n나이틀리\n베타\n안정적인\n\n대부분의 Rust 개발자는 주로 안정적인 채널을 사용하지만 실험적인 새 기능을 시도하려는 사용자는 nightly 또는 베타를 사용할 수 있습니다.\n다음은 개발 및 출시 프로세스가 어떻게 작동하는지에 대한 예입니다. Rust 팀이 Rust 1.5 출시 작업을 하고 있다고 가정해 봅시다. 해당 릴리스는 2015년 12월에 이루어졌지만 현실적인 버전 번호를 제공할 것입니다. Rust에 새로운 기능이 추가되었습니다: 새로운 커밋이 마스터 브랜치에 도달합니다. 매일 밤 Rust의 새로운 야간 버전이 생성됩니다. 매일이 출시일이며 이러한 출시는 출시 인프라에서 자동으로 생성됩니다. 그래서 시간이 지남에 따라 우리의 릴리스는 밤에 한 번 다음과 같이 보입니다.\nnightly: * - - * - - *\n\n6주마다 새로운 릴리스를 준비할 시간입니다! Rust 저장소의 베타 분기는 nightly에서 사용하는 마스터 분기에서 분기됩니다. 이제 두 가지 릴리스가 있습니다.\nnightly: * - - * - - *\n                     |\nbeta:                *\n\n대부분의 Rust 사용자는 베타 릴리스를 적극적으로 사용하지 않지만 Rust가 가능한 회귀를 발견할 수 있도록 CI 시스템에서 베타에 대해 테스트합니다. 그 동안 매일 밤마다 야간 릴리스가 있습니다.\nnightly: * - - * - - * - - * - - *\n                     |\nbeta:                *\n\n회귀가 발견되었다고 가정 해 봅시다. 회귀가 안정적인 릴리스에 들어가기 전에 베타 릴리스를 테스트할 시간이 있어서 다행입니다! 수정 사항이 마스터에 적용되어 nightly가 수정된 다음 수정 사항이 베타 분기로 백포트되고 새로운 베타 릴리스가 생성됩니다.\nnightly: * - - * - - * - - * - - * - - *\n                     |\nbeta:                * - - - - - - - - *\n\n첫 번째 베타가 생성된 지 6주가 지나면 안정적인 릴리스를 시작할 때입니다! 안정적인 분기는 베타 분기에서 생성됩니다.\nnightly: * - - * - - * - - * - - * - - * - * - *\n                     |\nbeta:                * - - - - - - - - *\n                                       |\nstable:                                *\n\n만세! 러스트 1.5가 완료되었습니다! 그러나 우리는 한 가지를 잊었습니다. 6주가 지났기 때문에 Rust의 다음 버전인 1.6의 새로운 베타 버전도 필요합니다. 따라서 stable이 beta에서 분기된 후 beta의 다음 버전이 nightly에서 다시 분기됩니다.\nnightly: * - - * - - * - - * - - * - - * - * - *\n                     |                         |\nbeta:                * - - - - - - - - *       *\n                                       |\nstable:                                *\n\n6주마다 릴리스가 정류장을 떠나지만 안정적인 릴리스로 도착하기 전에 베타 채널을 통과해야 하기 때문에 이를 기차 모델이라고 합니다.\nRust는 시계 장치처럼 6주마다 릴리스됩니다. 한 Rust 릴리스의 날짜를 알면 다음 날짜를 알 수 있습니다. 6주 후입니다. 6주마다 출시 일정을 잡는 것의 좋은 점은 다음 기차가 곧 온다는 것입니다. 특정 기능이 특정 릴리스를 놓치더라도 걱정할 필요가 없습니다. 곧 다른 기능이 출시될 것입니다! 이렇게 하면 릴리스 마감일에 가까워질 가능성이 있는 다듬지 않은 기능을 몰래 숨겨야 한다는 압력을 줄이는 데 도움이 됩니다.\n이 프로세스 덕분에 언제든지 Rust의 다음 빌드를 확인하고 업그레이드하기 쉬운지 직접 확인할 수 있습니다. 베타 릴리스가 예상대로 작동하지 않으면 팀에 보고하고 다음 안정 릴리스가 발생합니다! 베타 릴리스에서 파손은 상대적으로 드물지만 rustc는 여전히 소프트웨어의 일부이며 버그가 존재합니다.\n불안정한 기능\n이 릴리스 모델에는 불안정한 기능이 하나 더 있습니다. Rust는 기능 플래그라는 기술을 사용하여 주어진 릴리스에서 어떤 기능을 사용할 수 있는지 결정합니다. 새 기능이 활발히 개발 중인 경우 마스터에 도달하므로 야간이지만 기능 플래그 뒤에 있습니다. 사용자로서 진행 중인 기능을 시험해보고 싶다면 가능하지만 Rust의 나이틀리 릴리스를 사용하고 소스 코드에 옵트인할 적절한 플래그로 주석을 달아야 합니다.\nRust의 베타 또는 안정적인 릴리스를 사용하는 경우 기능 플래그를 사용할 수 없습니다. 이것은 우리가 새로운 기능을 영원히 안정적이라고 선언하기 전에 실제로 사용할 수 있게 해주는 열쇠입니다. 최신 기술을 선택하려는 사용자는 그렇게 할 수 있으며 견고한 경험을 원하는 사용자는 안정을 고수할 수 있으며 코드가 손상되지 않는다는 것을 알 수 있습니다. 정체가 없는 안정성.\n이 책에는 진행 중인 기능이 계속 변경되고 있기 때문에 안정적인 기능에 대한 정보만 포함되어 있으며 이 책이 쓰여진 시점과 안정적인 빌드에서 활성화되는 시점 사이에는 분명히 다를 것입니다. 야간 전용 기능에 대한 설명서는 온라인에서 찾을 수 있습니다.\nRustup과 Rust Nightly의 역할\nRustup을 사용하면 글로벌 또는 프로젝트별로 Rust의 서로 다른 릴리스 채널 간에 쉽게 변경할 수 있습니다. 기본적으로 안정적인 Rust가 설치되어 있습니다. 예를 들어 야간에 설치하려면 다음과 같이 하십시오.\n$ rustup toolchain install nightly\n\nrustup으로 설치한 모든 툴체인 (Rust 릴리스 및 관련 구성 요소)도 볼 수 있습니다. 다음은 작성자의 Windows 컴퓨터 중 하나에 대한 예입니다.\n&gt; rustup toolchain list\nstable-x86_64-pc-windows-msvc (default)\nbeta-x86_64-pc-windows-msvc\nnightly-x86_64-pc-windows-msvc\n\n보시다시피 안정적인 툴체인이 기본값입니다. 대부분의 Rust 사용자는 대부분 안정을 사용합니다. 대부분의 경우 안정적으로 사용하고 싶을 수 있지만 최신 기능에 관심이 있기 때문에 특정 프로젝트에서는 야간에 사용하십시오. 이렇게 하려면 해당 프로젝트의 디렉토리에서 rustup override를 사용하여 해당 디렉토리에 있을 때 rustup이 사용해야 하는 야간 툴체인을 설정할 수 있습니다.\n$ cd ~/projects/needs-nightly\n$ rustup override set nightly\n\n이제 ~/projects/needs-nightly 내부에서 rustc 또는 cargo를 호출할 때마다 rustup은 기본 안정적인 Rust가 아닌 야간 Rust를 사용하고 있는지 확인합니다. 이는 Rust 프로젝트가 많을 때 유용합니다!\nRFC 프로세스 및 팀\n그렇다면 이러한 새로운 기능에 대해 어떻게 알 수 있습니까? Rust의 개발 모델은 RFC(Request For Comments) 프로세스를 따릅니다. Rust를 개선하고 싶다면 RFC라는 제안을 작성할 수 있습니다.\n누구든지 Rust를 개선하기 위해 RFC를 작성할 수 있으며 제안은 많은 주제 하위 팀으로 구성된 Rust 팀에서 검토하고 논의합니다. Rust의 웹사이트에 팀의 전체 목록이 있습니다. 여기에는 언어 설계, 컴파일러 구현, 인프라, 문서 등 프로젝트의 각 영역에 대한 팀이 포함되어 있습니다. 적절한 팀이 제안서와 의견을 읽고, 의견을 직접 작성하고, 결국 기능을 수락하거나 거부하기 위한 합의가 이루어집니다.\n기능이 승인되면 Rust 리포지토리에 이슈가 열리고 누군가 이를 구현할 수 있습니다. 그것을 아주 잘 구현하는 사람은 애초에 그 기능을 제안한 사람이 아닐 수도 있습니다! 구현이 준비되면 불안정한 기능 섹션 에서 논의한 것처럼 기능 게이트 뒤의 마스터 브랜치에 도달합니다.\n시간이 지나면 나이틀리 릴리스를 사용하는 Rust 개발자가 새로운 기능을 시험해 볼 수 있게 되면 팀원들은 이 기능에 대해 논의하고 나이틀리에서 어떻게 작동하는지, 안정적인 Rust로 만들어야 하는지 여부를 결정할 것입니다. 앞으로 나아가기로 결정했다면 기능 게이트가 제거되고 이제 기능이 안정적인 것으로 간주됩니다! Rust의 안정적인 새 릴리스로 열차를 타고 이동합니다.\n","id":"http://127.0.0.1:1111/rust/chapter17-21/trans/","title":"18-21 translation"},"http://127.0.0.1:1111/rust/chapter2/":{"body":"요약\n\n\n프로젝트 생성 : cargo new 프로젝트이름\n\n\n\n표준 라이브러리를 가져오는 명령어 :\n\nuse std::라이브러리이름\nuse std::메소드이름::타입이름\n\n\n\n크레이트를 가져오는 명령어 : use 크레이트이름::트레잇이름\n\n\n크레이트 : Rust 소스 코드 파일의 모음\n\n\n트레잇 : 크레이트에 포함된 메서드(하나 또는 여러개)\n\n\n레지스트리 : Crates.io 의 데이터 사본 \n\n\nCrates.io : 사람들이 오픈 소스 Rust 프로젝트를 게시하는 곳\n\n\n\n\n\n변수생성 :\n\n\nlet 변수이름 : 변경불가능 \n\n\nlet mut 변수이름 : 변경가능\n\n\nlet 변수이름 : 타입, let mut 변수이름 : 타입 : 타입명시\n\n\nlet mut 변수이름 = String::new() : 빈 문자열 변수 생성\n\n\n\n\n변수이름은 재사용(덮어쓰기, shadowing) 가능\n\n\n\nmatch, cmp, loop, break 를 사용할 수 있다.\n\n\n\n일부 메서드는 \"결과값\"과 \"Result 타입\"을 함께 반환\n\n\nResult 타입 : 여러가지 변형(variant, 종류라고 이해하면 될듯)을 가지는 열거형(enumeration)\n\n\nResult 타입의 variant : Ok(T) 와 Err(E) \n\n\n\n\n\n\n오류해결\n\nResult 를 반환하는 메소드 뒤에 .expect를 붙인다\n메소드().expect(\"메세지\") : 메소드에서 반환하는 Result 타입의 variant가 Err 이면, 메세지 출력후 프로그램 중단\n\n\n\n추리게임 프로그래밍\n함께 실습 프로젝트를 통해 Rust에 뛰어들어 봅시다! 이 장에서는 실제 프로그램에서 사용하는 방법을 보여줌으로써 몇 가지 일반적인 Rust 개념을 소개합니다. let, match, 메서드, 관련 함수, 외부 크레이트 등에 대해 배우게 됩니다! 다음 장에서는 이러한 아이디어에 대해 자세히 살펴보겠습니다. 이 장에서는 기본 사항만 연습합니다.\n고전적인 초보자 프로그래밍 문제인 추측 게임을 구현할 것입니다. 작동 방식은 다음과 같습니다. 프로그램은 1에서 100 사이의 임의의 정수를 생성합니다. 그런 다음 플레이어에게 추측을 입력하라는 메시지가 표시됩니다. 추측이 입력되면 프로그램은 추측이 너무 낮은지 또는 너무 높은지 표시합니다. 추측이 맞으면 게임이 축하 메시지를 출력하고 종료됩니다.\n새 프로젝트 설정\n새 프로젝트를 설정하려면 1장에서 만든 프로젝트 디렉토리로 이동하고 다음과 같이 Cargo를 사용하여 새 프로젝트를 만듭니다.\n$ cargo new guessing_game\n$ cd guessing_game\n\n첫 번째 명령어인 cargo new는 프로젝트 이름( guessing_game)을 첫 번째 인수로 사용합니다. 두 번째 명령은 새 프로젝트의 디렉터리로 변경됩니다.\n\n생성된 Cargo.toml 파일을 살펴보십시오.\n파일 이름: Cargo.toml\n[package]\nname = \"guessing_game\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n\n[dependencies]\n\n\n1장에서 본 것처럼 cargo new 는 \"Hello, world!\" 프로그램을 생성합니다. src/main.rs 파일을 확인해봅시다.\n파일 이름: src/main.rs\nfn main() {\n    println!(\"Hello, world!\");\n}\n\n\n이제 \"Hello, world!\"  프로그램을 cargo run 명령을 사용하여 컴파일하고 실행하십시오 .\n$ cargo run\n   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n    Finished dev [unoptimized + debuginfo] target(s) in 1.50s\n     Running `target/debug/guessing_game`\nHello, world!\n\n이 run 명령은 프로젝트를 빠르게 반복해야 할 때 유용합니다. 이 게임에서 우리는 다음 반복으로 이동하기 전에 각 반복을 빠르게 테스트합니다.\nsrc/main.rs 파일을 다시 엽니다. 이제부터 이 파일에 모든 코드를 작성하게 됩니다.\n추측 처리\n추측 게임 프로그램의 첫 번째 부분은 사용자 입력을 요청하고, 해당 입력을 처리하고, 입력된 값이 예상된 형식인지 확인하는 것입니다. 시작하려면 플레이어가 추측을 입력하도록 허용합니다. 목록 2-1의 코드를 src/main.rs 에 입력합니다.\n파일 이름: src/main.rs\nuse std::io;\n\nfn main() {\n    println!(\"Guess the number!\");\n\n    println!(\"Please input your guess.\");\n\n    let mut guess = String::new();\n\n    io::stdin()\n        .read_line(&amp;mut guess)\n        .expect(\"Failed to read line\");\n\n    println!(\"You guessed: {guess}\");\n}\n\n목록 2-1: 사용자로부터 추측을 받아 출력하는 코드\n이 코드에는 많은 정보가 포함되어 있으므로 한 줄씩 살펴보겠습니다. 사용자 입력을 얻은 다음 결과를 출력으로 인쇄하려면  io 라고 하는 입력/출력 라이브러리를 범위(scope)로 가져와야 합니다. io라이브러리는 std로 알려진 표준 라이브러리에서 가져옵니다.\nuse std::io;\n\n기본적으로 Rust는 모든 프로그램의 범위로 가져오는 표준 라이브러리에 정의된 일련의 항목을 가지고 있습니다. 이 세트를 전주곡(prelude)이라고 하며 표준 라이브러리 문서에서 그 안에 있는 모든 것을 볼 수 있습니다.\n사용하려는 유형이 전주곡(prelude)에 없으면 use명령문을 사용하여 해당 유형을 명시적으로 범위로 가져와야 합니다. std::io라이브러리를 사용하면, 사용자 입력을 수락하는 기능을 포함하여 여러 가지 유용한 기능이 제공됩니다.\n\n1장에서 본 것처럼 main함수는 프로그램의 진입점입니다.\nfn main() {\n\n구문 fn은 새 함수를 선언합니다. ()괄호는 매개변수가 없음을 나타냅니다. 중괄호({) 는 함수 본문을 시작합니다.\n\n1장에서도 배웠듯이 println!는 화면에 문자열을 출력하는 매크로입니다.\n    println!(\"Guess the number!\");\n\n    println!(\"Please input your guess.\");\n\n\n이 코드는 게임이 무엇인지 설명하고 사용자의 입력을 요청하는 프롬프트를 인쇄합니다.\n변수와 함께 값 저장\n다음으로 다음과 같이 사용자 입력을 저장할 변수를 만듭니다.\nlet mut guess = String::new();\n\n이제 프로그램이 흥미로워지고 있습니다! 이 작은 줄에서 많은 일이 벌어지고 있습니다. let문을 사용하여 변수를 만듭니다.\n\n다음은 또 다른 예입니다.\nlet apples = 5;\n\n이 줄은 apples이름의 새 변수를 만들고, 변수에 값 5를 바인딩합니다. Rust에서 변수는 기본적으로 변경할 수 없습니다. 즉, 변수에 값을 지정하면 값이 변경되지 않습니다. 3장의 \"변수 및 가변성\" 섹션에서 이 개념에 대해 자세히 논의할 것입니다. 변수를 변경 가능하게 만들기 위해 변수 이름 앞에 mut을 추가합니다.\nlet apples = 5; // immutable\nlet mut bananas = 5; // mutable\n\n\n참고: //구문은 줄 끝까지 계속되는 주석을 시작합니다. Rust는 주석의 모든 것을 무시합니다. 주석에 대해서는 3장 에서 더 자세히 논의할 것입니다.\n\n추측 게임 프로그램으로 돌아가서, 이제 let mut guess 는 이름이 변경 가능한 변수 guess를 소개한다는 것을 알고 있습니다. 등호( =)는 Rust에게 우리가 지금 무언가를 변수에 묶고 싶다는 것을 알려줍니다. 등호 오른쪽에는 guess 에 바인딩된 값이 있는데, 그 값은 String의 새 인스턴스를 반환하는 함수인 String::new를 호출한 결과값 입니다. String은 표준 라이브러리에서 제공하는 문자열 유형인데, 확장 가능하고 UTF-8 로 인코딩된 비트(bit)입니다. \n\nString::new() 행의 ::구문은 new 가 String 타입의 연관함수임을 나타냅니다. 연관함수는 어떤 하나의 타입을 위한 함수이며, 이 경우에는 String 타입입니다. new 함수는 비어있는 새 문자열을 만듭니다. 어떤 종류의 새로운 값을 만드는 함수의 일반적인 이름이기 때문에, 많은 타입에서 new 함수를 찾을 수 있습니다.\n\n정리하면, let mut guess = String::new(); 은 변경가능한 guess 변수를 만드는데, 이 변수는 현재 비어 있고 새로운 String 인스턴스에 바인딩되어 있습니다. \n사용자 입력 받기\n프로그램의 첫 번째 줄에서 use std::io; 를 이용해서 표준 라이브러리의 입/출력 기능을 포함했음을 상기하십시오. 이제 io 모듈 에서 stdin 함수를 호출하여 사용자 입력을 처리할 수 있습니다.\n    io::stdin()\n        .read_line(&amp;mut guess)\n\n프로그램 시작 부분에서 use std::io; 를 이용해서 io 라이브러리를 가져오지 않았다면, 이 함수를 호출할때  std::io::stdin 이라고 적어야 합니다. stdin 함수는 std::io::Stdin 인스턴스를 반환하는데, 이것은 터미널에서 표준 입력에 대한 핸들을 나타내는 타입입니다.\n\n다음줄에 있는 .read_line(&amp;mut guess) 는 표준 입력 핸들의 read_line 메서드를 호출하여 사용자로부터 입력을 받습니다. 또한 사용자 입력을 저장할 문자열을 알려주기 위해 &amp;mut guess 를 read_line 함수의 인수(arg)로 전달하고 있습니다. read_line 의 전체 작업은 사용자가 표준 입력으로 입력하는 모든 것을 가져와 문자열(string)에 추가하는 것입니다(내용을 덮어쓰지 않고). 따라서 문자열(string)을 인수로 전달하십시오. 메서드가 문자열의 내용을 변경할 수 있도록 문자열 인수는 변경 가능해야 합니다.\n&amp; 는 이 인수가 참조자(reference)임을 나타냅니다. 즉, 해당 데이터를 메모리에 여러 번 복사할 필요 없이, 코드의 여러 부분에서 한 데이터에 액세스할 수 있는 방법을 제공합니다. 참조는 복잡한 기능이며, Rust의 주요 장점 중 하나는 참조를 사용하는 것이 얼마나 안전하고 쉬운가입니다. 이 프로그램을 마치기 위해 이러한 많은 세부 사항을 알 필요는 없습니다. 지금은 변수와 마찬가지로 참조도 기본적으로 변경할 수 없다(immutable)는 점만 알면 됩니다. 따라서 변경 가능하게 만들기 &amp;guess 가 아니라 &amp;mut guess 로 적어야 합니다. (4장에서 참고 문헌에 대해 더 자세히 설명합니다.)\nResult 타입으로 잠재적인 실패 처리\n우리는 여전히 이 코드 라인을 작업하고 있습니다. 이제 텍스트의 세 번째 줄에 대해 논의하고 있지만 여전히 하나의 논리적 코드 줄의 일부라는 점에 유의하십시오. 다음 부분은 이 메소드입니다.\n        .expect(\"Failed to read line\");\n\n이 코드를 다음과 같이 작성할 수도 있습니다.\nio::stdin().read_line(&amp;mut guess).expect(\"Failed to read line\");\n\n하지만, 하나의 긴 줄은 읽기 어려우므로 나누어서 쓰는 것이 좋습니다. .method_name() 구문을 사용하여 메서드를 호출할 때, 긴 줄을 구분하는 데 도움이 되도록 줄바꿈 및 기타 공백을 사용하는 것이 좋은 경우가 많습니다. 이제 이 줄이 무엇을 하는지 논의해 봅시다.\n앞에서 언급했듯이 read_line 은 사용자가 입력하는 문자열은 무엇이든 전달합니다. 동시에  Result 값도 반환합니다. Result  는 여러 상태(state) 중 하나가 될수 있는 타입인 enumeration 입니다. enum 이라고도 합니다. 가능한 각 상태를 변형(variant) 이라고 합니다.\n\n6장에서 열거형에 대해 자세히 다룰 것입니다. 이러한 Result 타입의 목적은 오류 처리 정보를 인코딩하는 것입니다.\nResult의 variant는 Ok 와 Err 입니다. Ok variant는 작업이 성공했음을 나타내며, Ok 내부는 성공적으로 생성된 결과값입니다.  Err variant는 작업이 실패했음을 의미하며,  Err 내부는 작업이 어떻게 또는 왜 실패했는지에 대한 정보를 포함합니다.\n다른 타입의 값과 마찬가지로, Result 타입의 값에는 메소드가 정의되어 있습니다. Result의 인스턴스에는 호출가능한  expect메서드 가 있습니다.\nResult의 인스턴스 값이 Err 이면, expect 는 프로그램을 중단하고 expect 에 인수로 전달한 메시지가 표시됩니다. read_line메서드가 Err를 반환하는 경우 기본 운영 체제에서 발생한 오류의 결과일 수 있습니다.\nResult 의 인스턴스 값이 Ok 이면, expect 는 Ok 가 보유하고 있는 반환값을 가져 와서 사용할 수 있도록 해당 값만 반환합니다. 이 경우 반환값은 사용자가 입력했던 바이트의 갯수입니다.\n\n만약 expect를 호출하지 않으면 프로그램이 컴파일되지만 경고가 표시됩니다.\n$ cargo build\n   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\nwarning: unused `Result` that must be used\n  --&gt; src/main.rs:10:5\n   |\n10 |     io::stdin().read_line(&amp;mut guess);\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: this `Result` may be an `Err` variant, which should be handled\n   = note: `#[warn(unused_must_use)]` on by default\n\nwarning: `guessing_game` (bin \"guessing_game\") generated 1 warning\n    Finished dev [unoptimized + debuginfo] target(s) in 0.59s\n\nRust는 read_line에서 반환된 Result 값을 사용하지 않았다고 경고합니다. 이 말은 프로그램이 발생 가능한 오류를 처리하지 않았다는 의미입니다.\n경고를 억제하는 올바른 방법은 실제로 오류 처리 코드를 작성하는 것이지만, 우리는 문제가 발생했을 때 이 프로그램을 중단하기를 원하므로 expect 를 사용했습니다. \n9장 에서 오류 복구에 대해 배웁니다.\nprintln! 변경자(placeholer)를 이용한 값 출력\n이제까지 작성한 코드에서 닫는 중괄호 말고도 살펴봐야 하는 코드가 하나 더 있습니다. 내용은 아래와 같습니다.\n    println!(\"You guessed: {guess}\");\n\n이 줄은 현재 사용자가 입력한 값을 저장한 문자열을 인쇄합니다. 중괄호 세트는 변경자입니다.  {} 를 값을 제자리에 고정하는 작은 게 집게발이라고생각하세요. \n변수 값을 출력할 때 변수 이름은 중괄호 안에 들어갈 수 있습니다. \n표현식 결과값을 출력할 때는 형식 문자열(format string)에 빈 중괄호를 넣습니다. 그 다음 각 빈 중괄호 변경자와 동일한 순서로, 표현식을 쉼표로 구분된 리스트 형식으로 입력합니다. 그러면 빈 중괄호 안에 순서대로 출력됩니다. 아래 코드는 println! 를 한 번 호출해서 변수와 식의 결과를 인쇄하는 방법을 보여줍니다. \nlet x = 5;\nlet y = 10;\n\nprintln!(\"x = {x} and y + 2 = {}\", y + 2);\n\n이 코드는 x = 5 and y + 2 = 12 를 출력합니다.\n첫 번째 부분을 테스트하기\n추측 게임의 첫 번째 부분을 테스트해 봅시다. cargo run을 사용하여 실행하십시오 .\n$ cargo run\n   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n    Finished dev [unoptimized + debuginfo] target(s) in 6.44s\n     Running `target/debug/guessing_game`\nGuess the number!\nPlease input your guess.\n6\nYou guessed: 6\n\n이제 게임의 첫 번째 부분이 완료되었습니다. 키보드에서 입력을 받은 다음, 그 값을 출력합니다.\n비밀 번호 생성\n다음으로 사용자가 추측할 비밀 번호를 생성해야 합니다. 시크릿 넘버는 매번 달라야 게임을 여러번 해도 재미있습니다. 게임이 너무 어렵지 않도록 1에서 100 사이의 임의의 숫자를 사용합니다. Rust는 아직 표준 라이브러리에 난수 기능을 포함하지 않습니다. 그러나 Rust 팀은 해당 기능이 포함된 rand 크레이트 를 제공합니다.\n크레이트를 사용하여 더 많은 기능 얻기\n크레이트는 Rust 소스 코드 파일의 모음입니다. 우리가 구축한 프로젝트는 실행 파일인 바이너리 크레이트 입니다. rand 크레이트는 라이브러리 크레이트로 , 다른 프로그램에서 사용하기 위한 코드가 들어 있으며 자체적으로는 실행할 수 없습니다.\n\nCargo의 외부 크레이트 활용은 Cargo가 정말 빛을 발하는 부분입니다. rand 를 사용하는 코드를 작성하려면, 먼저 크레이트를 종속항목(dependency)에 포함하도록 Cargo.toml파일을 수정해야 합니다. Cargo.toml파일을 열고 맨 아래, Cargo가 생성한 [dependencies]섹션 헤더 아래에 다음 행을 추가하십시오. 아래의 버전 번호를 사용하여 특정 rand 를 정확하게 지정해야 합니다. 그렇지 않으면 이 자습서의 코드 예제가 작동하지 않을 수 있습니다.\n파일 이름: Cargo.toml\n[dependencies]\nrand = \"0.8.5\"\n\nCargo.toml 파일에서 헤더 뒤에 오는 모든 것은 해당 섹션의 일부분이 되고, 다른 섹션이 시작될 때까지 계속됩니다.  [dependencies] 에서는 프로젝트가 의존하는 외부 크레이트와 그 크레이트의 버전을 Cargo 에 알려줍니다. 이 경우 rand크레이트를  0.8.5 시맨틱 버전 지정자로  지정합니다. \n\nCargo는 버전 번호 작성의 표준인 시맨틱 버전 관리 ( SemVer 라고도 함)를 이용합니다.  0.8.5지정자는 실제로는 ^0.8.5 의 줄임말입니다. 이는 0.8.5 이상 0.9.0 미만의 모든 버전을 의미합니다.\nCargo는 이러한 버전이 버전 0.8.5와 호환되는 공개 API를 갖는 것으로 간주하며, 이 사양은 이 장의 코드와 함께 여전히 컴파일되는 최신 패치 릴리스를 얻을 수 있도록 보장합니다. 버전 0.9.0 이상은 다음 예제에서 사용하는 것과 동일한 API를 갖는다고 보장되지 않습니다.\n\n[dependencies]만 추가하고, 코드를 변경하지 않은채 처음으로 프로젝트를 빌드해 보겠습니다.\n$ cargo build\n    Updating crates.io index\n  Downloaded rand_chacha v0.3.1\n  Downloaded ppv-lite86 v0.2.17\n  Downloaded rand_core v0.6.4\n  Downloaded rand v0.8.5\n  Downloaded getrandom v0.2.9\n  Downloaded cfg-if v1.0.0\n  Downloaded libc v0.2.144\n  Downloaded 7 crates (871.8 KB) in 1.28s\n   Compiling libc v0.2.144\n   Compiling cfg-if v1.0.0\n   Compiling ppv-lite86 v0.2.17\n   Compiling getrandom v0.2.9\n   Compiling rand_core v0.6.4\n   Compiling rand_chacha v0.3.1\n   Compiling rand v0.8.5\n   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n    Finished dev [unoptimized + debuginfo] target(s) in 2.53s\n\ncargo build목록 2-2: rand 크레이트를 종속 항목으로 추가한 후 실행 결과\n다른 버전 번호(그러나 SemVer 덕분에 모두 코드와 호환됨!)와 다른 라인(운영 체제에 따라 다름)이 표시될 수 있으며 라인의 순서가 다를 수 있습니다.\n외부 종속성(dependency)을 포함하면 Cargo는 레지스트리에서 종속성이 필요로 하는 모든 것의 최신 버전을 가져옵니다. 레지스트리는 Crates.io 의 데이터 사본입니다. Crates.io는 Rust 생태계의 사람들이 다른 사람들이 사용할 수 있도록 오픈 소스 Rust 프로젝트를 게시하는 곳입니다.\n레지스트리를 업데이트한 후 Cargo는 [dependencies]섹션을 확인하고 목록에 있는 아직 다운로드되지 않은 크레이트를 다운로드합니다. 이 경우, 의존성으로 rand만 나열했지만 Cargo는 rand가 의존하는 다른 크레이트도 가져왔습니다. 크레이트를 다운로드한 후, Rust는 크레이트를 컴파일한 다음, 사용 가능한 종속성과 함께 프로젝트를 컴파일합니다.\n\n변경한 내용 없이 cargo build 를 다시 실행하면 Finished행 외에는 출력이 표시되지 않습니다. Cargo는 의존성을 이미 다운로드하고 컴파일했으며 Cargo.toml 파일에서 아무것도 변경하지 않았다는 것을 알고 있습니다. 또한 Cargo는 당신이 코드를 아무 것도 변경하지 않았다는 것을 알고 있으므로 그것을 다시 컴파일하지도 않습니다. 할 일 없으면 그냥 종료됩니다.\n\nsrc/main.rs 파일을 열고 사소한 변경을 한 다음 저장하고 다시 빌드하면 두 줄의 출력만 표시됩니다.\n$ cargo build\n    Finished dev [unoptimized + debuginfo] target(s) in 0.01s\n\n이 줄은 Cargo가 src/main.rs 파일에 대한 작은 변경으로만 빌드를 업데이트한다는 것을 보여줍니다. 여러분의 종속성은 변경되지 않았으므로 Cargo는 이미 다운로드하고 컴파일한 것을 재사용할 수 있음을 알고 있습니다.\nCargo.lock 파일로 재현 가능한 빌드 보장\nCargo는 여러분 또는 다른 사람이 여러분의 코드를 빌드할 때마다 동일한 아티팩트를 다시 빌드할 수 있도록 보장하는 메커니즘을 가지고 있습니다. Cargo는 여러분이 수정하기 전까지 여러분이 지정한 종속성 버전만 사용합니다. \n예를 들어 다음 주에 rand크레이트의 버전 0.8.6이 나오고 해당 버전에 중요한 버그 수정이 포함되어 있지만 코드를 손상시키는 변경점이 포함되어 있다고 가정해 보겠습니다. 이를 처리하기 위해 Rust는 cargo build 를 처음 실행할 때 Cargo.lock 파일을 생성하며, guessing_game 디렉토리 에 이 파일이 있습니다.\nguessing_game\n  ├── Cargo.lock\n  ├── Cargo.toml\n  └── src\n   &nbsp;&nbsp; └── main.rs\n\n처음으로 프로젝트를 빌드할 때 Cargo는 기준에 맞는 종속성의 모든 버전을 파악한 다음 Cargo.lock 파일에 기록합니다. 나중에 프로젝트를 빌드할 때 Cargo는 Cargo.lock 파일이 존재하는지 확인하고 버전을 다시 파악하는 모든 작업을 수행하는 대신 여기에 지정된 버전을 사용할 것입니다. 이렇게 하면 재현 가능한 빌드가 자동으로 생성됩니다. 즉, Cargo.lock 파일 덕분에 명시적으로 업그레이드할 때까지 프로젝트가 0.8.5로 유지됩니다. Cargo.lock 파일은 재현 가능한 빌드에 중요하기 때문에 종종 프로젝트의 나머지 코드와 함께 소스 제어에 체크인됩니다.\n크레이트를 업데이트하여 새 버전 얻기\n크레이트를 업데이트하기위해 Cargo는  update 명령을 제공합니다. 이 명령어는 Cargo.lock파일을 무시 하고 Cargo.toml 의 사양에 맞는 모든 최신 버전을 파악합니다. 그다음 Cargo는 해당 버전을 Cargo.lock 파일에 기록합니다. \nrand = \"0.8.5\" 로 지정을 했고, 이것은 실제로는 ^0.8.5 의 줄임말이기 때문에 Cargo는 기본적으로 0.8.5보다 크고 0.9.0보다 작은 버전만 찾습니다. rand 크레이트가 두 개의 새 버전 0.8.6 및 0.9.0을 릴리스한 경우 cargo update 를 실행하면 다음과 같이 표시됩니다. (실제로 이렇게 실행되지는 않습니다.)\n$ cargo update\n    Updating crates.io index\n    Updating rand v0.8.5 -&gt; v0.8.6\n\nCargo는 0.9.0 릴리스를 무시합니다. 이제 Cargo.lock 파일에서 rand 크레이트의 현재 사용 중인 버전이 0.8.6 으로 변경된 것을 확인할 수 있습니다.\n\nrand 의 버전 0.9.0 또는 0.9.x 버전을 사용하려면 Cargo.toml 파일을 다음과 같이 업데이트해야 합니다. (실제로 이렇게 실행되지는 않습니다.)\n[dependencies]\nrand = \"0.9.0\"\n\n다음에 cargo build 를 실행하면 Cargo는 사용 가능한 크레이트의 레지스트리를 업데이트하고, 새로 지정된  rand 의 버전에 따라 요구 사항을 재평가합니다.\n\nCargo 와 그 생태계 에 대해 더 많은 이야기가 있습니다. 14장에서 다루겠지만 지금은 이것이 여러분이 알아야 할 전부입니다. Cargo는 라이브러리를 매우 쉽게 재사용할 수 있게 하므로 Rustaceans는 여러 패키지에서 조립되는 더 작은 프로젝트를 작성할 수 있습니다.\n난수 생성\n추측할 숫자를 생성하는 데 rand 크레이트 사용을 시작하겠습니다. 지금 할일은 Listing 2-3에 표시된 것처럼 src/main.rs 를 업데이트하는 것입니다.\n파일 이름: src/main.rs\nuse std::io;\nuse rand::Rng;  // 추가\n\nfn main() {\n    println!(\"Guess the number!\");\n\n    let secret_number = rand::thread_rng().gen_range(1..=100); //첫번째줄\n\n    println!(\"The secret number is: {secret_number}\");  //두번째줄\n\n    println!(\"Please input your guess.\");\n\n    let mut guess = String::new();\n\n    io::stdin()\n        .read_line(&amp;mut guess)\n        .expect(\"Failed to read line\");\n\n    println!(\"You guessed: {guess}\");\n}\n\n목록 2-3: 난수를 생성하는 코드 추가\n먼저 use rand::Rng; 줄을 추가합니다 . Rng 트레잇(trait)은 난수 생성기가 구현하는 메서드를 정의합니다. 트레잇은 해당 메서드를 사용할 수 있는 범위 내에 있어야 합니다. 10장에서는 트레잇에 대해 자세히 다룰 것입니다.\n다음으로 중간에 두 줄을 추가합니다. \n첫 번째 줄에서 우리가 사용할 특정 난수 생성기를 제공하는 함수 rand::thread_rng를 호출합니다. 이 생성기는 운영체제가 시드(seed)를 정하고 현재 스레드에서만 사용되는 특별한 정수생성기를 제공합니다. 그런 다음 난수 생성기에서  gen_range 메서드를 호출합니다. gen_range 메서드는 우리가 use rand::Rng;문으로 범위에 가져온 Rng 트레잇에 의해 정의됩니다. \n이 gen_range 메서드는 범위 식을 인수로 사용하고, 그 범위 안에서 난수를 생성합니다. 여기서 사용하는 범위 식은 start..=end 형식이며 하한과 상한을 포함하므로, 1에서 100 사이의 숫자를 요청하려면 1..=100 을 인수로 지정해야 합니다.\n\n참고: 어떤 트레이트를 사용할지, 크레이트에서 어떤 메서드와 함수를 호출할지 알 수 없으므로 각 크레이트에는 사용 지침이 포함된 문서가 있습니다. Cargo의 또 다른 멋진 기능은 cargo doc --open명령을 실행하면 로컬에서 모든 종속 항목이 제공하는 문서를 빌드하고 브라우저에서 열 수 있습니다.  예를 들어 rand크레이트의 다른 기능에 관심이 있는 경우 cargo doc --open 을 실행 하고 왼쪽의 사이드바에서 rand를 클릭합니다. \nSafari 에서 실행이 잘 안되는 경우, 주소를 복사해서 다른 브라우져를 사용해보세요.\n\n두 번째 줄은 비밀번호를 출력합니다. 이는 테스트할 수 있도록 프로그램을 개발하는 동안만 사용하고 최종 버전에서는 삭제할 것입니다. 프로그램이 시작되자마자 답을 출력한다면 그것은 게임이 아닙니다!\n프로그램을 몇 번 실행해 보십시오.\n$ cargo run\n   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n    Finished dev [unoptimized + debuginfo] target(s) in 2.53s\n     Running `target/debug/guessing_game`\nGuess the number!\nThe secret number is: 7\nPlease input your guess.\n4\nYou guessed: 4\n\n$ cargo run\n    Finished dev [unoptimized + debuginfo] target(s) in 0.02s\n     Running `target/debug/guessing_game`\nGuess the number!\nThe secret number is: 83\nPlease input your guess.\n5\nYou guessed: 5\n\n서로 다른 임의의 숫자를 가져와야 하며 모두 1에서 100 사이의 숫자여야 합니다. 잘하셨습니다!\n추측과 비밀 번호 비교\n이제 사용자 입력과 임의의 숫자가 있으므로 이를 비교할 수 있습니다. 그 단계는 목록 2-4에 나와 있습니다. 이 코드는 아직 정상적으로 컴파일되지 않습니다.\n파일 이름: src/main.rs\nuse rand::Rng;\nuse std::cmp::Ordering;\nuse std::io;\n\nfn main() {\n    // --snip--\n\n    println!(\"You guessed: {guess}\");\n\n    match guess.cmp(&amp;secret_number) {\n        Ordering::Less =&gt; println!(\"Too small!\"),\n        Ordering::Greater =&gt; println!(\"Too big!\"),\n        Ordering::Equal =&gt; println!(\"You win!\"),\n    }\n}\n\n목록 2-4: 두 숫자를 비교할 때 가능한 반환 값 처리\n\n먼저 use명령문을 사용하여,  std::cmp::Ordering 타입을 표준 라이브러리에서 범위로 가져옵니다. Ordering 타입은 또 다른 열거형이며 Less, Greater  및 Equal  변형(variant)가 있습니다. 이것들은 두 값을 비교할 때 가능한 세 가지 결과입니다.\n\n그런 다음 Ordering 타입을 사용하는 코드 다섯 줄을 맨 아래에 추가합니다.\n이 cmp 메서드는 두 값을 비교하고, 비교할 수 있는 모든 것들에 위해 호출할 수 있습니다. 이 메소드는 비교하고 싶은 것들의 참조자를 받습니다.  여기서는 guess 와 secret_number 를 비교하고 있습니다. 그런 다음 use 명령문을 사용하여 범위로 가져온 Ordering 열거형의 변형(variant)을 반환합니다. \n\n우리는 match 표현문을 사용하여, cmp 가 guess 와 secret_number 를 비교한 결과인 Ordering의 변형(variant)값에 따라 무엇을 할 것인지 결정할 수 있습니다. \nmatch 표현식은 arm 으로 이루어져 있습니다.  arm은 일치시킬 패턴 과 실행될 코드로 구성되는데, 이 코드는 match 에 주어진 값과 arm의 패턴이 일치하는 경우에 실행됩니다. Rust는 match 에 주어진 값을 받아서 각 arm의 패턴을 차례로 살펴봅니다. 패턴과 match 생성자는 강력한 Rust 기능입니다. 패턴과 구성은 코드에서 발생할 수 있는 다양한 상황을 표현할 수 있게 하고 모든 상황을 처리하도록 합니다. 이러한 기능은 각각 6장과 18장에서 자세히 다룰 것입니다.\n\n여기서 사용하는 match 표현식을 예로 들어 보겠습니다. 사용자가 50을 추측했고 이번에 무작위로 생성된 비밀 번호는 38이라고 가정합니다.\n코드가 50과 38을 비교하면 50이 38보다 크기 때문에 cmp메서드가 Ordering::Greater 를 반환합니다. match 표현식은 Ordering::Greater 값을 가져오고 각 arm의 패턴을 확인하기 시작합니다. 첫 번째 arm의 패턴은 Ordering::Less 이기 때문에, Ordering::Greater 값과 일치하지 않습니다. 그러면 해당 arm의 코드를 무시하고 다음 arm으로 이동합니다. 다음 팔의 패턴은 Ordering::Greater 이라서 일치합니다! 해당 arm의 관련 코드가 실행되어 화면에 Too big! 이 출력됩니다. match 표현식은 첫 번째 성공적인 일치  후에 끝나므로, 이 시나리오에서는 마지막 arm은 보지 않습니다.\n\n그런데 목록 2-4의 코드는 아직 컴파일되지 않습니다. 해봅시다:\n$ cargo build\n   Compiling libc v0.2.86\n   Compiling getrandom v0.2.2\n   Compiling cfg-if v1.0.0\n   Compiling ppv-lite86 v0.2.10\n   Compiling rand_core v0.6.2\n   Compiling rand_chacha v0.3.0\n   Compiling rand v0.8.5\n   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\nerror[E0308]: mismatched types\n  --&gt; src/main.rs:22:21\n    |\n22  |     match guess.cmp(&amp;secret_number) {\n    |                 --- ^^^^^^^^^^^^^^ expected `&amp;String`, found `&amp;{integer}`\n    |                 |\n    |                 arguments to this method are incorrect\n    |\n    = note: expected reference `&amp;String`\n               found reference `&amp;{integer}`\n\nnote: associated function defined here\n  --&gt; /rustc/d5a82bbd26e1ad8b7401f6a718a9c57c96905483/library/core/src/cmp.rs:783:8\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `guessing_game` due to previous error\n\n오류(error)의 핵심은 일치하지 않는 유형 이 있다는 것입니다. Rust는 강력한 정적 유형 시스템을 가지고 있습니다. 그러나 타입 유추도 있습니다. 우리가 let mut guess = String::new() 를 작성했을 때 Rust는 guess 가 String 타입이여야 한다고 타입을 유추했기때문에 우리가 타입을 직접 지정하라고 하지 않았습니다. 반면에 secret_number 는 숫자(number) 타입입니다. \n\n몇몇 숫자 타입들이 1과 100 사이의 값을 가질 수 있습니다. i32는 32비트 정수, u32는 32비트의 부호없는 정수, i64는 64비트의 정수이며 그 외에도 비슷합니다. d우리가 따로 타입을 지정하지 않으면서, 다른 정수형임을 추론할 수 있는 타입 정보를 제공하지 않는다면, 러스트는 기본적으로 숫자들을 i32 타입으로 생각합니다. 이 오류의 원인은 러스트가 문자열과 숫자 타입을 비교할 수 없기 때문입니다.\n\n궁극적으로 우리는 프로그램이 입력으로 받은 String을 숫자 타입으로 변환하여, 입력받은 숫자와 비밀번호를 비교하려고 합니다. main 함수 본문 에 다음 줄을 추가하면 됩니다. \n파일 이름: src/main.rs\n    // --snip--\n\n    let mut guess = String::new();\n\n    io::stdin()\n        .read_line(&amp;mut guess)\n        .expect(\"Failed to read line\");\n\n    let guess: u32 = guess.trim().parse().expect(\"Please type a number!\");\n\n    println!(\"You guessed: {guess}\");\n\n    match guess.cmp(&amp;secret_number) {\n        Ordering::Less =&gt; println!(\"Too small!\"),\n        Ordering::Greater =&gt; println!(\"Too big!\"),\n        Ordering::Equal =&gt; println!(\"You win!\"),\n    }\n\n\n추가된 줄은 다음과 같습니다.\nlet guess: u32 = guess.trim().parse().expect(\"Please type a number!\");\n\nguess 라는 변수를 만듭니다. 하지만 잠깐, 프로그램에 이미  guess 라는 변수가 있지 않습니까? 그렇지만, 유용한 Rust는  guess 의 이전 값을 새 값으로 가리게(shadow) 해줍니다. 섀도잉을 사용하면, 예를 들어 guess_str 와 guess 같은 두 개의 고유한 변수를 만들지 않고도, guess 라는 변수 이름을 재사용할 수 있습니다. 3장에서 이에 대해 자세히 다루겠지만, 지금은 이 기능이 값의 유형을 변환하기 위해 자주 사용된다는 점을 알아 두세요.\n\n우리는 새로만든 변수 guess를 guess.trim().parse() 표현식과 묶습니다. 표현식 안에 있는  guess 는 문자열로 입력 값을 입력받은 원래의  guess 변수를 나타냅니다. String 인스턴스의 trim 메서드는 처음과 끝 부분의 빈칸을 제거하는데, 이 작업은 문자열을 숫자 데이터와 비교하기 위해 반드시 필요합니다. 사용자는 추측하는 숫자를 입력하고 read_line 을 만족시키기 위해 Enter 키를 눌러야 합니다. 그러면 문자열에 개행 문자가 추가됩니다. \n예를 들어 사용자가 5를 입력 하고 Enter 키를 누르면 guess 는 5\\n 이 됩니다. 여기서 \\n 는 \"개행\"을 나타냅니다. (Windows에서 Enter 키를 누르면 캐리지 리턴과 줄 바꿈이 발생해서 \\r\\n 이 됩니다.) 이 trim메서드는 \\n 또는 \\r\\n 를 제거하여 5 만 남깁니다.\n\n문자열에 대한 parse 메소드 는 문자열을 다른 유형으로 변환합니다. 여기서는 문자열을 숫자로 변환하는 데 사용합니다. let guess: u32 를 사용하여 원하는 정확한 숫자 유형을 Rust에 알려야 합니다. guess 뒤의 콜론( :)은 우리가 Rust에게 변수의 타입을 명시한다고 알려줍니다. Rust에는 몇 가지 내장 숫자 유형이 있습니다. 여기서 보이는 u32 는 부호 없는 32비트 정수입니다. 이 타입은 작은 양수에 대한 좋은 기본 선택입니다. 다른 숫자 유형에 대해서는  3장에서 배우게 됩니다.\n또한, 이 예제 프로그램에서 u32 타입을 지정하고, secret_number 와 비교했다는 것은,  Rust가 추론할 것 secret_number 가 u32 로 유추해야 함을 의미합니다. 이제 동일한 유형의 두 값을 비교합니다!\n이 parse메서드는 논리적으로 숫자로 변환할 수 있는 글자에만 작동하므로 쉽게 오류가 발생할 수 있습니다. 예를 들어 문자열에 A👍% 가 포함된 경우 이를 숫자로 변환할 방법이 없습니다. 실패할 수 있기 때문에, parse 메서드는 read_line 메서드 결과와 마찬가지로 Result 타입을 반환합니다 (이전의 \"Result 로 잠재적 오류 처리 \" 에서 설명 ). \n우리는 이 Result 를 expect 메소드를 다시 사용하여 동일한 방식으로 처리합니다. 만약 parse 가 문자열에서 숫자를 생성할 수 없다는 이유로 Err 라는 Result 변형자(variant)를 반환한다면,   expect 는 게임을 중단하고 우리가 제공하는 메시지를 인쇄합니다. 만약 parse 가 문자열을 숫자로 성공적으로 변환할 수 있으면, Ok 라는 Result 변형자(variant)가 반환되고 expect 는 Ok 값 에서 원하는 숫자를 반환합니다 .\n이제 프로그램을 실행해 봅시다:\n$ cargo run\n   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.43s\n     Running `target/debug/guessing_game`\nGuess the number!\nThe secret number is: 58\nPlease input your guess.\n  76\nYou guessed: 76\nToo big!\n\nNice! 추측값 입력 전에 공백을 추가해도 프로그램은 여전히 사용자가 76을 추측했음을 알아냈습니다. 프로그램을 몇 번 실행하여 다른 종류의 입력으로 다른 동작을 확인합니다. 너무 낮은 숫자, 정확한 숫자, 높은 숫자를 입력해보세요. \n이제 게임이 잘 작동하지만 우리는 한번엔 한 가지만 추측할 수 있습니다. 루프를 추가하여 변경해 봅시다!\n루핑(Looping)으로 여러번의 추측 허용\nloop 키워드 는 무한 루프를 생성합니다. 사용자가 숫자를 추측할 수 있는 더 많은 기회를 제공하기 위해 루프를 추가합니다.\n파일 이름: src/main.rs\n    // --snip--\n\n    println!(\"The secret number is: {secret_number}\");\n\n    loop {\n        println!(\"Please input your guess.\");\n\n        // --snip--\n\n        match guess.cmp(&amp;secret_number) {\n            Ordering::Less =&gt; println!(\"Too small!\"),\n            Ordering::Greater =&gt; println!(\"Too big!\"),\n            Ordering::Equal =&gt; println!(\"You win!\"),\n        }\n    }\n}\n\n보시다시피 추측값 입력 프롬프트의 모든것을 루프로 이동했습니다. 루프 내부의 행을 각각 4칸 더 들여쓰기하고 프로그램을 다시 실행하십시오. 이제 프로그램은 영원히 또 다른 추측값 입력을 요구할 것이며, 이것은 새로운 문제를 만듭니다.  사용자가 종료할 수 없는 것 입니다!\n사용자는 언제나 키보드 단축키 ctrl-c를 사용하여 프로그램을 중단할 수 있습니다. 그러나 \"추측과 비밀 번호의 비교\"에서 parse 를 언급한 것처럼, 이 만족할 줄 모르는 괴물을 피할 수 있는 또 다른 방법이 있습니다. 사용자가 숫자가 아닌 답을 입력하면 프로그램이 중단(crash)됩니다. 다음과 같이 사용자가 종료할 수 있도록 이점을 활용할 수 있습니다.\n$ cargo run\n   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n    Finished dev [unoptimized + debuginfo] target(s) in 1.50s\n     Running `target/debug/guessing_game`\nGuess the number!\nThe secret number is: 59\nPlease input your guess.\n45\nYou guessed: 45\nToo small!\nPlease input your guess.\n60\nYou guessed: 60\nToo big!\nPlease input your guess.\n59\nYou guessed: 59\nYou win!\nPlease input your guess.\nquit\nthread 'main' panicked at 'Please type a number!: ParseIntError { kind: InvalidDigit }', src/main.rs:28:47\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\nquit 를 입력하면 게임이 종료되지만, 알다시피 숫자가 아닌 다른 입력도 마찬가지입니다. 이것은 차선책입니다. 우리는 정확한 숫자가 추측되면 게임도 멈추기를 원합니다.\n정답 이후 종료하기\nbreak 문장을 추가하여, 사용자가 이기면 게임이 종료되도록 프로그래밍해 보겠습니다 .\n파일 이름: src/main.rs\n        // --snip--\n\n        match guess.cmp(&amp;secret_number) {\n            Ordering::Less =&gt; println!(\"Too small!\"),\n            Ordering::Greater =&gt; println!(\"Too big!\"),\n            Ordering::Equal =&gt; {\n                println!(\"You win!\");\n                break;\n            }\n        }\n    }\n}\n\nYou win! 다음에 break 줄을 추가하면 사용자가 비밀 번호를 올바르게 추측할 때 프로그램이 루프를 종료합니다. 루프 종료는 프로그램 종료를 의미하기도 합니다. 루프는 main 의 마지막 부분이기 때문입니다 .\n잘못된 입력 처리\n게임의 동작을 더욱 개선하기 위해, 사용자가 숫자가 아닌 것을 입력할 때 프로그램이 충돌(crash)하는 대신, 사용자가 계속 추측할 수 있도록 게임이 숫자가 아닌 것을 무시하도록 합시다. Listing 2-5와 같이guess 가  String 에서 u32 로 변환되는 행을 변경하면 됩니다.\n파일 이름: src/main.rs\n        // --snip--\n\n        io::stdin()\n            .read_line(&amp;mut guess)\n            .expect(\"Failed to read line\");\n\n        let guess: u32 = match guess.trim().parse() {\n            Ok(num) =&gt; num,\n            Err(_) =&gt; continue,\n        };\n\n        println!(\"You guessed: {guess}\");\n\n        // --snip--\n\n목록 2-5: 프로그램을 충돌시키는 대신, 숫자가 아닌 추측을 무시하고 다른 추측을 요청\nexpect 호출에서 match 표현식으로 전환하여, 오류 발생시 충돌하는 대신 오류를  처리하는 방식으로 바꾸었습니다. parse 는 Result 타입을 반환 하고, Result 는 Ok 와 Err 변형자를 포함하는 열거형임을 기억하세요. 여기서 우리는 match 표현식을 사용하고 있는데, cmp 메소드의 Ordering 결과를 처리했을 때와 같습니다. \n만약 parse 가 문자열을 숫자로 성공적으로 변환할 수 있으면 결과 숫자를 포함하는 Ok  값을 반환합니다. Ok 값은 첫 번째 arm의 패턴과 일치하며,  match 표현식은 num 값을 반환합니다. num 값은 parse 가 생성하고 Ok 값 안에 넣어준 값 입니다. 그 숫자는 결국 우리가 만들고 있는 새 guess 변수에 위치합니다.\n만약 parse 가 문자열을 숫자로 변환 할 수 없으면, 오류에 대한 자세한 정보가 포함된 Err 값을 반환합니다.  Err 값은 첫 번째 arm에 있는 Ok(num) 패턴과 일치하지 않지만 두 번째 arm의 Err(_) 패턴과 일치합니다. 밑줄은 포괄적인 값입니다. 이 예시에서 밑줄을 사용함으로서, 우리는 Err 내부에 어떤 정보가 있든 관계없이 일치시키고 싶다고 말합니다. 따라서 프로그램은 두 번째 arm의 코드인 continue 를 실행하여 프로그램이 loop 의 다음 반복으로 이동하여 다른 추측을 요청하도록 지시합니다. 이렇게 프로그램은 parse 가 만날 수 있는 모든 오류를 효과적으로 무시합니다! \n\n이제 프로그램의 모든 것이 예상대로 작동해야 합니다. 해봅시다:\n$ cargo run\n   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)\n    Finished dev [unoptimized + debuginfo] target(s) in 4.45s\n     Running `target/debug/guessing_game`\nGuess the number!\nThe secret number is: 61\nPlease input your guess.\n10\nYou guessed: 10\nToo small!\nPlease input your guess.\n99\nYou guessed: 99\nToo big!\nPlease input your guess.\nfoo\nPlease input your guess.\n61\nYou guessed: 61\nYou win!\n\n훌륭합니다! 작은 마지막 조정 하나만 하고 추측 게임을 끝낼 것입니다. 프로그램이 여전히 비밀 번호를 미리 출력하고 있음을 기억하십시오. 테스트에는 잘 작동했지만 게임을 망쳤습니다. 비밀 번호를 출력하는 println! 를 삭제합시다. 목록 2-6은 최종 코드를 보여줍니다.\n\n파일 이름: src/main.rs\nuse rand::Rng;\nuse std::cmp::Ordering;\nuse std::io;\n\nfn main() {\n    println!(\"Guess the number!\");\n\n    let secret_number = rand::thread_rng().gen_range(1..=100);\n\n    loop {\n        println!(\"Please input your guess.\");\n\n        let mut guess = String::new();\n\n        io::stdin()\n            .read_line(&amp;mut guess)\n            .expect(\"Failed to read line\");\n\n        let guess: u32 = match guess.trim().parse() {\n            Ok(num) =&gt; num,\n            Err(_) =&gt; continue,\n        };\n\n        println!(\"You guessed: {guess}\");\n\n        match guess.cmp(&amp;secret_number) {\n            Ordering::Less =&gt; println!(\"Too small!\"),\n            Ordering::Greater =&gt; println!(\"Too big!\"),\n            Ordering::Equal =&gt; {\n                println!(\"You win!\");\n                break;\n            }\n        }\n    }\n}\n\nListing 2-6: 완전한 추측 게임 코드\n\n이제 추측 게임을 성공적으로 구축했습니다. 축하해요!\n요약\n이 프로젝트는 let, match, 함수, 외부 크레이트 사용 등 많은 새로운 Rust 개념을 소개하는 실습 방식이었습니다. 다음 장에서는 이러한 개념에 대해 자세히 알아봅니다. 3장은 변수, 데이터 유형, 함수와 같이 대부분의 프로그래밍 언어가 가지고 있는 개념을 다루고 Rust에서 사용하는 방법을 보여줍니다. 4장은 Rust를 다른 언어와 다르게 만드는 기능인 소유권(ownership)을 탐구합니다. 5장에서는 구조체(structs) 및 메서드 구문(method syntax)에 대해 설명하고 6장에서는 열거형(enums)의 작동 방식을 설명합니다.\n","id":"http://127.0.0.1:1111/rust/chapter2/","title":"Programming a Guessing Game"},"http://127.0.0.1:1111/rust/chapter22/":{"body":"4_Understanding Ownership\n4_1_What is Ownership?\n4_2_References and Borrowing\n4_3_The Slice Type\n\n5_Using Structs to Structure Related Data\n5_1_Defining and Instantiating Structs\n5_2_An Example Program Using Structs\n5_3_Method Syntax\n\n6_Enums and Pattern Matching\n6_1_Defining an Enum\n6_2_The match Control Flow Construct\n6_3_Concise Control Flow with if let\n\n7_Managing Growing Projects with Packages, Crates, and Modules\n7_1_Packages and Crates\n7_2_Defining Modules to Control Scope and Privacy\n7_3_Paths for Referring to an Item in the Module Tree\n7_4_Bringing Paths Into Scope with the use Keyword\n7_5_Separating Modules into Different Files\n\n8_Common Collections\n8_1_Storing Lists of Values with Vectors\n8_2_Storing UTF-8 Encoded Text with Strings\n8_3_Storing Keys with Associated Values in Hash Maps\n9_Error Handling\n9_1_Unrecoverable Errors with panic!\n9_2_Recoverable Errors with Result\n9_3_To panic! or Not to panic!\n\n10_Generic Types, Traits, and Lifetimes\n10_1_Generic Data Types\n10_2_Traits: Defining Shared Behavior\n10_3_Validating References with Lifetimes\n\n11_Writing Automated Tests\n11_1_How to Write Tests\n11_2_Controlling How Tests Are Run\n11_3_Test Organization\n\n12_An I/O Project: Building a Command Line Program\n12_1_Accepting Command Line Arguments\n12_2_Reading a File\n12_3_Refactoring to Improve Modularity and Error Handling\n12_4_Developing the Library’s Functionality with Test Driven Development\n12_5_Working with Environment Variables\n12_6_Writing Error Messages to Standard Error Instead of Standard Output\n\n13_Functional Language Features: Iterators and Closures\n13_1_Closures: Anonymous Functions that Capture Their Environment\n13_2_Processing a Series of Items with Iterators\n13_3_Improving Our I/O Project\n13_4_Comparing Performance: Loops vs_Iterators\n\n14_More about Cargo and Crates_io\n14_1_Customizing Builds with Release Profiles\n14_2_Publishing a Crate to Crates_io\n14_3_Cargo Workspaces\n14_4_Installing Binaries from Crates_io with cargo install\n14_5_Extending Cargo with Custom Commands\n\n15_Smart Pointers\n15_1_Using Box to Point to Data on the Heap\n15_2_Treating Smart Pointers Like Regular References with the Deref Trait\n15_3_Running Code on Cleanup with the Drop Trait\n15_4_Rc, the Reference Counted Smart Pointer\n15_5_RefCell and the Interior Mutability Pattern\n15_6_Reference Cycles Can Leak Memory\n\n16_Fearless Concurrency\n16_1_Using Threads to Run Code Simultaneously\n16_2_Using Message Passing to Transfer Data Between Threads\n16_3_Shared-State Concurrency\n16_4_Extensible Concurrency with the Sync and Send Traits\n\n17_Object Oriented Programming Features of Rust\n17_1_Characteristics of Object-Oriented Languages\n17_2_Using Trait Objects That Allow for Values of Different Types\n17_3_Implementing an Object-Oriented Design Pattern\n\n18_Patterns and Matching\n18_1_All the Places Patterns Can Be Used\n18_2_Refutability: Whether a Pattern Might Fail to Match\n18_3_Pattern Syntax\n\n19_Advanced Features\n19_1_Unsafe Rust\n19_2_Advanced Traits\n19_3_Advanced Types\n19_4_Advanced Functions and Closures\n19_5_Macros\n\n20_Final Project: Building a Multithreaded Web Server\n20_1_Building a Single-Threaded Web Server\n20_2_Turning Our Single-Threaded Server into a Multithreaded Server\n20_3_Graceful Shutdown and Cleanup\n\n21_Appendix\n21_1_A - Keywords\n21_2_B - Operators and Symbols\n21_3_C - Derivable Traits\n21_4_D - Useful Development Tools\n21_5_E - Editions\n21_6_F - Translations of the Book\n21_7_G - How Rust is Made and “Nightly Rust”\n","id":"http://127.0.0.1:1111/rust/chapter22/","title":"*** 목차들 ***"},"http://127.0.0.1:1111/rust/chapter3/":{"body":"요약\n\n\n변수, 기본 타입, 함수, 주석 및 흐름 제어를 알아보자.\n\n\n키워드로 선점된 이름은 변수나 함수의 이름으로 사용할 수 없다.\n\n\n일반적인 프로그래밍 개념\n이 장에서는 거의 모든 프로그래밍 언어에 나타나는 개념을 다루고, Rust에서 어떻게 작동하는지 알려드립니다. 프로그래밍 언어들은 그 핵심에 많은 공통점이 있고, 이 장에 제시된 개념들은 Rust에만 있는 것이 아닙니다. 이 개념들을 Rust의 맥락에서 논의하고, 사용하는 방법을 설명할 것입니다.\n특히 변수, 기본 타입, 함수, 주석 및 흐름 제어에 대해 배웁니다. 이러한 기초는 모든 Rust 프로그램에서 사용되며, 이를 초반에 배우면 매우 도움이 됩니다. \n\n키워드(keywords)\nRust 언어에는 다른 언어와 마찬가지로 해당 언어에서만 사용하도록 예약된 키워드(keywords)들이 있습니다. 이 키워드 이름을 변수나 함수의 이름으로 사용할 수 없음을 명심하십시오. 대부분의 키워드는 특별한 의미를 가지고 있으며 Rust 프로그램에서 다양한 작업을 수행하기 위해 키워드를 사용할 것입니다. 몇몇은 관련된 현재 기능이 없지만 미래에 Rust에 추가될 수 있는 기능을 위해 선점되었습니다. 부록 A 에서 키워드 목록을 찾을 수 있습니다 .\n\n","id":"http://127.0.0.1:1111/rust/chapter3/","title":"Common Programming Concepts"},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"body":"요약\n\n\nlet으로 선언한 변수는 그 값을 변경할 수 없다.\n\n\n변경 가능한 변수를 선언하려면 let mut x = 5; 와 같이 mut 를 사용한다.\n\n\n\nconst 로 선언한 상수는 항상 변경할 수 없다.\n\n\n상수 이름은 모두 대문자와 _를 사용한다.\n\n\n\nlet을 사용하여 섀도잉하면 같은 변수명에 다른 값을 넣을수 있다.\n\n\n섀도잉을 할 때 값의 type이 바뀔수 있다. mut는 값의 type 이 바뀔수 없다. \n\n\n변수와 가변성\n변수로 값 저장 섹션 에서 언급했듯이 기본적으로 변수는 변경할 수 없습니다. 이것은 Rust가 제공하는 안전하고 쉬운 동시성을 활용하는 방식으로 코드를 작성하도록 Rust가 제공하는 많은 넛지(강제하지 않고 부드럽게 좋은 선택을 유도하는 방법) 중 하나입니다. 그러나 여전히 변수를 변경 가능하게 만드는 옵션이 있습니다. Rust가 불변성을 선호하도록 권장하는 방법과 이유, 그리고 왜 때때로 선택 해제를 원할 수 있는지 살펴보겠습니다.\n\n변수가 변경 불가능한 경우, 값이 이름에 바인딩되면 해당 값을 변경할 수 없습니다. 이를 설명하기 위해 cargo new variables를 사용하여 프로젝트 디렉토리 에 variables 라는 새 프로젝트를 생성합니다 .\n그런 다음 새 변수 디렉토리에서 src/main.rs를 열고 코드를 아래의 코드로 바꿉니다. 이 코드는 아직 컴파일되지 않습니다.\n파일 이름: src/main.rs\nfn main() {\n    let x = 5;\n    println!(`The value of x is: {x}`);\n    x = 6;\n    println!(`The value of x is: {x}`);\n}\n\n\ncargo run을 사용하여 프로그램을 저장하고 실행합니다. 다음 출력과 같이 불변성 오류에 관한 오류 메시지를 수신해야 합니다.\n$ cargo run\n   Compiling variables v0.1.0 (file:///projects/variables)\nerror[E0384]: cannot assign twice to immutable variable `x`\n --&gt; src/main.rs:4:5\n  |\n2 |     let x = 5;\n  |         -\n  |         |\n  |         first assignment to `x`\n  |         help: consider making this binding mutable: `mut x`\n3 |     println!(`The value of x is: {x}`);\n4 |     x = 6;\n  |     ^^^^^ cannot assign twice to immutable variable\n\nFor more information about this error, try `rustc --explain E0384`.\nerror: could not compile `variables` due to previous error\n\n이 예제는 컴파일러가 프로그램에서 오류를 찾는 데 어떻게 도움이 되는지 보여줍니다. 컴파일러 오류는 실망스러울 수 있지만, 실제로는 프로그램이 원하는 작업을 아직 안전하게 수행하지 못한다는 의미일 뿐입니다. 오류는 당신이 좋은 프로그래머가 아니라는 것을 의미하지 않습니다 ! 숙련된 Rustacean도 여전히 컴파일러 오류가 발생합니다.\n변경할 수 없는 x 변수에 두 번째 값을 할당하려고 했기 때문에 변경할 수 없는 변수 x에 두 번 할당할 수 없습니다.라는 오류 메시지가 표시되었습니다.\n바로 이 상황이 버그로 이어질 수 있기 때문에, 변경할 수 없는 것으로 지정된 값을 변경하려고 시도할 때 컴파일 타임 오류가 발생하는 것이 중요합니다. 코드의 한 부분이 값이 절대 변경되지 않는다는 가정하에 작동하고, 코드의 다른 부분이 해당 값을 변경하는 경우 코드의 첫 번째 부분이 설계된 대로 작동하지 않을 수 있습니다. 이러한 종류의 버그의 원인은 나중에 추적하기 어려울 수 있습니다. 특히 두 번째 코드 조각이 가끔 값을 변경하는 경우에는 더욱 그렇습니다 . Rust 컴파일러는 값이 변경되지 않는다고 선언하면 실제로 변경되지 않으므로 직접 추적할 필요가 없습니다. 따라서 코드를 추론하기가 더 쉽습니다.\n\n그러나 가변성은 매우 유용할 수 있으며 코드를 작성하기 더 편리하게 만들 수 있습니다. 변수는 기본적으로 변경할 수 없지만 2장 에서 했던 것처럼 변수 이름 앞에 mut를 추가하여 변수를 변경할 수 있습니다. 또한 mut를 추가하면 코드의 다른 부분이 이 변수의 값을 변경할 것임을 나타내어 코드의 향후 독자에게 의도를 전달합니다.\n예를 들어 src/main.rs를 다음과 같이 변경해 보겠습니다.\n파일 이름: src/main.rs\nfn main() {\n    let mut x = 5;\n    println!(`The value of x is: {x}`);\n    x = 6;\n    println!(`The value of x is: {x}`);\n}\n\n지금 프로그램을 실행하면 다음과 같은 결과가 나타납니다.\n$ cargo run\n   Compiling variables v0.1.0 (file:///projects/variables)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.30s\n     Running `target/debug/variables`\nThe value of x is: 5\nThe value of x is: 6\n\nmut이 사용될 때 x에 바인딩된 값을 5에서 6으로 변경할 수 있습니다. 궁극적으로 가변성을 사용할지 여부는 여러분에게 달려 있으며, 여러분이 특정 상황에서 가장 명확하다고 생각하는 것에 따라 결정됩니다. \n상수\n변경할 수 없는 변수와 마찬가지로 상수 역시 값의 변경이 허용되지 않습니다. 하지만 상수와 변수 사이에는 몇 가지 차이점이 있습니다.\n첫째, 상수에는  mut를 사용할 수 없습니다. 상수는 어떤 경우에도 변경할 수 없습니다. let 키워드 대신 const 키워드를 사용하여 상수를 선언하고 값의 유형에 주석을 반드시  달아야 합니다. 다음 섹션인 데이터 유형 에서 유형 및 유형 주석을 다룰 것이므로 지금은 세부 사항에 대해 걱정하지 마십시오. 항상 유형에 주석을 달아야 한다는 점만 알아두세요.\n상수는 전역 범위를 포함한 모든 범위에서 선언할 수 있으므로, 코드의 많은 부분에서 알아야 하는 값에 유용합니다.\n마지막 차이점은 상수는 상수식으로만 표현될 수 있습니다. 런타임이 되어야만 계산되는 값을 결과가 될 수는 없습니다. (예를 들면 함수 호출의 결과값)\n\n다음은 상수 선언의 예입니다.\nconst THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;\n\n상수의 이름은 THREE_HOURS_IN_SECONDS이고, 값은 60(1분의 초 수)에 60(1시간의 분 수)에 3(세고 싶은 시간 수)을 곱한 결과로 설정됩니다. \n상수에 이름을 붙이는 Rust의 규칙은 단어 사이에 밑줄과 함께 모두 대문자를 사용하는 것입니다. 컴파일러는 컴파일 시간에 제한된 작업 집합을 평가할 수 있으므로 이 상수를 값 10,800으로 설정하는 대신 이해하고 확인하기 쉬운 방식으로 이 값을 작성하도록 선택할 수 있습니다. 상수를 선언할 때 사용할 수 있는 작업에 대한 자세한 내용은 Rust 참조의 상수 평가 섹션을 참조하세요.\n\n상수는 선언된 범위 내에서 프로그램이 실행되는 전체 시간 동안 유효합니다. 이런 특징때문에 어플리케이션 도메인에 있는 값이 프로그램의 여러 부분에서 사용되어야하는 경우, 그 값을 선언할 때 상수로 하는게 유용합니다.  예를 들면 게임의 모든 플레이어가 획득할 수 있는 최대 점수, 또는 빛의 속도와 같은 값입니다. \n\n프로그램 전체에서 사용되는 하드코딩된 값의 이름을 상수로 지정하면 향후 코드 관리자에게 해당 값의 의미를 전달하는 데 유용합니다. 또한 나중에 하드코딩된 값을 업데이트해야 하는 경우, 변경해야 하는 코드의 위치를 한군데로 지정할 수 있어 도움이 됩니다. \n섀도잉\n2장 의 추측 게임 튜토리얼에서 본 것처럼 이전 변수와 동일한 이름으로 새 변수를 선언할 수 있습니다. Rustaceans는 첫 번째 변수가 두 번째 변수에 의해 가려진다고 말하는데 , 이는 변수 이름을 사용할 때 컴파일러가 두 번째 변수를 보게 된다는 의미입니다. 실제로 두 번째 변수는 첫 번째 변수를 가리고, 변수 자체가 (다시) 가려지거나 범위가 끝날 때까지 변수 이름을 자신이 사용합니다. 동일한 변수의 이름을 사용하고 다음과 같이 let 키워드를 반복 사용하여 변수를 숨길 수 있습니다.\n파일 이름: src/main.rs\nfn main() {\n    let x = 5;\n\n    let x = x + 1;\n\n    {\n        let x = x * 2;\n        println!(`The value of x in the inner scope is: {x}`);\n    }\n\n    println!(`The value of x is: {x}`);\n}\n\n이 프로그램은 먼저 x를 5 라는 값에 바인딩합니다. 그런 다음 let x =를 반복하여 원래 값에 1을 추가하여 x의 값이 6이 되도록 새 변수 x를 만듭니다. 그런 다음 중괄호로 만든 내부 범위 내에서 세 번째 let 문도 x를 가리고 새 변수를 만들어 이전 값에 2를 곱하여 x 값 12를 제공합니다. 해당 범위가 끝나면 내부 그림자가 종료되고 x는 6으로 돌아갑니다. 이 프로그램을 실행하면 다음과 같이 출력됩니다.\n$ cargo run\n   Compiling variables v0.1.0 (file:///projects/variables)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.31s\n     Running `target/debug/variables`\nThe value of x in the inner scope is: 12\nThe value of x is: 6\n\n\n섀도잉은 변수를 mut를 사용해서 변경가능하게 하는 것과 다릅니다. 왜냐하면 섀도잉을 할 때 let 키워드를 사용하지 않고 이 변수를 재할당하려고 하면 컴파일 타임 오류가 발생하기 때문입니다.  let을 사용하여 값에 대해 몇 가지 변환을 수행할 수 있지만, 이러한 변환이 완료된 후에는 변수를 변경할 수 없습니다.\nmut와 섀도잉의 또 다른 차이점은, let 키워드로 섀도잉을 하면 새 변수를 생성하기 때문에 동일한 이름을 재사용하면서 값의 유형을 변경할 수 있다는 것입니다. 예를 들어 프로그램에서 사용자에게 공백 문자를 입력하여 일부 텍스트 사이에 원하는 공백 수를 표시하도록 요청한 다음 해당 입력을 숫자로 저장하려고 한다고 가정해 보겠습니다.\n    let spaces = `   `;\n    let spaces = spaces.len();\n\n첫 번째 spaces 변수는 문자열 유형이고, 두 번째 spaces 변수는 숫자 유형입니다. 따라서 섀도잉은 spaces_str 및 spaces_num과 같은 다른 이름을 생각해내지 않아도 됩니다. 대신 더 간단한 space라는 이름을 재사용할 수 있습니다. \n\n그러나 여기에 표시된 것처럼 mut를 사용하려고 하면 컴파일 타임 오류가 발생합니다.\n    let mut spaces = `   `;\n    spaces = spaces.len();\n\n오류는 변수의 유형을 변경할 수 없다고 말합니다.\n$ cargo run\n   Compiling variables v0.1.0 (file:///projects/variables)\nerror[E0308]: mismatched types\n --&gt; src/main.rs:3:14\n  |\n2 |     let mut spaces = `   `;\n  |                      ----- expected due to this value\n3 |     spaces = spaces.len();\n  |              ^^^^^^^^^^^^ expected `&amp;str`, found `usize`\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `variables` due to previous error\n\n이제 변수가 작동하는 방식을 살펴보았으므로 변수가 가질 수 있는 더 많은 데이터 유형을 살펴보겠습니다.\n","id":"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/","title":"Variables and Mutability"},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"body":"요약\n\n\nRust는 data의 type을 추론한다.\n\n\n여러 type이 가능한 경우 type을 명시해야한다.\n\n\n\n스칼라 타입: 단일 값\n\n\n\n\n정수타입: 부호있는 타입, 부호없이 양수만 있는 타입이 있다\n\n\n소수점 타입: 모두 부호가 있다.\n\n\nboolean 타입: true, false\n\n\n문자 타입: 한글자(영어, 한글, 이모지 등), 작은따옴표 사용\n\n\n\n\n\n복합 타입: 값의 그룹\n\n\n\n(튜플 타입): 길이 고정, 값의 타입은 다양\n[배열 타입]: 길이 고정, 값의 타입은 하나\n\n\n\n데이터 타입\nRust의 모든 값은 특정 데이터 타입을 가지고 있으며, 이는 Rust에게 이 데이터가 어떤 종류인지 알려주고, 이 데이터로 어떻게 작업해야하는지 알려줍니다. 우리는 2가지 종류의 하위 데이터 타입을 살펴볼건데, 바로 스칼라와 컴파운드입니다.\nRust는 정적으로 타입이 지정된 언어 라는 점을 명심하세요. 즉, 컴파일 할때 모든 변수의 타입을 알아야 합니다. 일반적으로 컴파일러는 값과 우리의 사용방식을 통해서 값의 타입을 추론할 수 있습니다. 그런데 여러가지 타입이 가능한 경우에는 아래와 같이 주석을 달아야합니다. 2장의 “Comparing the Guess to the Secret Number” 절에서 이런 경우가 있었습니다.  parse를 사용하여 String을 숫자 타입으로 변환한 경우에는 여러가지 타입이 가능한데, 이 경우 다음과 같이 타입 주석을 추가해야 합니다. :\nlet guess: u32 = `42`.parse().expect(`Not a number!`);\n\n앞의 코드에 표시된 : u32 타입 주석을 추가하지 않으면 Rust는 다음과 같은 오류를 표시할 것입니다. 이는 컴파일러가 어떤 타입을 사용하려는지 알기 위해 더 많은 정보가 필요함을 의미합니다.\n$ cargo build\n   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)\nerror[E0282]: type annotations needed\n --&gt; src/main.rs:2:9\n  |\n2 |     let guess = `42`.parse().expect(`Not a number!`);\n  |         ^^^^^\n  |\nhelp: consider giving `guess` an explicit type\n  |\n2 |     let guess: _ = `42`.parse().expect(`Not a number!`);\n  |              +++\n\nFor more information about this error, try `rustc --explain E0282`.\nerror: could not compile `no_type_annotations` due to previous error\n\n다른 데이터 타입에 대한 다른 타입 주석이 표시됩니다.\n스칼라 타입\n스칼라 타입은 단일 값을 나타냅니다. Rust에는 네 가지 기본 스칼라 타입이 있습니다: 정수(integers), 부동 소수점 숫자(floating-point numbers), 부울(Booleans) 및 문자(characters)입니다. 다른 프로그래밍 언어에서 본적이 있을겁니다. Rust에서 어떻게 작동하는지 살펴보겠습니다.\n정수 타입(Integer Type)\n정수는 분수 구성요소가 없는 숫자입니다. 2장에서 하나의 정수 타입인 u32 타입을 사용했습니다. 이 타입선언은 값이 32비트 공간을 차지하는 부호 없는 정수여야 함을 나타냅니다 (부호 있는 정수 타입는 u 대신 i로 시작). 표 3-1은 Rust에 내장된 정수 타입들을 보여줍니다. 이러한 타입을 사용하여 정수 값의 타입을 선언할 수 있습니다.\n표 3-1: Rust의 정수 타입들\n길이부호가 있는부호가 없는\n8비트i8u8\n16비트i16u16\n32비트i32u32\n64비트i64u64\n128비트i128u128\narchisizeusize\n\n각 타입은 부호가 있거나 없을수 있으며, 명시된 크기를 가집니다. 부호 있음  및 부호 없음은 숫자가 음수가 될 수 있는지 여부를 나타냅니다. 즉, 숫자에 부호가 있어야 하는 경우(signed)가 있고, 양수만 가능하므로 부호가 없어도 되는 경우(unsigned)가 있습니다. 이것은 종이에 숫자를 쓰는 것과 같습니다. 부호가 중요한 경우, 숫자에 더하기 기호 또는 빼기 기호가 함께 표시됩니다. 그러나 숫자가 양수라고 가정하는 것이 안전할 때는 부호 없이 표시됩니다. 부호 있는 숫자는 2의 보수 표현을 사용하여 저장됩니다.\n각 부호 있는 타입은 -(2^(n-1)) 에서 2(n-1) - 1까지의 숫자를 저장할 수 있습니다. 여기서 n 은 타입이 사용하는 비트 수입니다. 따라서 i8은 -(2^7)에서 2^7 - 1까지의 숫자를 저장할 수 있으며, 이는 -128에서 127까지입니다. 부호 없는 타입은 0에서 2^n - 1까지의 숫자를 저장할 수 있으므로 u8은 0에서 2^8 - 1 즉, 0에서 255 사이입니다.\n추가로 isize 및 usize 타입은 프로그램이 실행되는 컴퓨터의 아키텍처에 따라 달라지며 표에서 arch로 표시됩니다. 64비트 아키텍처를 사용하는 경우 64비트, 32비트 32비트 아키텍처를 사용하는 경우 32비트입니다.\n\n표 3-2에 표시된 형식으로 정수 리터럴을 작성할 수 있습니다. 여러 숫자 타입이 될 수 있는 숫자 리터럴은 타입을 지정하기 위해 57u8과 같은 타입 접미사를 허용합니다. 숫자 리터럴은 읽기 쉽게하기 위해 시각적 구분 기호로 _를 사용할 수 있습니다 (예: 1000 과  1_000은 동일).\n표 3-2: Rust의 정수 리터럴\n숫자 리터럴예\nDecimal98_222\nHex0xff\nOctal0o77\nBinary0b1111_0000\nByte(u8만 해당)b'A'\n\n\n그렇다면 어떤 정수 타입을 사용해야 할까요? 확신이 없다면 Rust의 기본값을 사용하세요. 정수 타입의 기본값은 i32입니다. isize 또는 usize 는 일부 컬렉션을 인덱싱할 때입니다.\n\n정수 오버플로\n0에서 255 사이의 값을 보유할 수 있는 u8 타입의 변수가 있다고 가정해 보겠습니다. 변수를 해당 범위 밖의 값(예: 256)으로 변경하려고 하면 정수 오버플로가 발생하여 두 가지 중 하나가 발생할 수 있습니다 . \n디버그 모드에서 컴파일할 때, Rust는 정수 오버플로에 대한 검사를 포함해서 이러한 동작이 발생하면 런타임에 프로그램 패닉을 유발합니다 . Rust는 프로그램이 오류와 함께 종료될 때 패닉이라는 용어를 사용합니다. 9장의 패닉!이 있는 복구할 수 없는 오류` 섹션 에서 패닉에 대해 더 깊이 논의할 것입니다.\n--release 플래그를 사용하여 릴리스 모드에서 컴파일할 때, Rust는 패닉을 유발하는 정수 오버플로 검사를 포함 하지 않습니다. 대신, 오버플로가 발생하면 Rust는 2의 보수 래핑을 수행합니다. 간단히 말해서, 타입이 보유할 수 있는 최대값보다 큰 값은, 타입이 보유할 수 있는 최소값으로 랩 어라운드됩니다. u8의 경우 값 256은 0이 되고 값 257은 1이 됩니다. 프로그램은 패닉을 일으키지 않지만 변수는 예상했던 것과 다른 값을 갖게 됩니다. 정수 오버플로의 래핑 동작에 의존하는 것은 오류로 간주됩니다.\n오버플로 가능성을 명시적으로 처리하기 위해 기본 숫자 타입에 대해 표준 라이브러리에서 제공하는 다음 메서드 계열을 사용할 수 있습니다.\n\nwrapping_add와 같은 wrapping_* 메서드를 사용하여 모든 모드에서 래핑합니다.\nchecked_* 메서드에 오버플로가 있는 경우 None 값을 반환합니다.\noverflowing_* 메서드로 오버플로가 발생했는지 여부를 나타내는 부울 값과 값을 반환합니다.\nsaturating_* 방법을 사용하여 값의 최소값 또는 최대값에서 포화시킵니다.\n\n\n부동 소수점 타입(Floating-Point Types)\nRust에는 소수점을 가진 숫자인 부동 소수점 숫자를 위한 두 가지 기본 타입이 있습니다. Rust의 부동 소수점 타입은 각각 크기가 32비트와 64비트인 f32와 f64입니다. 기본 타입은 f64입니다. 최신 CPU에서는 f32와 거의 같은 속도이지만, 더 정밀할 수 있기 때문입니다. 모든 부동 소수점 타입은 부호가 있습니다.\n다음은 실제 부동 소수점 숫자를 보여주는 예입니다.\n파일 이름: src/main.rs\nfn main() {\n    let x = 2.0; // f64\n\n    let y: f32 = 3.0; // f32\n}\n\n부동 소수점 숫자는 IEEE-754 표준에 따라 표현됩니다. f32 타입은 1배수의 정밀도인 부동소수점이고, f64는 2배수의 정밀도인 부동소수점입니다.\n수치 연산\nRust는 더하기, 빼기, 곱하기, 나누기 및 나머지와 같은 모든 숫자 타입에 대해 예상할 수 있는 기본 수학 연산을 지원합니다. 정수 나눗셈은 0을 향해 가장 가까운 정수로 자릅니다 (소수점을 버린다). 다음 코드는 let 문에서 각 숫자 연산을 사용하는 방법을 보여줍니다.\n파일 이름: src/main.rs\nfn main() {\n    // addition\n    let sum = 5 + 10;\n\n    // subtraction\n    let difference = 95.5 - 4.3;\n    \n    // multiplication\n    let product = 4 * 30;\n    \n    // division\n    let quotient = 56.7 / 32.2;\n    let truncated = -5 / 3; // Results in -1\n    \n    // remainder\n    let remainder = 43 % 5;\n}\n\n이러한 문의 각 식은 수학 연산자를 사용하고 단일 값으로 계산된 다음 변수에 바인딩됩니다. 부록 B 에는 Rust가 제공하는 모든 연산자 목록이 포함되어 있습니다.\nBoolean 타입\n대부분의 다른 프로그래밍 언어와 마찬가지로 Rust의 boolean 타입에는 true와 false의 두 가지 값이 있습니다. boolean은 크기가 1바이트입니다. Rust의 boolean 타입은 bool을 사용하여 지정됩니다. 예를 들어:\n파일 이름: src/main.rs\nfn main() {\n    let t = true;\n\n    let f: bool = false; // with explicit type annotation\n}\n\nboolean 값을 사용하는 주요 방법은 if 식과 같은 조건을 사용하는 것입니다. 제어 흐름 섹션 에서 Rust에서 if 표현식이 작동하는 방식을 다룰 것입니다.\n문자 타입\nRust의 char 타입은 언어의 가장 근본적인 알파벳 타입입니다. 다음은 char 값을 선언하는 몇 가지 예입니다.\n파일 이름: src/main.rs\nfn main() {\n    let c = 'z';\n    let z: char = 'ℤ'; // with explicit type annotation\n    let heart_eyed_cat = '😻';\n}\n\n큰따옴표를 사용하는 문자열 리터럴과 달리, 작은따옴표로 char 리터럴을 지정합니다. Rust의 char 타입은 크기가 4바이트이고 유니코드 스칼라 값을 나타냅니다. 즉, ASCII보다 훨씬 더 많은 것을 나타낼 수 있습니다. 악센트 문자; 중국어, 일본어 및 한국어 문자; 이모티콘; 너비가 0인 공백은 모두 Rust에서 유효한 char 값입니다. 유니코드 스칼라 값의 범위는 U+0000에서 U+D7FF까지, U+E000에서 U+10FFFF까지입니다. 그러나 문자는 실제로 유니코드의 개념이 아니므로, 인간으로서 문자가 무엇인지에 생각하는 직감과 Rust의 char가 무엇인지는 일치하지 않을 수 있습니다. 8장의 \"UTF-8 인코딩된 텍스트를 문자열과 함께 저장\" 에서 이 주제에 대해 자세히 설명합니다.\n\n복합 타입\n복합 타입은 여러 값을 하나의 타입으로 그룹화할 수 있습니다. Rust에는 튜플과 배열이라는 두 가지 복합 타입이 있습니다.\n튜플 타입\n튜플은 다양한 타입의 여러 값을 하나의 복합 타입으로 그룹화하는 일반적인 방법입니다. 튜플의 길이는 고정되어 있습니다. 일단 선언되면 크기가 늘어나거나 줄어들 수 없습니다.\n괄호 안에 쉼표로 구분된 값 목록을 작성하여 튜플을 만듭니다. 튜플의 각 위치에는 타입이 있으며 튜플의 서로 다른 값의 타입이 동일할 필요는 없습니다. 이 예에서는 선택적 타입 주석을 추가했습니다.\n파일 이름: src/main.rs\nfn main() {\n    let tup: (i32, f64, u8) = (500, 6.4, 1);\n}\n\n\n변수 tup은 튜플이 단일 복합 요소로 간주되기 때문에 전체 튜플에 바인딩됩니다. 튜플에서 개별 값을 가져오려면 다음과 같이 패턴 일치를 사용하여 튜플 값을 분해할 수 있습니다.\n파일 이름: src/main.rs\nfn main() {\n    let tup = (500, 6.4, 1);\n\n    let (x, y, z) = tup;\n    \n    println!(`The value of y is: {y}`);\n}\n\n이 프로그램은 먼저 튜플을 만들고 변수 tup에 바인딩합니다. 그런 다음 let이 포함된 패턴을 사용하여 tup을 가져오고 x, y 및 z의 세 가지 개별 변수로 변환합니다. 단일 튜플을 세 부분으로 나누기 때문에 이를 구조 분해(destructuring) 라고 합니다. 마지막으로 프로그램은 y의 값인 6.4를 출력합니다.\n\n튜플 요소에 직접 액세스할 수도 있습니다. 방법은 마침표(.) 다음에 액세스하려는 값의 인덱스를 사용합니다. 예를 들어:\n파일 이름: src/main.rs\nfn main() {\n    let x: (i32, f64, u8) = (500, 6.4, 1);\n\n    let five_hundred = x.0;\n    \n    let six_point_four = x.1;\n    \n    let one = x.2;\n}\n\n이 프로그램은 튜플 x를 만든 다음 해당 인덱스를 사용하여 튜플의 각 요소에 액세스합니다. 대부분의 프로그래밍 언어와 마찬가지로 튜플의 첫 번째 인덱스는 0입니다.\n\n값이 없는 튜플은 특별한 이름인 unit 을 가집니다. 이 값과 해당 타입은 모두 ()로 작성되며 빈 값 또는 빈 반환 타입을 나타냅니다. 식은 다른 값을 반환하지 않는 경우 암시적으로 단위 값을 반환합니다.\n배열 타입\n여러 값의 모음을 갖는 또 다른 방법은 배열 을 사용하는 것입니다. 튜플과 달리 배열의 모든 요소는 동일한 타입을 가져야 합니다. 다른 언어의 배열과 달리 Rust의 배열은 길이가 고정되어 있습니다.\n대괄호 안에 쉼표로 구분된 목록으로 배열의 값을 씁니다.\n파일 이름: src/main.rs\nfn main() {\n    let a = [1, 2, 3, 4, 5];\n}\n\n\n배열은 데이터를 힙이 아닌 스택에 할당하려는 경우(스택과 힙에 대해서는 4장 에서 자세히 설명함 ) 또는 항상 고정된 수의 요소를 갖도록 하려는 경우에 유용합니다. 그러나 배열은 벡터 타입만큼 유연하지 않습니다. 벡터는 크기를 늘리거나 줄일 수 있는 표준 라이브러리에서 제공하는 유사한 컬렉션 타입입니다. 배열을 사용할지 벡터를 사용할지 확실하지 않은 경우 벡터를 사용해야 할 가능성이 있습니다. 8장 에서는 벡터에 대해 자세히 설명합니다.\n\n배열은 요소의 수를 변경할 필요가 없다는 것을 알고 있을 때 더 유용합니다. 예를 들어 프로그램에서 월 이름을 사용하는 경우 벡터가 항상 12개의 요소를 포함한다는 것을 알기 때문에 벡터 대신 배열을 사용할 것입니다.\nlet months = [`January`, `February`, `March`, `April`, `May`, `June`, `July`,\n              `August`, `September`, `October`, `November`, `December`];\n\n\n다음과 같이 각 요소의 타입, 세미콜론, 배열의 요소 수와 함께 대괄호를 사용하여 배열의 타입을 작성합니다.\nlet a: [i32; 5] = [1, 2, 3, 4, 5];\n\n여기서 i32는 각 요소의 타입입니다. 세미콜론 뒤의 숫자 5는 배열에 5개의 요소가 포함되어 있음을 나타냅니다.\n\n다음과 같이 초기 값, 세미콜론, 대괄호 안에 배열 길이를 지정하여 각 요소에 대해 동일한 값을 포함하도록 배열을 초기화할 수도 있습니다.\nlet a = [3; 5];\n\na라는 이름의 배열에는 처음에 값 3으로 모두 설정되는 5 요소가 포함됩니다. 이것은 let a = [3, 3, 3, 3, 3];이라고 쓰는 것과 같습니다. 그러나 더 간결한 방법입니다.\n배열 요소에 액세스\n배열은 스택에 단일 메모리 뭉치로 할당됩니다.  다음과 같이 인덱싱을 사용하여 배열의 요소에 액세스할 수 있습니다.\n파일 이름: src/main.rs\nfn main() {\n    let a = [1, 2, 3, 4, 5];\n\n    let first = a[0];\n    let second = a[1];\n}\n\n이 예에서 first라는 변수는 배열의 인덱스 [0]에 있는 값이기 때문에 값 1을 가져옵니다. second라는 변수는 배열의 인덱스 [1]에서 값 2를 가져옵니다.\n잘못된 배열 요소 액세스\n배열의 끝을 지난 배열의 요소에 액세스하려고 하면 어떤 일이 발생하는지 살펴보겠습니다. 사용자로부터 배열 인덱스를 얻기 위해 2장의 추측 게임과 유사한 이 코드를 실행한다고 가정해 보겠습니다.\n파일 이름: src/main.rs\nuse std::io;\n\nfn main() {\n    let a = [1, 2, 3, 4, 5];\n\n    println!(`Please enter an array index.`);\n    \n    let mut index = String::new();\n    \n    io::stdin()\n        .read_line(&amp;mut index)\n        .expect(`Failed to read line`);\n    \n    let index: usize = index\n        .trim()\n        .parse()\n        .expect(`Index entered was not a number`);\n    \n    let element = a[index];\n    \n    println!(`The value of the element at index {index} is: {element}`);\n}\n\n이 코드는 성공적으로 컴파일됩니다. cargo run을 사용하여 이 코드를 실행하고 0, 1, 2, 3 또는 4를 입력하면 프로그램이 배열의 해당 인덱스에서 해당 값을 인쇄합니다. \n\n대신 10과 같이 배열의 끝을 지나 숫자를 입력하면 다음과 같은 출력이 표시됩니다.\nthread 'main' panicked at 'index out of bounds: the len is 5 but the index is 10', src/main.rs:19:19\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\n프로그램은 인덱싱 작업에서 유효하지 않은 값을 사용하는 시점에서 런타임 오류가 발생했습니다. 프로그램이 오류 메시지와 함께 종료되었고 마지막 println!은 실행하지 못했습니다. 인덱싱을 사용하여 요소에 액세스하려고 하면 Rust는 지정한 인덱스가 배열 길이보다 작은지 확인합니다. 인덱스가 길이보다 크거나 같으면 Rust는 패닉 상태가 됩니다. 이 검사는 런타임 시 수행되어야 합니다. 왜냐하면 컴파일러는 사용자가 나중에 코드를 실행할 때 어떤 값을 입력할지 알 수 없기 때문입니다.\n이것은 실행 중인 Rust의 메모리 안전 원칙의 예입니다. 많은 저수준 언어에서는 이러한 종류의 검사가 수행되지 않으며 잘못된 인덱스를 제공하면 잘못된 메모리에 액세스할 수 있습니다. Rust는 메모리 액세스를 허용하고 계속하는 대신, 즉시 종료하여 이러한 종류의 오류로부터 사용자를 보호합니다. 9장에서는 Rust의 오류 처리에 대해 자세히 설명합니다. 패닉이 발생하지 않고, 유효하지 않은 메모리 액세스를 허용하지 않는, 읽기 쉽고 안전한 코드를 작성하는 방법에 대해 설명합니다.\n","id":"http://127.0.0.1:1111/rust/chapter3/2-data-types/","title":"Data Types"},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"body":"요약\n\n\n함수이름은 소문자와 _를 사용하는 스네이크 케이스\n\n\n\n함수\n함수는 Rust 코드에서 널리 사용됩니다. 당신은 이미 언어에서 가장 중요한 함수 중 하나인 main 함수를 보았습니다. 이것은 많은 프로그램의 진입점입니다. 또한 새 함수를 선언할 수 있는 fn 키워드도 보았습니다.\nRust 코드는 스네이크 케이스를 함수 및 변수 이름에 대한 일반적인 스타일로 사용합니다. 여기서 모든 문자는 소문자이고 밑줄은 별도의 단어입니다. 다음 프로그램은 예제 함수 정의를 포함하고 있습니다.\n파일 이름: src/main.rs\nfn main() {\n    println!(`Hello, world!`);\n\n    another_function();\n}\n\nfn another_function() {\n    println!(`Another function.`);\n}\n\nRust에서 fn 뒤에 함수 이름과 괄호 세트를 입력하여 함수를 정의합니다. 중괄호는 컴파일러에게 함수 본문이 시작되고 끝나는 위치를 알려줍니다.\n\n함수를 호출하는 방법은 함수 이름 뒤에 괄호를 입력하는 것 입니다. another_function은 프로그램에 정의되어 있기 때문에 main 함수 내부에서 호출할 수 있습니다. 소스 코드에서 main 함수 다음에 another_function을 정의했습니다. main 함수 전에도 정의할 수 있었습니다. Rust는 당신이 당신의 함수를 정의하는 곳을 신경쓰지 않습니다. 어디든 호출자가 볼 수 있는 범위에 정의되어 있으면 됩니다. \n\n함수를 더 자세히 살펴보기 위해 functions 라는 이름의 새 binary 프로젝트를 시작하겠습니다. src/main.rs 에 another_function 예제를 배치 하고 실행합니다. 다음 출력이 표시되어야 합니다.\n$ cargo run\n   Compiling functions v0.1.0 (file:///projects/functions)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.28s\n     Running `target/debug/functions`\nHello, world!\nAnother function.\n\n행은 main 함수에 나타나는 순서대로 실행됩니다. 먼저 Hello, world! 메시지가 인쇄된 다음 another_function이 호출되고 해당 메시지가 출력됩니다.\n매개변수(Parameters)\n함수는 매개변수를 갖는 형식으로 정의할 수 있습니다. 함수에 매개변수가 있는 경우 해당 매개변수에 대한 구체적인 값을 함수에 제공할 수 있습니다. 기술적으로는 구체적인 값을 전달인자(arguments) 라고 부르지만, 일상적인 대화에서 사람들은 함수 정의의 변수나 함수를 호출할 때 전달되는 구체적인 값에 대해 매개변수 와 전달인자라는 단어를 같은 의미로 사용하는 경향이 있습니다.\n이 버전의 another_function에서는 매개변수를 추가합니다.\n파일 이름: src/main.rs\nfn main() {\n    another_function(5);\n}\n\nfn another_function(x: i32) {\n    println!(`The value of x is: {x}`);\n}\n\n이 프로그램을 실행해 보십시오. 다음 출력을 얻어야 합니다.\n$ cargo run\n   Compiling functions v0.1.0 (file:///projects/functions)\n    Finished dev [unoptimized + debuginfo] target(s) in 1.21s\n     Running `target/debug/functions`\nThe value of x is: 5\n\nanother_function 선언에는 x라는 매개변수가 하나 있습니다. x의 유형은 i32로 지정됩니다. another_function에 5를 전달하면 println! 매크로는 x를 포함하는 중괄호 쌍이 형식 문자열에 있던 곳에 5를 넣습니다.\n함수 선언에서 각 매개변수의 타입을 선언 해야 합니다. 이는 Rust의 설계에서 신중한 결정입니다. 함수 정의에 타입 주석을 요구한다는 것은, 컴파일러가 타입을 파악하기 위해 코드의 다른 곳에서 우리가 사용하는 것을 통해 타입을 추측할 필요가 없어진다는 것을 의미합니다. 또한 컴파일러는 함수가 기대하는 타입을 알고 있는 경우 더 유용한 오류 메시지를 제공할 수 있습니다.\n\n여러 매개변수를 정의할 때 다음과 같이 매개변수 사이를 쉼표로 구분합니다.\n파일 이름: src/main.rs\nfn main() {\n    print_labeled_measurement(5, `h`);\n}\n\nfn print_labeled_measurement(value: i32, unit_label: char) {\n    println!(`The measurement is: {value}{unit_label}`);\n}\n\n이 예에서는 두 개의 매개변수를 사용하여 print_labeled_measurement라는 함수를 생성합니다. 첫 번째 매개변수의 이름은 value이고 i32입니다. 두 번째는 unit_label이라는 이름과 char 유형입니다. 그런 다음 이 함수는 value와 unit_label을 모두 포함하는 텍스트를 인쇄합니다.\n이 코드를 실행해 봅시다. 현재 함수 프로젝트의 src/main.rs 파일 에 있는 프로그램을 이전 예제로 바꾸고 cargo run을 사용하여 실행합니다.\n$ cargo run\n   Compiling functions v0.1.0 (file:///projects/functions)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.31s\n     Running `target/debug/functions`\nThe measurement is: 5h\n\nvalue의 값이 5이고 unit_label의 값이 h인 함수를 호출했기 때문에 프로그램 출력에는 해당 값이 포함됩니다.\n구문과 표현식(Statements and Expressions)\n함수 본문은 표현식으로 끝나는 명령문들로 구성됩니다. 지금까지 우리가 다룬 함수에는 종료 표현식이 포함되지 않았지만, 명령문의 일부로 표현식을 보았습니다. Rust는 표현식 기반 언어이기 때문에 이해해야 할 중요한 차이점입니다. 다른 언어에는 동일한 구분이 없으므로 명령문과 표현식이 무엇이며, 그 차이가 함수 본문에 어떤 영향을 미치는지 살펴보겠습니다.\n문은 어떤 작업을 수행하고 값을 반환하지 않는 지침입니다.\n식은 결과 값으로 평가됩니다. 몇 가지 예를 살펴보겠습니다.\n우리는 실제로 이미 문장과 표현식을 사용했습니다. 변수를 만들고 let 키워드를 사용하여 값을 할당하는 것이 명령문입니다. 목록 3-1에서 let y = 6; 진술입니다.\n파일 이름: src/main.rs\nfn main() {\n    let y = 6;\n}\n\n목록 3-1: 하나의 명령문을 포함하는 main 함수 선언\n함수 정의도 명령문입니다. 앞의 전체 예는 그 자체로 명령문입니다.\n문은 값을 반환하지 않습니다. 따라서 다음 코드와 같이 let 문을 다른 변수에 할당할 수 없습니다. 오류가 발생합니다.\n파일 이름: src/main.rs\nfn main() {\n    let x = (let y = 6);\n}\n\n이 프로그램을 실행하면 다음과 같은 오류가 발생합니다.\n$ cargo run\n   Compiling functions v0.1.0 (file:///projects/functions)\nerror: expected expression, found `let` statement\n --&gt; src/main.rs:2:14\n  |\n2 |     let x = (let y = 6);\n  |              ^^^\n\nerror: expected expression, found statement (`let`)\n --&gt; src/main.rs:2:14\n  |\n2 |     let x = (let y = 6);\n  |              ^^^^^^^^^\n  |\n  = note: variable declaration using `let` is a statement\n\nerror[E0658]: `let` expressions in this position are unstable\n --&gt; src/main.rs:2:14\n  |\n2 |     let x = (let y = 6);\n  |              ^^^^^^^^^\n  |\n  = note: see issue #53667 &lt;https://github.com/rust-lang/rust/issues/53667&gt; for more information\n\nwarning: unnecessary parentheses around assigned value\n --&gt; src/main.rs:2:13\n  |\n2 |     let x = (let y = 6);\n  |             ^         ^\n  |\n  = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n  |\n2 -     let x = (let y = 6);\n2 +     let x = let y = 6;\n  |\n\nFor more information about this error, try `rustc --explain E0658`.\nwarning: `functions` (bin `functions`) generated 1 warning\nerror: could not compile `functions` due to 3 previous errors; 1 warning emitted\n\nlet y = 6 문은 값을 반환하지 않으므로 x가 바인딩할 항목이 없습니다. 이는 할당이 할당 값을 반환하는 C 및 Ruby와 같은 다른 언어에서 발생하는 것과 다릅니다. 이러한 언어에서는 x = y = 6이라고 쓰고 x와 y 모두 값이 6이 되도록 할 수 있습니다. Rust에서는 그렇지 않습니다.\n식은 값으로 평가되며 Rust에서 작성하게 될 나머지 코드의 대부분을 구성합니다. 값 11로 평가되는 표현식인 5 + 6과 같은 수학 연산을 고려하십시오. 표현식은 명령문의 일부가 될 수 있습니다. Listing 3-1에서 let y = 6; 명령문의 6은 값 6으로 평가되는 표현식입니다. 함수 호출은 표현식입니다. 매크로 호출은 표현식입니다. 중괄호로 만든 새 범위 블록은 식입니다. 예를 들면 다음과 같습니다.\n파일 이름: src/main.rs\nfn main() {\n    let y = {\n        let x = 3;\n        x + 1\n    };\n\n    println!(`The value of y is: {y}`);\n}\n이 표현:\n\n{\n    let x = 3;\n    x + 1\n}\n\n이 경우 4로 평가되는 블록입니다. 해당 값은 let 문의 일부로 y에 바인딩됩니다. x + 1 행에는 지금까지 본 대부분의 행과 달리 끝에 세미콜론이 없습니다. 표현식에는 종료 세미콜론이 포함되지 않습니다. 표현식 끝에 세미콜론을 추가하면 문장으로 바뀌고 값을 반환하지 않습니다. 다음에 함수 반환 값과 식을 탐색할 때 이 점을 염두에 두십시오.\n반환 값이 있는 함수\n함수는 이를 호출하는 코드에 값을 반환할 수 있습니다. 반환 값의 이름은 지정하지 않지만 화살표(-&gt;) 다음에 반환 값의 유형을 선언해야 합니다. Rust에서 함수의 반환 값은 함수 본문 블록의 최종 표현식 값과 동의어입니다. return 키워드를 사용하고 값을 지정하여 함수에서 일찍 반환할 수 있지만 대부분의 함수는 암시적으로 마지막 식을 반환합니다. 다음은 값을 반환하는 함수의 예입니다.\n파일 이름: src/main.rs\nfn five() -&gt; i32 {\n    5\n}\n\nfn main() {\n    let x = five();\n\n    println!(`The value of x is: {x}`);\n}\n\nfive 함수에는 함수 호출, 매크로 또는 let 문이 없으며 숫자 5만 있습니다. 이것은 Rust에서 완벽하게 유효한 함수입니다. 함수의 반환 유형도 -&gt; i32로 지정됩니다. 이 코드를 실행해 보십시오. 출력은 다음과 같아야 합니다.\n$ cargo run\n   Compiling functions v0.1.0 (file:///projects/functions)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.30s\n     Running `target/debug/functions`\nThe value of x is: 5\n\nfive의 5는 함수의 반환 값이며 반환 유형이 i32인 이유입니다. 이에 대해 자세히 살펴보겠습니다. 두 가지 중요한 부분이 있습니다. 첫째, let x = five(); 줄입니다. 변수를 초기화하기 위해 함수의 반환 값을 사용하고 있음을 보여줍니다. 함수 five는 5를 반환하므로 해당 행은 다음과 동일합니다.\nlet x = 5;\n둘째, five 함수는 매개변수가 없고 반환 값의 유형을 정의하지만 함수의 본문은 우리가 반환하려는 값을 가진 표현식이기 때문에 세미콜론이 없는 외로운 5입니다.\n다른 예를 살펴보겠습니다.\n파일 이름: src/main.rs\nfn main() {\n    let x = plus_one(5);\n\n    println!(`The value of x is: {x}`);\n}\n\nfn plus_one(x: i32) -&gt; i32 {\n    x + 1\n}\n\n이 코드를 실행하면 The value of x is: 6이 인쇄됩니다. 그러나 x + 1을 포함하는 줄 끝에 세미콜론을 배치하여 표현식에서 명령문으로 변경하면 오류가 발생합니다.\n파일 이름: src/main.rs\nfn main() {\n    let x = plus_one(5);\n\n    println!(`The value of x is: {x}`);\n}\n\nfn plus_one(x: i32) -&gt; i32 {\n    x + 1;\n}\n이 코드를 컴파일하면 다음과 같은 오류가 발생합니다.\n\n$ cargo run\n   Compiling functions v0.1.0 (file:///projects/functions)\nerror[E0308]: mismatched types\n --&gt; src/main.rs:7:24\n  |\n7 | fn plus_one(x: i32) -&gt; i32 {\n  |    --------            ^^^ expected `i32`, found `()`\n  |    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n8 |     x + 1;\n  |          - help: remove this semicolon to return this value\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `functions` due to previous error\n\n기본 오류 메시지인 일치하지 않는 유형은 이 코드의 핵심 문제를 나타냅니다. plus_one 함수의 정의는 i32를 반환한다고 하지만 명령문은 단위 유형인 ()로 표현되는 값으로 평가되지 않습니다. 따라서 아무 것도 반환되지 않으며 이는 함수 정의와 모순되고 오류가 발생합니다. 이 출력에서 ​​Rust는 이 문제를 수정하는 데 도움이 될 수 있는 메시지를 제공합니다. 오류를 수정하는 세미콜론을 제거할 것을 제안합니다.\n","id":"http://127.0.0.1:1111/rust/chapter3/3-functions/","title":"Functions"},"http://127.0.0.1:1111/rust/chapter3/4-comments/":{"body":"요약\n\n\n\n\n코멘트\n모든 프로그래머는 코드를 이해하기 쉽게 만들기 위해 노력하지만 때로는 추가 설명이 필요합니다. 이 경우 프로그래머는 소스 코드에 컴파일러가 무시할 주석을 남기지만 소스 코드를 읽는 사람들에게는 유용할 수 있습니다.\n다음은 간단한 설명입니다.\n// hello, world\n\nRust에서 관용적인 주석 스타일은 두 개의 슬래시로 주석을 시작하고 주석은 줄 끝까지 계속됩니다. 한 줄을 넘는 주석의 경우 다음과 같이 각 줄에 //를 포함해야 합니다.\n// So we’re doing something complicated here, long enough that we need\n// multiple lines of comments to do it! Whew! Hopefully, this comment will\n// explain what’s going on.\n\n주석은 코드를 포함하는 줄 끝에 배치할 수도 있습니다.\n파일 이름: src/main.rs\nfn main() {\n    let lucky_number = 7; // I’m feeling lucky today\n}\n\n그러나 주석을 추가하는 코드 위에 별도의 줄에 주석이 있는 이 형식으로 사용되는 것을 더 자주 볼 수 있습니다.\n파일 이름: src/main.rs\nfn main() {\n    // I’m feeling lucky today\n    let lucky_number = 7;\n}\n\nRust에는 또 다른 종류의 주석인 문서 주석이 있습니다. 이에 대해서는 14장의 Crates.io에 크레이트 게시 섹션 에서 논의할 것입니다 .\n","id":"http://127.0.0.1:1111/rust/chapter3/4-comments/","title":"Comments"},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"body":"요약\n\n\n\n\n제어 흐름\n조건이 참인지 여부에 따라 일부 코드를 실행하고 조건이 참인 동안 일부 코드를 반복적으로 실행하는 기능은 대부분의 프로그래밍 언어의 기본 구성 요소입니다. Rust 코드의 실행 흐름을 제어할 수 있는 가장 일반적인 구조는 if 표현식과 루프입니다.\n만약 표현식\nif 식을 사용하면 조건에 따라 코드를 분기할 수 있습니다. 조건을 제공한 다음 “이 조건이 충족되면 이 코드 블록을 실행하십시오. 조건이 충족되지 않으면 이 코드 블록을 실행하지 마십시오.”\nif 식을 탐색하려면 프로젝트 디렉터리 에 branches 라는 새 프로젝트를 만듭니다 . src/main.rs 파일 에 다음을 입력합니다.\n파일 이름: src/main.rs\nfn main() {\n    let number = 3;\n\n    if number &lt; 5 {\n        println!(`condition was true`);\n    } else {\n        println!(`condition was false`);\n    }\n}\n\n모든 if 표현식은 키워드 if로 시작하고 그 뒤에 조건이 옵니다. 이 경우 조건은 변수 숫자의 값이 5보다 작은지 여부를 확인합니다. 조건이 참이면 실행할 코드 블록을 중괄호 안의 조건 바로 뒤에 배치합니다. if 표현식의 조건과 관련된 코드 블록은 2장의 추측과 비밀 번호 비교 섹션 에서 논의한 match 표현식의 arm과 마찬가지로 arm이라고도 합니다 .\n선택적으로 조건이 false로 평가될 경우 실행할 대체 코드 블록을 프로그램에 제공하기 위해 여기에서 선택한 else 표현식을 포함할 수도 있습니다. else 표현식을 제공하지 않고 조건이 false인 경우 프로그램은 if 블록을 건너뛰고 다음 코드 비트로 이동합니다.\n이 코드를 실행해 보십시오. 다음 출력이 표시되어야 합니다.\n$ cargo run\n   Compiling branches v0.1.0 (file:///projects/branches)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.31s\n     Running `target/debug/branches`\ncondition was true\n\n어떤 일이 발생하는지 보기 위해 숫자 값을 조건을 거짓으로 만드는 값으로 변경해 보겠습니다.\n    let number = 7;\n\n프로그램을 다시 실행하고 출력을 확인합니다.\n$ cargo run\n   Compiling branches v0.1.0 (file:///projects/branches)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.31s\n     Running `target/debug/branches`\ncondition was false\n\n이 코드의 조건이 bool 이어야 한다는 점도 주목할 가치가 있습니다 . 조건이 bool이 아니면 오류가 발생합니다. 예를 들어 다음 코드를 실행해 보십시오.\n파일 이름: src/main.rs\nfn main() {\n    let number = 3;\n\n    if number {\n        println!(`number was three`);\n    }\n}\n\nif 조건은 이번에 3의 값으로 평가되고 Rust는 오류를 발생시킵니다:\n$ cargo run\n   Compiling branches v0.1.0 (file:///projects/branches)\nerror[E0308]: mismatched types\n --&gt; src/main.rs:4:8\n  |\n4 |     if number {\n  |        ^^^^^^ expected `bool`, found integer\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `branches` due to previous error\n\n오류는 Rust가 bool을 예상했지만 정수를 얻었음을 나타냅니다. Ruby 및 JavaScript와 같은 언어와 달리 Rust는 부울이 아닌 유형을 부울로 자동 변환하지 않습니다. 명시적이어야 하며 항상 if에 부울을 조건으로 제공해야 합니다. 예를 들어 숫자가 0이 아닌 경우에만 if 코드 블록을 실행하려면 if 식을 다음과 같이 변경할 수 있습니다.\n파일 이름: src/main.rs\nfn main() {\n    let number = 3;\n\n    if number != 0 {\n        println!(`number was something other than zero`);\n    }\n}\n\n이 코드를 실행하면 숫자는 0이 아닌 것입니다.가 인쇄됩니다.\nelse if로 여러 조건 처리\nelse if 식에서 if와 else를 결합하여 여러 조건을 사용할 수 있습니다. 예를 들어:\n파일 이름: src/main.rs\nfn main() {\n    let number = 6;\n\n    if number % 4 == 0 {\n        println!(`number is divisible by 4`);\n    } else if number % 3 == 0 {\n        println!(`number is divisible by 3`);\n    } else if number % 2 == 0 {\n        println!(`number is divisible by 2`);\n    } else {\n        println!(`number is not divisible by 4, 3, or 2`);\n    }\n}\n\n이 프로그램에는 네 가지 가능한 경로가 있습니다. 실행하면 다음과 같은 출력이 표시됩니다.\n$ cargo run\n   Compiling branches v0.1.0 (file:///projects/branches)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.31s\n     Running `target/debug/branches`\nnumber is divisible by 3\n\n이 프로그램이 실행될 때 각 if 표현식을 차례로 확인하고 조건이 true로 평가되는 첫 번째 본문을 실행합니다. 6은 2로 나눌 수 있지만 숫자는 2로 나눌 수 있습니다라는 출력이 표시되지 않으며 else 블록의 숫자는 4, 3 또는 2로 나눌 수 없습니다 텍스트도 표시되지 않습니다. . 이는 Rust가 첫 번째 참 조건에 대해서만 블록을 실행하고 일단 하나를 찾으면 나머지는 확인조차 하지 않기 때문입니다.\nelse if 식을 너무 많이 사용하면 코드가 복잡해질 수 있으므로 둘 이상의 식을 사용하는 경우 코드를 리팩터링해야 할 수 있습니다. 6장은 이러한 경우에 일치라고 하는 강력한 Rust 분기 구조를 설명합니다.\nlet 문에서 if 사용\nif는 표현식이기 때문에 목록 3-2에서와 같이 결과를 변수에 할당하기 위해 let 문의 오른쪽에 이를 사용할 수 있습니다.\n파일 이름: src/main.rs\nfn main() {\n    let condition = true;\n    let number = if condition { 5 } else { 6 };\n\n    println!(`The value of number is: {number}`);\n}\n\n목록 3-2: if 표현식의 결과를 변수에 할당\n숫자 변수는 if 식의 결과에 따라 값에 바인딩됩니다. 이 코드를 실행하여 무슨 일이 일어나는지 확인하십시오.\n$ cargo run\n   Compiling branches v0.1.0 (file:///projects/branches)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.30s\n     Running `target/debug/branches`\nThe value of number is: 5\n\n코드 블록은 코드 블록의 마지막 표현식으로 평가되며 숫자 자체도 표현식이라는 점을 기억하십시오. 이 경우 전체 if 표현식의 값은 실행되는 코드 블록에 따라 다릅니다. 이는 if의 각 부분에서 결과가 될 가능성이 있는 값이 동일한 유형이어야 함을 의미합니다. 목록 3-2에서 if 팔과 else 팔 모두의 결과는 i32 정수였습니다. 다음 예와 같이 유형이 일치하지 않으면 오류가 발생합니다.\n파일 이름: src/main.rs\nfn main() {\n    let condition = true;\n\n    let number = if condition { 5 } else { `six` };\n\n    println!(`The value of number is: {number}`);\n}\n\n이 코드를 컴파일하려고 하면 오류가 발생합니다. if 및 else 팔에는 호환되지 않는 값 유형이 있으며 Rust는 프로그램에서 문제를 찾을 위치를 정확히 나타냅니다.\n$ cargo run\n   Compiling branches v0.1.0 (file:///projects/branches)\nerror[E0308]: `if` and `else` have incompatible types\n --&gt; src/main.rs:4:44\n  |\n4 |     let number = if condition { 5 } else { `six` };\n  |                                 -          ^^^^^ expected integer, found `&amp;str`\n  |                                 |\n  |                                 expected because of this\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `branches` due to previous error\n\nif 블록의 식은 정수로 평가되고 else 블록의 식은 문자열로 평가됩니다. 이것은 변수가 단일 유형을 가져야 하기 때문에 작동하지 않으며 Rust는 컴파일 타임에 숫자 변수가 어떤 유형인지 확실히 알아야 합니다. 숫자의 유형을 알면 컴파일러가 숫자를 사용하는 모든 곳에서 유형이 유효한지 확인할 수 있습니다. 러스트는 숫자의 유형이 런타임에만 결정된다면 그렇게 할 수 없을 것입니다. 컴파일러는 변수에 대한 여러 가상 유형을 추적해야 하는 경우 코드에 대한 보장이 더 적어지고 더 복잡해집니다.\n루프를 사용한 반복\n코드 블록을 두 번 이상 실행하는 것이 종종 유용합니다. 이 작업을 위해 Rust는 여러 루프를 제공합니다 . 이 루프는 루프 본문 내부의 코드를 통해 끝까지 실행된 다음 처음부터 즉시 다시 시작됩니다. 루프를 실험하기 위해 loops 라는 새 프로젝트를 만들어 봅시다 .\nRust에는 loop, while 및 for의 세 종류의 루프가 있습니다. 각자 시도해 봅시다.\n루프를 사용하여 코드 반복\nloop 키워드는 Rust에게 코드 블록을 영원히 반복해서 실행하거나 명시적으로 중지하라고 지시할 때까지 실행하라고 지시합니다.\n예를 들어 루프 디렉토리 의 src/main.rs 파일을 다음과 같이 변경하십시오.\n파일 이름: src/main.rs\nfn main() {\n    loop {\n        println!(`again!`);\n    }\n}\n\n이 프로그램을 실행하면 다시! 프로그램을 수동으로 중지할 때까지 계속 반복해서 인쇄합니다. 대부분의 터미널은 키보드 단축키 ctrl-c를 지원하여 연속 루프에 빠진 프로그램을 중단합니다. 시도 해봐:\n$ cargo run\n   Compiling loops v0.1.0 (file:///projects/loops)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.29s\n     Running `target/debug/loops`\nagain!\nagain!\nagain!\nagain!\n^Cagain!\n\n^C 기호는 ctrl-c를 누른 위치를 나타냅니다. 다시!라는 단어가 표시될 수도 있고 표시되지 않을 수도 있습니다. 인터럽트 신호를 받았을 때 코드가 루프에 있던 위치에 따라 ^C 다음에 인쇄됩니다.\n다행스럽게도 Rust는 코드를 사용하여 루프에서 벗어날 수 있는 방법도 제공합니다. 루프 내에 break 키워드를 배치하여 루프 실행을 중지할 시기를 프로그램에 알릴 수 있습니다. 2장의 올바른 추측 후 종료 섹션 의 추측 게임에서 사용자가 올바른 숫자를 추측하여 게임에서 이겼을 때 프로그램을 종료하기 위해 이 작업을 수행한 것을 기억하십시오.\n우리는 또한 추측 게임에서 계속을 사용했는데, 이는 루프에서 루프의 이 반복에서 나머지 코드를 건너뛰고 다음 반복으로 이동하도록 프로그램에 지시합니다.\n루프에서 값 반환\n루프의 용도 중 하나는 스레드가 작업을 완료했는지 여부를 확인하는 것과 같이 실패할 수 있는 작업을 다시 시도하는 것입니다. 해당 작업의 결과를 루프에서 나머지 코드로 전달해야 할 수도 있습니다. 이를 위해 루프를 중지하는 데 사용하는 break 표현식 뒤에 반환하려는 값을 추가할 수 있습니다. 해당 값은 다음과 같이 사용할 수 있도록 루프 외부로 반환됩니다.\nfn main() {\n    let mut counter = 0;\n\n    let result = loop {\n        counter += 1;\n\n        if counter == 10 {\n            break counter * 2;\n        }\n    };\n\n    println!(`The result is {result}`);\n}\n\n루프 전에 counter라는 변수를 선언하고 0으로 초기화합니다. 그런 다음 루프에서 반환된 값을 보유하기 위해 result라는 변수를 선언합니다. 루프가 반복될 때마다 카운터 변수에 1을 추가한 다음 카운터가 10과 같은지 확인합니다. 그럴 때 counter * 2 값과 함께 break 키워드를 사용합니다. 루프 다음에 세미콜론을 사용하여 result에 값을 할당하는 명령문을 종료합니다. 마지막으로 result에 값을 인쇄합니다. 이 경우에는 20입니다.\n여러 루프 사이를 명확하게 하기 위한 루프 레이블\n루프 내에 루프가 있는 경우 중단 및 계속은 해당 지점에서 가장 안쪽 루프에 적용됩니다. 선택적으로 break 또는 continue와 함께 사용할 수 있는 루프에 루프 레이블을 지정하여 해당 키워드가 가장 안쪽 루프 대신 레이블이 지정된 루프에 적용되도록 지정할 수 있습니다. 루프 레이블은 작은따옴표로 시작해야 합니다. 다음은 두 개의 중첩 루프가 있는 예입니다.\nfn main() {\n    let mut count = 0;\n    'counting_up: loop {\n        println!(`count = {count}`);\n        let mut remaining = 10;\n\n        loop {\n            println!(`remaining = {remaining}`);\n            if remaining == 9 {\n                break;\n            }\n            if count == 2 {\n                break 'counting_up;\n            }\n            remaining -= 1;\n        }\n\n        count += 1;\n    }\n    println!(`End count = {count}`);\n}\n\n외부 루프에는 'counting_up 레이블이 있으며 0에서 2까지 카운트합니다. 레이블이 없는 내부 루프는 10에서 9까지 카운트다운합니다. 레이블을 지정하지 않은 첫 번째 중단은 내부 루프를 종료합니다. 루프만. 브레이크 'counting_up; 문은 외부 루프를 종료합니다. 이 코드는 다음을 인쇄합니다.\n$ cargo run\n   Compiling loops v0.1.0 (file:///projects/loops)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.58s\n     Running `target/debug/loops`\ncount = 0\nremaining = 10\nremaining = 9\ncount = 1\nremaining = 10\nremaining = 9\ncount = 2\nremaining = 10\nEnd count = 2\n\nwhile이 있는 조건부 루프\n프로그램은 종종 루프 내에서 조건을 평가해야 합니다. 조건이 true인 동안 루프가 실행됩니다. 조건이 참이 아니게 되면 프로그램은 중단을 호출하여 루프를 중지합니다. loop, if, else 및 break의 조합을 사용하여 이와 같은 동작을 구현할 수 있습니다. 원하는 경우 지금 프로그램에서 시도해 볼 수 있습니다. 그러나 이 패턴은 너무 일반적이어서 Rust에는 while 루프라고 하는 내장 언어 구조가 있습니다. Listing 3-3에서 우리는 while을 사용하여 프로그램을 세 번 반복하고 매번 카운트다운한 다음 루프가 끝난 후 메시지를 인쇄하고 종료합니다.\n파일 이름: src/main.rs\nfn main() {\n    let mut number = 3;\n\n    while number != 0 {\n        println!(`{number}!`);\n\n        number -= 1;\n    }\n\n    println!(`LIFTOFF!!!`);\n}\n\n목록 3-3: while 루프를 사용하여 조건이 참일 때 코드 실행\n이 구성은 loop, if, else 및 break를 사용하는 경우 필요한 많은 중첩을 제거하고 더 명확합니다. 조건이 true로 평가되는 동안 코드가 실행됩니다. 그렇지 않으면 루프를 종료합니다.\nfor를 사용하여 컬렉션 반복\nwhile 구성을 사용하여 배열과 같은 컬렉션의 요소를 반복하도록 선택할 수 있습니다. 예를 들어 목록 3-4의 루프는 배열 a의 각 요소를 인쇄합니다.\n파일 이름: src/main.rs\nfn main() {\n    let a = [10, 20, 30, 40, 50];\n    let mut index = 0;\n\n    while index &lt; 5 {\n        println!(`the value is: {}`, a[index]);\n\n        index += 1;\n    }\n}\n\nListing 3-4: while 루프를 사용하여 컬렉션의 각 요소를 순환\n여기서 코드는 배열의 요소를 통해 계산됩니다. 인덱스 0에서 시작한 다음 배열의 마지막 인덱스에 도달할 때까지(즉, index &lt; 5가 더 이상 true가 아닌 경우) 반복합니다. 이 코드를 실행하면 배열의 모든 요소가 인쇄됩니다.\n$ cargo run\n   Compiling loops v0.1.0 (file:///projects/loops)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.32s\n     Running `target/debug/loops`\nthe value is: 10\nthe value is: 20\nthe value is: 30\nthe value is: 40\nthe value is: 50\n\n5개의 배열 값이 모두 예상대로 터미널에 나타납니다. 인덱스가 어느 시점에서 5 값에 도달하더라도 루프는 배열에서 6번째 값을 가져오려고 시도하기 전에 실행을 중지합니다.\n그러나 이 방법은 오류가 발생하기 쉽습니다. 인덱스 값이나 테스트 조건이 올바르지 않으면 프로그램이 패닉 상태가 될 수 있습니다. 예를 들어 a 배열의 정의를 4개의 요소를 갖도록 변경했지만 조건을 while index &lt; 4로 업데이트하는 것을 잊은 경우 코드가 패닉 상태가 됩니다. 또한 컴파일러가 루프를 통한 모든 반복에서 인덱스가 배열 범위 내에 있는지 여부에 대한 조건부 검사를 수행하기 위해 런타임 코드를 추가하기 때문에 속도가 느립니다.\n보다 간결한 대안으로 for 루프를 사용하고 컬렉션의 각 항목에 대해 일부 코드를 실행할 수 있습니다. for 루프는 Listing 3-5의 코드처럼 보입니다.\n파일 이름: src/main.rs\nfn main() {\n    let a = [10, 20, 30, 40, 50];\n\n    for element in a {\n        println!(`the value is: {element}`);\n    }\n}\n\nListing 3-5: for 루프를 사용하여 컬렉션의 각 요소를 순환\n이 코드를 실행하면 목록 3-4와 동일한 출력이 표시됩니다. 더 중요한 것은 이제 코드의 안전성을 높이고 배열의 끝을 벗어나거나 충분히 멀리 가지 않고 일부 항목이 누락되어 발생할 수 있는 버그의 가능성을 제거했습니다.\nfor 루프를 사용하면 Listing 3-4에서 사용된 방법과 같이 배열의 값 수를 변경한 경우 다른 코드를 변경할 필요가 없습니다.\nfor 루프의 안전성과 간결함은 Rust에서 가장 일반적으로 사용되는 루프 구조입니다. Listing 3-3에서 while 루프를 사용한 카운트다운 예제와 같이 일부 코드를 특정 횟수만큼 실행하려는 상황에서도 대부분의 Rustacean은 for 루프를 사용합니다. 이를 수행하는 방법은 표준 라이브러리에서 제공하는 범위를 사용하는 것입니다. 이 범위는 한 숫자에서 시작하여 다른 숫자 앞에서 끝나는 모든 숫자를 순서대로 생성합니다.\n카운트다운은 for 루프와 아직 언급하지 않은 rev 방법을 사용하여 범위를 역전시키는 것과 같습니다.\n파일 이름: src/main.rs\nfn main() {\n    for number in (1..4).rev() {\n        println!(`{number}!`);\n    }\n    println!(`LIFTOFF!!!`);\n}\n\n이 코드가 좀 더 멋지죠?\n요약\n네가 해냈어! 변수, 스칼라 및 복합 데이터 유형, 함수, 주석, if 표현식 및 루프에 대해 배웠습니다! 이 장에서 설명한 개념을 연습하려면 다음을 수행하는 프로그램을 작성해 보십시오.\n\n화씨와 섭씨 사이의 온도를 변환합니다.\nn 번째 피보나치 수를 생성합니다 .\n노래의 반복을 활용하여 크리스마스 캐롤 The Twelve Days of Christmas의 가사를 인쇄하세요.\n\n계속 진행할 준비가 되면 다른 프로그래밍 언어에는 일반적으로 존재 하지 않는 Rust의 개념인 소유권에 대해 이야기하겠습니다.\n&lt;\n내장 암호 그리고 사랑\n에 의해 구동 졸라\n","id":"http://127.0.0.1:1111/rust/chapter3/5-control-flow/","title":"Control Flow"},"http://127.0.0.1:1111/rust/chapter4-10/":{"body":"Understanding Ownership\nOwnership is Rust’s most unique feature and has deep implications for the rest of the language. It enables Rust to make memory safety guarantees without needing a garbage collector, so it’s important to understand how ownership works. In this chapter, we’ll talk about ownership as well as several related features: borrowing, slices, and how Rust lays data out in memory.\n\nWhat Is Ownership?\nOwnership is a set of rules that govern how a Rust program manages memory. All programs have to manage the way they use a computer’s memory while running. Some languages have garbage collection that regularly looks for no-longer-used memory as the program runs; in other languages, the programmer must explicitly allocate and free the memory. Rust uses a third approach: memory is managed through a system of ownership with a set of rules that the compiler checks. If any of the rules are violated, the program won’t compile. None of the features of ownership will slow down your program while it’s running.\nBecause ownership is a new concept for many programmers, it does take some time to get used to. The good news is that the more experienced you become with Rust and the rules of the ownership system, the easier you’ll find it to naturally develop code that is safe and efficient. Keep at it!\nWhen you understand ownership, you’ll have a solid foundation for understanding the features that make Rust unique. In this chapter, you’ll learn ownership by working through some examples that focus on a very common data structure: strings.\n\nThe Stack and the Heap\nMany programming languages don’t require you to think about the stack and the heap very often. But in a systems programming language like Rust, whether a value is on the stack or the heap affects how the language behaves and why you have to make certain decisions. Parts of ownership will be described in relation to the stack and the heap later in this chapter, so here is a brief explanation in preparation.\nBoth the stack and the heap are parts of memory available to your code to use at runtime, but they are structured in different ways. The stack stores values in the order it gets them and removes the values in the opposite order. This is referred to as last in, first out. Think of a stack of plates: when you add more plates, you put them on top of the pile, and when you need a plate, you take one off the top. Adding or removing plates from the middle or bottom wouldn’t work as well! Adding data is called pushing onto the stack, and removing data is called popping off the stack. All data stored on the stack must have a known, fixed size. Data with an unknown size at compile time or a size that might change must be stored on the heap instead.\nThe heap is less organized: when you put data on the heap, you request a certain amount of space. The memory allocator finds an empty spot in the heap that is big enough, marks it as being in use, and returns a pointer, which is the address of that location. This process is called allocating on the heap and is sometimes abbreviated as just allocating (pushing values onto the stack is not considered allocating). Because the pointer to the heap is a known, fixed size, you can store the pointer on the stack, but when you want the actual data, you must follow the pointer. Think of being seated at a restaurant. When you enter, you state the number of people in your group, and the host finds an empty table that fits everyone and leads you there. If someone in your group comes late, they can ask where you’ve been seated to find you.\nPushing to the stack is faster than allocating on the heap because the allocator never has to search for a place to store new data; that location is always at the top of the stack. Comparatively, allocating space on the heap requires more work because the allocator must first find a big enough space to hold the data and then perform bookkeeping to prepare for the next allocation.\nAccessing data in the heap is slower than accessing data on the stack because you have to follow a pointer to get there. Contemporary processors are faster if they jump around less in memory. Continuing the analogy, consider a server at a restaurant taking orders from many tables. It’s most efficient to get all the orders at one table before moving on to the next table. Taking an order from table A, then an order from table B, then one from A again, and then one from B again would be a much slower process. By the same token, a processor can do its job better if it works on data that’s close to other data (as it is on the stack) rather than farther away (as it can be on the heap).\nWhen your code calls a function, the values passed into the function (including, potentially, pointers to data on the heap) and the function’s local variables get pushed onto the stack. When the function is over, those values get popped off the stack.\nKeeping track of what parts of code are using what data on the heap, minimizing the amount of duplicate data on the heap, and cleaning up unused data on the heap so you don’t run out of space are all problems that ownership addresses. Once you understand ownership, you won’t need to think about the stack and the heap very often, but knowing that the main purpose of ownership is to manage heap data can help explain why it works the way it does.\n\nOwnership Rules\nFirst, let’s take a look at the ownership rules. Keep these rules in mind as we work through the examples that illustrate them:\n\nEach value in Rust has an owner.\nThere can only be one owner at a time.\nWhen the owner goes out of scope, the value will be dropped.\n\nVariable Scope\nNow that we’re past basic Rust syntax, we won’t include all the \"fn main() {\" code in examples, so if you’re following along, make sure to put the following examples inside a \"main\" function manually. As a result, our examples will be a bit more concise, letting us focus on the actual details rather than boilerplate code.\nAs a first example of ownership, we’ll look at the scope of some variables. A scope is the range within a program for which an item is valid. Take the following variable:\nlet s = \"hello\";\n\nThe variable \"s\" refers to a string literal, where the value of the string is hardcoded into the text of our program. The variable is valid from the point at which it’s declared until the end of the current scope. Listing 4-1 shows a program with comments annotating where the variable \"s\" would be valid.\n    {                      // s is not valid here, it’s not yet declared\n        let s = \"hello\";   // s is valid from this point forward\n\n        // do stuff with s\n    }                      // this scope is now over, and s is no longer valid\n\nListing 4-1: A variable and the scope in which it is valid\nIn other words, there are two important points in time here:\n\nWhen \"s\" comes into scope, it is valid.\nIt remains valid until it goes out of scope.\n\nAt this point, the relationship between scopes and when variables are valid is similar to that in other programming languages. Now we’ll build on top of this understanding by introducing the \"String\" type.\nThe \"String\" Type\nTo illustrate the rules of ownership, we need a data type that is more complex than those we covered in the “Data Types” section of Chapter 3. The types covered previously are of a known size, can be stored on the stack and popped off the stack when their scope is over, and can be quickly and trivially copied to make a new, independent instance if another part of code needs to use the same value in a different scope. But we want to look at data that is stored on the heap and explore how Rust knows when to clean up that data, and the \"String\" type is a great example.\nWe’ll concentrate on the parts of \"String\" that relate to ownership. These aspects also apply to other complex data types, whether they are provided by the standard library or created by you. We’ll discuss \"String\" in more depth in Chapter 8.\nWe’ve already seen string literals, where a string value is hardcoded into our program. String literals are convenient, but they aren’t suitable for every situation in which we may want to use text. One reason is that they’re immutable. Another is that not every string value can be known when we write our code: for example, what if we want to take user input and store it? For these situations, Rust has a second string type, \"String\". This type manages data allocated on the heap and as such is able to store an amount of text that is unknown to us at compile time. You can create a \"String\" from a string literal using the \"from\" function, like so:\nlet s = String::from(\"hello\");\n\nThe double colon \"::\" operator allows us to namespace this particular \"from\" function under the \"String\" type rather than using some sort of name like \"string_from\". We’ll discuss this syntax more in the “Method Syntax” section of Chapter 5, and when we talk about namespacing with modules in “Paths for Referring to an Item in the Module Tree” in Chapter 7.\nThis kind of string can be mutated:\n    let mut s = String::from(\"hello\");\n\n    s.push_str(\", world!\"); // push_str() appends a literal to a String\n\n    println!(\"{}\", s); // This will print \"hello, world!\"\n\nSo, what’s the difference here? Why can \"String\" be mutated but literals cannot? The difference is in how these two types deal with memory.\nMemory and Allocation\nIn the case of a string literal, we know the contents at compile time, so the text is hardcoded directly into the final executable. This is why string literals are fast and efficient. But these properties only come from the string literal’s immutability. Unfortunately, we can’t put a blob of memory into the binary for each piece of text whose size is unknown at compile time and whose size might change while running the program.\nWith the \"String\" type, in order to support a mutable, growable piece of text, we need to allocate an amount of memory on the heap, unknown at compile time, to hold the contents. This means:\n\nThe memory must be requested from the memory allocator at runtime.\nWe need a way of returning this memory to the allocator when we’re done with our \"String\".\n\nThat first part is done by us: when we call \"String::from\", its implementation requests the memory it needs. This is pretty much universal in programming languages.\nHowever, the second part is different. In languages with a garbage collector (GC), the GC keeps track of and cleans up memory that isn’t being used anymore, and we don’t need to think about it. In most languages without a GC, it’s our responsibility to identify when memory is no longer being used and to call code to explicitly free it, just as we did to request it. Doing this correctly has historically been a difficult programming problem. If we forget, we’ll waste memory. If we do it too early, we’ll have an invalid variable. If we do it twice, that’s a bug too. We need to pair exactly one \"allocate\" with exactly one \"free\".\nRust takes a different path: the memory is automatically returned once the variable that owns it goes out of scope. Here’s a version of our scope example from Listing 4-1 using a \"String\" instead of a string literal:\n    {\n        let s = String::from(\"hello\"); // s is valid from this point forward\n\n        // do stuff with s\n    }                                  // this scope is now over, and s is no\n                                       // longer valid\n\nThere is a natural point at which we can return the memory our \"String\" needs to the allocator: when \"s\" goes out of scope. When a variable goes out of scope, Rust calls a special function for us. This function is called \"drop\", and it’s where the author of \"String\" can put the code to return the memory. Rust calls \"drop\" automatically at the closing curly bracket.\n\nNote: In C++, this pattern of deallocating resources at the end of an item’s lifetime is sometimes called Resource Acquisition Is Initialization (RAII). The \"drop\" function in Rust will be familiar to you if you’ve used RAII patterns.\n\nThis pattern has a profound impact on the way Rust code is written. It may seem simple right now, but the behavior of code can be unexpected in more complicated situations when we want to have multiple variables use the data we’ve allocated on the heap. Let’s explore some of those situations now.\nVariables and Data Interacting with Move\nMultiple variables can interact with the same data in different ways in Rust. Let’s look at an example using an integer in Listing 4-2.\n    let x = 5;\n    let y = x;\n\nListing 4-2: Assigning the integer value of variable \"x\" to \"y\"\nWe can probably guess what this is doing: “bind the value \"5\" to \"x\"; then make a copy of the value in \"x\" and bind it to \"y\".” We now have two variables, \"x\" and \"y\", and both equal \"5\". This is indeed what is happening, because integers are simple values with a known, fixed size, and these two \"5\" values are pushed onto the stack.\nNow let’s look at the \"String\" version:\n    let s1 = String::from(\"hello\");\n    let s2 = s1;\n\nThis looks very similar, so we might assume that the way it works would be the same: that is, the second line would make a copy of the value in \"s1\" and bind it to \"s2\". But this isn’t quite what happens.\nTake a look at Figure 4-1 to see what is happening to \"String\" under the covers. A \"String\" is made up of three parts, shown on the left: a pointer to the memory that holds the contents of the string, a length, and a capacity. This group of data is stored on the stack. On the right is the memory on the heap that holds the contents.\n\nFigure 4-1: Representation in memory of a \"String\" holding the value \"\"hello\"\" bound to \"s1\"\nThe length is how much memory, in bytes, the contents of the \"String\" are currently using. The capacity is the total amount of memory, in bytes, that the \"String\" has received from the allocator. The difference between length and capacity matters, but not in this context, so for now, it’s fine to ignore the capacity.\nWhen we assign \"s1\" to \"s2\", the \"String\" data is copied, meaning we copy the pointer, the length, and the capacity that are on the stack. We do not copy the data on the heap that the pointer refers to. In other words, the data representation in memory looks like Figure 4-2.\n\nFigure 4-2: Representation in memory of the variable \"s2\" that has a copy of the pointer, length, and capacity of \"s1\"\nThe representation does not look like Figure 4-3, which is what memory would look like if Rust instead copied the heap data as well. If Rust did this, the operation \"s2 = s1\" could be very expensive in terms of runtime performance if the data on the heap were large.\n\nFigure 4-3: Another possibility for what \"s2 = s1\" might do if Rust copied the heap data as well\nEarlier, we said that when a variable goes out of scope, Rust automatically calls the \"drop\" function and cleans up the heap memory for that variable. But Figure 4-2 shows both data pointers pointing to the same location. This is a problem: when \"s2\" and \"s1\" go out of scope, they will both try to free the same memory. This is known as a double free error and is one of the memory safety bugs we mentioned previously. Freeing memory twice can lead to memory corruption, which can potentially lead to security vulnerabilities.\nTo ensure memory safety, after the line \"let s2 = s1;\", Rust considers \"s1\" as no longer valid. Therefore, Rust doesn’t need to free anything when \"s1\" goes out of scope. Check out what happens when you try to use \"s1\" after \"s2\" is created; it won’t work:\n    let s1 = String::from(\"hello\");\n    let s2 = s1;\n\n    println!(\"{}, world!\", s1);\n\nYou’ll get an error like this because Rust prevents you from using the invalidated reference:\n$ cargo run\n   Compiling ownership v0.1.0 (file:///projects/ownership)\nerror[E0382]: borrow of moved value: \"s1\"\n --&gt; src/main.rs:5:28\n  |\n2 |     let s1 = String::from(\"hello\");\n  |         -- move occurs because \"s1\" has type \"String\", which does not implement the \"Copy\" trait\n3 |     let s2 = s1;\n  |              -- value moved here\n4 |\n5 |     println!(\"{}, world!\", s1);\n  |                            ^^ value borrowed here after move\n  |\n  = note: this error originates in the macro \"$crate::format_args_nl\" which comes from the expansion of the macro \"println\" (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider cloning the value if the performance cost is acceptable\n  |\n3 |     let s2 = s1.clone();\n  |                ++++++++\n\nFor more information about this error, try \"rustc --explain E0382\".\nerror: could not compile \"ownership\" due to previous error\n\nIf you’ve heard the terms shallow copy and deep copy while working with other languages, the concept of copying the pointer, length, and capacity without copying the data probably sounds like making a shallow copy. But because Rust also invalidates the first variable, instead of being called a shallow copy, it’s known as a move. In this example, we would say that \"s1\" was moved into \"s2\". So, what actually happens is shown in Figure 4-4.\n\nFigure 4-4: Representation in memory after \"s1\" has been invalidated\nThat solves our problem! With only \"s2\" valid, when it goes out of scope it alone will free the memory, and we’re done.\nIn addition, there’s a design choice that’s implied by this: Rust will never automatically create “deep” copies of your data. Therefore, any automatic copying can be assumed to be inexpensive in terms of runtime performance.\nVariables and Data Interacting with Clone\nIf we do want to deeply copy the heap data of the \"String\", not just the stack data, we can use a common method called \"clone\". We’ll discuss method syntax in Chapter 5, but because methods are a common feature in many programming languages, you’ve probably seen them before.\nHere’s an example of the \"clone\" method in action:\n    let s1 = String::from(\"hello\");\n    let s2 = s1.clone();\n\n    println!(\"s1 = {}, s2 = {}\", s1, s2);\n\nThis works just fine and explicitly produces the behavior shown in Figure 4-3, where the heap data does get copied.\nWhen you see a call to \"clone\", you know that some arbitrary code is being executed and that code may be expensive. It’s a visual indicator that something different is going on.\nStack-Only Data: Copy\nThere’s another wrinkle we haven’t talked about yet. This code using integers—part of which was shown in Listing 4-2—works and is valid:\n    let x = 5;\n    let y = x;\n\n    println!(\"x = {}, y = {}\", x, y);\n\nBut this code seems to contradict what we just learned: we don’t have a call to \"clone\", but \"x\" is still valid and wasn’t moved into \"y\".\nThe reason is that types such as integers that have a known size at compile time are stored entirely on the stack, so copies of the actual values are quick to make. That means there’s no reason we would want to prevent \"x\" from being valid after we create the variable \"y\". In other words, there’s no difference between deep and shallow copying here, so calling \"clone\" wouldn’t do anything different from the usual shallow copying, and we can leave it out.\nRust has a special annotation called the \"Copy\" trait that we can place on types that are stored on the stack, as integers are (we’ll talk more about traits in Chapter 10). If a type implements the \"Copy\" trait, variables that use it do not move, but rather are trivially copied, making them still valid after assignment to another variable.\nRust won’t let us annotate a type with \"Copy\" if the type, or any of its parts, has implemented the \"Drop\" trait. If the type needs something special to happen when the value goes out of scope and we add the \"Copy\" annotation to that type, we’ll get a compile-time error. To learn about how to add the \"Copy\" annotation to your type to implement the trait, see “Derivable Traits” in Appendix C.\nSo, what types implement the \"Copy\" trait? You can check the documentation for the given type to be sure, but as a general rule, any group of simple scalar values can implement \"Copy\", and nothing that requires allocation or is some form of resource can implement \"Copy\". Here are some of the types that implement \"Copy\":\n\nAll the integer types, such as \"u32\".\nThe Boolean type, \"bool\", with values \"true\" and \"false\".\nAll the floating-point types, such as \"f64\".\nThe character type, \"char\".\nTuples, if they only contain types that also implement \"Copy\". For example, \"(i32, i32)\" implements \"Copy\", but \"(i32, String)\" does not.\n\nOwnership and Functions\nThe mechanics of passing a value to a function are similar to those when assigning a value to a variable. Passing a variable to a function will move or copy, just as assignment does. Listing 4-3 has an example with some annotations showing where variables go into and out of scope.\nFilename: src/main.rs\nfn main() {\n    let s = String::from(\"hello\");  // s comes into scope\n\n    takes_ownership(s);             // s's value moves into the function...\n                                    // ... and so is no longer valid here\n\n    let x = 5;                      // x comes into scope\n\n    makes_copy(x);                  // x would move into the function,\n                                    // but i32 is Copy, so it's okay to still\n                                    // use x afterward\n\n} // Here, x goes out of scope, then s. But because s's value was moved, nothing\n  // special happens.\n\nfn takes_ownership(some_string: String) { // some_string comes into scope\n    println!(\"{}\", some_string);\n} // Here, some_string goes out of scope and \"drop\" is called. The backing\n  // memory is freed.\n\nfn makes_copy(some_integer: i32) { // some_integer comes into scope\n    println!(\"{}\", some_integer);\n} // Here, some_integer goes out of scope. Nothing special happens.\n\nListing 4-3: Functions with ownership and scope annotated\nIf we tried to use \"s\" after the call to \"takes_ownership\", Rust would throw a compile-time error. These static checks protect us from mistakes. Try adding code to \"main\" that uses \"s\" and \"x\" to see where you can use them and where the ownership rules prevent you from doing so.\nReturn Values and Scope\nReturning values can also transfer ownership. Listing 4-4 shows an example of a function that returns some value, with similar annotations as those in Listing 4-3.\nFilename: src/main.rs\nfn main() {\n    let s1 = gives_ownership();         // gives_ownership moves its return\n                                        // value into s1\n\n    let s2 = String::from(\"hello\");     // s2 comes into scope\n\n    let s3 = takes_and_gives_back(s2);  // s2 is moved into\n                                        // takes_and_gives_back, which also\n                                        // moves its return value into s3\n} // Here, s3 goes out of scope and is dropped. s2 was moved, so nothing\n  // happens. s1 goes out of scope and is dropped.\n\nfn gives_ownership() -&gt; String {             // gives_ownership will move its\n                                             // return value into the function\n                                             // that calls it\n\n    let some_string = String::from(\"yours\"); // some_string comes into scope\n\n    some_string                              // some_string is returned and\n                                             // moves out to the calling\n                                             // function\n}\n\n// This function takes a String and returns one\nfn takes_and_gives_back(a_string: String) -&gt; String { // a_string comes into\n                                                      // scope\n\n    a_string  // a_string is returned and moves out to the calling function\n}\n\nListing 4-4: Transferring ownership of return values\nThe ownership of a variable follows the same pattern every time: assigning a value to another variable moves it. When a variable that includes data on the heap goes out of scope, the value will be cleaned up by \"drop\" unless ownership of the data has been moved to another variable.\nWhile this works, taking ownership and then returning ownership with every function is a bit tedious. What if we want to let a function use a value but not take ownership? It’s quite annoying that anything we pass in also needs to be passed back if we want to use it again, in addition to any data resulting from the body of the function that we might want to return as well.\nRust does let us return multiple values using a tuple, as shown in Listing 4-5.\nFilename: src/main.rs\nfn main() {\n    let s1 = String::from(\"hello\");\n\n    let (s2, len) = calculate_length(s1);\n\n    println!(\"The length of '{}' is {}.\", s2, len);\n}\n\nfn calculate_length(s: String) -&gt; (String, usize) {\n    let length = s.len(); // len() returns the length of a String\n\n    (s, length)\n}\n\nListing 4-5: Returning ownership of parameters\nBut this is too much ceremony and a lot of work for a concept that should be common. Luckily for us, Rust has a feature for using a value without transferring ownership, called references.\n\nReferences and Borrowing\nThe issue with the tuple code in Listing 4-5 is that we have to return the \"String\" to the calling function so we can still use the \"String\" after the call to \"calculate_length\", because the \"String\" was moved into \"calculate_length\". Instead, we can provide a reference to the \"String\" value. A reference is like a pointer in that it’s an address we can follow to access the data stored at that address; that data is owned by some other variable. Unlike a pointer, a reference is guaranteed to point to a valid value of a particular type for the life of that reference.\nHere is how you would define and use a \"calculate_length\" function that has a reference to an object as a parameter instead of taking ownership of the value:\nFilename: src/main.rs\nfn main() {\n    let s1 = String::from(\"hello\");\n\n    let len = calculate_length(&amp;s1);\n\n    println!(\"The length of '{}' is {}.\", s1, len);\n}\n\nfn calculate_length(s: &amp;String) -&gt; usize {\n    s.len()\n}\n\nFirst, notice that all the tuple code in the variable declaration and the function return value is gone. Second, note that we pass \"&amp;s1\" into \"calculate_length\" and, in its definition, we take \"&amp;String\" rather than \"String\". These ampersands represent references, and they allow you to refer to some value without taking ownership of it. Figure 4-5 depicts this concept.\n\nFigure 4-5: A diagram of \"&amp;String s\" pointing at \"String s1\"\n\nNote: The opposite of referencing by using \"&amp;\" is dereferencing, which is accomplished with the dereference operator, \"*\". We’ll see some uses of the dereference operator in Chapter 8 and discuss details of dereferencing in Chapter 15.\n\nLet’s take a closer look at the function call here:\n    let s1 = String::from(\"hello\");\n\n    let len = calculate_length(&amp;s1);\n\nThe \"&amp;s1\" syntax lets us create a reference that refers to the value of \"s1\" but does not own it. Because it does not own it, the value it points to will not be dropped when the reference stops being used.\nLikewise, the signature of the function uses \"&amp;\" to indicate that the type of the parameter \"s\" is a reference. Let’s add some explanatory annotations:\nfn calculate_length(s: &amp;String) -&gt; usize { // s is a reference to a String\n    s.len()\n} // Here, s goes out of scope. But because it does not have ownership of what\n  // it refers to, it is not dropped.\n\nThe scope in which the variable \"s\" is valid is the same as any function parameter’s scope, but the value pointed to by the reference is not dropped when \"s\" stops being used, because \"s\" doesn’t have ownership. When functions have references as parameters instead of the actual values, we won’t need to return the values in order to give back ownership, because we never had ownership.\nWe call the action of creating a reference borrowing. As in real life, if a person owns something, you can borrow it from them. When you’re done, you have to give it back. You don’t own it.\nSo, what happens if we try to modify something we’re borrowing? Try the code in Listing 4-6. Spoiler alert: it doesn’t work!\nFilename: src/main.rs\nfn main() {\n    let s = String::from(\"hello\");\n\n    change(&amp;s);\n}\n\nfn change(some_string: &amp;String) {\n    some_string.push_str(\", world\");\n}\n\nListing 4-6: Attempting to modify a borrowed value\nHere’s the error:\n$ cargo run\n   Compiling ownership v0.1.0 (file:///projects/ownership)\nerror[E0596]: cannot borrow \"*some_string\" as mutable, as it is behind a \"&amp;\" reference\n --&gt; src/main.rs:8:5\n  |\n7 | fn change(some_string: &amp;String) {\n  |                        ------- help: consider changing this to be a mutable reference: \"&amp;mut String\"\n8 |     some_string.push_str(\", world\");\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ \"some_string\" is a \"&amp;\" reference, so the data it refers to cannot be borrowed as mutable\n\nFor more information about this error, try \"rustc --explain E0596\".\nerror: could not compile \"ownership\" due to previous error\n\nJust as variables are immutable by default, so are references. We’re not allowed to modify something we have a reference to.\nMutable References\nWe can fix the code from Listing 4-6 to allow us to modify a borrowed value with just a few small tweaks that use, instead, a mutable reference:\nFilename: src/main.rs\nfn main() {\n    let mut s = String::from(\"hello\");\n\n    change(&amp;mut s);\n}\n\nfn change(some_string: &amp;mut String) {\n    some_string.push_str(\", world\");\n}\n\nFirst we change \"s\" to be \"mut\". Then we create a mutable reference with \"&amp;mut s\" where we call the \"change\" function, and update the function signature to accept a mutable reference with \"some_string: &amp;mut String\". This makes it very clear that the \"change\" function will mutate the value it borrows.\nMutable references have one big restriction: if you have a mutable reference to a value, you can have no other references to that value. This code that attempts to create two mutable references to \"s\" will fail:\nFilename: src/main.rs\n    let mut s = String::from(\"hello\");\n\n    let r1 = &amp;mut s;\n    let r2 = &amp;mut s;\n\n    println!(\"{}, {}\", r1, r2);\n\nHere’s the error:\n$ cargo run\n   Compiling ownership v0.1.0 (file:///projects/ownership)\nerror[E0499]: cannot borrow \"s\" as mutable more than once at a time\n --&gt; src/main.rs:5:14\n  |\n4 |     let r1 = &amp;mut s;\n  |              ------ first mutable borrow occurs here\n5 |     let r2 = &amp;mut s;\n  |              ^^^^^^ second mutable borrow occurs here\n6 |\n7 |     println!(\"{}, {}\", r1, r2);\n  |                        -- first borrow later used here\n\nFor more information about this error, try \"rustc --explain E0499\".\nerror: could not compile \"ownership\" due to previous error\n\nThis error says that this code is invalid because we cannot borrow \"s\" as mutable more than once at a time. The first mutable borrow is in \"r1\" and must last until it’s used in the \"println!\", but between the creation of that mutable reference and its usage, we tried to create another mutable reference in \"r2\" that borrows the same data as \"r1\".\nThe restriction preventing multiple mutable references to the same data at the same time allows for mutation but in a very controlled fashion. It’s something that new Rustaceans struggle with because most languages let you mutate whenever you’d like. The benefit of having this restriction is that Rust can prevent data races at compile time. A data race is similar to a race condition and happens when these three behaviors occur:\n\nTwo or more pointers access the same data at the same time.\nAt least one of the pointers is being used to write to the data.\nThere’s no mechanism being used to synchronize access to the data.\n\nData races cause undefined behavior and can be difficult to diagnose and fix when you’re trying to track them down at runtime; Rust prevents this problem by refusing to compile code with data races!\nAs always, we can use curly brackets to create a new scope, allowing for multiple mutable references, just not simultaneous ones:\n    let mut s = String::from(\"hello\");\n\n    {\n        let r1 = &amp;mut s;\n    } // r1 goes out of scope here, so we can make a new reference with no problems.\n\n    let r2 = &amp;mut s;\n\nRust enforces a similar rule for combining mutable and immutable references. This code results in an error:\n    let mut s = String::from(\"hello\");\n\n    let r1 = &amp;s; // no problem\n    let r2 = &amp;s; // no problem\n    let r3 = &amp;mut s; // BIG PROBLEM\n\n    println!(\"{}, {}, and {}\", r1, r2, r3);\n\nHere’s the error:\n$ cargo run\n   Compiling ownership v0.1.0 (file:///projects/ownership)\nerror[E0502]: cannot borrow \"s\" as mutable because it is also borrowed as immutable\n --&gt; src/main.rs:6:14\n  |\n4 |     let r1 = &amp;s; // no problem\n  |              -- immutable borrow occurs here\n5 |     let r2 = &amp;s; // no problem\n6 |     let r3 = &amp;mut s; // BIG PROBLEM\n  |              ^^^^^^ mutable borrow occurs here\n7 |\n8 |     println!(\"{}, {}, and {}\", r1, r2, r3);\n  |                                -- immutable borrow later used here\n\nFor more information about this error, try \"rustc --explain E0502\".\nerror: could not compile \"ownership\" due to previous error\n\nWhew! We also cannot have a mutable reference while we have an immutable one to the same value.\nUsers of an immutable reference don’t expect the value to suddenly change out from under them! However, multiple immutable references are allowed because no one who is just reading the data has the ability to affect anyone else’s reading of the data.\nNote that a reference’s scope starts from where it is introduced and continues through the last time that reference is used. For instance, this code will compile because the last usage of the immutable references, the \"println!\", occurs before the mutable reference is introduced:\n    let mut s = String::from(\"hello\");\n\n    let r1 = &amp;s; // no problem\n    let r2 = &amp;s; // no problem\n    println!(\"{} and {}\", r1, r2);\n    // variables r1 and r2 will not be used after this point\n\n    let r3 = &amp;mut s; // no problem\n    println!(\"{}\", r3);\n\nThe scopes of the immutable references \"r1\" and \"r2\" end after the \"println!\" where they are last used, which is before the mutable reference \"r3\" is created. These scopes don’t overlap, so this code is allowed: the compiler can tell that the reference is no longer being used at a point before the end of the scope.\nEven though borrowing errors may be frustrating at times, remember that it’s the Rust compiler pointing out a potential bug early (at compile time rather than at runtime) and showing you exactly where the problem is. Then you don’t have to track down why your data isn’t what you thought it was.\nDangling References\nIn languages with pointers, it’s easy to erroneously create a dangling pointer—a pointer that references a location in memory that may have been given to someone else—by freeing some memory while preserving a pointer to that memory. In Rust, by contrast, the compiler guarantees that references will never be dangling references: if you have a reference to some data, the compiler will ensure that the data will not go out of scope before the reference to the data does.\nLet’s try to create a dangling reference to see how Rust prevents them with a compile-time error:\nFilename: src/main.rs\nfn main() {\n    let reference_to_nothing = dangle();\n}\n\nfn dangle() -&gt; &amp;String {\n    let s = String::from(\"hello\");\n\n    &amp;s\n}\n\nHere’s the error:\n$ cargo run\n   Compiling ownership v0.1.0 (file:///projects/ownership)\nerror[E0106]: missing lifetime specifier\n --&gt; src/main.rs:5:16\n  |\n5 | fn dangle() -&gt; &amp;String {\n  |                ^ expected named lifetime parameter\n  |\n  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\nhelp: consider using the \"'static\" lifetime\n  |\n5 | fn dangle() -&gt; &amp;'static String {\n  |                 +++++++\n\nFor more information about this error, try \"rustc --explain E0106\".\nerror: could not compile \"ownership\" due to previous error\n\nThis error message refers to a feature we haven’t covered yet: lifetimes. We’ll discuss lifetimes in detail in Chapter 10. But, if you disregard the parts about lifetimes, the message does contain the key to why this code is a problem:\nthis function's return type contains a borrowed value, but there is no value\nfor it to be borrowed from\n\nLet’s take a closer look at exactly what’s happening at each stage of our \"dangle\" code:\nFilename: src/main.rs\nfn dangle() -&gt; &amp;String { // dangle returns a reference to a String\n\n    let s = String::from(\"hello\"); // s is a new String\n\n    &amp;s // we return a reference to the String, s\n} // Here, s goes out of scope, and is dropped. Its memory goes away.\n  // Danger!\n\nBecause \"s\" is created inside \"dangle\", when the code of \"dangle\" is finished, \"s\" will be deallocated. But we tried to return a reference to it. That means this reference would be pointing to an invalid \"String\". That’s no good! Rust won’t let us do this.\nThe solution here is to return the \"String\" directly:\nfn no_dangle() -&gt; String {\n    let s = String::from(\"hello\");\n\n    s\n}\n\nThis works without any problems. Ownership is moved out, and nothing is deallocated.\nThe Rules of References\nLet’s recap what we’ve discussed about references:\n\nAt any given time, you can have either one mutable reference or any number of immutable references.\nReferences must always be valid.\n\nNext, we’ll look at a different kind of reference: slices.\n\nThe Slice Type\nSlices let you reference a contiguous sequence of elements in a collection rather than the whole collection. A slice is a kind of reference, so it does not have ownership.\nHere’s a small programming problem: write a function that takes a string of words separated by spaces and returns the first word it finds in that string. If the function doesn’t find a space in the string, the whole string must be one word, so the entire string should be returned.\nLet’s work through how we’d write the signature of this function without using slices, to understand the problem that slices will solve:\nfn first_word(s: &amp;String) -&gt; ?\n\nThe \"first_word\" function has a \"&amp;String\" as a parameter. We don’t want ownership, so this is fine. But what should we return? We don’t really have a way to talk about part of a string. However, we could return the index of the end of the word, indicated by a space. Let’s try that, as shown in Listing 4-7.\nFilename: src/main.rs\nfn first_word(s: &amp;String) -&gt; usize {\n    let bytes = s.as_bytes();\n\n    for (i, &amp;item) in bytes.iter().enumerate() {\n        if item == b' ' {\n            return i;\n        }\n    }\n\n    s.len()\n}\n\nListing 4-7: The \"first_word\" function that returns a byte index value into the \"String\" parameter\nBecause we need to go through the \"String\" element by element and check whether a value is a space, we’ll convert our \"String\" to an array of bytes using the \"as_bytes\" method.\n    let bytes = s.as_bytes();\n\nNext, we create an iterator over the array of bytes using the \"iter\" method:\n    for (i, &amp;item) in bytes.iter().enumerate() {\n\nWe’ll discuss iterators in more detail in Chapter 13. For now, know that \"iter\" is a method that returns each element in a collection and that \"enumerate\" wraps the result of \"iter\" and returns each element as part of a tuple instead. The first element of the tuple returned from \"enumerate\" is the index, and the second element is a reference to the element. This is a bit more convenient than calculating the index ourselves.\nBecause the \"enumerate\" method returns a tuple, we can use patterns to destructure that tuple. We’ll be discussing patterns more in Chapter 6. In the \"for\" loop, we specify a pattern that has \"i\" for the index in the tuple and \"&amp;item\" for the single byte in the tuple. Because we get a reference to the element from \".iter().enumerate()\", we use \"&amp;\" in the pattern.\nInside the \"for\" loop, we search for the byte that represents the space by using the byte literal syntax. If we find a space, we return the position. Otherwise, we return the length of the string by using \"s.len()\".\n        if item == b' ' {\n            return i;\n        }\n    }\n\n    s.len()\n\nWe now have a way to find out the index of the end of the first word in the string, but there’s a problem. We’re returning a \"usize\" on its own, but it’s only a meaningful number in the context of the \"&amp;String\". In other words, because it’s a separate value from the \"String\", there’s no guarantee that it will still be valid in the future. Consider the program in Listing 4-8 that uses the \"first_word\" function from Listing 4-7.\nFilename: src/main.rs\nfn main() {\n    let mut s = String::from(\"hello world\");\n\n    let word = first_word(&amp;s); // word will get the value 5\n\n    s.clear(); // this empties the String, making it equal to \"\"\n\n    // word still has the value 5 here, but there's no more string that\n    // we could meaningfully use the value 5 with. word is now totally invalid!\n}\n\nListing 4-8: Storing the result from calling the \"first_word\" function and then changing the \"String\" contents\nThis program compiles without any errors and would also do so if we used \"word\" after calling \"s.clear()\". Because \"word\" isn’t connected to the state of \"s\" at all, \"word\" still contains the value \"5\". We could use that value \"5\" with the variable \"s\" to try to extract the first word out, but this would be a bug because the contents of \"s\" have changed since we saved \"5\" in \"word\".\nHaving to worry about the index in \"word\" getting out of sync with the data in \"s\" is tedious and error prone! Managing these indices is even more brittle if we write a \"second_word\" function. Its signature would have to look like this:\nfn second_word(s: &amp;String) -&gt; (usize, usize) {\n\nNow we’re tracking a starting and an ending index, and we have even more values that were calculated from data in a particular state but aren’t tied to that state at all. We have three unrelated variables floating around that need to be kept in sync.\nLuckily, Rust has a solution to this problem: string slices.\nString Slices\nA string slice is a reference to part of a \"String\", and it looks like this:\n    let s = String::from(\"hello world\");\n\n    let hello = &amp;s[0..5];\n    let world = &amp;s[6..11];\n\nRather than a reference to the entire \"String\", \"hello\" is a reference to a portion of the \"String\", specified in the extra \"[0..5]\" bit. We create slices using a range within brackets by specifying \"[starting_index..ending_index]\", where \"starting_index\" is the first position in the slice and \"ending_index\" is one more than the last position in the slice. Internally, the slice data structure stores the starting position and the length of the slice, which corresponds to \"ending_index\" minus \"starting_index\". So, in the case of \"let world = &amp;s[6..11];\", \"world\" would be a slice that contains a pointer to the byte at index 6 of \"s\" with a length value of \"5\".\nFigure 4-6 shows this in a diagram.\n\nFigure 4-6: String slice referring to part of a \"String\"\nWith Rust’s \"..\" range syntax, if you want to start at index 0, you can drop the value before the two periods. In other words, these are equal:\nlet s = String::from(\"hello\");\n\nlet slice = &amp;s[0..2];\nlet slice = &amp;s[..2];\n\nBy the same token, if your slice includes the last byte of the \"String\", you can drop the trailing number. That means these are equal:\nlet s = String::from(\"hello\");\n\nlet len = s.len();\n\nlet slice = &amp;s[3..len];\nlet slice = &amp;s[3..];\n\nYou can also drop both values to take a slice of the entire string. So these are equal:\nlet s = String::from(\"hello\");\n\nlet len = s.len();\n\nlet slice = &amp;s[0..len];\nlet slice = &amp;s[..];\n\n\nNote: String slice range indices must occur at valid UTF-8 character boundaries. If you attempt to create a string slice in the middle of a multibyte character, your program will exit with an error. For the purposes of introducing string slices, we are assuming ASCII only in this section; a more thorough discussion of UTF-8 handling is in the “Storing UTF-8 Encoded Text with Strings” section of Chapter 8.\n\nWith all this information in mind, let’s rewrite \"first_word\" to return a slice. The type that signifies “string slice” is written as \"&amp;str\":\nFilename: src/main.rs\nfn first_word(s: &amp;String) -&gt; &amp;str {\n    let bytes = s.as_bytes();\n\n    for (i, &amp;item) in bytes.iter().enumerate() {\n        if item == b' ' {\n            return &amp;s[0..i];\n        }\n    }\n\n    &amp;s[..]\n}\n\nWe get the index for the end of the word the same way we did in Listing 4-7, by looking for the first occurrence of a space. When we find a space, we return a string slice using the start of the string and the index of the space as the starting and ending indices.\nNow when we call \"first_word\", we get back a single value that is tied to the underlying data. The value is made up of a reference to the starting point of the slice and the number of elements in the slice.\nReturning a slice would also work for a \"second_word\" function:\nfn second_word(s: &amp;String) -&gt; &amp;str {\n\nWe now have a straightforward API that’s much harder to mess up because the compiler will ensure the references into the \"String\" remain valid. Remember the bug in the program in Listing 4-8, when we got the index to the end of the first word but then cleared the string so our index was invalid? That code was logically incorrect but didn’t show any immediate errors. The problems would show up later if we kept trying to use the first word index with an emptied string. Slices make this bug impossible and let us know we have a problem with our code much sooner. Using the slice version of \"first_word\" will throw a compile-time error:\nFilename: src/main.rs\nfn main() {\n    let mut s = String::from(\"hello world\");\n\n    let word = first_word(&amp;s);\n\n    s.clear(); // error!\n\n    println!(\"the first word is: {}\", word);\n}\n\nHere’s the compiler error:\n$ cargo run\n   Compiling ownership v0.1.0 (file:///projects/ownership)\nerror[E0502]: cannot borrow \"s\" as mutable because it is also borrowed as immutable\n  --&gt; src/main.rs:18:5\n   |\n16 |     let word = first_word(&amp;s);\n   |                           -- immutable borrow occurs here\n17 |\n18 |     s.clear(); // error!\n   |     ^^^^^^^^^ mutable borrow occurs here\n19 |\n20 |     println!(\"the first word is: {}\", word);\n   |                                       ---- immutable borrow later used here\n\nFor more information about this error, try \"rustc --explain E0502\".\nerror: could not compile \"ownership\" due to previous error\n\nRecall from the borrowing rules that if we have an immutable reference to something, we cannot also take a mutable reference. Because \"clear\" needs to truncate the \"String\", it needs to get a mutable reference. The \"println!\" after the call to \"clear\" uses the reference in \"word\", so the immutable reference must still be active at that point. Rust disallows the mutable reference in \"clear\" and the immutable reference in \"word\" from existing at the same time, and compilation fails. Not only has Rust made our API easier to use, but it has also eliminated an entire class of errors at compile time!\nString Literals as Slices\nRecall that we talked about string literals being stored inside the binary. Now that we know about slices, we can properly understand string literals:\nlet s = \"Hello, world!\";\n\nThe type of \"s\" here is \"&amp;str\": it’s a slice pointing to that specific point of the binary. This is also why string literals are immutable; \"&amp;str\" is an immutable reference.\nString Slices as Parameters\nKnowing that you can take slices of literals and \"String\" values leads us to one more improvement on \"first_word\", and that’s its signature:\nfn first_word(s: &amp;String) -&gt; &amp;str {\n\nA more experienced Rustacean would write the signature shown in Listing 4-9 instead because it allows us to use the same function on both \"&amp;String\" values and \"&amp;str\" values.\nfn first_word(s: &amp;str) -&gt; &amp;str {\n\nListing 4-9: Improving the \"first_word\" function by using a string slice for the type of the \"s\" parameter\nIf we have a string slice, we can pass that directly. If we have a \"String\", we can pass a slice of the \"String\" or a reference to the \"String\". This flexibility takes advantage of deref coercions, a feature we will cover in “Implicit Deref Coercions with Functions and Methods” section of Chapter 15.\nDefining a function to take a string slice instead of a reference to a \"String\" makes our API more general and useful without losing any functionality:\nFilename: src/main.rs\nfn main() {\n    let my_string = String::from(\"hello world\");\n\n    // \"first_word\" works on slices of \"String\"s, whether partial or whole\n    let word = first_word(&amp;my_string[0..6]);\n    let word = first_word(&amp;my_string[..]);\n    // \"first_word\" also works on references to \"String\"s, which are equivalent\n    // to whole slices of \"String\"s\n    let word = first_word(&amp;my_string);\n\n    let my_string_literal = \"hello world\";\n\n    // \"first_word\" works on slices of string literals, whether partial or whole\n    let word = first_word(&amp;my_string_literal[0..6]);\n    let word = first_word(&amp;my_string_literal[..]);\n\n    // Because string literals *are* string slices already,\n    // this works too, without the slice syntax!\n    let word = first_word(my_string_literal);\n}\n\nOther Slices\nString slices, as you might imagine, are specific to strings. But there’s a more general slice type too. Consider this array:\nlet a = [1, 2, 3, 4, 5];\n\nJust as we might want to refer to part of a string, we might want to refer to part of an array. We’d do so like this:\nlet a = [1, 2, 3, 4, 5];\n\nlet slice = &amp;a[1..3];\n\nassert_eq!(slice, &amp;[2, 3]);\n\nThis slice has the type \"&amp;[i32]\". It works the same way as string slices do, by storing a reference to the first element and a length. You’ll use this kind of slice for all sorts of other collections. We’ll discuss these collections in detail when we talk about vectors in Chapter 8.\nSummary\nThe concepts of ownership, borrowing, and slices ensure memory safety in Rust programs at compile time. The Rust language gives you control over your memory usage in the same way as other systems programming languages, but having the owner of data automatically clean up that data when the owner goes out of scope means you don’t have to write and debug extra code to get this control.\nOwnership affects how lots of other parts of Rust work, so we’ll talk about these concepts further throughout the rest of the book. Let’s move on to Chapter 5 and look at grouping pieces of data together in a \"struct\".\n\nUsing Structs to Structure Related Data\nA struct, or structure, is a custom data type that lets you package together and name multiple related values that make up a meaningful group. If you’re familiar with an object-oriented language, a struct is like an object’s data attributes. In this chapter, we’ll compare and contrast tuples with structs to build on what you already know and demonstrate when structs are a better way to group data.\nWe’ll demonstrate how to define and instantiate structs. We’ll discuss how to define associated functions, especially the kind of associated functions called methods, to specify behavior associated with a struct type. Structs and enums (discussed in Chapter 6) are the building blocks for creating new types in your program’s domain to take full advantage of Rust’s compile-time type checking.\n\nDefining and Instantiating Structs\nStructs are similar to tuples, discussed in “The Tuple Type” section, in that both hold multiple related values. Like tuples, the pieces of a struct can be different types. Unlike with tuples, in a struct you’ll name each piece of data so it’s clear what the values mean. Adding these names means that structs are more flexible than tuples: you don’t have to rely on the order of the data to specify or access the values of an instance.\nTo define a struct, we enter the keyword \"struct\" and name the entire struct. A struct’s name should describe the significance of the pieces of data being grouped together. Then, inside curly brackets, we define the names and types of the pieces of data, which we call fields. For example, Listing 5-1 shows a struct that stores information about a user account.\nFilename: src/main.rs\nstruct User {\n    active: bool,\n    username: String,\n    email: String,\n    sign_in_count: u64,\n}\n\nListing 5-1: A \"User\" struct definition\nTo use a struct after we’ve defined it, we create an instance of that struct by specifying concrete values for each of the fields. We create an instance by stating the name of the struct and then add curly brackets containing key: value pairs, where the keys are the names of the fields and the values are the data we want to store in those fields. We don’t have to specify the fields in the same order in which we declared them in the struct. In other words, the struct definition is like a general template for the type, and instances fill in that template with particular data to create values of the type. For example, we can declare a particular user as shown in Listing 5-2.\nFilename: src/main.rs\nfn main() {\n    let user1 = User {\n        active: true,\n        username: String::from(\"someusername123\"),\n        email: String::from(\"someone@example.com\"),\n        sign_in_count: 1,\n    };\n}\n\nListing 5-2: Creating an instance of the \"User\" struct\nTo get a specific value from a struct, we use dot notation. For example, to access this user’s email address, we use \"user1.email\". If the instance is mutable, we can change a value by using the dot notation and assigning into a particular field. Listing 5-3 shows how to change the value in the \"email\" field of a mutable \"User\" instance.\nFilename: src/main.rs\nfn main() {\n    let mut user1 = User {\n        active: true,\n        username: String::from(\"someusername123\"),\n        email: String::from(\"someone@example.com\"),\n        sign_in_count: 1,\n    };\n\n    user1.email = String::from(\"anotheremail@example.com\");\n}\n\nListing 5-3: Changing the value in the \"email\" field of a \"User\" instance\nNote that the entire instance must be mutable; Rust doesn’t allow us to mark only certain fields as mutable. As with any expression, we can construct a new instance of the struct as the last expression in the function body to implicitly return that new instance.\nListing 5-4 shows a \"build_user\" function that returns a \"User\" instance with the given email and username. The \"active\" field gets the value of \"true\", and the \"sign_in_count\" gets a value of \"1\".\nFilename: src/main.rs\nfn build_user(email: String, username: String) -&gt; User {\n    User {\n        active: true,\n        username: username,\n        email: email,\n        sign_in_count: 1,\n    }\n}\n\nListing 5-4: A \"build_user\" function that takes an email and username and returns a \"User\" instance\nIt makes sense to name the function parameters with the same name as the struct fields, but having to repeat the \"email\" and \"username\" field names and variables is a bit tedious. If the struct had more fields, repeating each name would get even more annoying. Luckily, there’s a convenient shorthand!\nUsing the Field Init Shorthand\nBecause the parameter names and the struct field names are exactly the same in Listing 5-4, we can use the field init shorthand syntax to rewrite \"build_user\" so it behaves exactly the same but doesn’t have the repetition of \"username\" and \"email\", as shown in Listing 5-5.\nFilename: src/main.rs\nfn build_user(email: String, username: String) -&gt; User {\n    User {\n        active: true,\n        username,\n        email,\n        sign_in_count: 1,\n    }\n}\n\nListing 5-5: A \"build_user\" function that uses field init shorthand because the \"username\" and \"email\" parameters have the same name as struct fields\nHere, we’re creating a new instance of the \"User\" struct, which has a field named \"email\". We want to set the \"email\" field’s value to the value in the \"email\" parameter of the \"build_user\" function. Because the \"email\" field and the \"email\" parameter have the same name, we only need to write \"email\" rather than \"email: email\".\nCreating Instances from Other Instances with Struct Update Syntax\nIt’s often useful to create a new instance of a struct that includes most of the values from another instance, but changes some. You can do this using struct update syntax.\nFirst, in Listing 5-6 we show how to create a new \"User\" instance in \"user2\" regularly, without the update syntax. We set a new value for \"email\" but otherwise use the same values from \"user1\" that we created in Listing 5-2.\nFilename: src/main.rs\nfn main() {\n    // --snip--\n\n    let user2 = User {\n        active: user1.active,\n        username: user1.username,\n        email: String::from(\"another@example.com\"),\n        sign_in_count: user1.sign_in_count,\n    };\n}\n\nListing 5-6: Creating a new \"User\" instance using one of the values from \"user1\"\nUsing struct update syntax, we can achieve the same effect with less code, as shown in Listing 5-7. The syntax \"..\" specifies that the remaining fields not explicitly set should have the same value as the fields in the given instance.\nFilename: src/main.rs\nfn main() {\n    // --snip--\n\n    let user2 = User {\n        email: String::from(\"another@example.com\"),\n        ..user1\n    };\n}\n\nListing 5-7: Using struct update syntax to set a new \"email\" value for a \"User\" instance but to use the rest of the values from \"user1\"\nThe code in Listing 5-7 also creates an instance in \"user2\" that has a different value for \"email\" but has the same values for the \"username\", \"active\", and \"sign_in_count\" fields from \"user1\". The \"..user1\" must come last to specify that any remaining fields should get their values from the corresponding fields in \"user1\", but we can choose to specify values for as many fields as we want in any order, regardless of the order of the fields in the struct’s definition.\nNote that the struct update syntax uses \"=\" like an assignment; this is because it moves the data, just as we saw in the “Variables and Data Interacting with Move” section. In this example, we can no longer use \"user1\" as a whole after creating \"user2\" because the \"String\" in the \"username\" field of \"user1\" was moved into \"user2\". If we had given \"user2\" new \"String\" values for both \"email\" and \"username\", and thus only used the \"active\" and \"sign_in_count\" values from \"user1\", then \"user1\" would still be valid after creating \"user2\". Both \"active\" and \"sign_in_count\" are types that implement the \"Copy\" trait, so the behavior we discussed in the “Stack-Only Data: Copy” section would apply.\nUsing Tuple Structs Without Named Fields to Create Different Types\nRust also supports structs that look similar to tuples, called tuple structs. Tuple structs have the added meaning the struct name provides but don’t have names associated with their fields; rather, they just have the types of the fields. Tuple structs are useful when you want to give the whole tuple a name and make the tuple a different type from other tuples, and when naming each field as in a regular struct would be verbose or redundant.\nTo define a tuple struct, start with the \"struct\" keyword and the struct name followed by the types in the tuple. For example, here we define and use two tuple structs named \"Color\" and \"Point\":\nFilename: src/main.rs\nstruct Color(i32, i32, i32);\nstruct Point(i32, i32, i32);\n\nfn main() {\n    let black = Color(0, 0, 0);\n    let origin = Point(0, 0, 0);\n}\n\nNote that the \"black\" and \"origin\" values are different types because they’re instances of different tuple structs. Each struct you define is its own type, even though the fields within the struct might have the same types. For example, a function that takes a parameter of type \"Color\" cannot take a \"Point\" as an argument, even though both types are made up of three \"i32\" values. Otherwise, tuple struct instances are similar to tuples in that you can destructure them into their individual pieces, and you can use a \".\" followed by the index to access an individual value.\nUnit-Like Structs Without Any Fields\nYou can also define structs that don’t have any fields! These are called unit-like structs because they behave similarly to \"()\", the unit type that we mentioned in “The Tuple Type” section. Unit-like structs can be useful when you need to implement a trait on some type but don’t have any data that you want to store in the type itself. We’ll discuss traits in Chapter 10. Here’s an example of declaring and instantiating a unit struct named \"AlwaysEqual\":\nFilename: src/main.rs\nstruct AlwaysEqual;\n\nfn main() {\n    let subject = AlwaysEqual;\n}\n\nTo define \"AlwaysEqual\", we use the \"struct\" keyword, the name we want, and then a semicolon. No need for curly brackets or parentheses! Then we can get an instance of \"AlwaysEqual\" in the \"subject\" variable in a similar way: using the name we defined, without any curly brackets or parentheses. Imagine that later we’ll implement behavior for this type such that every instance of \"AlwaysEqual\" is always equal to every instance of any other type, perhaps to have a known result for testing purposes. We wouldn’t need any data to implement that behavior! You’ll see in Chapter 10 how to define traits and implement them on any type, including unit-like structs.\n\nOwnership of Struct Data\nIn the \"User\" struct definition in Listing 5-1, we used the owned \"String\" type rather than the \"&amp;str\" string slice type. This is a deliberate choice because we want each instance of this struct to own all of its data and for that data to be valid for as long as the entire struct is valid.\nIt’s also possible for structs to store references to data owned by something else, but to do so requires the use of lifetimes, a Rust feature that we’ll discuss in Chapter 10. Lifetimes ensure that the data referenced by a struct is valid for as long as the struct is. Let’s say you try to store a reference in a struct without specifying lifetimes, like the following; this won’t work:\nFilename: src/main.rs\nstruct User {\n    active: bool,\n    username: &amp;str,\n    email: &amp;str,\n    sign_in_count: u64,\n}\n\nfn main() {\n    let user1 = User {\n        active: true,\n        username: \"someusername123\",\n        email: \"someone@example.com\",\n        sign_in_count: 1,\n    };\n}\n\nThe compiler will complain that it needs lifetime specifiers:\n$ cargo run\n   Compiling structs v0.1.0 (file:///projects/structs)\nerror[E0106]: missing lifetime specifier\n --&gt; src/main.rs:3:15\n  |\n3 |     username: &amp;str,\n  |               ^ expected named lifetime parameter\n  |\nhelp: consider introducing a named lifetime parameter\n  |\n1 ~ struct User&lt;'a&gt; {\n2 |     active: bool,\n3 ~     username: &amp;'a str,\n  |\n\nerror[E0106]: missing lifetime specifier\n --&gt; src/main.rs:4:12\n  |\n4 |     email: &amp;str,\n  |            ^ expected named lifetime parameter\n  |\nhelp: consider introducing a named lifetime parameter\n  |\n1 ~ struct User&lt;'a&gt; {\n2 |     active: bool,\n3 |     username: &amp;str,\n4 ~     email: &amp;'a str,\n  |\n\nFor more information about this error, try \"rustc --explain E0106\".\nerror: could not compile \"structs\" due to 2 previous errors\n\nIn Chapter 10, we’ll discuss how to fix these errors so you can store references in structs, but for now, we’ll fix errors like these using owned types like \"String\" instead of references like \"&amp;str\".\n\n\nAn Example Program Using Structs\nTo understand when we might want to use structs, let’s write a program that calculates the area of a rectangle. We’ll start by using single variables, and then refactor the program until we’re using structs instead.\nLet’s make a new binary project with Cargo called rectangles that will take the width and height of a rectangle specified in pixels and calculate the area of the rectangle. Listing 5-8 shows a short program with one way of doing exactly that in our project’s src/main.rs.\nFilename: src/main.rs\nfn main() {\n    let width1 = 30;\n    let height1 = 50;\n\n    println!(\n        \"The area of the rectangle is {} square pixels.\",\n        area(width1, height1)\n    );\n}\n\nfn area(width: u32, height: u32) -&gt; u32 {\n    width * height\n}\n\nListing 5-8: Calculating the area of a rectangle specified by separate width and height variables\nNow, run this program using \"cargo run\":\n$ cargo run\n   Compiling rectangles v0.1.0 (file:///projects/rectangles)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.42s\n     Running \"target/debug/rectangles\"\nThe area of the rectangle is 1500 square pixels.\n\nThis code succeeds in figuring out the area of the rectangle by calling the \"area\" function with each dimension, but we can do more to make this code clear and readable.\nThe issue with this code is evident in the signature of \"area\":\nfn area(width: u32, height: u32) -&gt; u32 {\n\nThe \"area\" function is supposed to calculate the area of one rectangle, but the function we wrote has two parameters, and it’s not clear anywhere in our program that the parameters are related. It would be more readable and more manageable to group width and height together. We’ve already discussed one way we might do that in “The Tuple Type” section of Chapter 3: by using tuples.\nRefactoring with Tuples\nListing 5-9 shows another version of our program that uses tuples.\nFilename: src/main.rs\nfn main() {\n    let rect1 = (30, 50);\n\n    println!(\n        \"The area of the rectangle is {} square pixels.\",\n        area(rect1)\n    );\n}\n\nfn area(dimensions: (u32, u32)) -&gt; u32 {\n    dimensions.0 * dimensions.1\n}\n\nListing 5-9: Specifying the width and height of the rectangle with a tuple\nIn one way, this program is better. Tuples let us add a bit of structure, and we’re now passing just one argument. But in another way, this version is less clear: tuples don’t name their elements, so we have to index into the parts of the tuple, making our calculation less obvious.\nMixing up the width and height wouldn’t matter for the area calculation, but if we want to draw the rectangle on the screen, it would matter! We would have to keep in mind that \"width\" is the tuple index \"0\" and \"height\" is the tuple index \"1\". This would be even harder for someone else to figure out and keep in mind if they were to use our code. Because we haven’t conveyed the meaning of our data in our code, it’s now easier to introduce errors.\nRefactoring with Structs: Adding More Meaning\nWe use structs to add meaning by labeling the data. We can transform the tuple we’re using into a struct with a name for the whole as well as names for the parts, as shown in Listing 5-10.\nFilename: src/main.rs\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n\n    println!(\n        \"The area of the rectangle is {} square pixels.\",\n        area(&amp;rect1)\n    );\n}\n\nfn area(rectangle: &amp;Rectangle) -&gt; u32 {\n    rectangle.width * rectangle.height\n}\n\nListing 5-10: Defining a \"Rectangle\" struct\nHere we’ve defined a struct and named it \"Rectangle\". Inside the curly brackets, we defined the fields as \"width\" and \"height\", both of which have type \"u32\". Then, in \"main\", we created a particular instance of \"Rectangle\" that has a width of \"30\" and a height of \"50\".\nOur \"area\" function is now defined with one parameter, which we’ve named \"rectangle\", whose type is an immutable borrow of a struct \"Rectangle\" instance. As mentioned in Chapter 4, we want to borrow the struct rather than take ownership of it. This way, \"main\" retains its ownership and can continue using \"rect1\", which is the reason we use the \"&amp;\" in the function signature and where we call the function.\nThe \"area\" function accesses the \"width\" and \"height\" fields of the \"Rectangle\" instance (note that accessing fields of a borrowed struct instance does not move the field values, which is why you often see borrows of structs). Our function signature for \"area\" now says exactly what we mean: calculate the area of \"Rectangle\", using its \"width\" and \"height\" fields. This conveys that the width and height are related to each other, and it gives descriptive names to the values rather than using the tuple index values of \"0\" and \"1\". This is a win for clarity.\nAdding Useful Functionality with Derived Traits\nIt’d be useful to be able to print an instance of \"Rectangle\" while we’re debugging our program and see the values for all its fields. Listing 5-11 tries using the \"println!\" macro as we have used in previous chapters. This won’t work, however.\nFilename: src/main.rs\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n\n    println!(\"rect1 is {}\", rect1);\n}\n\nListing 5-11: Attempting to print a \"Rectangle\" instance\nWhen we compile this code, we get an error with this core message:\nerror[E0277]: \"Rectangle\" doesn't implement \"std::fmt::Display\"\n\nThe \"println!\" macro can do many kinds of formatting, and by default, the curly brackets tell \"println!\" to use formatting known as \"Display\": output intended for direct end user consumption. The primitive types we’ve seen so far implement \"Display\" by default because there’s only one way you’d want to show a \"1\" or any other primitive type to a user. But with structs, the way \"println!\" should format the output is less clear because there are more display possibilities: Do you want commas or not? Do you want to print the curly brackets? Should all the fields be shown? Due to this ambiguity, Rust doesn’t try to guess what we want, and structs don’t have a provided implementation of \"Display\" to use with \"println!\" and the \"{}\" placeholder.\nIf we continue reading the errors, we’ll find this helpful note:\n   = help: the trait \"std::fmt::Display\" is not implemented for \"Rectangle\"\n   = note: in format strings you may be able to use \"{:?}\" (or {:#?} for pretty-print) instead\n\nLet’s try it! The \"println!\" macro call will now look like \"println!(\"rect1 is {:?}\", rect1);\". Putting the specifier \":?\" inside the curly brackets tells \"println!\" we want to use an output format called \"Debug\". The \"Debug\" trait enables us to print our struct in a way that is useful for developers so we can see its value while we’re debugging our code.\nCompile the code with this change. Drat! We still get an error:\nerror[E0277]: \"Rectangle\" doesn't implement \"Debug\"\n\nBut again, the compiler gives us a helpful note:\n   = help: the trait \"Debug\" is not implemented for \"Rectangle\"\n   = note: add \"#[derive(Debug)]\" to \"Rectangle\" or manually \"impl Debug for Rectangle\"\n\nRust does include functionality to print out debugging information, but we have to explicitly opt in to make that functionality available for our struct. To do that, we add the outer attribute \"#[derive(Debug)]\" just before the struct definition, as shown in Listing 5-12.\nFilename: src/main.rs\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n\n    println!(\"rect1 is {:?}\", rect1);\n}\n\nListing 5-12: Adding the attribute to derive the \"Debug\" trait and printing the \"Rectangle\" instance using debug formatting\nNow when we run the program, we won’t get any errors, and we’ll see the following output:\n$ cargo run\n   Compiling rectangles v0.1.0 (file:///projects/rectangles)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.48s\n     Running \"target/debug/rectangles\"\nrect1 is Rectangle { width: 30, height: 50 }\n\nNice! It’s not the prettiest output, but it shows the values of all the fields for this instance, which would definitely help during debugging. When we have larger structs, it’s useful to have output that’s a bit easier to read; in those cases, we can use \"{:#?}\" instead of \"{:?}\" in the \"println!\" string. In this example, using the \"{:#?}\" style will output the following:\n$ cargo run\n   Compiling rectangles v0.1.0 (file:///projects/rectangles)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.48s\n     Running \"target/debug/rectangles\"\nrect1 is Rectangle {\n    width: 30,\n    height: 50,\n}\n\nAnother way to print out a value using the \"Debug\" format is to use the \"dbg!\" macro, which takes ownership of an expression (as opposed to \"println!\", which takes a reference), prints the file and line number of where that \"dbg!\" macro call occurs in your code along with the resultant value of that expression, and returns ownership of the value.\n\nNote: Calling the \"dbg!\" macro prints to the standard error console stream (\"stderr\"), as opposed to \"println!\", which prints to the standard output console stream (\"stdout\"). We’ll talk more about \"stderr\" and \"stdout\" in the “Writing Error Messages to Standard Error Instead of Standard Output” section in Chapter 12.\n\nHere’s an example where we’re interested in the value that gets assigned to the \"width\" field, as well as the value of the whole struct in \"rect1\":\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let scale = 2;\n    let rect1 = Rectangle {\n        width: dbg!(30 * scale),\n        height: 50,\n    };\n\n    dbg!(&amp;rect1);\n}\n\nWe can put \"dbg!\" around the expression \"30 * scale\" and, because \"dbg!\" returns ownership of the expression’s value, the \"width\" field will get the same value as if we didn’t have the \"dbg!\" call there. We don’t want \"dbg!\" to take ownership of \"rect1\", so we use a reference to \"rect1\" in the next call. Here’s what the output of this example looks like:\n$ cargo run\n   Compiling rectangles v0.1.0 (file:///projects/rectangles)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.61s\n     Running \"target/debug/rectangles\"\n[src/main.rs:10] 30 * scale = 60\n[src/main.rs:14] &amp;rect1 = Rectangle {\n    width: 60,\n    height: 50,\n}\n\nWe can see the first bit of output came from src/main.rs line 10 where we’re debugging the expression \"30 * scale\", and its resultant value is \"60\" (the \"Debug\" formatting implemented for integers is to print only their value). The \"dbg!\" call on line 14 of src/main.rs outputs the value of \"&amp;rect1\", which is the \"Rectangle\" struct. This output uses the pretty \"Debug\" formatting of the \"Rectangle\" type. The \"dbg!\" macro can be really helpful when you’re trying to figure out what your code is doing!\nIn addition to the \"Debug\" trait, Rust has provided a number of traits for us to use with the \"derive\" attribute that can add useful behavior to our custom types. Those traits and their behaviors are listed in Appendix C. We’ll cover how to implement these traits with custom behavior as well as how to create your own traits in Chapter 10. There are also many attributes other than \"derive\"; for more information, see the “Attributes” section of the Rust Reference.\nOur \"area\" function is very specific: it only computes the area of rectangles. It would be helpful to tie this behavior more closely to our \"Rectangle\" struct because it won’t work with any other type. Let’s look at how we can continue to refactor this code by turning the \"area\" function into an \"area\" method defined on our \"Rectangle\" type.\n\nMethod Syntax\nMethods are similar to functions: we declare them with the \"fn\" keyword and a name, they can have parameters and a return value, and they contain some code that’s run when the method is called from somewhere else. Unlike functions, methods are defined within the context of a struct (or an enum or a trait object, which we cover in Chapter 6 and Chapter 17, respectively), and their first parameter is always \"self\", which represents the instance of the struct the method is being called on.\nDefining Methods\nLet’s change the \"area\" function that has a \"Rectangle\" instance as a parameter and instead make an \"area\" method defined on the \"Rectangle\" struct, as shown in Listing 5-13.\nFilename: src/main.rs\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nimpl Rectangle {\n    fn area(&amp;self) -&gt; u32 {\n        self.width * self.height\n    }\n}\n\nfn main() {\n    let rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n\n    println!(\n        \"The area of the rectangle is {} square pixels.\",\n        rect1.area()\n    );\n}\n\nListing 5-13: Defining an \"area\" method on the \"Rectangle\" struct\nTo define the function within the context of \"Rectangle\", we start an \"impl\" (implementation) block for \"Rectangle\". Everything within this \"impl\" block will be associated with the \"Rectangle\" type. Then we move the \"area\" function within the \"impl\" curly brackets and change the first (and in this case, only) parameter to be \"self\" in the signature and everywhere within the body. In \"main\", where we called the \"area\" function and passed \"rect1\" as an argument, we can instead use method syntax to call the \"area\" method on our \"Rectangle\" instance. The method syntax goes after an instance: we add a dot followed by the method name, parentheses, and any arguments.\nIn the signature for \"area\", we use \"&amp;self\" instead of \"rectangle: &amp;Rectangle\". The \"&amp;self\" is actually short for \"self: &amp;Self\". Within an \"impl\" block, the type \"Self\" is an alias for the type that the \"impl\" block is for. Methods must have a parameter named \"self\" of type \"Self\" for their first parameter, so Rust lets you abbreviate this with only the name \"self\" in the first parameter spot. Note that we still need to use the \"&amp;\" in front of the \"self\" shorthand to indicate that this method borrows the \"Self\" instance, just as we did in \"rectangle: &amp;Rectangle\". Methods can take ownership of \"self\", borrow \"self\" immutably, as we’ve done here, or borrow \"self\" mutably, just as they can any other parameter.\nWe chose \"&amp;self\" here for the same reason we used \"&amp;Rectangle\" in the function version: we don’t want to take ownership, and we just want to read the data in the struct, not write to it. If we wanted to change the instance that we’ve called the method on as part of what the method does, we’d use \"&amp;mut self\" as the first parameter. Having a method that takes ownership of the instance by using just \"self\" as the first parameter is rare; this technique is usually used when the method transforms \"self\" into something else and you want to prevent the caller from using the original instance after the transformation.\nThe main reason for using methods instead of functions, in addition to providing method syntax and not having to repeat the type of \"self\" in every method’s signature, is for organization. We’ve put all the things we can do with an instance of a type in one \"impl\" block rather than making future users of our code search for capabilities of \"Rectangle\" in various places in the library we provide.\nNote that we can choose to give a method the same name as one of the struct’s fields. For example, we can define a method on \"Rectangle\" that is also named \"width\":\nFilename: src/main.rs\nimpl Rectangle {\n    fn width(&amp;self) -&gt; bool {\n        self.width &gt; 0\n    }\n}\n\nfn main() {\n    let rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n\n    if rect1.width() {\n        println!(\"The rectangle has a nonzero width; it is {}\", rect1.width);\n    }\n}\n\nHere, we’re choosing to make the \"width\" method return \"true\" if the value in the instance’s \"width\" field is greater than \"0\" and \"false\" if the value is \"0\": we can use a field within a method of the same name for any purpose. In \"main\", when we follow \"rect1.width\" with parentheses, Rust knows we mean the method \"width\". When we don’t use parentheses, Rust knows we mean the field \"width\".\nOften, but not always, when we give a method the same name as a field we want it to only return the value in the field and do nothing else. Methods like this are called getters, and Rust does not implement them automatically for struct fields as some other languages do. Getters are useful because you can make the field private but the method public, and thus enable read-only access to that field as part of the type’s public API. We will discuss what public and private are and how to designate a field or method as public or private in Chapter 7.\n\nWhere’s the \"-&gt;\" Operator?\nIn C and C++, two different operators are used for calling methods: you use \".\" if you’re calling a method on the object directly and \"-&gt;\" if you’re calling the method on a pointer to the object and need to dereference the pointer first. In other words, if \"object\" is a pointer, \"object-&gt;something()\" is similar to \"(*object).something()\".\nRust doesn’t have an equivalent to the \"-&gt;\" operator; instead, Rust has a feature called automatic referencing and dereferencing. Calling methods is one of the few places in Rust that has this behavior.\nHere’s how it works: when you call a method with \"object.something()\", Rust automatically adds in \"&amp;\", \"&amp;mut\", or \"*\" so \"object\" matches the signature of the method. In other words, the following are the same:\np1.distance(&amp;p2);\n(&amp;p1).distance(&amp;p2);\n\nThe first one looks much cleaner. This automatic referencing behavior works because methods have a clear receiver—the type of \"self\". Given the receiver and name of a method, Rust can figure out definitively whether the method is reading (\"&amp;self\"), mutating (\"&amp;mut self\"), or consuming (\"self\"). The fact that Rust makes borrowing implicit for method receivers is a big part of making ownership ergonomic in practice.\n\nMethods with More Parameters\nLet’s practice using methods by implementing a second method on the \"Rectangle\" struct. This time we want an instance of \"Rectangle\" to take another instance of \"Rectangle\" and return \"true\" if the second \"Rectangle\" can fit completely within \"self\" (the first \"Rectangle\"); otherwise, it should return \"false\". That is, once we’ve defined the \"can_hold\" method, we want to be able to write the program shown in Listing 5-14.\nFilename: src/main.rs\nfn main() {\n    let rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n    let rect2 = Rectangle {\n        width: 10,\n        height: 40,\n    };\n    let rect3 = Rectangle {\n        width: 60,\n        height: 45,\n    };\n\n    println!(\"Can rect1 hold rect2? {}\", rect1.can_hold(&amp;rect2));\n    println!(\"Can rect1 hold rect3? {}\", rect1.can_hold(&amp;rect3));\n}\n\nListing 5-14: Using the as-yet-unwritten \"can_hold\" method\nThe expected output would look like the following because both dimensions of \"rect2\" are smaller than the dimensions of \"rect1\", but \"rect3\" is wider than \"rect1\":\nCan rect1 hold rect2? true\nCan rect1 hold rect3? false\n\nWe know we want to define a method, so it will be within the \"impl Rectangle\" block. The method name will be \"can_hold\", and it will take an immutable borrow of another \"Rectangle\" as a parameter. We can tell what the type of the parameter will be by looking at the code that calls the method: \"rect1.can_hold(&amp;rect2)\" passes in \"&amp;rect2\", which is an immutable borrow to \"rect2\", an instance of \"Rectangle\". This makes sense because we only need to read \"rect2\" (rather than write, which would mean we’d need a mutable borrow), and we want \"main\" to retain ownership of \"rect2\" so we can use it again after calling the \"can_hold\" method. The return value of \"can_hold\" will be a Boolean, and the implementation will check whether the width and height of \"self\" are greater than the width and height of the other \"Rectangle\", respectively. Let’s add the new \"can_hold\" method to the \"impl\" block from Listing 5-13, shown in Listing 5-15.\nFilename: src/main.rs\nimpl Rectangle {\n    fn area(&amp;self) -&gt; u32 {\n        self.width * self.height\n    }\n\n    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {\n        self.width &gt; other.width &amp;&amp; self.height &gt; other.height\n    }\n}\n\nListing 5-15: Implementing the \"can_hold\" method on \"Rectangle\" that takes another \"Rectangle\" instance as a parameter\nWhen we run this code with the \"main\" function in Listing 5-14, we’ll get our desired output. Methods can take multiple parameters that we add to the signature after the \"self\" parameter, and those parameters work just like parameters in functions.\nAssociated Functions\nAll functions defined within an \"impl\" block are called associated functions because they’re associated with the type named after the \"impl\". We can define associated functions that don’t have \"self\" as their first parameter (and thus are not methods) because they don’t need an instance of the type to work with. We’ve already used one function like this: the \"String::from\" function that’s defined on the \"String\" type.\nAssociated functions that aren’t methods are often used for constructors that will return a new instance of the struct. These are often called \"new\", but \"new\" isn’t a special name and isn’t built into the language. For example, we could choose to provide an associated function named \"square\" that would have one dimension parameter and use that as both width and height, thus making it easier to create a square \"Rectangle\" rather than having to specify the same value twice:\nFilename: src/main.rs\nimpl Rectangle {\n    fn square(size: u32) -&gt; Self {\n        Self {\n            width: size,\n            height: size,\n        }\n    }\n}\n\nThe \"Self\" keywords in the return type and in the body of the function are aliases for the type that appears after the \"impl\" keyword, which in this case is \"Rectangle\".\nTo call this associated function, we use the \"::\" syntax with the struct name; \"let sq = Rectangle::square(3);\" is an example. This function is namespaced by the struct: the \"::\" syntax is used for both associated functions and namespaces created by modules. We’ll discuss modules in Chapter 7.\nMultiple \"impl\" Blocks\nEach struct is allowed to have multiple \"impl\" blocks. For example, Listing 5-15 is equivalent to the code shown in Listing 5-16, which has each method in its own \"impl\" block.\nimpl Rectangle {\n    fn area(&amp;self) -&gt; u32 {\n        self.width * self.height\n    }\n}\n\nimpl Rectangle {\n    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {\n        self.width &gt; other.width &amp;&amp; self.height &gt; other.height\n    }\n}\n\nListing 5-16: Rewriting Listing 5-15 using multiple \"impl\" blocks\nThere’s no reason to separate these methods into multiple \"impl\" blocks here, but this is valid syntax. We’ll see a case in which multiple \"impl\" blocks are useful in Chapter 10, where we discuss generic types and traits.\nSummary\nStructs let you create custom types that are meaningful for your domain. By using structs, you can keep associated pieces of data connected to each other and name each piece to make your code clear. In \"impl\" blocks, you can define functions that are associated with your type, and methods are a kind of associated function that let you specify the behavior that instances of your structs have.\nBut structs aren’t the only way you can create custom types: let’s turn to Rust’s enum feature to add another tool to your toolbox.\n\nEnums and Pattern Matching\nIn this chapter, we’ll look at enumerations, also referred to as enums. Enums allow you to define a type by enumerating its possible variants. First we’ll define and use an enum to show how an enum can encode meaning along with data. Next, we’ll explore a particularly useful enum, called \"Option\", which expresses that a value can be either something or nothing. Then we’ll look at how pattern matching in the \"match\" expression makes it easy to run different code for different values of an enum. Finally, we’ll cover how the \"if let\" construct is another convenient and concise idiom available to handle enums in your code.\n\nDefining an Enum\nWhere structs give you a way of grouping together related fields and data, like a \"Rectangle\" with its \"width\" and \"height\", enums give you a way of saying a value is one of a possible set of values. For example, we may want to say that \"Rectangle\" is one of a set of possible shapes that also includes \"Circle\" and \"Triangle\". To do this, Rust allows us to encode these possibilities as an enum.\nLet’s look at a situation we might want to express in code and see why enums are useful and more appropriate than structs in this case. Say we need to work with IP addresses. Currently, two major standards are used for IP addresses: version four and version six. Because these are the only possibilities for an IP address that our program will come across, we can enumerate all possible variants, which is where enumeration gets its name.\nAny IP address can be either a version four or a version six address, but not both at the same time. That property of IP addresses makes the enum data structure appropriate because an enum value can only be one of its variants. Both version four and version six addresses are still fundamentally IP addresses, so they should be treated as the same type when the code is handling situations that apply to any kind of IP address.\nWe can express this concept in code by defining an \"IpAddrKind\" enumeration and listing the possible kinds an IP address can be, \"V4\" and \"V6\". These are the variants of the enum:\nenum IpAddrKind {\n    V4,\n    V6,\n}\n\n\"IpAddrKind\" is now a custom data type that we can use elsewhere in our code.\nEnum Values\nWe can create instances of each of the two variants of \"IpAddrKind\" like this:\n    let four = IpAddrKind::V4;\n    let six = IpAddrKind::V6;\n\nNote that the variants of the enum are namespaced under its identifier, and we use a double colon to separate the two. This is useful because now both values \"IpAddrKind::V4\" and \"IpAddrKind::V6\" are of the same type: \"IpAddrKind\". We can then, for instance, define a function that takes any \"IpAddrKind\":\nfn route(ip_kind: IpAddrKind) {}\n\nAnd we can call this function with either variant:\n    route(IpAddrKind::V4);\n    route(IpAddrKind::V6);\n\nUsing enums has even more advantages. Thinking more about our IP address type, at the moment we don’t have a way to store the actual IP address data; we only know what kind it is. Given that you just learned about structs in Chapter 5, you might be tempted to tackle this problem with structs as shown in Listing 6-1.\n    enum IpAddrKind {\n        V4,\n        V6,\n    }\n\n    struct IpAddr {\n        kind: IpAddrKind,\n        address: String,\n    }\n\n    let home = IpAddr {\n        kind: IpAddrKind::V4,\n        address: String::from(\"127.0.0.1\"),\n    };\n\n    let loopback = IpAddr {\n        kind: IpAddrKind::V6,\n        address: String::from(\"::1\"),\n    };\n\nListing 6-1: Storing the data and \"IpAddrKind\" variant of an IP address using a \"struct\"\nHere, we’ve defined a struct \"IpAddr\" that has two fields: a \"kind\" field that is of type \"IpAddrKind\" (the enum we defined previously) and an \"address\" field of type \"String\". We have two instances of this struct. The first is \"home\", and it has the value \"IpAddrKind::V4\" as its \"kind\" with associated address data of \"127.0.0.1\". The second instance is \"loopback\". It has the other variant of \"IpAddrKind\" as its \"kind\" value, \"V6\", and has address \"::1\" associated with it. We’ve used a struct to bundle the \"kind\" and \"address\" values together, so now the variant is associated with the value.\nHowever, representing the same concept using just an enum is more concise: rather than an enum inside a struct, we can put data directly into each enum variant. This new definition of the \"IpAddr\" enum says that both \"V4\" and \"V6\" variants will have associated \"String\" values:\n    enum IpAddr {\n        V4(String),\n        V6(String),\n    }\n\n    let home = IpAddr::V4(String::from(\"127.0.0.1\"));\n\n    let loopback = IpAddr::V6(String::from(\"::1\"));\n\nWe attach data to each variant of the enum directly, so there is no need for an extra struct. Here, it’s also easier to see another detail of how enums work: the name of each enum variant that we define also becomes a function that constructs an instance of the enum. That is, \"IpAddr::V4()\" is a function call that takes a \"String\" argument and returns an instance of the \"IpAddr\" type. We automatically get this constructor function defined as a result of defining the enum.\nThere’s another advantage to using an enum rather than a struct: each variant can have different types and amounts of associated data. Version four IP addresses will always have four numeric components that will have values between 0 and 255. If we wanted to store \"V4\" addresses as four \"u8\" values but still express \"V6\" addresses as one \"String\" value, we wouldn’t be able to with a struct. Enums handle this case with ease:\n    enum IpAddr {\n        V4(u8, u8, u8, u8),\n        V6(String),\n    }\n\n    let home = IpAddr::V4(127, 0, 0, 1);\n\n    let loopback = IpAddr::V6(String::from(\"::1\"));\n\nWe’ve shown several different ways to define data structures to store version four and version six IP addresses. However, as it turns out, wanting to store IP addresses and encode which kind they are is so common that the standard library has a definition we can use! Let’s look at how the standard library defines \"IpAddr\": it has the exact enum and variants that we’ve defined and used, but it embeds the address data inside the variants in the form of two different structs, which are defined differently for each variant:\nstruct Ipv4Addr {\n    // --snip--\n}\n\nstruct Ipv6Addr {\n    // --snip--\n}\n\nenum IpAddr {\n    V4(Ipv4Addr),\n    V6(Ipv6Addr),\n}\n\nThis code illustrates that you can put any kind of data inside an enum variant: strings, numeric types, or structs, for example. You can even include another enum! Also, standard library types are often not much more complicated than what you might come up with.\nNote that even though the standard library contains a definition for \"IpAddr\", we can still create and use our own definition without conflict because we haven’t brought the standard library’s definition into our scope. We’ll talk more about bringing types into scope in Chapter 7.\nLet’s look at another example of an enum in Listing 6-2: this one has a wide variety of types embedded in its variants.\nenum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n}\n\nListing 6-2: A \"Message\" enum whose variants each store different amounts and types of values\nThis enum has four variants with different types:\n\n\"Quit\" has no data associated with it at all.\n\"Move\" has named fields, like a struct does.\n\"Write\" includes a single \"String\".\n\"ChangeColor\" includes three \"i32\" values.\n\nDefining an enum with variants such as the ones in Listing 6-2 is similar to defining different kinds of struct definitions, except the enum doesn’t use the \"struct\" keyword and all the variants are grouped together under the \"Message\" type. The following structs could hold the same data that the preceding enum variants hold:\nstruct QuitMessage; // unit struct\nstruct MoveMessage {\n    x: i32,\n    y: i32,\n}\nstruct WriteMessage(String); // tuple struct\nstruct ChangeColorMessage(i32, i32, i32); // tuple struct\n\nBut if we used the different structs, each of which has its own type, we couldn’t as easily define a function to take any of these kinds of messages as we could with the \"Message\" enum defined in Listing 6-2, which is a single type.\nThere is one more similarity between enums and structs: just as we’re able to define methods on structs using \"impl\", we’re also able to define methods on enums. Here’s a method named \"call\" that we could define on our \"Message\" enum:\n    impl Message {\n        fn call(&amp;self) {\n            // method body would be defined here\n        }\n    }\n\n    let m = Message::Write(String::from(\"hello\"));\n    m.call();\n\nThe body of the method would use \"self\" to get the value that we called the method on. In this example, we’ve created a variable \"m\" that has the value \"Message::Write(String::from(\"hello\"))\", and that is what \"self\" will be in the body of the \"call\" method when \"m.call()\" runs.\nLet’s look at another enum in the standard library that is very common and useful: \"Option\".\nThe \"Option\" Enum and Its Advantages Over Null Values\nThis section explores a case study of \"Option\", which is another enum defined by the standard library. The \"Option\" type encodes the very common scenario in which a value could be something or it could be nothing.\nFor example, if you request the first item in a non-empty list, you would get a value. If you request the first item in an empty list, you would get nothing. Expressing this concept in terms of the type system means the compiler can check whether you’ve handled all the cases you should be handling; this functionality can prevent bugs that are extremely common in other programming languages.\nProgramming language design is often thought of in terms of which features you include, but the features you exclude are important too. Rust doesn’t have the null feature that many other languages have. Null is a value that means there is no value there. In languages with null, variables can always be in one of two states: null or not-null.\nIn his 2009 presentation “Null References: The Billion Dollar Mistake,” Tony Hoare, the inventor of null, has this to say:\n\nI call it my billion-dollar mistake. At that time, I was designing the first comprehensive type system for references in an object-oriented language. My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn’t resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.\n\nThe problem with null values is that if you try to use a null value as a not-null value, you’ll get an error of some kind. Because this null or not-null property is pervasive, it’s extremely easy to make this kind of error.\nHowever, the concept that null is trying to express is still a useful one: a null is a value that is currently invalid or absent for some reason.\nThe problem isn’t really with the concept but with the particular implementation. As such, Rust does not have nulls, but it does have an enum that can encode the concept of a value being present or absent. This enum is \"Option\", and it is defined by the standard library as follows:\nenum Option&lt;T&gt; {\n    None,\n    Some(T),\n}\n\nThe \"Option\" enum is so useful that it’s even included in the prelude; you don’t need to bring it into scope explicitly. Its variants are also included in the prelude: you can use \"Some\" and \"None\" directly without the \"Option::\" prefix. The \"Option\" enum is still just a regular enum, and \"Some(T)\" and \"None\" are still variants of type \"Option\".\nThe \"\" syntax is a feature of Rust we haven’t talked about yet. It’s a generic type parameter, and we’ll cover generics in more detail in Chapter 10. For now, all you need to know is that \"\" means that the \"Some\" variant of the \"Option\" enum can hold one piece of data of any type, and that each concrete type that gets used in place of \"T\" makes the overall \"Option\" type a different type. Here are some examples of using \"Option\" values to hold number types and string types:\n    let some_number = Some(5);\n    let some_char = Some('e');\n\n    let absent_number: Option&lt;i32&gt; = None;\n\nThe type of \"some_number\" is \"Option\". The type of \"some_char\" is \"Option\", which is a different type. Rust can infer these types because we’ve specified a value inside the \"Some\" variant. For \"absent_number\", Rust requires us to annotate the overall \"Option\" type: the compiler can’t infer the type that the corresponding \"Some\" variant will hold by looking only at a \"None\" value. Here, we tell Rust that we mean for \"absent_number\" to be of type \"Option\".\nWhen we have a \"Some\" value, we know that a value is present and the value is held within the \"Some\". When we have a \"None\" value, in some sense it means the same thing as null: we don’t have a valid value. So why is having \"Option\" any better than having null?\nIn short, because \"Option\" and \"T\" (where \"T\" can be any type) are different types, the compiler won’t let us use an \"Option\" value as if it were definitely a valid value. For example, this code won’t compile, because it’s trying to add an \"i8\" to an \"Option\":\n    let x: i8 = 5;\n    let y: Option&lt;i8&gt; = Some(5);\n\n    let sum = x + y;\n\nIf we run this code, we get an error message like this one:\n$ cargo run\n   Compiling enums v0.1.0 (file:///projects/enums)\nerror[E0277]: cannot add \"Option&lt;i8&gt;\" to \"i8\"\n --&gt; src/main.rs:5:17\n  |\n5 |     let sum = x + y;\n  |                 ^ no implementation for \"i8 + Option&lt;i8&gt;\"\n  |\n  = help: the trait \"Add&lt;Option&lt;i8&gt;&gt;\" is not implemented for \"i8\"\n  = help: the following other types implement trait \"Add&lt;Rhs&gt;\":\n            &lt;&amp;'a i8 as Add&lt;i8&gt;&gt;\n            &lt;&amp;i8 as Add&lt;&amp;i8&gt;&gt;\n            &lt;i8 as Add&lt;&amp;i8&gt;&gt;\n            &lt;i8 as Add&gt;\n\nFor more information about this error, try \"rustc --explain E0277\".\nerror: could not compile \"enums\" due to previous error\n\nIntense! In effect, this error message means that Rust doesn’t understand how to add an \"i8\" and an \"Option\", because they’re different types. When we have a value of a type like \"i8\" in Rust, the compiler will ensure that we always have a valid value. We can proceed confidently without having to check for null before using that value. Only when we have an \"Option\" (or whatever type of value we’re working with) do we have to worry about possibly not having a value, and the compiler will make sure we handle that case before using the value.\nIn other words, you have to convert an \"Option\" to a \"T\" before you can perform \"T\" operations with it. Generally, this helps catch one of the most common issues with null: assuming that something isn’t null when it actually is.\nEliminating the risk of incorrectly assuming a not-null value helps you to be more confident in your code. In order to have a value that can possibly be null, you must explicitly opt in by making the type of that value \"Option\". Then, when you use that value, you are required to explicitly handle the case when the value is null. Everywhere that a value has a type that isn’t an \"Option\", you can safely assume that the value isn’t null. This was a deliberate design decision for Rust to limit null’s pervasiveness and increase the safety of Rust code.\nSo how do you get the \"T\" value out of a \"Some\" variant when you have a value of type \"Option\" so that you can use that value? The \"Option\" enum has a large number of methods that are useful in a variety of situations; you can check them out in its documentation. Becoming familiar with the methods on \"Option\" will be extremely useful in your journey with Rust.\nIn general, in order to use an \"Option\" value, you want to have code that will handle each variant. You want some code that will run only when you have a \"Some(T)\" value, and this code is allowed to use the inner \"T\". You want some other code to run only if you have a \"None\" value, and that code doesn’t have a \"T\" value available. The \"match\" expression is a control flow construct that does just this when used with enums: it will run different code depending on which variant of the enum it has, and that code can use the data inside the matching value.\n\nThe \"match\" Control Flow Construct\nRust has an extremely powerful control flow construct called \"match\" that allows you to compare a value against a series of patterns and then execute code based on which pattern matches. Patterns can be made up of literal values, variable names, wildcards, and many other things; Chapter 18 covers all the different kinds of patterns and what they do. The power of \"match\" comes from the expressiveness of the patterns and the fact that the compiler confirms that all possible cases are handled.\nThink of a \"match\" expression as being like a coin-sorting machine: coins slide down a track with variously sized holes along it, and each coin falls through the first hole it encounters that it fits into. In the same way, values go through each pattern in a \"match\", and at the first pattern the value “fits,” the value falls into the associated code block to be used during execution.\nSpeaking of coins, let’s use them as an example using \"match\"! We can write a function that takes an unknown US coin and, in a similar way as the counting machine, determines which coin it is and returns its value in cents, as shown in Listing 6-3.\nenum Coin {\n    Penny,\n    Nickel,\n    Dime,\n    Quarter,\n}\n\nfn value_in_cents(coin: Coin) -&gt; u8 {\n    match coin {\n        Coin::Penny =&gt; 1,\n        Coin::Nickel =&gt; 5,\n        Coin::Dime =&gt; 10,\n        Coin::Quarter =&gt; 25,\n    }\n}\n\nListing 6-3: An enum and a \"match\" expression that has the variants of the enum as its patterns\nLet’s break down the \"match\" in the \"value_in_cents\" function. First we list the \"match\" keyword followed by an expression, which in this case is the value \"coin\". This seems very similar to a conditional expression used with \"if\", but there’s a big difference: with \"if\", the condition needs to evaluate to a Boolean value, but here it can be any type. The type of \"coin\" in this example is the \"Coin\" enum that we defined on the first line.\nNext are the \"match\" arms. An arm has two parts: a pattern and some code. The first arm here has a pattern that is the value \"Coin::Penny\" and then the \"=&gt;\" operator that separates the pattern and the code to run. The code in this case is just the value \"1\". Each arm is separated from the next with a comma.\nWhen the \"match\" expression executes, it compares the resultant value against the pattern of each arm, in order. If a pattern matches the value, the code associated with that pattern is executed. If that pattern doesn’t match the value, execution continues to the next arm, much as in a coin-sorting machine. We can have as many arms as we need: in Listing 6-3, our \"match\" has four arms.\nThe code associated with each arm is an expression, and the resultant value of the expression in the matching arm is the value that gets returned for the entire \"match\" expression.\nWe don’t typically use curly brackets if the match arm code is short, as it is in Listing 6-3 where each arm just returns a value. If you want to run multiple lines of code in a match arm, you must use curly brackets, and the comma following the arm is then optional. For example, the following code prints “Lucky penny!” every time the method is called with a \"Coin::Penny\", but still returns the last value of the block, \"1\":\nfn value_in_cents(coin: Coin) -&gt; u8 {\n    match coin {\n        Coin::Penny =&gt; {\n            println!(\"Lucky penny!\");\n            1\n        }\n        Coin::Nickel =&gt; 5,\n        Coin::Dime =&gt; 10,\n        Coin::Quarter =&gt; 25,\n    }\n}\n\nPatterns That Bind to Values\nAnother useful feature of match arms is that they can bind to the parts of the values that match the pattern. This is how we can extract values out of enum variants.\nAs an example, let’s change one of our enum variants to hold data inside it. From 1999 through 2008, the United States minted quarters with different designs for each of the 50 states on one side. No other coins got state designs, so only quarters have this extra value. We can add this information to our \"enum\" by changing the \"Quarter\" variant to include a \"UsState\" value stored inside it, which we’ve done in Listing 6-4.\n#[derive(Debug)] // so we can inspect the state in a minute\nenum UsState {\n    Alabama,\n    Alaska,\n    // --snip--\n}\n\nenum Coin {\n    Penny,\n    Nickel,\n    Dime,\n    Quarter(UsState),\n}\n\nListing 6-4: A \"Coin\" enum in which the \"Quarter\" variant also holds a \"UsState\" value\nLet’s imagine that a friend is trying to collect all 50 state quarters. While we sort our loose change by coin type, we’ll also call out the name of the state associated with each quarter so that if it’s one our friend doesn’t have, they can add it to their collection.\nIn the match expression for this code, we add a variable called \"state\" to the pattern that matches values of the variant \"Coin::Quarter\". When a \"Coin::Quarter\" matches, the \"state\" variable will bind to the value of that quarter’s state. Then we can use \"state\" in the code for that arm, like so:\nfn value_in_cents(coin: Coin) -&gt; u8 {\n    match coin {\n        Coin::Penny =&gt; 1,\n        Coin::Nickel =&gt; 5,\n        Coin::Dime =&gt; 10,\n        Coin::Quarter(state) =&gt; {\n            println!(\"State quarter from {:?}!\", state);\n            25\n        }\n    }\n}\n\nIf we were to call \"value_in_cents(Coin::Quarter(UsState::Alaska))\", \"coin\" would be \"Coin::Quarter(UsState::Alaska)\". When we compare that value with each of the match arms, none of them match until we reach \"Coin::Quarter(state)\". At that point, the binding for \"state\" will be the value \"UsState::Alaska\". We can then use that binding in the \"println!\" expression, thus getting the inner state value out of the \"Coin\" enum variant for \"Quarter\".\nMatching with \"Option\"\nIn the previous section, we wanted to get the inner \"T\" value out of the \"Some\" case when using \"Option\"; we can also handle \"Option\" using \"match\", as we did with the \"Coin\" enum! Instead of comparing coins, we’ll compare the variants of \"Option\", but the way the \"match\" expression works remains the same.\nLet’s say we want to write a function that takes an \"Option\" and, if there’s a value inside, adds 1 to that value. If there isn’t a value inside, the function should return the \"None\" value and not attempt to perform any operations.\nThis function is very easy to write, thanks to \"match\", and will look like Listing 6-5.\n    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {\n        match x {\n            None =&gt; None,\n            Some(i) =&gt; Some(i + 1),\n        }\n    }\n\n    let five = Some(5);\n    let six = plus_one(five);\n    let none = plus_one(None);\n\nListing 6-5: A function that uses a \"match\" expression on an \"Option\"\nLet’s examine the first execution of \"plus_one\" in more detail. When we call \"plus_one(five)\", the variable \"x\" in the body of \"plus_one\" will have the value \"Some(5)\". We then compare that against each match arm:\n            None =&gt; None,\n\nThe \"Some(5)\" value doesn’t match the pattern \"None\", so we continue to the next arm:\n            Some(i) =&gt; Some(i + 1),\n\nDoes \"Some(5)\" match \"Some(i)\"? It does! We have the same variant. The \"i\" binds to the value contained in \"Some\", so \"i\" takes the value \"5\". The code in the match arm is then executed, so we add 1 to the value of \"i\" and create a new \"Some\" value with our total \"6\" inside.\nNow let’s consider the second call of \"plus_one\" in Listing 6-5, where \"x\" is \"None\". We enter the \"match\" and compare to the first arm:\n            None =&gt; None,\n\nIt matches! There’s no value to add to, so the program stops and returns the \"None\" value on the right side of \"=&gt;\". Because the first arm matched, no other arms are compared.\nCombining \"match\" and enums is useful in many situations. You’ll see this pattern a lot in Rust code: \"match\" against an enum, bind a variable to the data inside, and then execute code based on it. It’s a bit tricky at first, but once you get used to it, you’ll wish you had it in all languages. It’s consistently a user favorite.\nMatches Are Exhaustive\nThere’s one other aspect of \"match\" we need to discuss: the arms’ patterns must cover all possibilities. Consider this version of our \"plus_one\" function, which has a bug and won’t compile:\n    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {\n        match x {\n            Some(i) =&gt; Some(i + 1),\n        }\n    }\n\nWe didn’t handle the \"None\" case, so this code will cause a bug. Luckily, it’s a bug Rust knows how to catch. If we try to compile this code, we’ll get this error:\n$ cargo run\n   Compiling enums v0.1.0 (file:///projects/enums)\nerror[E0004]: non-exhaustive patterns: \"None\" not covered\n --&gt; src/main.rs:3:15\n  |\n3 |         match x {\n  |               ^ pattern \"None\" not covered\n  |\nnote: \"Option&lt;i32&gt;\" defined here\n --&gt; /rustc/d5a82bbd26e1ad8b7401f6a718a9c57c96905483/library/core/src/option.rs:518:1\n  |\n  = note: \n/rustc/d5a82bbd26e1ad8b7401f6a718a9c57c96905483/library/core/src/option.rs:522:5: not covered\n  = note: the matched value is of type \"Option&lt;i32&gt;\"\nhelp: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n  |\n4 ~             Some(i) =&gt; Some(i + 1),\n5 ~             None =&gt; todo!(),\n  |\n\nFor more information about this error, try \"rustc --explain E0004\".\nerror: could not compile \"enums\" due to previous error\n\nRust knows that we didn’t cover every possible case, and even knows which pattern we forgot! Matches in Rust are exhaustive: we must exhaust every last possibility in order for the code to be valid. Especially in the case of \"Option\", when Rust prevents us from forgetting to explicitly handle the \"None\" case, it protects us from assuming that we have a value when we might have null, thus making the billion-dollar mistake discussed earlier impossible.\nCatch-all Patterns and the \"_\" Placeholder\nUsing enums, we can also take special actions for a few particular values, but for all other values take one default action. Imagine we’re implementing a game where, if you roll a 3 on a dice roll, your player doesn’t move, but instead gets a new fancy hat. If you roll a 7, your player loses a fancy hat. For all other values, your player moves that number of spaces on the game board. Here’s a \"match\" that implements that logic, with the result of the dice roll hardcoded rather than a random value, and all other logic represented by functions without bodies because actually implementing them is out of scope for this example:\n    let dice_roll = 9;\n    match dice_roll {\n        3 =&gt; add_fancy_hat(),\n        7 =&gt; remove_fancy_hat(),\n        other =&gt; move_player(other),\n    }\n\n    fn add_fancy_hat() {}\n    fn remove_fancy_hat() {}\n    fn move_player(num_spaces: u8) {}\n\nFor the first two arms, the patterns are the literal values \"3\" and \"7\". For the last arm that covers every other possible value, the pattern is the variable we’ve chosen to name \"other\". The code that runs for the \"other\" arm uses the variable by passing it to the \"move_player\" function.\nThis code compiles, even though we haven’t listed all the possible values a \"u8\" can have, because the last pattern will match all values not specifically listed. This catch-all pattern meets the requirement that \"match\" must be exhaustive. Note that we have to put the catch-all arm last because the patterns are evaluated in order. If we put the catch-all arm earlier, the other arms would never run, so Rust will warn us if we add arms after a catch-all!\nRust also has a pattern we can use when we want a catch-all but don’t want to use the value in the catch-all pattern: \"_\" is a special pattern that matches any value and does not bind to that value. This tells Rust we aren’t going to use the value, so Rust won’t warn us about an unused variable.\nLet’s change the rules of the game: now, if you roll anything other than a 3 or a 7, you must roll again. We no longer need to use the catch-all value, so we can change our code to use \"_\" instead of the variable named \"other\":\n    let dice_roll = 9;\n    match dice_roll {\n        3 =&gt; add_fancy_hat(),\n        7 =&gt; remove_fancy_hat(),\n        _ =&gt; reroll(),\n    }\n\n    fn add_fancy_hat() {}\n    fn remove_fancy_hat() {}\n    fn reroll() {}\n\nThis example also meets the exhaustiveness requirement because we’re explicitly ignoring all other values in the last arm; we haven’t forgotten anything.\nFinally, we’ll change the rules of the game one more time so that nothing else happens on your turn if you roll anything other than a 3 or a 7. We can express that by using the unit value (the empty tuple type we mentioned in “The Tuple Type” section) as the code that goes with the \"_\" arm:\n    let dice_roll = 9;\n    match dice_roll {\n        3 =&gt; add_fancy_hat(),\n        7 =&gt; remove_fancy_hat(),\n        _ =&gt; (),\n    }\n\n    fn add_fancy_hat() {}\n    fn remove_fancy_hat() {}\n\nHere, we’re telling Rust explicitly that we aren’t going to use any other value that doesn’t match a pattern in an earlier arm, and we don’t want to run any code in this case.\nThere’s more about patterns and matching that we’ll cover in Chapter 18. For now, we’re going to move on to the \"if let\" syntax, which can be useful in situations where the \"match\" expression is a bit wordy.\n\nConcise Control Flow with \"if let\"\nThe \"if let\" syntax lets you combine \"if\" and \"let\" into a less verbose way to handle values that match one pattern while ignoring the rest. Consider the program in Listing 6-6 that matches on an \"Option\" value in the \"config_max\" variable but only wants to execute code if the value is the \"Some\" variant.\n    let config_max = Some(3u8);\n    match config_max {\n        Some(max) =&gt; println!(\"The maximum is configured to be {}\", max),\n        _ =&gt; (),\n    }\n\nListing 6-6: A \"match\" that only cares about executing code when the value is \"Some\"\nIf the value is \"Some\", we print out the value in the \"Some\" variant by binding the value to the variable \"max\" in the pattern. We don’t want to do anything with the \"None\" value. To satisfy the \"match\" expression, we have to add \"_ =&gt; ()\" after processing just one variant, which is annoying boilerplate code to add.\nInstead, we could write this in a shorter way using \"if let\". The following code behaves the same as the \"match\" in Listing 6-6:\n    let config_max = Some(3u8);\n    if let Some(max) = config_max {\n        println!(\"The maximum is configured to be {}\", max);\n    }\n\nThe syntax \"if let\" takes a pattern and an expression separated by an equal sign. It works the same way as a \"match\", where the expression is given to the \"match\" and the pattern is its first arm. In this case, the pattern is \"Some(max)\", and the \"max\" binds to the value inside the \"Some\". We can then use \"max\" in the body of the \"if let\" block in the same way we used \"max\" in the corresponding \"match\" arm. The code in the \"if let\" block isn’t run if the value doesn’t match the pattern.\nUsing \"if let\" means less typing, less indentation, and less boilerplate code. However, you lose the exhaustive checking that \"match\" enforces. Choosing between \"match\" and \"if let\" depends on what you’re doing in your particular situation and whether gaining conciseness is an appropriate trade-off for losing exhaustive checking.\nIn other words, you can think of \"if let\" as syntax sugar for a \"match\" that runs code when the value matches one pattern and then ignores all other values.\nWe can include an \"else\" with an \"if let\". The block of code that goes with the \"else\" is the same as the block of code that would go with the \"_\" case in the \"match\" expression that is equivalent to the \"if let\" and \"else\". Recall the \"Coin\" enum definition in Listing 6-4, where the \"Quarter\" variant also held a \"UsState\" value. If we wanted to count all non-quarter coins we see while also announcing the state of the quarters, we could do that with a \"match\" expression, like this:\n    let mut count = 0;\n    match coin {\n        Coin::Quarter(state) =&gt; println!(\"State quarter from {:?}!\", state),\n        _ =&gt; count += 1,\n    }\n\nOr we could use an \"if let\" and \"else\" expression, like this:\n    let mut count = 0;\n    if let Coin::Quarter(state) = coin {\n        println!(\"State quarter from {:?}!\", state);\n    } else {\n        count += 1;\n    }\n\nIf you have a situation in which your program has logic that is too verbose to express using a \"match\", remember that \"if let\" is in your Rust toolbox as well.\nSummary\nWe’ve now covered how to use enums to create custom types that can be one of a set of enumerated values. We’ve shown how the standard library’s \"Option\" type helps you use the type system to prevent errors. When enum values have data inside them, you can use \"match\" or \"if let\" to extract and use those values, depending on how many cases you need to handle.\nYour Rust programs can now express concepts in your domain using structs and enums. Creating custom types to use in your API ensures type safety: the compiler will make certain your functions only get values of the type each function expects.\nIn order to provide a well-organized API to your users that is straightforward to use and only exposes exactly what your users will need, let’s now turn to Rust’s modules.\n\nManaging Growing Projects with Packages, Crates, and Modules\nAs you write large programs, organizing your code will become increasingly important. By grouping related functionality and separating code with distinct features, you’ll clarify where to find code that implements a particular feature and where to go to change how a feature works.\nThe programs we’ve written so far have been in one module in one file. As a project grows, you should organize code by splitting it into multiple modules and then multiple files. A package can contain multiple binary crates and optionally one library crate. As a package grows, you can extract parts into separate crates that become external dependencies. This chapter covers all these techniques. For very large projects comprising a set of interrelated packages that evolve together, Cargo provides workspaces, which we’ll cover in the “Cargo Workspaces” section in Chapter 14.\nWe’ll also discuss encapsulating implementation details, which lets you reuse code at a higher level: once you’ve implemented an operation, other code can call your code via its public interface without having to know how the implementation works. The way you write code defines which parts are public for other code to use and which parts are private implementation details that you reserve the right to change. This is another way to limit the amount of detail you have to keep in your head.\nA related concept is scope: the nested context in which code is written has a set of names that are defined as “in scope.” When reading, writing, and compiling code, programmers and compilers need to know whether a particular name at a particular spot refers to a variable, function, struct, enum, module, constant, or other item and what that item means. You can create scopes and change which names are in or out of scope. You can’t have two items with the same name in the same scope; tools are available to resolve name conflicts.\nRust has a number of features that allow you to manage your code’s organization, including which details are exposed, which details are private, and what names are in each scope in your programs. These features, sometimes collectively referred to as the module system, include:\n\nPackages: A Cargo feature that lets you build, test, and share crates\nCrates: A tree of modules that produces a library or executable\nModules and use: Let you control the organization, scope, and privacy of paths\nPaths: A way of naming an item, such as a struct, function, or module\n\nIn this chapter, we’ll cover all these features, discuss how they interact, and explain how to use them to manage scope. By the end, you should have a solid understanding of the module system and be able to work with scopes like a pro!\n\nPackages and Crates\nThe first parts of the module system we’ll cover are packages and crates.\nA crate is the smallest amount of code that the Rust compiler considers at a time. Even if you run \"rustc\" rather than \"cargo\" and pass a single source code file (as we did all the way back in the “Writing and Running a Rust Program” section of Chapter 1), the compiler considers that file to be a crate. Crates can contain modules, and the modules may be defined in other files that get compiled with the crate, as we’ll see in the coming sections.\nA crate can come in one of two forms: a binary crate or a library crate. Binary crates are programs you can compile to an executable that you can run, such as a command-line program or a server. Each must have a function called \"main\" that defines what happens when the executable runs. All the crates we’ve created so far have been binary crates.\nLibrary crates don’t have a \"main\" function, and they don’t compile to an executable. Instead, they define functionality intended to be shared with multiple projects. For example, the \"rand\" crate we used in Chapter 2 provides functionality that generates random numbers. Most of the time when Rustaceans say “crate”, they mean library crate, and they use “crate” interchangeably with the general programming concept of a “library\".\nThe crate root is a source file that the Rust compiler starts from and makes up the root module of your crate (we’ll explain modules in depth in the “Defining Modules to Control Scope and Privacy” section).\nA package is a bundle of one or more crates that provides a set of functionality. A package contains a Cargo.toml file that describes how to build those crates. Cargo is actually a package that contains the binary crate for the command-line tool you’ve been using to build your code. The Cargo package also contains a library crate that the binary crate depends on. Other projects can depend on the Cargo library crate to use the same logic the Cargo command-line tool uses.\nA package can contain as many binary crates as you like, but at most only one library crate. A package must contain at least one crate, whether that’s a library or binary crate.\nLet’s walk through what happens when we create a package. First, we enter the command \"cargo new\":\n$ cargo new my-project\n     Created binary (application) \"my-project\" package\n$ ls my-project\nCargo.toml\nsrc\n$ ls my-project/src\nmain.rs\n\nAfter we run \"cargo new\", we use \"ls\" to see what Cargo creates. In the project directory, there’s a Cargo.toml file, giving us a package. There’s also a src directory that contains main.rs. Open Cargo.toml in your text editor, and note there’s no mention of src/main.rs. Cargo follows a convention that src/main.rs is the crate root of a binary crate with the same name as the package. Likewise, Cargo knows that if the package directory contains src/lib.rs, the package contains a library crate with the same name as the package, and src/lib.rs is its crate root. Cargo passes the crate root files to \"rustc\" to build the library or binary.\nHere, we have a package that only contains src/main.rs, meaning it only contains a binary crate named \"my-project\". If a package contains src/main.rs and src/lib.rs, it has two crates: a binary and a library, both with the same name as the package. A package can have multiple binary crates by placing files in the src/bin directory: each file will be a separate binary crate.\n\nDefining Modules to Control Scope and Privacy\nIn this section, we’ll talk about modules and other parts of the module system, namely paths that allow you to name items; the \"use\" keyword that brings a path into scope; and the \"pub\" keyword to make items public. We’ll also discuss the \"as\" keyword, external packages, and the glob operator.\nFirst, we’re going to start with a list of rules for easy reference when you’re organizing your code in the future. Then we’ll explain each of the rules in detail.\nModules Cheat Sheet\nHere we provide a quick reference on how modules, paths, the \"use\" keyword, and the \"pub\" keyword work in the compiler, and how most developers organize their code. We’ll be going through examples of each of these rules throughout this chapter, but this is a great place to refer to as a reminder of how modules work.\n\n\nStart from the crate root: When compiling a crate, the compiler first looks in the crate root file (usually src/lib.rs for a library crate or src/main.rs for a binary crate) for code to compile.\n\n\nDeclaring modules\n: In the crate root file, you can declare new modules; say, you declare a “garden” module with\nmod garden;\n\n. The compiler will look for the module’s code in these places:\n\nInline, within curly brackets that replace the semicolon following \"mod garden\"\nIn the file src/garden.rs\nIn the file src/garden/mod.rs\n\n\n\nDeclaring submodules\n: In any file other than the crate root, you can declare submodules. For example, you might declare\nmod vegetables;\n\nin\nsrc/garden.rs\n. The compiler will look for the submodule’s code within the directory named for the parent module in these places:\n\nInline, directly following \"mod vegetables\", within curly brackets instead of the semicolon\nIn the file src/garden/vegetables.rs\nIn the file src/garden/vegetables/mod.rs\n\n\n\nPaths to code in modules: Once a module is part of your crate, you can refer to code in that module from anywhere else in that same crate, as long as the privacy rules allow, using the path to the code. For example, an \"Asparagus\" type in the garden vegetables module would be found at \"crate::garden::vegetables::Asparagus\".\n\n\nPrivate vs public: Code within a module is private from its parent modules by default. To make a module public, declare it with \"pub mod\" instead of \"mod\". To make items within a public module public as well, use \"pub\" before their declarations.\n\n\nThe \"use\" keyword: Within a scope, the \"use\" keyword creates shortcuts to items to reduce repetition of long paths. In any scope that can refer to \"crate::garden::vegetables::Asparagus\", you can create a shortcut with \"use crate::garden::vegetables::Asparagus;\" and from then on you only need to write \"Asparagus\" to make use of that type in the scope.\n\n\nHere we create a binary crate named \"backyard\" that illustrates these rules. The crate’s directory, also named \"backyard\", contains these files and directories:\nbackyard\n├── Cargo.lock\n├── Cargo.toml\n└── src\n    ├── garden\n    │   └── vegetables.rs\n    ├── garden.rs\n    └── main.rs\n\nThe crate root file in this case is src/main.rs, and it contains:\nFilename: src/main.rs\nuse crate::garden::vegetables::Asparagus;\n\npub mod garden;\n\nfn main() {\n    let plant = Asparagus {};\n    println!(\"I'm growing {:?}!\", plant);\n}\n\nThe \"pub mod garden;\" line tells the compiler to include the code it finds in src/garden.rs, which is:\nFilename: src/garden.rs\npub mod vegetables;\n\nHere, \"pub mod vegetables;\" means the code in src/garden/vegetables.rs is included too. That code is:\n#[derive(Debug)]\npub struct Asparagus {}\n\nNow let’s get into the details of these rules and demonstrate them in action!\nGrouping Related Code in Modules\nModules let us organize code within a crate for readability and easy reuse. Modules also allow us to control the privacy of items, because code within a module is private by default. Private items are internal implementation details not available for outside use. We can choose to make modules and the items within them public, which exposes them to allow external code to use and depend on them.\nAs an example, let’s write a library crate that provides the functionality of a restaurant. We’ll define the signatures of functions but leave their bodies empty to concentrate on the organization of the code, rather than the implementation of a restaurant.\nIn the restaurant industry, some parts of a restaurant are referred to as front of house and others as back of house. Front of house is where customers are; this encompasses where the hosts seat customers, servers take orders and payment, and bartenders make drinks. Back of house is where the chefs and cooks work in the kitchen, dishwashers clean up, and managers do administrative work.\nTo structure our crate in this way, we can organize its functions into nested modules. Create a new library named \"restaurant\" by running \"cargo new restaurant --lib\"; then enter the code in Listing 7-1 into src/lib.rs to define some modules and function signatures. Here’s the front of house section:\nFilename: src/lib.rs\nmod front_of_house {\n    mod hosting {\n        fn add_to_waitlist() {}\n\n        fn seat_at_table() {}\n    }\n\n    mod serving {\n        fn take_order() {}\n\n        fn serve_order() {}\n\n        fn take_payment() {}\n    }\n}\n\nListing 7-1: A \"front_of_house\" module containing other modules that then contain functions\nWe define a module with the \"mod\" keyword followed by the name of the module (in this case, \"front_of_house\"). The body of the module then goes inside curly brackets. Inside modules, we can place other modules, as in this case with the modules \"hosting\" and \"serving\". Modules can also hold definitions for other items, such as structs, enums, constants, traits, and—as in Listing 7-1—functions.\nBy using modules, we can group related definitions together and name why they’re related. Programmers using this code can navigate the code based on the groups rather than having to read through all the definitions, making it easier to find the definitions relevant to them. Programmers adding new functionality to this code would know where to place the code to keep the program organized.\nEarlier, we mentioned that src/main.rs and src/lib.rs are called crate roots. The reason for their name is that the contents of either of these two files form a module named \"crate\" at the root of the crate’s module structure, known as the module tree.\nListing 7-2 shows the module tree for the structure in Listing 7-1.\ncrate\n └── front_of_house\n     ├── hosting\n     │   ├── add_to_waitlist\n     │   └── seat_at_table\n     └── serving\n         ├── take_order\n         ├── serve_order\n         └── take_payment\n\nListing 7-2: The module tree for the code in Listing 7-1\nThis tree shows how some of the modules nest inside one another; for example, \"hosting\" nests inside \"front_of_house\". The tree also shows that some modules are siblings to each other, meaning they’re defined in the same module; \"hosting\" and \"serving\" are siblings defined within \"front_of_house\". If module A is contained inside module B, we say that module A is the child of module B and that module B is the parent of module A. Notice that the entire module tree is rooted under the implicit module named \"crate\".\nThe module tree might remind you of the filesystem’s directory tree on your computer; this is a very apt comparison! Just like directories in a filesystem, you use modules to organize your code. And just like files in a directory, we need a way to find our modules.\n\nPaths for Referring to an Item in the Module Tree\nTo show Rust where to find an item in a module tree, we use a path in the same way we use a path when navigating a filesystem. To call a function, we need to know its path.\nA path can take two forms:\n\nAn absolute path is the full path starting from a crate root; for code from an external crate, the absolute path begins with the crate name, and for code from the current crate, it starts with the literal \"crate\".\nA relative path starts from the current module and uses \"self\", \"super\", or an identifier in the current module.\n\nBoth absolute and relative paths are followed by one or more identifiers separated by double colons (\"::\").\nReturning to Listing 7-1, say we want to call the \"add_to_waitlist\" function. This is the same as asking: what’s the path of the \"add_to_waitlist\" function? Listing 7-3 contains Listing 7-1 with some of the modules and functions removed.\nWe’ll show two ways to call the \"add_to_waitlist\" function from a new function \"eat_at_restaurant\" defined in the crate root. These paths are correct, but there’s another problem remaining that will prevent this example from compiling as-is. We’ll explain why in a bit.\nThe \"eat_at_restaurant\" function is part of our library crate’s public API, so we mark it with the \"pub\" keyword. In the “Exposing Paths with the \"pub\" Keyword” section, we’ll go into more detail about \"pub\".\nFilename: src/lib.rs\nmod front_of_house {\n    mod hosting {\n        fn add_to_waitlist() {}\n    }\n}\n\npub fn eat_at_restaurant() {\n    // Absolute path\n    crate::front_of_house::hosting::add_to_waitlist();\n\n    // Relative path\n    front_of_house::hosting::add_to_waitlist();\n}\n\nListing 7-3: Calling the \"add_to_waitlist\" function using absolute and relative paths\nThe first time we call the \"add_to_waitlist\" function in \"eat_at_restaurant\", we use an absolute path. The \"add_to_waitlist\" function is defined in the same crate as \"eat_at_restaurant\", which means we can use the \"crate\" keyword to start an absolute path. We then include each of the successive modules until we make our way to \"add_to_waitlist\". You can imagine a filesystem with the same structure: we’d specify the path \"/front_of_house/hosting/add_to_waitlist\" to run the \"add_to_waitlist\" program; using the \"crate\" name to start from the crate root is like using \"/\" to start from the filesystem root in your shell.\nThe second time we call \"add_to_waitlist\" in \"eat_at_restaurant\", we use a relative path. The path starts with \"front_of_house\", the name of the module defined at the same level of the module tree as \"eat_at_restaurant\". Here the filesystem equivalent would be using the path \"front_of_house/hosting/add_to_waitlist\". Starting with a module name means that the path is relative.\nChoosing whether to use a relative or absolute path is a decision you’ll make based on your project, and depends on whether you’re more likely to move item definition code separately from or together with the code that uses the item. For example, if we move the \"front_of_house\" module and the \"eat_at_restaurant\" function into a module named \"customer_experience\", we’d need to update the absolute path to \"add_to_waitlist\", but the relative path would still be valid. However, if we moved the \"eat_at_restaurant\" function separately into a module named \"dining\", the absolute path to the \"add_to_waitlist\" call would stay the same, but the relative path would need to be updated. Our preference in general is to specify absolute paths because it’s more likely we’ll want to move code definitions and item calls independently of each other.\nLet’s try to compile Listing 7-3 and find out why it won’t compile yet! The error we get is shown in Listing 7-4.\n$ cargo build\n   Compiling restaurant v0.1.0 (file:///projects/restaurant)\nerror[E0603]: module \"hosting\" is private\n --&gt; src/lib.rs:9:28\n  |\n9 |     crate::front_of_house::hosting::add_to_waitlist();\n  |                            ^^^^^^^ private module\n  |\nnote: the module \"hosting\" is defined here\n --&gt; src/lib.rs:2:5\n  |\n2 |     mod hosting {\n  |     ^^^^^^^^^^^\n\nerror[E0603]: module \"hosting\" is private\n  --&gt; src/lib.rs:12:21\n   |\n12 |     front_of_house::hosting::add_to_waitlist();\n   |                     ^^^^^^^ private module\n   |\nnote: the module \"hosting\" is defined here\n  --&gt; src/lib.rs:2:5\n   |\n2  |     mod hosting {\n   |     ^^^^^^^^^^^\n\nFor more information about this error, try \"rustc --explain E0603\".\nerror: could not compile \"restaurant\" due to 2 previous errors\n\nListing 7-4: Compiler errors from building the code in Listing 7-3\nThe error messages say that module \"hosting\" is private. In other words, we have the correct paths for the \"hosting\" module and the \"add_to_waitlist\" function, but Rust won’t let us use them because it doesn’t have access to the private sections. In Rust, all items (functions, methods, structs, enums, modules, and constants) are private to parent modules by default. If you want to make an item like a function or struct private, you put it in a module.\nItems in a parent module can’t use the private items inside child modules, but items in child modules can use the items in their ancestor modules. This is because child modules wrap and hide their implementation details, but the child modules can see the context in which they’re defined. To continue with our metaphor, think of the privacy rules as being like the back office of a restaurant: what goes on in there is private to restaurant customers, but office managers can see and do everything in the restaurant they operate.\nRust chose to have the module system function this way so that hiding inner implementation details is the default. That way, you know which parts of the inner code you can change without breaking outer code. However, Rust does give you the option to expose inner parts of child modules’ code to outer ancestor modules by using the \"pub\" keyword to make an item public.\nExposing Paths with the \"pub\" Keyword\nLet’s return to the error in Listing 7-4 that told us the \"hosting\" module is private. We want the \"eat_at_restaurant\" function in the parent module to have access to the \"add_to_waitlist\" function in the child module, so we mark the \"hosting\" module with the \"pub\" keyword, as shown in Listing 7-5.\nFilename: src/lib.rs\nmod front_of_house {\n    pub mod hosting {\n        fn add_to_waitlist() {}\n    }\n}\n\npub fn eat_at_restaurant() {\n    // Absolute path\n    crate::front_of_house::hosting::add_to_waitlist();\n\n    // Relative path\n    front_of_house::hosting::add_to_waitlist();\n}\n\nListing 7-5: Declaring the \"hosting\" module as \"pub\" to use it from \"eat_at_restaurant\"\nUnfortunately, the code in Listing 7-5 still results in an error, as shown in Listing 7-6.\n$ cargo build\n   Compiling restaurant v0.1.0 (file:///projects/restaurant)\nerror[E0603]: function \"add_to_waitlist\" is private\n --&gt; src/lib.rs:9:37\n  |\n9 |     crate::front_of_house::hosting::add_to_waitlist();\n  |                                     ^^^^^^^^^^^^^^^ private function\n  |\nnote: the function \"add_to_waitlist\" is defined here\n --&gt; src/lib.rs:3:9\n  |\n3 |         fn add_to_waitlist() {}\n  |         ^^^^^^^^^^^^^^^^^^^^\n\nerror[E0603]: function \"add_to_waitlist\" is private\n  --&gt; src/lib.rs:12:30\n   |\n12 |     front_of_house::hosting::add_to_waitlist();\n   |                              ^^^^^^^^^^^^^^^ private function\n   |\nnote: the function \"add_to_waitlist\" is defined here\n  --&gt; src/lib.rs:3:9\n   |\n3  |         fn add_to_waitlist() {}\n   |         ^^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try \"rustc --explain E0603\".\nerror: could not compile \"restaurant\" due to 2 previous errors\n\nListing 7-6: Compiler errors from building the code in Listing 7-5\nWhat happened? Adding the \"pub\" keyword in front of \"mod hosting\" makes the module public. With this change, if we can access \"front_of_house\", we can access \"hosting\". But the contents of \"hosting\" are still private; making the module public doesn’t make its contents public. The \"pub\" keyword on a module only lets code in its ancestor modules refer to it, not access its inner code. Because modules are containers, there’s not much we can do by only making the module public; we need to go further and choose to make one or more of the items within the module public as well.\nThe errors in Listing 7-6 say that the \"add_to_waitlist\" function is private. The privacy rules apply to structs, enums, functions, and methods as well as modules.\nLet’s also make the \"add_to_waitlist\" function public by adding the \"pub\" keyword before its definition, as in Listing 7-7.\nFilename: src/lib.rs\nmod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {}\n    }\n}\n\npub fn eat_at_restaurant() {\n    // Absolute path\n    crate::front_of_house::hosting::add_to_waitlist();\n\n    // Relative path\n    front_of_house::hosting::add_to_waitlist();\n}\n\nListing 7-7: Adding the \"pub\" keyword to \"mod hosting\" and \"fn add_to_waitlist\" lets us call the function from \"eat_at_restaurant\"\nNow the code will compile! To see why adding the \"pub\" keyword lets us use these paths in \"add_to_waitlist\" with respect to the privacy rules, let’s look at the absolute and the relative paths.\nIn the absolute path, we start with \"crate\", the root of our crate’s module tree. The \"front_of_house\" module is defined in the crate root. While \"front_of_house\" isn’t public, because the \"eat_at_restaurant\" function is defined in the same module as \"front_of_house\" (that is, \"eat_at_restaurant\" and \"front_of_house\" are siblings), we can refer to \"front_of_house\" from \"eat_at_restaurant\". Next is the \"hosting\" module marked with \"pub\". We can access the parent module of \"hosting\", so we can access \"hosting\". Finally, the \"add_to_waitlist\" function is marked with \"pub\" and we can access its parent module, so this function call works!\nIn the relative path, the logic is the same as the absolute path except for the first step: rather than starting from the crate root, the path starts from \"front_of_house\". The \"front_of_house\" module is defined within the same module as \"eat_at_restaurant\", so the relative path starting from the module in which \"eat_at_restaurant\" is defined works. Then, because \"hosting\" and \"add_to_waitlist\" are marked with \"pub\", the rest of the path works, and this function call is valid!\nIf you plan on sharing your library crate so other projects can use your code, your public API is your contract with users of your crate that determines how they can interact with your code. There are many considerations around managing changes to your public API to make it easier for people to depend on your crate. These considerations are out of the scope of this book; if you’re interested in this topic, see The Rust API Guidelines.\n\nBest Practices for Packages with a Binary and a Library\nWe mentioned a package can contain both a src/main.rs binary crate root as well as a src/lib.rs library crate root, and both crates will have the package name by default. Typically, packages with this pattern of containing both a library and a binary crate will have just enough code in the binary crate to start an executable that calls code with the library crate. This lets other projects benefit from the most functionality that the package provides, because the library crate’s code can be shared.\nThe module tree should be defined in src/lib.rs. Then, any public items can be used in the binary crate by starting paths with the name of the package. The binary crate becomes a user of the library crate just like a completely external crate would use the library crate: it can only use the public API. This helps you design a good API; not only are you the author, you’re also a client!\nIn Chapter 12, we’ll demonstrate this organizational practice with a command-line program that will contain both a binary crate and a library crate.\n\nStarting Relative Paths with \"super\"\nWe can construct relative paths that begin in the parent module, rather than the current module or the crate root, by using \"super\" at the start of the path. This is like starting a filesystem path with the \"..\" syntax. Using \"super\" allows us to reference an item that we know is in the parent module, which can make rearranging the module tree easier when the module is closely related to the parent, but the parent might be moved elsewhere in the module tree someday.\nConsider the code in Listing 7-8 that models the situation in which a chef fixes an incorrect order and personally brings it out to the customer. The function \"fix_incorrect_order\" defined in the \"back_of_house\" module calls the function \"deliver_order\" defined in the parent module by specifying the path to \"deliver_order\" starting with \"super\":\nFilename: src/lib.rs\nfn deliver_order() {}\n\nmod back_of_house {\n    fn fix_incorrect_order() {\n        cook_order();\n        super::deliver_order();\n    }\n\n    fn cook_order() {}\n}\n\nListing 7-8: Calling a function using a relative path starting with \"super\"\nThe \"fix_incorrect_order\" function is in the \"back_of_house\" module, so we can use \"super\" to go to the parent module of \"back_of_house\", which in this case is \"crate\", the root. From there, we look for \"deliver_order\" and find it. Success! We think the \"back_of_house\" module and the \"deliver_order\" function are likely to stay in the same relationship to each other and get moved together should we decide to reorganize the crate’s module tree. Therefore, we used \"super\" so we’ll have fewer places to update code in the future if this code gets moved to a different module.\nMaking Structs and Enums Public\nWe can also use \"pub\" to designate structs and enums as public, but there are a few details extra to the usage of \"pub\" with structs and enums. If we use \"pub\" before a struct definition, we make the struct public, but the struct’s fields will still be private. We can make each field public or not on a case-by-case basis. In Listing 7-9, we’ve defined a public \"back_of_house::Breakfast\" struct with a public \"toast\" field but a private \"seasonal_fruit\" field. This models the case in a restaurant where the customer can pick the type of bread that comes with a meal, but the chef decides which fruit accompanies the meal based on what’s in season and in stock. The available fruit changes quickly, so customers can’t choose the fruit or even see which fruit they’ll get.\nFilename: src/lib.rs\nmod back_of_house {\n    pub struct Breakfast {\n        pub toast: String,\n        seasonal_fruit: String,\n    }\n\n    impl Breakfast {\n        pub fn summer(toast: &amp;str) -&gt; Breakfast {\n            Breakfast {\n                toast: String::from(toast),\n                seasonal_fruit: String::from(\"peaches\"),\n            }\n        }\n    }\n}\n\npub fn eat_at_restaurant() {\n    // Order a breakfast in the summer with Rye toast\n    let mut meal = back_of_house::Breakfast::summer(\"Rye\");\n    // Change our mind about what bread we'd like\n    meal.toast = String::from(\"Wheat\");\n    println!(\"I'd like {} toast please\", meal.toast);\n\n    // The next line won't compile if we uncomment it; we're not allowed\n    // to see or modify the seasonal fruit that comes with the meal\n    // meal.seasonal_fruit = String::from(\"blueberries\");\n}\n\nListing 7-9: A struct with some public fields and some private fields\nBecause the \"toast\" field in the \"back_of_house::Breakfast\" struct is public, in \"eat_at_restaurant\" we can write and read to the \"toast\" field using dot notation. Notice that we can’t use the \"seasonal_fruit\" field in \"eat_at_restaurant\" because \"seasonal_fruit\" is private. Try uncommenting the line modifying the \"seasonal_fruit\" field value to see what error you get!\nAlso, note that because \"back_of_house::Breakfast\" has a private field, the struct needs to provide a public associated function that constructs an instance of \"Breakfast\" (we’ve named it \"summer\" here). If \"Breakfast\" didn’t have such a function, we couldn’t create an instance of \"Breakfast\" in \"eat_at_restaurant\" because we couldn’t set the value of the private \"seasonal_fruit\" field in \"eat_at_restaurant\".\nIn contrast, if we make an enum public, all of its variants are then public. We only need the \"pub\" before the \"enum\" keyword, as shown in Listing 7-10.\nFilename: src/lib.rs\nmod back_of_house {\n    pub enum Appetizer {\n        Soup,\n        Salad,\n    }\n}\n\npub fn eat_at_restaurant() {\n    let order1 = back_of_house::Appetizer::Soup;\n    let order2 = back_of_house::Appetizer::Salad;\n}\n\nListing 7-10: Designating an enum as public makes all its variants public\nBecause we made the \"Appetizer\" enum public, we can use the \"Soup\" and \"Salad\" variants in \"eat_at_restaurant\".\nEnums aren’t very useful unless their variants are public; it would be annoying to have to annotate all enum variants with \"pub\" in every case, so the default for enum variants is to be public. Structs are often useful without their fields being public, so struct fields follow the general rule of everything being private by default unless annotated with \"pub\".\nThere’s one more situation involving \"pub\" that we haven’t covered, and that is our last module system feature: the \"use\" keyword. We’ll cover \"use\" by itself first, and then we’ll show how to combine \"pub\" and \"use\".\n\nBringing Paths into Scope with the \"use\" Keyword\nHaving to write out the paths to call functions can feel inconvenient and repetitive. In Listing 7-7, whether we chose the absolute or relative path to the \"add_to_waitlist\" function, every time we wanted to call \"add_to_waitlist\" we had to specify \"front_of_house\" and \"hosting\" too. Fortunately, there’s a way to simplify this process: we can create a shortcut to a path with the \"use\" keyword once, and then use the shorter name everywhere else in the scope.\nIn Listing 7-11, we bring the \"crate::front_of_house::hosting\" module into the scope of the \"eat_at_restaurant\" function so we only have to specify \"hosting::add_to_waitlist\" to call the \"add_to_waitlist\" function in \"eat_at_restaurant\".\nFilename: src/lib.rs\nmod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {}\n    }\n}\n\nuse crate::front_of_house::hosting;\n\npub fn eat_at_restaurant() {\n    hosting::add_to_waitlist();\n}\n\nListing 7-11: Bringing a module into scope with \"use\"\nAdding \"use\" and a path in a scope is similar to creating a symbolic link in the filesystem. By adding \"use crate::front_of_house::hosting\" in the crate root, \"hosting\" is now a valid name in that scope, just as though the \"hosting\" module had been defined in the crate root. Paths brought into scope with \"use\" also check privacy, like any other paths.\nNote that \"use\" only creates the shortcut for the particular scope in which the \"use\" occurs. Listing 7-12 moves the \"eat_at_restaurant\" function into a new child module named \"customer\", which is then a different scope than the \"use\" statement, so the function body won’t compile:\nFilename: src/lib.rs\nmod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {}\n    }\n}\n\nuse crate::front_of_house::hosting;\n\nmod customer {\n    pub fn eat_at_restaurant() {\n        hosting::add_to_waitlist();\n    }\n}\n\nListing 7-12: A \"use\" statement only applies in the scope it’s in\nThe compiler error shows that the shortcut no longer applies within the \"customer\" module:\n$ cargo build\n   Compiling restaurant v0.1.0 (file:///projects/restaurant)\nwarning: unused import: \"crate::front_of_house::hosting\"\n --&gt; src/lib.rs:7:5\n  |\n7 | use crate::front_of_house::hosting;\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: \"#[warn(unused_imports)]\" on by default\n\nerror[E0433]: failed to resolve: use of undeclared crate or module \"hosting\"\n  --&gt; src/lib.rs:11:9\n   |\n11 |         hosting::add_to_waitlist();\n   |         ^^^^^^^ use of undeclared crate or module \"hosting\"\n\nFor more information about this error, try \"rustc --explain E0433\".\nwarning: \"restaurant\" (lib) generated 1 warning\nerror: could not compile \"restaurant\" due to previous error; 1 warning emitted\n\nNotice there’s also a warning that the \"use\" is no longer used in its scope! To fix this problem, move the \"use\" within the \"customer\" module too, or reference the shortcut in the parent module with \"super::hosting\" within the child \"customer\" module.\nCreating Idiomatic \"use\" Paths\nIn Listing 7-11, you might have wondered why we specified \"use crate::front_of_house::hosting\" and then called \"hosting::add_to_waitlist\" in \"eat_at_restaurant\" rather than specifying the \"use\" path all the way out to the \"add_to_waitlist\" function to achieve the same result, as in Listing 7-13.\nFilename: src/lib.rs\nmod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {}\n    }\n}\n\nuse crate::front_of_house::hosting::add_to_waitlist;\n\npub fn eat_at_restaurant() {\n    add_to_waitlist();\n}\n\nListing 7-13: Bringing the \"add_to_waitlist\" function into scope with \"use\", which is unidiomatic\nAlthough both Listing 7-11 and 7-13 accomplish the same task, Listing 7-11 is the idiomatic way to bring a function into scope with \"use\". Bringing the function’s parent module into scope with \"use\" means we have to specify the parent module when calling the function. Specifying the parent module when calling the function makes it clear that the function isn’t locally defined while still minimizing repetition of the full path. The code in Listing 7-13 is unclear as to where \"add_to_waitlist\" is defined.\nOn the other hand, when bringing in structs, enums, and other items with \"use\", it’s idiomatic to specify the full path. Listing 7-14 shows the idiomatic way to bring the standard library’s \"HashMap\" struct into the scope of a binary crate.\nFilename: src/main.rs\nuse std::collections::HashMap;\n\nfn main() {\n    let mut map = HashMap::new();\n    map.insert(1, 2);\n}\n\nListing 7-14: Bringing \"HashMap\" into scope in an idiomatic way\nThere’s no strong reason behind this idiom: it’s just the convention that has emerged, and folks have gotten used to reading and writing Rust code this way.\nThe exception to this idiom is if we’re bringing two items with the same name into scope with \"use\" statements, because Rust doesn’t allow that. Listing 7-15 shows how to bring two \"Result\" types into scope that have the same name but different parent modules and how to refer to them.\nFilename: src/lib.rs\nuse std::fmt;\nuse std::io;\n\nfn function1() -&gt; fmt::Result {\n    // --snip--\n}\n\nfn function2() -&gt; io::Result&lt;()&gt; {\n    // --snip--\n}\n\nListing 7-15: Bringing two types with the same name into the same scope requires using their parent modules.\nAs you can see, using the parent modules distinguishes the two \"Result\" types. If instead we specified \"use std::fmt::Result\" and \"use std::io::Result\", we’d have two \"Result\" types in the same scope and Rust wouldn’t know which one we meant when we used \"Result\".\nProviding New Names with the \"as\" Keyword\nThere’s another solution to the problem of bringing two types of the same name into the same scope with \"use\": after the path, we can specify \"as\" and a new local name, or alias, for the type. Listing 7-16 shows another way to write the code in Listing 7-15 by renaming one of the two \"Result\" types using \"as\".\nFilename: src/lib.rs\nuse std::fmt::Result;\nuse std::io::Result as IoResult;\n\nfn function1() -&gt; Result {\n    // --snip--\n}\n\nfn function2() -&gt; IoResult&lt;()&gt; {\n    // --snip--\n}\n\nListing 7-16: Renaming a type when it’s brought into scope with the \"as\" keyword\nIn the second \"use\" statement, we chose the new name \"IoResult\" for the \"std::io::Result\" type, which won’t conflict with the \"Result\" from \"std::fmt\" that we’ve also brought into scope. Listing 7-15 and Listing 7-16 are considered idiomatic, so the choice is up to you!\nRe-exporting Names with \"pub use\"\nWhen we bring a name into scope with the \"use\" keyword, the name available in the new scope is private. To enable the code that calls our code to refer to that name as if it had been defined in that code’s scope, we can combine \"pub\" and \"use\". This technique is called re-exporting because we’re bringing an item into scope but also making that item available for others to bring into their scope.\nListing 7-17 shows the code in Listing 7-11 with \"use\" in the root module changed to \"pub use\".\nFilename: src/lib.rs\nmod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {}\n    }\n}\n\npub use crate::front_of_house::hosting;\n\npub fn eat_at_restaurant() {\n    hosting::add_to_waitlist();\n}\n\nListing 7-17: Making a name available for any code to use from a new scope with \"pub use\"\nBefore this change, external code would have to call the \"add_to_waitlist\" function by using the path \"restaurant::front_of_house::hosting::add_to_waitlist()\". Now that this \"pub use\" has re-exported the \"hosting\" module from the root module, external code can now use the path \"restaurant::hosting::add_to_waitlist()\" instead.\nRe-exporting is useful when the internal structure of your code is different from how programmers calling your code would think about the domain. For example, in this restaurant metaphor, the people running the restaurant think about “front of house” and “back of house.” But customers visiting a restaurant probably won’t think about the parts of the restaurant in those terms. With \"pub use\", we can write our code with one structure but expose a different structure. Doing so makes our library well organized for programmers working on the library and programmers calling the library. We’ll look at another example of \"pub use\" and how it affects your crate’s documentation in the “Exporting a Convenient Public API with \"pub use\"” section of Chapter 14.\nUsing External Packages\nIn Chapter 2, we programmed a guessing game project that used an external package called \"rand\" to get random numbers. To use \"rand\" in our project, we added this line to Cargo.toml:\nFilename: Cargo.toml\nrand = \"0.8.5\"\n\nAdding \"rand\" as a dependency in Cargo.toml tells Cargo to download the \"rand\" package and any dependencies from crates.io and make \"rand\" available to our project.\nThen, to bring \"rand\" definitions into the scope of our package, we added a \"use\" line starting with the name of the crate, \"rand\", and listed the items we wanted to bring into scope. Recall that in the “Generating a Random Number” section in Chapter 2, we brought the \"Rng\" trait into scope and called the \"rand::thread_rng\" function:\nuse rand::Rng;\n\nfn main() {\n    let secret_number = rand::thread_rng().gen_range(1..=100);\n}\n\nMembers of the Rust community have made many packages available at crates.io, and pulling any of them into your package involves these same steps: listing them in your package’s Cargo.toml file and using \"use\" to bring items from their crates into scope.\nNote that the standard \"std\" library is also a crate that’s external to our package. Because the standard library is shipped with the Rust language, we don’t need to change Cargo.toml to include \"std\". But we do need to refer to it with \"use\" to bring items from there into our package’s scope. For example, with \"HashMap\" we would use this line:\nuse std::collections::HashMap;\n\nThis is an absolute path starting with \"std\", the name of the standard library crate.\nUsing Nested Paths to Clean Up Large \"use\" Lists\nIf we’re using multiple items defined in the same crate or same module, listing each item on its own line can take up a lot of vertical space in our files. For example, these two \"use\" statements we had in the Guessing Game in Listing 2-4 bring items from \"std\" into scope:\nFilename: src/main.rs\n// --snip--\nuse std::cmp::Ordering;\nuse std::io;\n// --snip--\n\nInstead, we can use nested paths to bring the same items into scope in one line. We do this by specifying the common part of the path, followed by two colons, and then curly brackets around a list of the parts of the paths that differ, as shown in Listing 7-18.\nFilename: src/main.rs\n// --snip--\nuse std::{cmp::Ordering, io};\n// --snip--\n\nListing 7-18: Specifying a nested path to bring multiple items with the same prefix into scope\nIn bigger programs, bringing many items into scope from the same crate or module using nested paths can reduce the number of separate \"use\" statements needed by a lot!\nWe can use a nested path at any level in a path, which is useful when combining two \"use\" statements that share a subpath. For example, Listing 7-19 shows two \"use\" statements: one that brings \"std::io\" into scope and one that brings \"std::io::Write\" into scope.\nFilename: src/lib.rs\nuse std::io;\nuse std::io::Write;\n\nListing 7-19: Two \"use\" statements where one is a subpath of the other\nThe common part of these two paths is \"std::io\", and that’s the complete first path. To merge these two paths into one \"use\" statement, we can use \"self\" in the nested path, as shown in Listing 7-20.\nFilename: src/lib.rs\nuse std::io::{self, Write};\n\nListing 7-20: Combining the paths in Listing 7-19 into one \"use\" statement\nThis line brings \"std::io\" and \"std::io::Write\" into scope.\nThe Glob Operator\nIf we want to bring all public items defined in a path into scope, we can specify that path followed by the \"*\" glob operator:\nuse std::collections::*;\n\nThis \"use\" statement brings all public items defined in \"std::collections\" into the current scope. Be careful when using the glob operator! Glob can make it harder to tell what names are in scope and where a name used in your program was defined.\nThe glob operator is often used when testing to bring everything under test into the \"tests\" module; we’ll talk about that in the “How to Write Tests” section in Chapter 11. The glob operator is also sometimes used as part of the prelude pattern: see the standard library documentation for more information on that pattern.\n\nSeparating Modules into Different Files\nSo far, all the examples in this chapter defined multiple modules in one file. When modules get large, you might want to move their definitions to a separate file to make the code easier to navigate.\nFor example, let’s start from the code in Listing 7-17 that had multiple restaurant modules. We’ll extract modules into files instead of having all the modules defined in the crate root file. In this case, the crate root file is src/lib.rs, but this procedure also works with binary crates whose crate root file is src/main.rs.\nFirst, we’ll extract the \"front_of_house\" module to its own file. Remove the code inside the curly brackets for the \"front_of_house\" module, leaving only the \"mod front_of_house;\" declaration, so that src/lib.rs contains the code shown in Listing 7-21. Note that this won’t compile until we create the src/front_of_house.rs file in Listing 7-22.\nFilename: src/lib.rs\nmod front_of_house;\n\npub use crate::front_of_house::hosting;\n\npub fn eat_at_restaurant() {\n    hosting::add_to_waitlist();\n}\n\nListing 7-21: Declaring the \"front_of_house\" module whose body will be in src/front_of_house.rs\nNext, place the code that was in the curly brackets into a new file named src/front_of_house.rs, as shown in Listing 7-22. The compiler knows to look in this file because it came across the module declaration in the crate root with the name \"front_of_house\".\nFilename: src/front_of_house.rs\npub mod hosting {\n    pub fn add_to_waitlist() {}\n}\n\nListing 7-22: Definitions inside the \"front_of_house\" module in src/front_of_house.rs\nNote that you only need to load a file using a \"mod\" declaration once in your module tree. Once the compiler knows the file is part of the project (and knows where in the module tree the code resides because of where you’ve put the \"mod\" statement), other files in your project should refer to the loaded file’s code using a path to where it was declared, as covered in the “Paths for Referring to an Item in the Module Tree” section. In other words, \"mod\" is not an “include” operation that you may have seen in other programming languages.\nNext, we’ll extract the \"hosting\" module to its own file. The process is a bit different because \"hosting\" is a child module of \"front_of_house\", not of the root module. We’ll place the file for \"hosting\" in a new directory that will be named for its ancestors in the module tree, in this case src/front_of_house/.\nTo start moving \"hosting\", we change src/front_of_house.rs to contain only the declaration of the \"hosting\" module:\nFilename: src/front_of_house.rs\npub mod hosting;\n\nThen we create a src/front_of_house directory and a file hosting.rs to contain the definitions made in the \"hosting\" module:\nFilename: src/front_of_house/hosting.rs\npub fn add_to_waitlist() {}\n\nIf we instead put hosting.rs in the src directory, the compiler would expect the hosting.rs code to be in a \"hosting\" module declared in the crate root, and not declared as a child of the \"front_of_house\" module. The compiler’s rules for which files to check for which modules’ code means the directories and files more closely match the module tree.\n\nAlternate File Paths\nSo far we’ve covered the most idiomatic file paths the Rust compiler uses, but Rust also supports an older style of file path. For a module named \"front_of_house\" declared in the crate root, the compiler will look for the module’s code in:\n\nsrc/front_of_house.rs (what we covered)\nsrc/front_of_house/mod.rs (older style, still supported path)\n\nFor a module named \"hosting\" that is a submodule of \"front_of_house\", the compiler will look for the module’s code in:\n\nsrc/front_of_house/hosting.rs (what we covered)\nsrc/front_of_house/hosting/mod.rs (older style, still supported path)\n\nIf you use both styles for the same module, you’ll get a compiler error. Using a mix of both styles for different modules in the same project is allowed, but might be confusing for people navigating your project.\nThe main downside to the style that uses files named mod.rs is that your project can end up with many files named mod.rs, which can get confusing when you have them open in your editor at the same time.\n\nWe’ve moved each module’s code to a separate file, and the module tree remains the same. The function calls in \"eat_at_restaurant\" will work without any modification, even though the definitions live in different files. This technique lets you move modules to new files as they grow in size.\nNote that the \"pub use crate::front_of_house::hosting\" statement in src/lib.rs also hasn’t changed, nor does \"use\" have any impact on what files are compiled as part of the crate. The \"mod\" keyword declares modules, and Rust looks in a file with the same name as the module for the code that goes into that module.\nSummary\nRust lets you split a package into multiple crates and a crate into modules so you can refer to items defined in one module from another module. You can do this by specifying absolute or relative paths. These paths can be brought into scope with a \"use\" statement so you can use a shorter path for multiple uses of the item in that scope. Module code is private by default, but you can make definitions public by adding the \"pub\" keyword.\nIn the next chapter, we’ll look at some collection data structures in the standard library that you can use in your neatly organized code.\n\nCommon Collections\nRust’s standard library includes a number of very useful data structures called collections. Most other data types represent one specific value, but collections can contain multiple values. Unlike the built-in array and tuple types, the data these collections point to is stored on the heap, which means the amount of data does not need to be known at compile time and can grow or shrink as the program runs. Each kind of collection has different capabilities and costs, and choosing an appropriate one for your current situation is a skill you’ll develop over time. In this chapter, we’ll discuss three collections that are used very often in Rust programs:\n\nA vector allows you to store a variable number of values next to each other.\nA string is a collection of characters. We’ve mentioned the \"String\" type previously, but in this chapter we’ll talk about it in depth.\nA hash map allows you to associate a value with a particular key. It’s a particular implementation of the more general data structure called a map.\n\nTo learn about the other kinds of collections provided by the standard library, see the documentation.\nWe’ll discuss how to create and update vectors, strings, and hash maps, as well as what makes each special.\n\nStoring Lists of Values with Vectors\nThe first collection type we’ll look at is \"Vec\", also known as a vector. Vectors allow you to store more than one value in a single data structure that puts all the values next to each other in memory. Vectors can only store values of the same type. They are useful when you have a list of items, such as the lines of text in a file or the prices of items in a shopping cart.\nCreating a New Vector\nTo create a new empty vector, we call the \"Vec::new\" function, as shown in Listing 8-1.\n    let v: Vec&lt;i32&gt; = Vec::new();\n\nListing 8-1: Creating a new, empty vector to hold values of type \"i32\"\nNote that we added a type annotation here. Because we aren’t inserting any values into this vector, Rust doesn’t know what kind of elements we intend to store. This is an important point. Vectors are implemented using generics; we’ll cover how to use generics with your own types in Chapter 10. For now, know that the \"Vec\" type provided by the standard library can hold any type. When we create a vector to hold a specific type, we can specify the type within angle brackets. In Listing 8-1, we’ve told Rust that the \"Vec\" in \"v\" will hold elements of the \"i32\" type.\nMore often, you’ll create a \"Vec\" with initial values and Rust will infer the type of value you want to store, so you rarely need to do this type annotation. Rust conveniently provides the \"vec!\" macro, which will create a new vector that holds the values you give it. Listing 8-2 creates a new \"Vec\" that holds the values \"1\", \"2\", and \"3\". The integer type is \"i32\" because that’s the default integer type, as we discussed in the “Data Types” section of Chapter 3.\n    let v = vec![1, 2, 3];\n\nListing 8-2: Creating a new vector containing values\nBecause we’ve given initial \"i32\" values, Rust can infer that the type of \"v\" is \"Vec\", and the type annotation isn’t necessary. Next, we’ll look at how to modify a vector.\nUpdating a Vector\nTo create a vector and then add elements to it, we can use the \"push\" method, as shown in Listing 8-3.\n    let mut v = Vec::new();\n\n    v.push(5);\n    v.push(6);\n    v.push(7);\n    v.push(8);\n\nListing 8-3: Using the \"push\" method to add values to a vector\nAs with any variable, if we want to be able to change its value, we need to make it mutable using the \"mut\" keyword, as discussed in Chapter 3. The numbers we place inside are all of type \"i32\", and Rust infers this from the data, so we don’t need the \"Vec\" annotation.\nReading Elements of Vectors\nThere are two ways to reference a value stored in a vector: via indexing or using the \"get\" method. In the following examples, we’ve annotated the types of the values that are returned from these functions for extra clarity.\nListing 8-4 shows both methods of accessing a value in a vector, with indexing syntax and the \"get\" method.\n    let v = vec![1, 2, 3, 4, 5];\n\n    let third: &amp;i32 = &amp;v[2];\n    println!(\"The third element is {third}\");\n\n    let third: Option&lt;&amp;i32&gt; = v.get(2);\n    match third {\n        Some(third) =&gt; println!(\"The third element is {third}\"),\n        None =&gt; println!(\"There is no third element.\"),\n    }\n\nListing 8-4: Using indexing syntax or the \"get\" method to access an item in a vector\nNote a few details here. We use the index value of \"2\" to get the third element because vectors are indexed by number, starting at zero. Using \"&amp;\" and \"[]\" gives us a reference to the element at the index value. When we use the \"get\" method with the index passed as an argument, we get an \"Option&lt;&amp;T&gt;\" that we can use with \"match\".\nThe reason Rust provides these two ways to reference an element is so you can choose how the program behaves when you try to use an index value outside the range of existing elements. As an example, let’s see what happens when we have a vector of five elements and then we try to access an element at index 100 with each technique, as shown in Listing 8-5.\n    let v = vec![1, 2, 3, 4, 5];\n\n    let does_not_exist = &amp;v[100];\n    let does_not_exist = v.get(100);\n\nListing 8-5: Attempting to access the element at index 100 in a vector containing five elements\nWhen we run this code, the first \"[]\" method will cause the program to panic because it references a nonexistent element. This method is best used when you want your program to crash if there’s an attempt to access an element past the end of the vector.\nWhen the \"get\" method is passed an index that is outside the vector, it returns \"None\" without panicking. You would use this method if accessing an element beyond the range of the vector may happen occasionally under normal circumstances. Your code will then have logic to handle having either \"Some(&amp;element)\" or \"None\", as discussed in Chapter 6. For example, the index could be coming from a person entering a number. If they accidentally enter a number that’s too large and the program gets a \"None\" value, you could tell the user how many items are in the current vector and give them another chance to enter a valid value. That would be more user-friendly than crashing the program due to a typo!\nWhen the program has a valid reference, the borrow checker enforces the ownership and borrowing rules (covered in Chapter 4) to ensure this reference and any other references to the contents of the vector remain valid. Recall the rule that states you can’t have mutable and immutable references in the same scope. That rule applies in Listing 8-6, where we hold an immutable reference to the first element in a vector and try to add an element to the end. This program won’t work if we also try to refer to that element later in the function:\n    let mut v = vec![1, 2, 3, 4, 5];\n\n    let first = &amp;v[0];\n\n    v.push(6);\n\n    println!(\"The first element is: {first}\");\n\nListing 8-6: Attempting to add an element to a vector while holding a reference to an item\nCompiling this code will result in this error:\n$ cargo run\n   Compiling collections v0.1.0 (file:///projects/collections)\nerror[E0502]: cannot borrow \"v\" as mutable because it is also borrowed as immutable\n --&gt; src/main.rs:6:5\n  |\n4 |     let first = &amp;v[0];\n  |                  - immutable borrow occurs here\n5 |\n6 |     v.push(6);\n  |     ^^^^^^^^^ mutable borrow occurs here\n7 |\n8 |     println!(\"The first element is: {first}\");\n  |                                      ----- immutable borrow later used here\n\nFor more information about this error, try \"rustc --explain E0502\".\nerror: could not compile \"collections\" due to previous error\n\nThe code in Listing 8-6 might look like it should work: why should a reference to the first element care about changes at the end of the vector? This error is due to the way vectors work: because vectors put the values next to each other in memory, adding a new element onto the end of the vector might require allocating new memory and copying the old elements to the new space, if there isn’t enough room to put all the elements next to each other where the vector is currently stored. In that case, the reference to the first element would be pointing to deallocated memory. The borrowing rules prevent programs from ending up in that situation.\n\nNote: For more on the implementation details of the \"Vec\" type, see “The Rustonomicon”.\n\nIterating over the Values in a Vector\nTo access each element in a vector in turn, we would iterate through all of the elements rather than use indices to access one at a time. Listing 8-7 shows how to use a \"for\" loop to get immutable references to each element in a vector of \"i32\" values and print them.\n    let v = vec![100, 32, 57];\n    for i in &amp;v {\n        println!(\"{i}\");\n    }\n\nListing 8-7: Printing each element in a vector by iterating over the elements using a \"for\" loop\nWe can also iterate over mutable references to each element in a mutable vector in order to make changes to all the elements. The \"for\" loop in Listing 8-8 will add \"50\" to each element.\n    let mut v = vec![100, 32, 57];\n    for i in &amp;mut v {\n        *i += 50;\n    }\n\nListing 8-8: Iterating over mutable references to elements in a vector\nTo change the value that the mutable reference refers to, we have to use the \"*\" dereference operator to get to the value in \"i\" before we can use the \"+=\" operator. We’ll talk more about the dereference operator in the “Following the Pointer to the Value with the Dereference Operator” section of Chapter 15.\nIterating over a vector, whether immutably or mutably, is safe because of the borrow checker's rules. If we attempted to insert or remove items in the \"for\" loop bodies in Listing 8-7 and Listing 8-8, we would get a compiler error similar to the one we got with the code in Listing 8-6. The reference to the vector that the \"for\" loop holds prevents simultaneous modification of the whole vector.\nUsing an Enum to Store Multiple Types\nVectors can only store values that are the same type. This can be inconvenient; there are definitely use cases for needing to store a list of items of different types. Fortunately, the variants of an enum are defined under the same enum type, so when we need one type to represent elements of different types, we can define and use an enum!\nFor example, say we want to get values from a row in a spreadsheet in which some of the columns in the row contain integers, some floating-point numbers, and some strings. We can define an enum whose variants will hold the different value types, and all the enum variants will be considered the same type: that of the enum. Then we can create a vector to hold that enum and so, ultimately, holds different types. We’ve demonstrated this in Listing 8-9.\n    enum SpreadsheetCell {\n        Int(i32),\n        Float(f64),\n        Text(String),\n    }\n\n    let row = vec![\n        SpreadsheetCell::Int(3),\n        SpreadsheetCell::Text(String::from(\"blue\")),\n        SpreadsheetCell::Float(10.12),\n    ];\n\nListing 8-9: Defining an \"enum\" to store values of different types in one vector\nRust needs to know what types will be in the vector at compile time so it knows exactly how much memory on the heap will be needed to store each element. We must also be explicit about what types are allowed in this vector. If Rust allowed a vector to hold any type, there would be a chance that one or more of the types would cause errors with the operations performed on the elements of the vector. Using an enum plus a \"match\" expression means that Rust will ensure at compile time that every possible case is handled, as discussed in Chapter 6.\nIf you don’t know the exhaustive set of types a program will get at runtime to store in a vector, the enum technique won’t work. Instead, you can use a trait object, which we’ll cover in Chapter 17.\nNow that we’ve discussed some of the most common ways to use vectors, be sure to review the API documentation for all the many useful methods defined on \"Vec\" by the standard library. For example, in addition to \"push\", a \"pop\" method removes and returns the last element.\nDropping a Vector Drops Its Elements\nLike any other \"struct\", a vector is freed when it goes out of scope, as annotated in Listing 8-10.\n    {\n        let v = vec![1, 2, 3, 4];\n\n        // do stuff with v\n    } // &lt;- v goes out of scope and is freed here\n\nListing 8-10: Showing where the vector and its elements are dropped\nWhen the vector gets dropped, all of its contents are also dropped, meaning the integers it holds will be cleaned up. The borrow checker ensures that any references to contents of a vector are only used while the vector itself is valid.\nLet’s move on to the next collection type: \"String\"!\n\nStoring UTF-8 Encoded Text with Strings\nWe talked about strings in Chapter 4, but we’ll look at them in more depth now. New Rustaceans commonly get stuck on strings for a combination of three reasons: Rust’s propensity for exposing possible errors, strings being a more complicated data structure than many programmers give them credit for, and UTF-8. These factors combine in a way that can seem difficult when you’re coming from other programming languages.\nWe discuss strings in the context of collections because strings are implemented as a collection of bytes, plus some methods to provide useful functionality when those bytes are interpreted as text. In this section, we’ll talk about the operations on \"String\" that every collection type has, such as creating, updating, and reading. We’ll also discuss the ways in which \"String\" is different from the other collections, namely how indexing into a \"String\" is complicated by the differences between how people and computers interpret \"String\" data.\nWhat Is a String?\nWe’ll first define what we mean by the term string. Rust has only one string type in the core language, which is the string slice \"str\" that is usually seen in its borrowed form \"&amp;str\". In Chapter 4, we talked about string slices, which are references to some UTF-8 encoded string data stored elsewhere. String literals, for example, are stored in the program’s binary and are therefore string slices.\nThe \"String\" type, which is provided by Rust’s standard library rather than coded into the core language, is a growable, mutable, owned, UTF-8 encoded string type. When Rustaceans refer to “strings” in Rust, they might be referring to either the \"String\" or the string slice \"&amp;str\" types, not just one of those types. Although this section is largely about \"String\", both types are used heavily in Rust’s standard library, and both \"String\" and string slices are UTF-8 encoded.\nCreating a New String\nMany of the same operations available with \"Vec\" are available with \"String\" as well, because \"String\" is actually implemented as a wrapper around a vector of bytes with some extra guarantees, restrictions, and capabilities. An example of a function that works the same way with \"Vec\" and \"String\" is the \"new\" function to create an instance, shown in Listing 8-11.\n    let mut s = String::new();\n\nListing 8-11: Creating a new, empty \"String\"\nThis line creates a new empty string called \"s\", which we can then load data into. Often, we’ll have some initial data that we want to start the string with. For that, we use the \"to_string\" method, which is available on any type that implements the \"Display\" trait, as string literals do. Listing 8-12 shows two examples.\n    let data = \"initial contents\";\n\n    let s = data.to_string();\n\n    // the method also works on a literal directly:\n    let s = \"initial contents\".to_string();\n\nListing 8-12: Using the \"to_string\" method to create a \"String\" from a string literal\nThis code creates a string containing \"initial contents\".\nWe can also use the function \"String::from\" to create a \"String\" from a string literal. The code in Listing 8-13 is equivalent to the code from Listing 8-12 that uses \"to_string\".\n    let s = String::from(\"initial contents\");\n\nListing 8-13: Using the \"String::from\" function to create a \"String\" from a string literal\nBecause strings are used for so many things, we can use many different generic APIs for strings, providing us with a lot of options. Some of them can seem redundant, but they all have their place! In this case, \"String::from\" and \"to_string\" do the same thing, so which you choose is a matter of style and readability.\nRemember that strings are UTF-8 encoded, so we can include any properly encoded data in them, as shown in Listing 8-14.\n    let hello = String::from(\"السلام عليكم\");\n    let hello = String::from(\"Dobrý den\");\n    let hello = String::from(\"Hello\");\n    let hello = String::from(\"שָׁלוֹם\");\n    let hello = String::from(\"नमस्ते\");\n    let hello = String::from(\"こんにちは\");\n    let hello = String::from(\"안녕하세요\");\n    let hello = String::from(\"你好\");\n    let hello = String::from(\"Olá\");\n    let hello = String::from(\"Здравствуйте\");\n    let hello = String::from(\"Hola\");\n\nListing 8-14: Storing greetings in different languages in strings\nAll of these are valid \"String\" values.\nUpdating a String\nA \"String\" can grow in size and its contents can change, just like the contents of a \"Vec\", if you push more data into it. In addition, you can conveniently use the \"+\" operator or the \"format!\" macro to concatenate \"String\" values.\nAppending to a String with \"push_str\" and \"push\"\nWe can grow a \"String\" by using the \"push_str\" method to append a string slice, as shown in Listing 8-15.\n    let mut s = String::from(\"foo\");\n    s.push_str(\"bar\");\n\nListing 8-15: Appending a string slice to a \"String\" using the \"push_str\" method\nAfter these two lines, \"s\" will contain \"foobar\". The \"push_str\" method takes a string slice because we don’t necessarily want to take ownership of the parameter. For example, in the code in Listing 8-16, we want to be able to use \"s2\" after appending its contents to \"s1\".\n    let mut s1 = String::from(\"foo\");\n    let s2 = \"bar\";\n    s1.push_str(s2);\n    println!(\"s2 is {s2}\");\n\nListing 8-16: Using a string slice after appending its contents to a \"String\"\nIf the \"push_str\" method took ownership of \"s2\", we wouldn’t be able to print its value on the last line. However, this code works as we’d expect!\nThe \"push\" method takes a single character as a parameter and adds it to the \"String\". Listing 8-17 adds the letter “l” to a \"String\" using the \"push\" method.\n    let mut s = String::from(\"lo\");\n    s.push('l');\n\nListing 8-17: Adding one character to a \"String\" value using \"push\"\nAs a result, \"s\" will contain \"lol\".\nConcatenation with the \"+\" Operator or the \"format!\" Macro\nOften, you’ll want to combine two existing strings. One way to do so is to use the \"+\" operator, as shown in Listing 8-18.\n    let s1 = String::from(\"Hello, \");\n    let s2 = String::from(\"world!\");\n    let s3 = s1 + &amp;s2; // note s1 has been moved here and can no longer be used\n\nListing 8-18: Using the \"+\" operator to combine two \"String\" values into a new \"String\" value\nThe string \"s3\" will contain \"Hello, world!\". The reason \"s1\" is no longer valid after the addition, and the reason we used a reference to \"s2\", has to do with the signature of the method that’s called when we use the \"+\" operator. The \"+\" operator uses the \"add\" method, whose signature looks something like this:\nfn add(self, s: &amp;str) -&gt; String {\n\nIn the standard library, you'll see \"add\" defined using generics and associated types. Here, we’ve substituted in concrete types, which is what happens when we call this method with \"String\" values. We’ll discuss generics in Chapter 10. This signature gives us the clues we need to understand the tricky bits of the \"+\" operator.\nFirst, \"s2\" has an \"&amp;\", meaning that we’re adding a reference of the second string to the first string. This is because of the \"s\" parameter in the \"add\" function: we can only add a \"&amp;str\" to a \"String\"; we can’t add two \"String\" values together. But wait—the type of \"&amp;s2\" is \"&amp;String\", not \"&amp;str\", as specified in the second parameter to \"add\". So why does Listing 8-18 compile?\nThe reason we’re able to use \"&amp;s2\" in the call to \"add\" is that the compiler can coerce the \"&amp;String\" argument into a \"&amp;str\". When we call the \"add\" method, Rust uses a deref coercion, which here turns \"&amp;s2\" into \"&amp;s2[..]\". We’ll discuss deref coercion in more depth in Chapter 15. Because \"add\" does not take ownership of the \"s\" parameter, \"s2\" will still be a valid \"String\" after this operation.\nSecond, we can see in the signature that \"add\" takes ownership of \"self\", because \"self\" does not have an \"&amp;\". This means \"s1\" in Listing 8-18 will be moved into the \"add\" call and will no longer be valid after that. So although \"let s3 = s1 + &amp;s2;\" looks like it will copy both strings and create a new one, this statement actually takes ownership of \"s1\", appends a copy of the contents of \"s2\", and then returns ownership of the result. In other words, it looks like it’s making a lot of copies but isn’t; the implementation is more efficient than copying.\nIf we need to concatenate multiple strings, the behavior of the \"+\" operator gets unwieldy:\n    let s1 = String::from(\"tic\");\n    let s2 = String::from(\"tac\");\n    let s3 = String::from(\"toe\");\n\n    let s = s1 + \"-\" + &amp;s2 + \"-\" + &amp;s3;\n\nAt this point, \"s\" will be \"tic-tac-toe\". With all of the \"+\" and ``` characters, it’s difficult to see what’s going on. For more complicated string combining, we can instead use the \"format!\" macro:\n    let s1 = String::from(\"tic\");\n    let s2 = String::from(\"tac\");\n    let s3 = String::from(\"toe\");\n\n    let s = format!(\"{s1}-{s2}-{s3}\");\n\nThis code also sets \"s\" to \"tic-tac-toe\". The \"format!\" macro works like \"println!\", but instead of printing the output to the screen, it returns a \"String\" with the contents. The version of the code using \"format!\" is much easier to read, and the code generated by the \"format!\" macro uses references so that this call doesn’t take ownership of any of its parameters.\nIndexing into Strings\nIn many other programming languages, accessing individual characters in a string by referencing them by index is a valid and common operation. However, if you try to access parts of a \"String\" using indexing syntax in Rust, you’ll get an error. Consider the invalid code in Listing 8-19.\n    let s1 = String::from(\"hello\");\n    let h = s1[0];\n\nListing 8-19: Attempting to use indexing syntax with a String\nThis code will result in the following error:\n$ cargo run\n   Compiling collections v0.1.0 (file:///projects/collections)\nerror[E0277]: the type \"String\" cannot be indexed by \"{integer}\"\n --&gt; src/main.rs:3:13\n  |\n3 |     let h = s1[0];\n  |             ^^^^^ \"String\" cannot be indexed by \"{integer}\"\n  |\n  = help: the trait \"Index&lt;{integer}&gt;\" is not implemented for \"String\"\n  = help: the following other types implement trait \"Index&lt;Idx&gt;\":\n            &lt;String as Index&lt;RangeFrom&lt;usize&gt;&gt;&gt;\n            &lt;String as Index&lt;RangeFull&gt;&gt;\n            &lt;String as Index&lt;RangeInclusive&lt;usize&gt;&gt;&gt;\n            &lt;String as Index&lt;RangeTo&lt;usize&gt;&gt;&gt;\n            &lt;String as Index&lt;RangeToInclusive&lt;usize&gt;&gt;&gt;\n            &lt;String as Index&lt;std::ops::Range&lt;usize&gt;&gt;&gt;\n\nFor more information about this error, try \"rustc --explain E0277\".\nerror: could not compile \"collections\" due to previous error\n\nThe error and the note tell the story: Rust strings don’t support indexing. But why not? To answer that question, we need to discuss how Rust stores strings in memory.\nInternal Representation\nA \"String\" is a wrapper over a \"Vec\". Let’s look at some of our properly encoded UTF-8 example strings from Listing 8-14. First, this one:\n    let hello = String::from(\"Hola\");\n\nIn this case, \"len\" will be 4, which means the vector storing the string “Hola” is 4 bytes long. Each of these letters takes 1 byte when encoded in UTF-8. The following line, however, may surprise you. (Note that this string begins with the capital Cyrillic letter Ze, not the Arabic number 3.)\n    let hello = String::from(\"Здравствуйте\");\n\nAsked how long the string is, you might say 12. In fact, Rust’s answer is 24: that’s the number of bytes it takes to encode “Здравствуйте” in UTF-8, because each Unicode scalar value in that string takes 2 bytes of storage. Therefore, an index into the string’s bytes will not always correlate to a valid Unicode scalar value. To demonstrate, consider this invalid Rust code:\nlet hello = \"Здравствуйте\";\nlet answer = &amp;hello[0];\n\nYou already know that \"answer\" will not be \"З\", the first letter. When encoded in UTF-8, the first byte of \"З\" is \"208\" and the second is \"151\", so it would seem that \"answer\" should in fact be \"208\", but \"208\" is not a valid character on its own. Returning \"208\" is likely not what a user would want if they asked for the first letter of this string; however, that’s the only data that Rust has at byte index 0. Users generally don’t want the byte value returned, even if the string contains only Latin letters: if \"&amp;\"hello\"[0]\" were valid code that returned the byte value, it would return \"104\", not \"h\".\nThe answer, then, is that to avoid returning an unexpected value and causing bugs that might not be discovered immediately, Rust doesn’t compile this code at all and prevents misunderstandings early in the development process.\nBytes and Scalar Values and Grapheme Clusters! Oh My!\nAnother point about UTF-8 is that there are actually three relevant ways to look at strings from Rust’s perspective: as bytes, scalar values, and grapheme clusters (the closest thing to what we would call letters).\nIf we look at the Hindi word “नमस्ते” written in the Devanagari script, it is stored as a vector of \"u8\" values that looks like this:\n[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,\n224, 165, 135]\n\nThat’s 18 bytes and is how computers ultimately store this data. If we look at them as Unicode scalar values, which are what Rust’s \"char\" type is, those bytes look like this:\n['न', 'म', 'स', '्', 'त', 'े']\n\nThere are six \"char\" values here, but the fourth and sixth are not letters: they’re diacritics that don’t make sense on their own. Finally, if we look at them as grapheme clusters, we’d get what a person would call the four letters that make up the Hindi word:\n[\"न\", \"म\", \"स्\", \"ते\"]\n\nRust provides different ways of interpreting the raw string data that computers store so that each program can choose the interpretation it needs, no matter what human language the data is in.\nA final reason Rust doesn’t allow us to index into a \"String\" to get a character is that indexing operations are expected to always take constant time (O(1)). But it isn’t possible to guarantee that performance with a \"String\", because Rust would have to walk through the contents from the beginning to the index to determine how many valid characters there were.\nSlicing Strings\nIndexing into a string is often a bad idea because it’s not clear what the return type of the string-indexing operation should be: a byte value, a character, a grapheme cluster, or a string slice. If you really need to use indices to create string slices, therefore, Rust asks you to be more specific.\nRather than indexing using \"[]\" with a single number, you can use \"[]\" with a range to create a string slice containing particular bytes:\nlet hello = \"Здравствуйте\";\n\nlet s = &amp;hello[0..4];\n\nHere, \"s\" will be a \"&amp;str\" that contains the first 4 bytes of the string. Earlier, we mentioned that each of these characters was 2 bytes, which means \"s\" will be \"Зд\".\nIf we were to try to slice only part of a character’s bytes with something like \"&amp;hello[0..1]\", Rust would panic at runtime in the same way as if an invalid index were accessed in a vector:\n$ cargo run\n   Compiling collections v0.1.0 (file:///projects/collections)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.43s\n     Running \"target/debug/collections\"\nthread 'main' panicked at 'byte index 1 is not a char boundary; it is inside 'З' (bytes 0..2) of \"Здравствуйте\"', src/main.rs:4:14\nnote: run with \"RUST_BACKTRACE=1\" environment variable to display a backtrace\n\nYou should use ranges to create string slices with caution, because doing so can crash your program.\nMethods for Iterating Over Strings\nThe best way to operate on pieces of strings is to be explicit about whether you want characters or bytes. For individual Unicode scalar values, use the \"chars\" method. Calling \"chars\" on “Зд” separates out and returns two values of type \"char\", and you can iterate over the result to access each element:\nfor c in \"Зд\".chars() {\n    println!(\"{c}\");\n}\n\nThis code will print the following:\nЗ\nд\n\nAlternatively, the \"bytes\" method returns each raw byte, which might be appropriate for your domain:\nfor b in \"Зд\".bytes() {\n    println!(\"{b}\");\n}\n\nThis code will print the four bytes that make up this string:\n208\n151\n208\n180\n\nBut be sure to remember that valid Unicode scalar values may be made up of more than 1 byte.\nGetting grapheme clusters from strings as with the Devanagari script is complex, so this functionality is not provided by the standard library. Crates are available on crates.io if this is the functionality you need.\nStrings Are Not So Simple\nTo summarize, strings are complicated. Different programming languages make different choices about how to present this complexity to the programmer. Rust has chosen to make the correct handling of \"String\" data the default behavior for all Rust programs, which means programmers have to put more thought into handling UTF-8 data upfront. This trade-off exposes more of the complexity of strings than is apparent in other programming languages, but it prevents you from having to handle errors involving non-ASCII characters later in your development life cycle.\nThe good news is that the standard library offers a lot of functionality built off the \"String\" and \"&amp;str\" types to help handle these complex situations correctly. Be sure to check out the documentation for useful methods like \"contains\" for searching in a string and \"replace\" for substituting parts of a string with another string.\nLet’s switch to something a bit less complex: hash maps!\n\nStoring Keys with Associated Values in Hash Maps\nThe last of our common collections is the hash map. The type \"HashMap&lt;K, V&gt;\" stores a mapping of keys of type \"K\" to values of type \"V\" using a hashing function, which determines how it places these keys and values into memory. Many programming languages support this kind of data structure, but they often use a different name, such as hash, map, object, hash table, dictionary, or associative array, just to name a few.\nHash maps are useful when you want to look up data not by using an index, as you can with vectors, but by using a key that can be of any type. For example, in a game, you could keep track of each team’s score in a hash map in which each key is a team’s name and the values are each team’s score. Given a team name, you can retrieve its score.\nWe’ll go over the basic API of hash maps in this section, but many more goodies are hiding in the functions defined on \"HashMap&lt;K, V&gt;\" by the standard library. As always, check the standard library documentation for more information.\nCreating a New Hash Map\nOne way to create an empty hash map is using \"new\" and adding elements with \"insert\". In Listing 8-20, we’re keeping track of the scores of two teams whose names are Blue and Yellow. The Blue team starts with 10 points, and the Yellow team starts with 50.\n    use std::collections::HashMap;\n\n    let mut scores = HashMap::new();\n\n    scores.insert(String::from(\"Blue\"), 10);\n    scores.insert(String::from(\"Yellow\"), 50);\n\nListing 8-20: Creating a new hash map and inserting some keys and values\nNote that we need to first \"use\" the \"HashMap\" from the collections portion of the standard library. Of our three common collections, this one is the least often used, so it’s not included in the features brought into scope automatically in the prelude. Hash maps also have less support from the standard library; there’s no built-in macro to construct them, for example.\nJust like vectors, hash maps store their data on the heap. This \"HashMap\" has keys of type \"String\" and values of type \"i32\". Like vectors, hash maps are homogeneous: all of the keys must have the same type as each other, and all of the values must have the same type.\nAccessing Values in a Hash Map\nWe can get a value out of the hash map by providing its key to the \"get\" method, as shown in Listing 8-21.\n    use std::collections::HashMap;\n\n    let mut scores = HashMap::new();\n\n    scores.insert(String::from(\"Blue\"), 10);\n    scores.insert(String::from(\"Yellow\"), 50);\n\n    let team_name = String::from(\"Blue\");\n    let score = scores.get(&amp;team_name).copied().unwrap_or(0);\n\nListing 8-21: Accessing the score for the Blue team stored in the hash map\nHere, \"score\" will have the value that’s associated with the Blue team, and the result will be \"10\". The \"get\" method returns an \"Option&lt;&amp;V&gt;\"; if there’s no value for that key in the hash map, \"get\" will return \"None\". This program handles the \"Option\" by calling \"copied\" to get an \"Option\" rather than an \"Option&lt;&amp;i32&gt;\", then \"unwrap_or\" to set \"score\" to zero if \"scores\" doesn't have an entry for the key.\nWe can iterate over each key/value pair in a hash map in a similar manner as we do with vectors, using a \"for\" loop:\n    use std::collections::HashMap;\n\n    let mut scores = HashMap::new();\n\n    scores.insert(String::from(\"Blue\"), 10);\n    scores.insert(String::from(\"Yellow\"), 50);\n\n    for (key, value) in &amp;scores {\n        println!(\"{key}: {value}\");\n    }\n\nThis code will print each pair in an arbitrary order:\nYellow: 50\nBlue: 10\n\nHash Maps and Ownership\nFor types that implement the \"Copy\" trait, like \"i32\", the values are copied into the hash map. For owned values like \"String\", the values will be moved and the hash map will be the owner of those values, as demonstrated in Listing 8-22.\n    use std::collections::HashMap;\n\n    let field_name = String::from(\"Favorite color\");\n    let field_value = String::from(\"Blue\");\n\n    let mut map = HashMap::new();\n    map.insert(field_name, field_value);\n    // field_name and field_value are invalid at this point, try using them and\n    // see what compiler error you get!\n\nListing 8-22: Showing that keys and values are owned by the hash map once they’re inserted\nWe aren’t able to use the variables \"field_name\" and \"field_value\" after they’ve been moved into the hash map with the call to \"insert\".\nIf we insert references to values into the hash map, the values won’t be moved into the hash map. The values that the references point to must be valid for at least as long as the hash map is valid. We’ll talk more about these issues in the “Validating References with Lifetimes” section in Chapter 10.\nUpdating a Hash Map\nAlthough the number of key and value pairs is growable, each unique key can only have one value associated with it at a time (but not vice versa: for example, both the Blue team and the Yellow team could have value 10 stored in the \"scores\" hash map).\nWhen you want to change the data in a hash map, you have to decide how to handle the case when a key already has a value assigned. You could replace the old value with the new value, completely disregarding the old value. You could keep the old value and ignore the new value, only adding the new value if the key doesn’t already have a value. Or you could combine the old value and the new value. Let’s look at how to do each of these!\nOverwriting a Value\nIf we insert a key and a value into a hash map and then insert that same key with a different value, the value associated with that key will be replaced. Even though the code in Listing 8-23 calls \"insert\" twice, the hash map will only contain one key/value pair because we’re inserting the value for the Blue team’s key both times.\n    use std::collections::HashMap;\n\n    let mut scores = HashMap::new();\n\n    scores.insert(String::from(\"Blue\"), 10);\n    scores.insert(String::from(\"Blue\"), 25);\n\n    println!(\"{:?}\", scores);\n\nListing 8-23: Replacing a value stored with a particular key\nThis code will print \"{\"Blue\": 25}\". The original value of \"10\" has been overwritten.\nAdding a Key and Value Only If a Key Isn’t Present\nIt’s common to check whether a particular key already exists in the hash map with a value then take the following actions: if the key does exist in the hash map, the existing value should remain the way it is. If the key doesn’t exist, insert it and a value for it.\nHash maps have a special API for this called \"entry\" that takes the key you want to check as a parameter. The return value of the \"entry\" method is an enum called \"Entry\" that represents a value that might or might not exist. Let’s say we want to check whether the key for the Yellow team has a value associated with it. If it doesn’t, we want to insert the value 50, and the same for the Blue team. Using the \"entry\" API, the code looks like Listing 8-24.\n    use std::collections::HashMap;\n\n    let mut scores = HashMap::new();\n    scores.insert(String::from(\"Blue\"), 10);\n\n    scores.entry(String::from(\"Yellow\")).or_insert(50);\n    scores.entry(String::from(\"Blue\")).or_insert(50);\n\n    println!(\"{:?}\", scores);\n\nListing 8-24: Using the \"entry\" method to only insert if the key does not already have a value\nThe \"or_insert\" method on \"Entry\" is defined to return a mutable reference to the value for the corresponding \"Entry\" key if that key exists, and if not, inserts the parameter as the new value for this key and returns a mutable reference to the new value. This technique is much cleaner than writing the logic ourselves and, in addition, plays more nicely with the borrow checker.\nRunning the code in Listing 8-24 will print \"{\"Yellow\": 50, \"Blue\": 10}\". The first call to \"entry\" will insert the key for the Yellow team with the value 50 because the Yellow team doesn’t have a value already. The second call to \"entry\" will not change the hash map because the Blue team already has the value 10.\nUpdating a Value Based on the Old Value\nAnother common use case for hash maps is to look up a key’s value and then update it based on the old value. For instance, Listing 8-25 shows code that counts how many times each word appears in some text. We use a hash map with the words as keys and increment the value to keep track of how many times we’ve seen that word. If it’s the first time we’ve seen a word, we’ll first insert the value 0.\n    use std::collections::HashMap;\n\n    let text = \"hello world wonderful world\";\n\n    let mut map = HashMap::new();\n\n    for word in text.split_whitespace() {\n        let count = map.entry(word).or_insert(0);\n        *count += 1;\n    }\n\n    println!(\"{:?}\", map);\n\nListing 8-25: Counting occurrences of words using a hash map that stores words and counts\nThis code will print \"{\"world\": 2, \"hello\": 1, \"wonderful\": 1}\". You might see the same key/value pairs printed in a different order: recall from the “Accessing Values in a Hash Map” section that iterating over a hash map happens in an arbitrary order.\nThe \"split_whitespace\" method returns an iterator over sub-slices, separated by whitespace, of the value in \"text\". The \"or_insert\" method returns a mutable reference (\"&amp;mut V\") to the value for the specified key. Here we store that mutable reference in the \"count\" variable, so in order to assign to that value, we must first dereference \"count\" using the asterisk (\"*\"). The mutable reference goes out of scope at the end of the \"for\" loop, so all of these changes are safe and allowed by the borrowing rules.\nHashing Functions\nBy default, \"HashMap\" uses a hashing function called SipHash that can provide resistance to Denial of Service (DoS) attacks involving hash tables1. This is not the fastest hashing algorithm available, but the trade-off for better security that comes with the drop in performance is worth it. If you profile your code and find that the default hash function is too slow for your purposes, you can switch to another function by specifying a different hasher. A hasher is a type that implements the \"BuildHasher\" trait. We’ll talk about traits and how to implement them in Chapter 10. You don’t necessarily have to implement your own hasher from scratch; crates.io has libraries shared by other Rust users that provide hashers implementing many common hashing algorithms.\n1 \nhttps://en.wikipedia.org/wiki/SipHash\nSummary\nVectors, strings, and hash maps will provide a large amount of functionality necessary in programs when you need to store, access, and modify data. Here are some exercises you should now be equipped to solve:\n\nGiven a list of integers, use a vector and return the median (when sorted, the value in the middle position) and mode (the value that occurs most often; a hash map will be helpful here) of the list.\nConvert strings to pig latin. The first consonant of each word is moved to the end of the word and “ay” is added, so “first” becomes “irst-fay.” Words that start with a vowel have “hay” added to the end instead (“apple” becomes “apple-hay”). Keep in mind the details about UTF-8 encoding!\nUsing a hash map and vectors, create a text interface to allow a user to add employee names to a department in a company. For example, “Add Sally to Engineering” or “Add Amir to Sales.” Then let the user retrieve a list of all people in a department or all people in the company by department, sorted alphabetically.\n\nThe standard library API documentation describes methods that vectors, strings, and hash maps have that will be helpful for these exercises!\nWe’re getting into more complex programs in which operations can fail, so, it’s a perfect time to discuss error handling. We’ll do that next!\n\nError Handling\nErrors are a fact of life in software, so Rust has a number of features for handling situations in which something goes wrong. In many cases, Rust requires you to acknowledge the possibility of an error and take some action before your code will compile. This requirement makes your program more robust by ensuring that you’ll discover errors and handle them appropriately before you’ve deployed your code to production!\nRust groups errors into two major categories: recoverable and unrecoverable errors. For a recoverable error, such as a file not found error, we most likely just want to report the problem to the user and retry the operation. Unrecoverable errors are always symptoms of bugs, like trying to access a location beyond the end of an array, and so we want to immediately stop the program.\nMost languages don’t distinguish between these two kinds of errors and handle both in the same way, using mechanisms such as exceptions. Rust doesn’t have exceptions. Instead, it has the type \"Result&lt;T, E&gt;\" for recoverable errors and the \"panic!\" macro that stops execution when the program encounters an unrecoverable error. This chapter covers calling \"panic!\" first and then talks about returning \"Result&lt;T, E&gt;\" values. Additionally, we’ll explore considerations when deciding whether to try to recover from an error or to stop execution.\nUnrecoverable Errors with \"panic!\"\nSometimes, bad things happen in your code, and there’s nothing you can do about it. In these cases, Rust has the \"panic!\" macro. There are two ways to cause a panic in practice: by taking an action that causes our code to panic (such as accessing an array past the end) or by explicitly calling the \"panic!\" macro. In both cases, we cause a panic in our program. By default, these panics will print a failure message, unwind, clean up the stack, and quit. Via an environment variable, you can also have Rust display the call stack when a panic occurs to make it easier to track down the source of the panic.\n\nUnwinding the Stack or Aborting in Response to a Panic\nBy default, when a panic occurs, the program starts unwinding, which means Rust walks back up the stack and cleans up the data from each function it encounters. However, this walking back and cleanup is a lot of work. Rust, therefore, allows you to choose the alternative of immediately aborting, which ends the program without cleaning up.\nMemory that the program was using will then need to be cleaned up by the operating system. If in your project you need to make the resulting binary as small as possible, you can switch from unwinding to aborting upon a panic by adding \"panic = 'abort'\" to the appropriate \"[profile]\" sections in your Cargo.toml file. For example, if you want to abort on panic in release mode, add this:\n[profile.release]\npanic = 'abort'\n\n\nLet’s try calling \"panic!\" in a simple program:\nFilename: src/main.rs\nfn main() {\n    panic!(\"crash and burn\");\n}\n\nWhen you run the program, you’ll see something like this:\n$ cargo run\n   Compiling panic v0.1.0 (file:///projects/panic)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.25s\n     Running \"target/debug/panic\"\nthread 'main' panicked at 'crash and burn', src/main.rs:2:5\nnote: run with \"RUST_BACKTRACE=1\" environment variable to display a backtrace\n\nThe call to \"panic!\" causes the error message contained in the last two lines. The first line shows our panic message and the place in our source code where the panic occurred: src/main.rs:2:5 indicates that it’s the second line, fifth character of our src/main.rs file.\nIn this case, the line indicated is part of our code, and if we go to that line, we see the \"panic!\" macro call. In other cases, the \"panic!\" call might be in code that our code calls, and the filename and line number reported by the error message will be someone else’s code where the \"panic!\" macro is called, not the line of our code that eventually led to the \"panic!\" call. We can use the backtrace of the functions the \"panic!\" call came from to figure out the part of our code that is causing the problem. We’ll discuss backtraces in more detail next.\nUsing a \"panic!\" Backtrace\nLet’s look at another example to see what it’s like when a \"panic!\" call comes from a library because of a bug in our code instead of from our code calling the macro directly. Listing 9-1 has some code that attempts to access an index in a vector beyond the range of valid indexes.\nFilename: src/main.rs\nfn main() {\n    let v = vec![1, 2, 3];\n\n    v[99];\n}\n\nListing 9-1: Attempting to access an element beyond the end of a vector, which will cause a call to \"panic!\"\nHere, we’re attempting to access the 100th element of our vector (which is at index 99 because indexing starts at zero), but the vector has only 3 elements. In this situation, Rust will panic. Using \"[]\" is supposed to return an element, but if you pass an invalid index, there’s no element that Rust could return here that would be correct.\nIn C, attempting to read beyond the end of a data structure is undefined behavior. You might get whatever is at the location in memory that would correspond to that element in the data structure, even though the memory doesn’t belong to that structure. This is called a buffer overread and can lead to security vulnerabilities if an attacker is able to manipulate the index in such a way as to read data they shouldn’t be allowed to that is stored after the data structure.\nTo protect your program from this sort of vulnerability, if you try to read an element at an index that doesn’t exist, Rust will stop execution and refuse to continue. Let’s try it and see:\n$ cargo run\n   Compiling panic v0.1.0 (file:///projects/panic)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.27s\n     Running \"target/debug/panic\"\nthread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', src/main.rs:4:5\nnote: run with \"RUST_BACKTRACE=1\" environment variable to display a backtrace\n\nThis error points at line 4 of our \"main.rs\" where we attempt to access index 99. The next note line tells us that we can set the \"RUST_BACKTRACE\" environment variable to get a backtrace of exactly what happened to cause the error. A backtrace is a list of all the functions that have been called to get to this point. Backtraces in Rust work as they do in other languages: the key to reading the backtrace is to start from the top and read until you see files you wrote. That’s the spot where the problem originated. The lines above that spot are code that your code has called; the lines below are code that called your code. These before-and-after lines might include core Rust code, standard library code, or crates that you’re using. Let’s try getting a backtrace by setting the \"RUST_BACKTRACE\" environment variable to any value except 0. Listing 9-2 shows output similar to what you’ll see.\n$ RUST_BACKTRACE=1 cargo run\nthread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', src/main.rs:4:5\nstack backtrace:\n   0: rust_begin_unwind\n             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/std/src/panicking.rs:584:5\n   1: core::panicking::panic_fmt\n             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/panicking.rs:142:14\n   2: core::panicking::panic_bounds_check\n             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/panicking.rs:84:5\n   3: &lt;usize as core::slice::index::SliceIndex&lt;[T]&gt;&gt;::index\n             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/slice/index.rs:242:10\n   4: core::slice::index::&lt;impl core::ops::index::Index&lt;I&gt; for [T]&gt;::index\n             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/slice/index.rs:18:9\n   5: &lt;alloc::vec::Vec&lt;T,A&gt; as core::ops::index::Index&lt;I&gt;&gt;::index\n             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/alloc/src/vec/mod.rs:2591:9\n   6: panic::main\n             at ./src/main.rs:4:5\n   7: core::ops::function::FnOnce::call_once\n             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/ops/function.rs:248:5\nnote: Some details are omitted, run with \"RUST_BACKTRACE=full\" for a verbose backtrace.\n\nListing 9-2: The backtrace generated by a call to \"panic!\" displayed when the environment variable \"RUST_BACKTRACE\" is set\nThat’s a lot of output! The exact output you see might be different depending on your operating system and Rust version. In order to get backtraces with this information, debug symbols must be enabled. Debug symbols are enabled by default when using \"cargo build\" or \"cargo run\" without the \"--release\" flag, as we have here.\nIn the output in Listing 9-2, line 6 of the backtrace points to the line in our project that’s causing the problem: line 4 of src/main.rs. If we don’t want our program to panic, we should start our investigation at the location pointed to by the first line mentioning a file we wrote. In Listing 9-1, where we deliberately wrote code that would panic, the way to fix the panic is to not request an element beyond the range of the vector indexes. When your code panics in the future, you’ll need to figure out what action the code is taking with what values to cause the panic and what the code should do instead.\nWe’ll come back to \"panic!\" and when we should and should not use \"panic!\" to handle error conditions in the “To \"panic!\" or Not to \"panic!\"” section later in this chapter. Next, we’ll look at how to recover from an error using \"Result\".\n\nRecoverable Errors with \"Result\"\nMost errors aren’t serious enough to require the program to stop entirely. Sometimes, when a function fails, it’s for a reason that you can easily interpret and respond to. For example, if you try to open a file and that operation fails because the file doesn’t exist, you might want to create the file instead of terminating the process.\nRecall from “Handling Potential Failure with \"Result\"” in Chapter 2 that the \"Result\" enum is defined as having two variants, \"Ok\" and \"Err\", as follows:\nenum Result&lt;T, E&gt; {\n    Ok(T),\n    Err(E),\n}\n\nThe \"T\" and \"E\" are generic type parameters: we’ll discuss generics in more detail in Chapter 10. What you need to know right now is that \"T\" represents the type of the value that will be returned in a success case within the \"Ok\" variant, and \"E\" represents the type of the error that will be returned in a failure case within the \"Err\" variant. Because \"Result\" has these generic type parameters, we can use the \"Result\" type and the functions defined on it in many different situations where the successful value and error value we want to return may differ.\nLet’s call a function that returns a \"Result\" value because the function could fail. In Listing 9-3 we try to open a file.\nFilename: src/main.rs\nuse std::fs::File;\n\nfn main() {\n    let greeting_file_result = File::open(\"hello.txt\");\n}\n\nListing 9-3: Opening a file\nThe return type of \"File::open\" is a \"Result&lt;T, E&gt;\". The generic parameter \"T\" has been filled in by the implementation of \"File::open\" with the type of the success value, \"std::fs::File\", which is a file handle. The type of \"E\" used in the error value is \"std::io::Error\". This return type means the call to \"File::open\" might succeed and return a file handle that we can read from or write to. The function call also might fail: for example, the file might not exist, or we might not have permission to access the file. The \"File::open\" function needs to have a way to tell us whether it succeeded or failed and at the same time give us either the file handle or error information. This information is exactly what the \"Result\" enum conveys.\nIn the case where \"File::open\" succeeds, the value in the variable \"greeting_file_result\" will be an instance of \"Ok\" that contains a file handle. In the case where it fails, the value in \"greeting_file_result\" will be an instance of \"Err\" that contains more information about the kind of error that happened.\nWe need to add to the code in Listing 9-3 to take different actions depending on the value \"File::open\" returns. Listing 9-4 shows one way to handle the \"Result\" using a basic tool, the \"match\" expression that we discussed in Chapter 6.\nFilename: src/main.rs\nuse std::fs::File;\n\nfn main() {\n    let greeting_file_result = File::open(\"hello.txt\");\n\n    let greeting_file = match greeting_file_result {\n        Ok(file) =&gt; file,\n        Err(error) =&gt; panic!(\"Problem opening the file: {:?}\", error),\n    };\n}\n\nListing 9-4: Using a \"match\" expression to handle the \"Result\" variants that might be returned\nNote that, like the \"Option\" enum, the \"Result\" enum and its variants have been brought into scope by the prelude, so we don’t need to specify \"Result::\" before the \"Ok\" and \"Err\" variants in the \"match\" arms.\nWhen the result is \"Ok\", this code will return the inner \"file\" value out of the \"Ok\" variant, and we then assign that file handle value to the variable \"greeting_file\". After the \"match\", we can use the file handle for reading or writing.\nThe other arm of the \"match\" handles the case where we get an \"Err\" value from \"File::open\". In this example, we’ve chosen to call the \"panic!\" macro. If there’s no file named hello.txt in our current directory and we run this code, we’ll see the following output from the \"panic!\" macro:\n$ cargo run\n   Compiling error-handling v0.1.0 (file:///projects/error-handling)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.73s\n     Running \"target/debug/error-handling\"\nthread 'main' panicked at 'Problem opening the file: Os { code: 2, kind: NotFound, message: \"No such file or directory\" }', src/main.rs:8:23\nnote: run with \"RUST_BACKTRACE=1\" environment variable to display a backtrace\n\nAs usual, this output tells us exactly what has gone wrong.\nMatching on Different Errors\nThe code in Listing 9-4 will \"panic!\" no matter why \"File::open\" failed. However, we want to take different actions for different failure reasons: if \"File::open\" failed because the file doesn’t exist, we want to create the file and return the handle to the new file. If \"File::open\" failed for any other reason—for example, because we didn’t have permission to open the file—we still want the code to \"panic!\" in the same way as it did in Listing 9-4. For this we add an inner \"match\" expression, shown in Listing 9-5.\nFilename: src/main.rs\nuse std::fs::File;\nuse std::io::ErrorKind;\n\nfn main() {\n    let greeting_file_result = File::open(\"hello.txt\");\n\n    let greeting_file = match greeting_file_result {\n        Ok(file) =&gt; file,\n        Err(error) =&gt; match error.kind() {\n            ErrorKind::NotFound =&gt; match File::create(\"hello.txt\") {\n                Ok(fc) =&gt; fc,\n                Err(e) =&gt; panic!(\"Problem creating the file: {:?}\", e),\n            },\n            other_error =&gt; {\n                panic!(\"Problem opening the file: {:?}\", other_error);\n            }\n        },\n    };\n}\n\nListing 9-5: Handling different kinds of errors in different ways\nThe type of the value that \"File::open\" returns inside the \"Err\" variant is \"io::Error\", which is a struct provided by the standard library. This struct has a method \"kind\" that we can call to get an \"io::ErrorKind\" value. The enum \"io::ErrorKind\" is provided by the standard library and has variants representing the different kinds of errors that might result from an \"io\" operation. The variant we want to use is \"ErrorKind::NotFound\", which indicates the file we’re trying to open doesn’t exist yet. So we match on \"greeting_file_result\", but we also have an inner match on \"error.kind()\".\nThe condition we want to check in the inner match is whether the value returned by \"error.kind()\" is the \"NotFound\" variant of the \"ErrorKind\" enum. If it is, we try to create the file with \"File::create\". However, because \"File::create\" could also fail, we need a second arm in the inner \"match\" expression. When the file can’t be created, a different error message is printed. The second arm of the outer \"match\" stays the same, so the program panics on any error besides the missing file error.\n\nAlternatives to Using \"match\" with \"Result\"\nThat’s a lot of \"match\"! The \"match\" expression is very useful but also very much a primitive. In Chapter 13, you’ll learn about closures, which are used with many of the methods defined on \"Result&lt;T, E&gt;\". These methods can be more concise than using \"match\" when handling \"Result&lt;T, E&gt;\" values in your code.\nFor example, here’s another way to write the same logic as shown in Listing 9-5, this time using closures and the \"unwrap_or_else\" method:\nuse std::fs::File;\nuse std::io::ErrorKind;\n\nfn main() {\n    let greeting_file = File::open(\"hello.txt\").unwrap_or_else(|error| {\n        if error.kind() == ErrorKind::NotFound {\n            File::create(\"hello.txt\").unwrap_or_else(|error| {\n                panic!(\"Problem creating the file: {:?}\", error);\n            })\n        } else {\n            panic!(\"Problem opening the file: {:?}\", error);\n        }\n    });\n}\n\nAlthough this code has the same behavior as Listing 9-5, it doesn’t contain any \"match\" expressions and is cleaner to read. Come back to this example after you’ve read Chapter 13, and look up the \"unwrap_or_else\" method in the standard library documentation. Many more of these methods can clean up huge nested \"match\" expressions when you’re dealing with errors.\n\nShortcuts for Panic on Error: \"unwrap\" and \"expect\"\nUsing \"match\" works well enough, but it can be a bit verbose and doesn’t always communicate intent well. The \"Result&lt;T, E&gt;\" type has many helper methods defined on it to do various, more specific tasks. The \"unwrap\" method is a shortcut method implemented just like the \"match\" expression we wrote in Listing 9-4. If the \"Result\" value is the \"Ok\" variant, \"unwrap\" will return the value inside the \"Ok\". If the \"Result\" is the \"Err\" variant, \"unwrap\" will call the \"panic!\" macro for us. Here is an example of \"unwrap\" in action:\nFilename: src/main.rs\nuse std::fs::File;\n\nfn main() {\n    let greeting_file = File::open(\"hello.txt\").unwrap();\n}\n\nIf we run this code without a hello.txt file, we’ll see an error message from the \"panic!\" call that the \"unwrap\" method makes:\nthread 'main' panicked at 'called \"Result::unwrap()\" on an \"Err\" value: Os {\ncode: 2, kind: NotFound, message: \"No such file or directory\" }',\nsrc/main.rs:4:49\n\nSimilarly, the \"expect\" method lets us also choose the \"panic!\" error message. Using \"expect\" instead of \"unwrap\" and providing good error messages can convey your intent and make tracking down the source of a panic easier. The syntax of \"expect\" looks like this:\nFilename: src/main.rs\nuse std::fs::File;\n\nfn main() {\n    let greeting_file = File::open(\"hello.txt\")\n        .expect(\"hello.txt should be included in this project\");\n}\n\nWe use \"expect\" in the same way as \"unwrap\": to return the file handle or call the \"panic!\" macro. The error message used by \"expect\" in its call to \"panic!\" will be the parameter that we pass to \"expect\", rather than the default \"panic!\" message that \"unwrap\" uses. Here’s what it looks like:\nthread 'main' panicked at 'hello.txt should be included in this project: Os {\ncode: 2, kind: NotFound, message: \"No such file or directory\" }',\nsrc/main.rs:5:10\n\nIn production-quality code, most Rustaceans choose \"expect\" rather than \"unwrap\" and give more context about why the operation is expected to always succeed. That way, if your assumptions are ever proven wrong, you have more information to use in debugging.\nPropagating Errors\nWhen a function’s implementation calls something that might fail, instead of handling the error within the function itself, you can return the error to the calling code so that it can decide what to do. This is known as propagating the error and gives more control to the calling code, where there might be more information or logic that dictates how the error should be handled than what you have available in the context of your code.\nFor example, Listing 9-6 shows a function that reads a username from a file. If the file doesn’t exist or can’t be read, this function will return those errors to the code that called the function.\nFilename: src/main.rs\nuse std::fs::File;\nuse std::io::{self, Read};\n\nfn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {\n    let username_file_result = File::open(\"hello.txt\");\n\n    let mut username_file = match username_file_result {\n        Ok(file) =&gt; file,\n        Err(e) =&gt; return Err(e),\n    };\n\n    let mut username = String::new();\n\n    match username_file.read_to_string(&amp;mut username) {\n        Ok(_) =&gt; Ok(username),\n        Err(e) =&gt; Err(e),\n    }\n}\n\nListing 9-6: A function that returns errors to the calling code using \"match\"\nThis function can be written in a much shorter way, but we’re going to start by doing a lot of it manually in order to explore error handling; at the end, we’ll show the shorter way. Let’s look at the return type of the function first: \"Result&lt;String, io::Error&gt;\". This means the function is returning a value of the type \"Result&lt;T, E&gt;\" where the generic parameter \"T\" has been filled in with the concrete type \"String\", and the generic type \"E\" has been filled in with the concrete type \"io::Error\".\nIf this function succeeds without any problems, the code that calls this function will receive an \"Ok\" value that holds a \"String\"—the username that this function read from the file. If this function encounters any problems, the calling code will receive an \"Err\" value that holds an instance of \"io::Error\" that contains more information about what the problems were. We chose \"io::Error\" as the return type of this function because that happens to be the type of the error value returned from both of the operations we’re calling in this function’s body that might fail: the \"File::open\" function and the \"read_to_string\" method.\nThe body of the function starts by calling the \"File::open\" function. Then we handle the \"Result\" value with a \"match\" similar to the \"match\" in Listing 9-4. If \"File::open\" succeeds, the file handle in the pattern variable \"file\" becomes the value in the mutable variable \"username_file\" and the function continues. In the \"Err\" case, instead of calling \"panic!\", we use the \"return\" keyword to return early out of the function entirely and pass the error value from \"File::open\", now in the pattern variable \"e\", back to the calling code as this function’s error value.\nSo if we have a file handle in \"username_file\", the function then creates a new \"String\" in variable \"username\" and calls the \"read_to_string\" method on the file handle in \"username_file\" to read the contents of the file into \"username\". The \"read_to_string\" method also returns a \"Result\" because it might fail, even though \"File::open\" succeeded. So we need another \"match\" to handle that \"Result\": if \"read_to_string\" succeeds, then our function has succeeded, and we return the username from the file that’s now in \"username\" wrapped in an \"Ok\". If \"read_to_string\" fails, we return the error value in the same way that we returned the error value in the \"match\" that handled the return value of \"File::open\". However, we don’t need to explicitly say \"return\", because this is the last expression in the function.\nThe code that calls this code will then handle getting either an \"Ok\" value that contains a username or an \"Err\" value that contains an \"io::Error\". It’s up to the calling code to decide what to do with those values. If the calling code gets an \"Err\" value, it could call \"panic!\" and crash the program, use a default username, or look up the username from somewhere other than a file, for example. We don’t have enough information on what the calling code is actually trying to do, so we propagate all the success or error information upward for it to handle appropriately.\nThis pattern of propagating errors is so common in Rust that Rust provides the question mark operator \"?\" to make this easier.\nA Shortcut for Propagating Errors: the \"?\" Operator\nListing 9-7 shows an implementation of \"read_username_from_file\" that has the same functionality as in Listing 9-6, but this implementation uses the \"?\" operator.\nFilename: src/main.rs\nuse std::fs::File;\nuse std::io::{self, Read};\n\nfn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {\n    let mut username_file = File::open(\"hello.txt\")?;\n    let mut username = String::new();\n    username_file.read_to_string(&amp;mut username)?;\n    Ok(username)\n}\n\nListing 9-7: A function that returns errors to the calling code using the \"?\" operator\nThe \"?\" placed after a \"Result\" value is defined to work in almost the same way as the \"match\" expressions we defined to handle the \"Result\" values in Listing 9-6. If the value of the \"Result\" is an \"Ok\", the value inside the \"Ok\" will get returned from this expression, and the program will continue. If the value is an \"Err\", the \"Err\" will be returned from the whole function as if we had used the \"return\" keyword so the error value gets propagated to the calling code.\nThere is a difference between what the \"match\" expression from Listing 9-6 does and what the \"?\" operator does: error values that have the \"?\" operator called on them go through the \"from\" function, defined in the \"From\" trait in the standard library, which is used to convert values from one type into another. When the \"?\" operator calls the \"from\" function, the error type received is converted into the error type defined in the return type of the current function. This is useful when a function returns one error type to represent all the ways a function might fail, even if parts might fail for many different reasons.\nFor example, we could change the \"read_username_from_file\" function in Listing 9-7 to return a custom error type named \"OurError\" that we define. If we also define \"impl Fromio::Error for OurError\" to construct an instance of \"OurError\" from an \"io::Error\", then the \"?\" operator calls in the body of \"read_username_from_file\" will call \"from\" and convert the error types without needing to add any more code to the function.\nIn the context of Listing 9-7, the \"?\" at the end of the \"File::open\" call will return the value inside an \"Ok\" to the variable \"username_file\". If an error occurs, the \"?\" operator will return early out of the whole function and give any \"Err\" value to the calling code. The same thing applies to the \"?\" at the end of the \"read_to_string\" call.\nThe \"?\" operator eliminates a lot of boilerplate and makes this function’s implementation simpler. We could even shorten this code further by chaining method calls immediately after the \"?\", as shown in Listing 9-8.\nFilename: src/main.rs\nuse std::fs::File;\nuse std::io::{self, Read};\n\nfn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {\n    let mut username = String::new();\n\n    File::open(\"hello.txt\")?.read_to_string(&amp;mut username)?;\n\n    Ok(username)\n}\n\nListing 9-8: Chaining method calls after the \"?\" operator\nWe’ve moved the creation of the new \"String\" in \"username\" to the beginning of the function; that part hasn’t changed. Instead of creating a variable \"username_file\", we’ve chained the call to \"read_to_string\" directly onto the result of \"File::open(\"hello.txt\")?\". We still have a \"?\" at the end of the \"read_to_string\" call, and we still return an \"Ok\" value containing \"username\" when both \"File::open\" and \"read_to_string\" succeed rather than returning errors. The functionality is again the same as in Listing 9-6 and Listing 9-7; this is just a different, more ergonomic way to write it.\nListing 9-9 shows a way to make this even shorter using \"fs::read_to_string\".\nFilename: src/main.rs\nuse std::fs;\nuse std::io;\n\nfn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {\n    fs::read_to_string(\"hello.txt\")\n}\n\nListing 9-9: Using \"fs::read_to_string\" instead of opening and then reading the file\nReading a file into a string is a fairly common operation, so the standard library provides the convenient \"fs::read_to_string\" function that opens the file, creates a new \"String\", reads the contents of the file, puts the contents into that \"String\", and returns it. Of course, using \"fs::read_to_string\" doesn’t give us the opportunity to explain all the error handling, so we did it the longer way first.\nWhere The \"?\" Operator Can Be Used\nThe \"?\" operator can only be used in functions whose return type is compatible with the value the \"?\" is used on. This is because the \"?\" operator is defined to perform an early return of a value out of the function, in the same manner as the \"match\" expression we defined in Listing 9-6. In Listing 9-6, the \"match\" was using a \"Result\" value, and the early return arm returned an \"Err(e)\" value. The return type of the function has to be a \"Result\" so that it’s compatible with this \"return\".\nIn Listing 9-10, let’s look at the error we’ll get if we use the \"?\" operator in a \"main\" function with a return type incompatible with the type of the value we use \"?\" on:\nFilename: src/main.rs\nuse std::fs::File;\n\nfn main() {\n    let greeting_file = File::open(\"hello.txt\")?;\n}\n\nListing 9-10: Attempting to use the \"?\" in the \"main\" function that returns \"()\" won’t compile\nThis code opens a file, which might fail. The \"?\" operator follows the \"Result\" value returned by \"File::open\", but this \"main\" function has the return type of \"()\", not \"Result\". When we compile this code, we get the following error message:\n$ cargo run\n   Compiling error-handling v0.1.0 (file:///projects/error-handling)\nerror[E0277]: the \"?\" operator can only be used in a function that returns \"Result\" or \"Option\" (or another type that implements \"FromResidual\")\n --&gt; src/main.rs:4:48\n  |\n3 | fn main() {\n  | --------- this function should return \"Result\" or \"Option\" to accept \"?\"\n4 |     let greeting_file = File::open(\"hello.txt\")?;\n  |                                                ^ cannot use the \"?\" operator in a function that returns \"()\"\n  |\n  = help: the trait \"FromResidual&lt;Result&lt;Infallible, std::io::Error&gt;&gt;\" is not implemented for \"()\"\n\nFor more information about this error, try \"rustc --explain E0277\".\nerror: could not compile \"error-handling\" due to previous error\n\nThis error points out that we’re only allowed to use the \"?\" operator in a function that returns \"Result\", \"Option\", or another type that implements \"FromResidual\".\nTo fix the error, you have two choices. One choice is to change the return type of your function to be compatible with the value you’re using the \"?\" operator on as long as you have no restrictions preventing that. The other technique is to use a \"match\" or one of the \"Result&lt;T, E&gt;methods to handle theResult&lt;T, E&gt;` in whatever way is appropriate.\nThe error message also mentioned that ? can be used with Option&lt;T&gt; values as well. As with using ? on Result, you can only use ? on Option in a function that returns an Option. The behavior of the ? operator when called on an Option&lt;T&gt; is similar to its behavior when called on a Result&lt;T, E&gt;: if the value is None, the None will be returned early from the function at that point. If the value is Some, the value inside the Some is the resulting value of the expression and the function continues. Listing 9-11 has an example of a function that finds the last character of the first line in the given text:\nfn last_char_of_first_line(text: &amp;str) -&gt; Option&lt;char&gt; {\n    text.lines().next()?.chars().last()\n}\n\nListing 9-11: Using the ? operator on an Option&lt;T&gt; value\nThis function returns Option&lt;char&gt; because it’s possible that there is a character there, but it’s also possible that there isn’t. This code takes the text string slice argument and calls the lines method on it, which returns an iterator over the lines in the string. Because this function wants to examine the first line, it calls next on the iterator to get the first value from the iterator. If text is the empty string, this call to next will return None, in which case we use ? to stop and return None from last_char_of_first_line. If text is not the empty string, next will return a Some value containing a string slice of the first line in text.\nThe ? extracts the string slice, and we can call chars on that string slice to get an iterator of its characters. We’re interested in the last character in this first line, so we call last to return the last item in the iterator. This is an Option because it’s possible that the first line is the empty string, for example if text starts with a blank line but has characters on other lines, as in \"\\nhi\". However, if there is a last character on the first line, it will be returned in the Some variant. The ? operator in the middle gives us a concise way to express this logic, allowing us to implement the function in one line. If we couldn’t use the ? operator on Option, we’d have to implement this logic using more method calls or a match expression.\nNote that you can use the ? operator on a Result in a function that returns Result, and you can use the ? operator on an Option in a function that returns Option, but you can’t mix and match. The ? operator won’t automatically convert a Result to an Option or vice versa; in those cases, you can use methods like the ok method on Result or the ok_or method on Option to do the conversion explicitly.\nSo far, all the main functions we’ve used return (). The main function is special because it’s the entry and exit point of executable programs, and there are restrictions on what its return type can be for the programs to behave as expected.\nLuckily, main can also return a Result&lt;(), E&gt;. Listing 9-12 has the code from Listing 9-10 but we’ve changed the return type of main to be Result&lt;(), Box&lt;dyn Error&gt;&gt; and added a return value Ok(()) to the end. This code will now compile:\nuse std::error::Error;\nuse std::fs::File;\n\nfn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {\n    let greeting_file = File::open(\"hello.txt\")?;\n\n    Ok(())\n}\n\nListing 9-12: Changing main to return Result&lt;(), E&gt; allows the use of the ? operator on Result values\nThe Box&lt;dyn Error&gt; type is a trait object, which we’ll talk about in the “Using Trait Objects that Allow for Values of Different Types” section in Chapter 17. For now, you can read Box&lt;dyn Error&gt; to mean “any kind of error.” Using ? on a Result value in a main function with the error type Box&lt;dyn Error&gt; is allowed, because it allows any Err value to be returned early. Even though the body of this main function will only ever return errors of type std::io::Error, by specifying Box&lt;dyn Error&gt;, this signature will continue to be correct even if more code that returns other errors is added to the body of main.\nWhen a main function returns a Result&lt;(), E&gt;, the executable will exit with a value of 0 if main returns Ok(()) and will exit with a nonzero value if main returns an Err value. Executables written in C return integers when they exit: programs that exit successfully return the integer 0, and programs that error return some integer other than 0. Rust also returns integers from executables to be compatible with this convention.\nThe main function may return any types that implement the std::process::Termination trait, which contains a function report that returns an ExitCode. Consult the standard library documentation for more information on implementing the Termination trait for your own types.\nNow that we’ve discussed the details of calling panic! or returning Result, let’s return to the topic of how to decide which is appropriate to use in which cases.\n\nTo panic! or Not to panic!\nSo how do you decide when you should call panic! and when you should return Result? When code panics, there’s no way to recover. You could call panic! for any error situation, whether there’s a possible way to recover or not, but then you’re making the decision that a situation is unrecoverable on behalf of the calling code. When you choose to return a Result value, you give the calling code options. The calling code could choose to attempt to recover in a way that’s appropriate for its situation, or it could decide that an Err value in this case is unrecoverable, so it can call panic! and turn your recoverable error into an unrecoverable one. Therefore, returning Result is a good default choice when you’re defining a function that might fail.\nIn situations such as examples, prototype code, and tests, it’s more appropriate to write code that panics instead of returning a Result. Let’s explore why, then discuss situations in which the compiler can’t tell that failure is impossible, but you as a human can. The chapter will conclude with some general guidelines on how to decide whether to panic in library code.\nExamples, Prototype Code, and Tests\nWhen you’re writing an example to illustrate some concept, also including robust error-handling code can make the example less clear. In examples, it’s understood that a call to a method like unwrap that could panic is meant as a placeholder for the way you’d want your application to handle errors, which can differ based on what the rest of your code is doing.\nSimilarly, the unwrap and expect methods are very handy when prototyping, before you’re ready to decide how to handle errors. They leave clear markers in your code for when you’re ready to make your program more robust.\nIf a method call fails in a test, you’d want the whole test to fail, even if that method isn’t the functionality under test. Because panic! is how a test is marked as a failure, calling unwrap or expect is exactly what should happen.\nCases in Which You Have More Information Than the Compiler\nIt would also be appropriate to call unwrap or expect when you have some other logic that ensures the Result will have an Ok value, but the logic isn’t something the compiler understands. You’ll still have a Result value that you need to handle: whatever operation you’re calling still has the possibility of failing in general, even though it’s logically impossible in your particular situation. If you can ensure by manually inspecting the code that you’ll never have an Err variant, it’s perfectly acceptable to call unwrap, and even better to document the reason you think you’ll never have an Err variant in the expect text. Here’s an example:\n    use std::net::IpAddr;\n\n    let home: IpAddr = \"127.0.0.1\"\n        .parse()\n        .expect(\"Hardcoded IP address should be valid\");\n\nWe’re creating an IpAddr instance by parsing a hardcoded string. We can see that 127.0.0.1 is a valid IP address, so it’s acceptable to use expect here. However, having a hardcoded, valid string doesn’t change the return type of the parse method: we still get a Result value, and the compiler will still make us handle the Result as if the Err variant is a possibility because the compiler isn’t smart enough to see that this string is always a valid IP address. If the IP address string came from a user rather than being hardcoded into the program and therefore did have a possibility of failure, we’d definitely want to handle the Result in a more robust way instead. Mentioning the assumption that this IP address is hardcoded will prompt us to change expect to better error handling code if in the future, we need to get the IP address from some other source instead.\nGuidelines for Error Handling\nIt’s advisable to have your code panic when it’s possible that your code could end up in a bad state. In this context, a bad state is when some assumption, guarantee, contract, or invariant has been broken, such as when invalid values, contradictory values, or missing values are passed to your code—plus one or more of the following:\n\nThe bad state is something that is unexpected, as opposed to something that will likely happen occasionally, like a user entering data in the wrong format.\nYour code after this point needs to rely on not being in this bad state, rather than checking for the problem at every step.\nThere’s not a good way to encode this information in the types you use. We’ll work through an example of what we mean in the “Encoding States and Behavior as Types” section of Chapter 17.\n\nIf someone calls your code and passes in values that don’t make sense, it’s best to return an error if you can so the user of the library can decide what they want to do in that case. However, in cases where continuing could be insecure or harmful, the best choice might be to call panic! and alert the person using your library to the bug in their code so they can fix it during development. Similarly, panic! is often appropriate if you’re calling external code that is out of your control and it returns an invalid state that you have no way of fixing.\nHowever, when failure is expected, it’s more appropriate to return a Result than to make a panic! call. Examples include a parser being given malformed data or an HTTP request returning a status that indicates you have hit a rate limit. In these cases, returning a Result indicates that failure is an expected possibility that the calling code must decide how to handle.\nWhen your code performs an operation that could put a user at risk if it’s called using invalid values, your code should verify the values are valid first and panic if the values aren’t valid. This is mostly for safety reasons: attempting to operate on invalid data can expose your code to vulnerabilities. This is the main reason the standard library will call panic! if you attempt an out-of-bounds memory access: trying to access memory that doesn’t belong to the current data structure is a common security problem. Functions often have contracts: their behavior is only guaranteed if the inputs meet particular requirements. Panicking when the contract is violated makes sense because a contract violation always indicates a caller-side bug and it’s not a kind of error you want the calling code to have to explicitly handle. In fact, there’s no reasonable way for calling code to recover; the calling programmers need to fix the code. Contracts for a function, especially when a violation will cause a panic, should be explained in the API documentation for the function.\nHowever, having lots of error checks in all of your functions would be verbose and annoying. Fortunately, you can use Rust’s type system (and thus the type checking done by the compiler) to do many of the checks for you. If your function has a particular type as a parameter, you can proceed with your code’s logic knowing that the compiler has already ensured you have a valid value. For example, if you have a type rather than an Option, your program expects to have something rather than nothing. Your code then doesn’t have to handle two cases for the Some and None variants: it will only have one case for definitely having a value. Code trying to pass nothing to your function won’t even compile, so your function doesn’t have to check for that case at runtime. Another example is using an unsigned integer type such as u32, which ensures the parameter is never negative.\nCreating Custom Types for Validation\nLet’s take the idea of using Rust’s type system to ensure we have a valid value one step further and look at creating a custom type for validation. Recall the guessing game in Chapter 2 in which our code asked the user to guess a number between 1 and 100. We never validated that the user’s guess was between those numbers before checking it against our secret number; we only validated that the guess was positive. In this case, the consequences were not very dire: our output of “Too high” or “Too low” would still be correct. But it would be a useful enhancement to guide the user toward valid guesses and have different behavior when a user guesses a number that’s out of range versus when a user types, for example, letters instead.\nOne way to do this would be to parse the guess as an i32 instead of only a u32 to allow potentially negative numbers, and then add a check for the number being in range, like so:\n    loop {\n        // --snip--\n\n        let guess: i32 = match guess.trim().parse() {\n            Ok(num) =&gt; num,\n            Err(_) =&gt; continue,\n        };\n\n        if guess &lt; 1 || guess &gt; 100 {\n            println!(\"The secret number will be between 1 and 100.\");\n            continue;\n        }\n\n        match guess.cmp(&amp;secret_number) {\n            // --snip--\n    }\n\nThe if expression checks whether our value is out of range, tells the user about the problem, and calls continue to start the next iteration of the loop and ask for another guess. After the if expression, we can proceed with the comparisons between guess and the secret number knowing that guess is between 1 and 100.\nHowever, this is not an ideal solution: if it was absolutely critical that the program only operated on values between 1 and 100, and it had many functions with this requirement, having a check like this in every function would be tedious (and might impact performance).\nInstead, we can make a new type and put the validations in a function to create an instance of the type rather than repeating the validations everywhere. That way, it’s safe for functions to use the new type in their signatures and confidently use the values they receive. Listing 9-13 shows one way to define a Guess type that will only create an instance of Guess if the new function receives a value between 1 and 100.\npub struct Guess {\n    value: i32,\n}\n\nimpl Guess {\n    pub fn new(value: i32) -&gt; Guess {\n        if value &lt; 1 || value &gt; 100 {\n            panic!(\"Guess value must be between 1 and 100, got {}.\", value);\n        }\n\n        Guess { value }\n    }\n\n    pub fn value(&amp;self) -&gt; i32 {\n        self.value\n    }\n}\n\nListing 9-13: A Guess type that will only continue with values between 1 and 100\nFirst, we define a struct named Guess that has a field named value that holds an i32. This is where the number will be stored.\nThen we implement an associated function named new on Guess that creates instances of Guess values. The new function is defined to have one parameter named value of type i32 and to return a Guess. The code in the body of the new function tests value to make sure it’s between 1 and 100. If value doesn’t pass this test, we make a panic! call, which will alert the programmer who is writing the calling code that they have a bug they need to fix, because creating a Guess with a value outside this range would violate the contract that Guess::new is relying on. The conditions in which Guess::new might panic should be discussed in its public-facing API documentation; we’ll cover documentation conventions indicating the possibility of a panic! in the API documentation that you create in Chapter 14. If value does pass the test, we create a new Guess with its value field set to the value parameter and return the Guess.\nNext, we implement a method named value that borrows self, doesn’t have any other parameters, and returns an i32. This kind of method is sometimes called a getter, because its purpose is to get some data from its fields and return it. This public method is necessary because the value field of the Guess struct is private. It’s important that the value field be private so code using the Guess struct is not allowed to set value directly: code outside the module must use the Guess::new function to create an instance of Guess, thereby ensuring there’s no way for a Guess to have a value that hasn’t been checked by the conditions in the Guess::new function.\nA function that has a parameter or returns only numbers between 1 and 100 could then declare in its signature that it takes or returns a Guess rather than an i32 and wouldn’t need to do any additional checks in its body.\nSummary\nRust’s error handling features are designed to help you write more robust code. The panic! macro signals that your program is in a state it can’t handle and lets you tell the process to stop instead of trying to proceed with invalid or incorrect values. The Result enum uses Rust’s type system to indicate that operations might fail in a way that your code could recover from. You can use Result to tell code that calls your code that it needs to handle potential success or failure as well. Using panic! and Result in the appropriate situations will make your code more reliable in the face of inevitable problems.\nNow that you’ve seen useful ways that the standard library uses generics with the Option and Result enums, we’ll talk about how generics work and how you can use them in your code.\n\nGeneric Types, Traits, and Lifetimes\nEvery programming language has tools for effectively handling the duplication of concepts. In Rust, one such tool is generics: abstract stand-ins for concrete types or other properties. We can express the behavior of generics or how they relate to other generics without knowing what will be in their place when compiling and running the code.\nFunctions can take parameters of some generic type, instead of a concrete type like i32 or String, in the same way a function takes parameters with unknown values to run the same code on multiple concrete values. In fact, we’ve already used generics in Chapter 6 with Option&lt;T&gt;, Chapter 8 with Vec&lt;T&gt; and HashMap&lt;K, V&gt;, and Chapter 9 with Result&lt;T, E&gt;. In this chapter, you’ll explore how to define your own types, functions, and methods with generics!\nFirst, we’ll review how to extract a function to reduce code duplication. We’ll then use the same technique to make a generic function from two functions that differ only in the types of their parameters. We’ll also explain how to use generic types in struct and enum definitions.\nThen you’ll learn how to use traits to define behavior in a generic way. You can combine traits with generic types to constrain a generic type to accept only those types that have a particular behavior, as opposed to just any type.\nFinally, we’ll discuss lifetimes: a variety of generics that give the compiler information about how references relate to each other. Lifetimes allow us to give the compiler enough information about borrowed values so that it can ensure references will be valid in more situations than it could without our help.\nRemoving Duplication by Extracting a Function\nGenerics allow us to replace specific types with a placeholder that represents multiple types to remove code duplication. Before diving into generics syntax, then, let’s first look at how to remove duplication in a way that doesn’t involve generic types by extracting a function that replaces specific values with a placeholder that represents multiple values. Then we’ll apply the same technique to extract a generic function! By looking at how to recognize duplicated code you can extract into a function, you’ll start to recognize duplicated code that can use generics.\nWe begin with the short program in Listing 10-1 that finds the largest number in a list.\nFilename: src/main.rs\nfn main() {\n    let number_list = vec![34, 50, 25, 100, 65];\n\n    let mut largest = &amp;number_list[0];\n\n    for number in &amp;number_list {\n        if number &gt; largest {\n            largest = number;\n        }\n    }\n\n    println!(\"The largest number is {}\", largest);\n}\n\nListing 10-1: Finding the largest number in a list of numbers\nWe store a list of integers in the variable number_list and place a reference to the first number in the list in a variable named largest. We then iterate through all the numbers in the list, and if the current number is greater than the number stored in largest, replace the reference in that variable. However, if the current number is less than or equal to the largest number seen so far, the variable doesn’t change, and the code moves on to the next number in the list. After considering all the numbers in the list, largest should refer to the largest number, which in this case is 100.\nWe've now been tasked with finding the largest number in two different lists of numbers. To do so, we can choose to duplicate the code in Listing 10-1 and use the same logic at two different places in the program, as shown in Listing 10-2.\nFilename: src/main.rs\nfn main() {\n    let number_list = vec![34, 50, 25, 100, 65];\n\n    let mut largest = &amp;number_list[0];\n\n    for number in &amp;number_list {\n        if number &gt; largest {\n            largest = number;\n        }\n    }\n\n    println!(\"The largest number is {}\", largest);\n\n    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];\n\n    let mut largest = &amp;number_list[0];\n\n    for number in &amp;number_list {\n        if number &gt; largest {\n            largest = number;\n        }\n    }\n\n    println!(\"The largest number is {}\", largest);\n}\n\nListing 10-2: Code to find the largest number in two lists of numbers\nAlthough this code works, duplicating code is tedious and error prone. We also have to remember to update the code in multiple places when we want to change it.\nTo eliminate this duplication, we’ll create an abstraction by defining a function that operates on any list of integers passed in a parameter. This solution makes our code clearer and lets us express the concept of finding the largest number in a list abstractly.\nIn Listing 10-3, we extract the code that finds the largest number into a function named largest. Then we call the function to find the largest number in the two lists from Listing 10-2. We could also use the function on any other list of i32 values we might have in the future.\nFilename: src/main.rs\nfn largest(list: &amp;[i32]) -&gt; &amp;i32 {\n    let mut largest = &amp;list[0];\n\n    for item in list {\n        if item &gt; largest {\n            largest = item;\n        }\n    }\n\n    largest\n}\n\nfn main() {\n    let number_list = vec![34, 50, 25, 100, 65];\n\n    let result = largest(&amp;number_list);\n    println!(\"The largest number is {}\", result);\n\n    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];\n\n    let result = largest(&amp;number_list);\n    println!(\"The largest number is {}\", result);\n}\n\nListing 10-3: Abstracted code to find the largest number in two lists\nThe largest function has a parameter called list, which represents any concrete slice of i32 values we might pass into the function. As a result, when we call the function, the code runs on the specific values that we pass in.\nIn summary, here are the steps we took to change the code from Listing 10-2 to Listing 10-3:\n\nIdentify duplicate code.\nExtract the duplicate code into the body of the function and specify the inputs and return values of that code in the function signature.\nUpdate the two instances of duplicated code to call the function instead.\n\nNext, we’ll use these same steps with generics to reduce code duplication. In the same way that the function body can operate on an abstract list instead of specific values, generics allow code to operate on abstract types.\nFor example, say we had two functions: one that finds the largest item in a slice of i32 values and one that finds the largest item in a slice of char values. How would we eliminate that duplication? Let’s find out!\n\nGeneric Data Types\nWe use generics to create definitions for items like function signatures or structs, which we can then use with many different concrete data types. Let’s first look at how to define functions, structs, enums, and methods using generics. Then we’ll discuss how generics affect code performance.\nIn Function Definitions\nWhen defining a function that uses generics, we place the generics in the signature of the function where we would usually specify the data types of the parameters and return value. Doing so makes our code more flexible and provides more functionality to callers of our function while preventing code duplication.\nContinuing with our largest function, Listing 10-4 shows two functions that both find the largest value in a slice. We'll then combine these into a single function that uses generics.\nFilename: src/main.rs\nfn largest_i32(list: &amp;[i32]) -&gt; &amp;i32 {\n    let mut largest = &amp;list[0];\n\n    for item in list {\n        if item &gt; largest {\n            largest = item;\n        }\n    }\n\n    largest\n}\n\nfn largest_char(list: &amp;[char]) -&gt; &amp;char {\n    let mut largest = &amp;list[0];\n\n    for item in list {\n        if item &gt; largest {\n            largest = item;\n        }\n    }\n\n    largest\n}\n\nfn main() {\n    let number_list = vec![34, 50, 25, 100, 65];\n\n    let result = largest_i32(&amp;number_list);\n    println!(\"The largest number is {}\", result);\n\n    let char_list = vec!['y', 'm', 'a', 'q'];\n\n    let result = largest_char(&amp;char_list);\n    println!(\"The largest char is {}\", result);\n}\n\nListing 10-4: Two functions that differ only in their names and the types in their signatures\nThe largest_i32 function is the one we extracted in Listing 10-3 that finds the largest i32 in a slice. The largest_char function finds the largest char in a slice. The function bodies have the same code, so let’s eliminate the duplication by introducing a generic type parameter in a single function.\nTo parameterize the types in a new single function, we need to name the type parameter, just as we do for the value parameters to a function. You can use any identifier as a type parameter name. But we’ll use T because, by convention, type parameter names in Rust are short, often just a letter, and Rust’s type-naming convention is UpperCamelCase. Short for “type,” T is the default choice of most Rust programmers.\nWhen we use a parameter in the body of the function, we have to declare the parameter name in the signature so the compiler knows what that name means. Similarly, when we use a type parameter name in a function signature, we have to declare the type parameter name before we use it. To define the generic largest function, place type name declarations inside angle brackets, &lt;&gt;, between the name of the function and the parameter list, like this:\nfn largest&lt;T&gt;(list: &amp;[T]) -&gt; &amp;T {\n\nWe read this definition as: the function largest is generic over some type T. This function has one parameter named list, which is a slice of values of type T. The largest function will return a reference to a value of the same type T.\nListing 10-5 shows the combined largest function definition using the generic data type in its signature. The listing also shows how we can call the function with either a slice of i32 values or char values. Note that this code won’t compile yet, but we’ll fix it later in this chapter.\nFilename: src/main.rs\nfn largest&lt;T&gt;(list: &amp;[T]) -&gt; &amp;T {\n    let mut largest = &amp;list[0];\n\n    for item in list {\n        if item &gt; largest {\n            largest = item;\n        }\n    }\n\n    largest\n}\n\nfn main() {\n    let number_list = vec![34, 50, 25, 100, 65];\n\n    let result = largest(&amp;number_list);\n    println!(\"The largest number is {}\", result);\n\n    let char_list = vec!['y', 'm', 'a', 'q'];\n\n    let result = largest(&amp;char_list);\n    println!(\"The largest char is {}\", result);\n}\n\nListing 10-5: The largest function using generic type parameters; this doesn’t yet compile\nIf we compile this code right now, we’ll get this error:\n$ cargo run\n   Compiling chapter10 v0.1.0 (file:///projects/chapter10)\nerror[E0369]: binary operation `&gt;` cannot be applied to type `&amp;T`\n --&gt; src/main.rs:5:17\n  |\n5 |         if item &gt; largest {\n  |            ---- ^ ------- &amp;T\n  |            |\n  |            &amp;T\n  |\nhelp: consider restricting type parameter `T`\n  |\n1 | fn largest&lt;T: std::cmp::PartialOrd&gt;(list: &amp;[T]) -&gt; &amp;T {\n  |             ++++++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0369`.\nerror: could not compile `chapter10` due to previous error\n\nThe help text mentions std::cmp::PartialOrd, which is a trait, and we’re going to talk about traits in the next section. For now, know that this error states that the body of largest won’t work for all possible types that T could be. Because we want to compare values of type T in the body, we can only use types whose values can be ordered. To enable comparisons, the standard library has the std::cmp::PartialOrd trait that you can implement on types (see Appendix C for more on this trait). By following the help text's suggestion, we restrict the types valid for T to only those that implement PartialOrd and this example will compile, because the standard library implements PartialOrd on both i32 and char.\nIn Struct Definitions\nWe can also define structs to use a generic type parameter in one or more fields using the &lt;&gt; syntax. Listing 10-6 defines a Point&lt;T&gt; struct to hold x and y coordinate values of any type.\nFilename: src/main.rs\nstruct Point&lt;T&gt; {\n    x: T,\n    y: T,\n}\n\nfn main() {\n    let integer = Point { x: 5, y: 10 };\n    let float = Point { x: 1.0, y: 4.0 };\n}\n\nListing 10-6: A Point&lt;T&gt; struct that holds x and y values of type T\nThe syntax for using generics in struct definitions is similar to that used in function definitions. First, we declare the name of the type parameter inside angle brackets just after the name of the struct. Then we use the generic type in the struct definition where we would otherwise specify concrete data types.\nNote that because we’ve used only one generic type to define Point&lt;T&gt;, this definition says that the Point&lt;T&gt; struct is generic over some type T, and the fields x and y are both that same type, whatever that type may be. If we create an instance of a Point&lt;T&gt; that has values of different types, as in Listing 10-7, our code won’t compile.\nFilename: src/main.rs\nstruct Point&lt;T&gt; {\n    x: T,\n    y: T,\n}\n\nfn main() {\n    let wont_work = Point { x: 5, y: 4.0 };\n}\n\nListing 10-7: The fields x and y must be the same type because both have the same generic data type T.\nIn this example, when we assign the integer value 5 to x, we let the compiler know that the generic type T will be an integer for this instance of Point&lt;T&gt;. Then when we specify 4.0 for y, which we’ve defined to have the same type as x, we’ll get a type mismatch error like this:\n$ cargo run\n   Compiling chapter10 v0.1.0 (file:///projects/chapter10)\nerror[E0308]: mismatched types\n --&gt; src/main.rs:7:38\n  |\n7 |     let wont_work = Point { x: 5, y: 4.0 };\n  |                                      ^^^ expected integer, found floating-point number\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `chapter10` due to previous error\n\nTo define a Point struct where x and y are both generics but could have different types, we can use multiple generic type parameters. For example, in Listing 10-8, we change the definition of Point to be generic over types T and U where x is of type T and y is of type U.\nFilename: src/main.rs\nstruct Point&lt;T, U&gt; {\n    x: T,\n    y: U,\n}\n\nfn main() {\n    let both_integer = Point { x: 5, y: 10 };\n    let both_float = Point { x: 1.0, y: 4.0 };\n    let integer_and_float = Point { x: 5, y: 4.0 };\n}\n\nListing 10-8: A Point&lt;T, U&gt; generic over two types so that x and y can be values of different types\nNow all the instances of Point shown are allowed! You can use as many generic type parameters in a definition as you want, but using more than a few makes your code hard to read. If you're finding you need lots of generic types in your code, it could indicate that your code needs restructuring into smaller pieces.\nIn Enum Definitions\nAs we did with structs, we can define enums to hold generic data types in their variants. Let’s take another look at the Option&lt;T&gt; enum that the standard library provides, which we used in Chapter 6:\nenum Option&lt;T&gt; {\n    Some(T),\n    None,\n}\n\nThis definition should now make more sense to you. As you can see, the Option&lt;T&gt; enum is generic over type T and has two variants: Some, which holds one value of type T, and a None variant that doesn’t hold any value. By using the Option&lt;T&gt; enum, we can express the abstract concept of an optional value, and because Option&lt;T&gt; is generic, we can use this abstraction no matter what the type of the optional value is.\nEnums can use multiple generic types as well. The definition of the Result enum that we used in Chapter 9 is one example:\nenum Result&lt;T, E&gt; {\n    Ok(T),\n    Err(E),\n}\n\nThe Result enum is generic over two types, T and E, and has two variants: Ok, which holds a value of type T, and Err, which holds a value of type E. This definition makes it convenient to use the Result enum anywhere we have an operation that might succeed (return a value of some type T) or fail (return an error of some type E). In fact, this is what we used to open a file in Listing 9-3, where T was filled in with the type std::fs::File when the file was opened successfully and E was filled in with the type std::io::Error when there were problems opening the file.\nWhen you recognize situations in your code with multiple struct or enum definitions that differ only in the types of the values they hold, you can avoid duplication by using generic types instead.\nIn Method Definitions\nWe can implement methods on structs and enums (as we did in Chapter 5) and use generic types in their definitions, too. Listing 10-9 shows the Point&lt;T&gt; struct we defined in Listing 10-6 with a method named x implemented on it.\nFilename: src/main.rs\nstruct Point&lt;T&gt; {\n    x: T,\n    y: T,\n}\n\nimpl&lt;T&gt; Point&lt;T&gt; {\n    fn x(&amp;self) -&gt; &amp;T {\n        &amp;self.x\n    }\n}\n\nfn main() {\n    let p = Point { x: 5, y: 10 };\n\n    println!(\"p.x = {}\", p.x());\n}\n\nListing 10-9: Implementing a method named x on the Point&lt;T&gt; struct that will return a reference to the x field of type T\nHere, we’ve defined a method named x on Point&lt;T&gt; that returns a reference to the data in the field x.\nNote that we have to declare T just after impl so we can use T to specify that we’re implementing methods on the type Point&lt;T&gt;. By declaring T as a generic type after impl, Rust can identify that the type in the angle brackets in Point is a generic type rather than a concrete type. We could have chosen a different name for this generic parameter than the generic parameter declared in the struct definition, but using the same name is conventional. Methods written within an impl that declares the generic type will be defined on any instance of the type, no matter what concrete type ends up substituting for the generic type.\nWe can also specify constraints on generic types when defining methods on the type. We could, for example, implement methods only on Point&lt;f32&gt; instances rather than on Point&lt;T&gt; instances with any generic type. In Listing 10-10 we use the concrete type f32, meaning we don’t declare any types after impl.\nFilename: src/main.rs\nimpl Point&lt;f32&gt; {\n    fn distance_from_origin(&amp;self) -&gt; f32 {\n        (self.x.powi(2) + self.y.powi(2)).sqrt()\n    }\n}\n\nListing 10-10: An impl block that only applies to a struct with a particular concrete type for the generic type parameter T\nThis code means the type Point&lt;f32&gt; will have a distance_from_origin method; other instances of Point&lt;T&gt; where T is not of type f32 will not have this method defined. The method measures how far our point is from the point at coordinates (0.0, 0.0) and uses mathematical operations that are available only for floating point types.\nGeneric type parameters in a struct definition aren’t always the same as those you use in that same struct’s method signatures. Listing 10-11 uses the generic types X1 and Y1 for the Point struct and X2 Y2 for the mixup method signature to make the example clearer. The method creates a new Point instance with the x value from the self Point (of type X1) and the y value from the passed-in Point (of type Y2).\nFilename: src/main.rs\nstruct Point&lt;X1, Y1&gt; {\n    x: X1,\n    y: Y1,\n}\n\nimpl&lt;X1, Y1&gt; Point&lt;X1, Y1&gt; {\n    fn mixup&lt;X2, Y2&gt;(self, other: Point&lt;X2, Y2&gt;) -&gt; Point&lt;X1, Y2&gt; {\n        Point {\n            x: self.x,\n            y: other.y,\n        }\n    }\n}\n\nfn main() {\n    let p1 = Point { x: 5, y: 10.4 };\n    let p2 = Point { x: \"Hello\", y: 'c' };\n\n    let p3 = p1.mixup(p2);\n\n    println!(\"p3.x = {}, p3.y = {}\", p3.x, p3.y);\n}\n\nListing 10-11: A method that uses generic types different from its struct’s definition\nIn main, we’ve defined a Point that has an i32 for x (with value 5) and an f64 for y (with value 10.4). The p2 variable is a Point struct that has a string slice for x (with value \"Hello\") and a char for y (with value c). Calling mixup on p1 with the argument p2 gives us p3, which will have an i32 for x, because x came from p1. The p3 variable will have a char for y, because y came from p2. The println! macro call will print p3.x = 5, p3.y = c.\nThe purpose of this example is to demonstrate a situation in which some generic parameters are declared with impl and some are declared with the method definition. Here, the generic parameters X1 and Y1 are declared after impl because they go with the struct definition. The generic parameters X2 and Y2 are declared after fn mixup, because they’re only relevant to the method.\nPerformance of Code Using Generics\nYou might be wondering whether there is a runtime cost when using generic type parameters. The good news is that using generic types won't make your program run any slower than it would with concrete types.\nRust accomplishes this by performing monomorphization of the code using generics at compile time. Monomorphization is the process of turning generic code into specific code by filling in the concrete types that are used when compiled. In this process, the compiler does the opposite of the steps we used to create the generic function in Listing 10-5: the compiler looks at all the places where generic code is called and generates code for the concrete types the generic code is called with.\nLet’s look at how this works by using the standard library’s generic Option&lt;T&gt; enum:\nlet integer = Some(5);\nlet float = Some(5.0);\n\nWhen Rust compiles this code, it performs monomorphization. During that process, the compiler reads the values that have been used in Option&lt;T&gt; instances and identifies two kinds of Option&lt;T&gt;: one is i32 and the other is f64. As such, it expands the generic definition of Option&lt;T&gt; into two definitions specialized to i32 and f64, thereby replacing the generic definition with the specific ones.\nThe monomorphized version of the code looks similar to the following (the compiler uses different names than what we’re using here for illustration):\nFilename: src/main.rs\nenum Option_i32 {\n    Some(i32),\n    None,\n}\n\nenum Option_f64 {\n    Some(f64),\n    None,\n}\n\nfn main() {\n    let integer = Option_i32::Some(5);\n    let float = Option_f64::Some(5.0);\n}\n\nThe generic Option&lt;T&gt; is replaced with the specific definitions created by the compiler. Because Rust compiles generic code into code that specifies the type in each instance, we pay no runtime cost for using generics. When the code runs, it performs just as it would if we had duplicated each definition by hand. The process of monomorphization makes Rust’s generics extremely efficient at runtime.\n\nTraits: Defining Shared Behavior\nA trait defines functionality a particular type has and can share with other types. We can use traits to define shared behavior in an abstract way. We can use trait bounds to specify that a generic type can be any type that has certain behavior.\n\nNote: Traits are similar to a feature often called interfaces in other languages, although with some differences.\n\nDefining a Trait\nA type’s behavior consists of the methods we can call on that type. Different types share the same behavior if we can call the same methods on all of those types. Trait definitions are a way to group method signatures together to define a set of behaviors necessary to accomplish some purpose.\nFor example, let’s say we have multiple structs that hold various kinds and amounts of text: a NewsArticle struct that holds a news story filed in a particular location and a Tweet that can have at most 280 characters along with metadata that indicates whether it was a new tweet, a retweet, or a reply to another tweet.\nWe want to make a media aggregator library crate named aggregator that can display summaries of data that might be stored in a NewsArticle or Tweet instance. To do this, we need a summary from each type, and we’ll request that summary by calling a summarize method on an instance. Listing 10-12 shows the definition of a public Summary trait that expresses this behavior.\nFilename: src/lib.rs\npub trait Summary {\n    fn summarize(&amp;self) -&gt; String;\n}\n\nListing 10-12: A Summary trait that consists of the behavior provided by a summarize method\nHere, we declare a trait using the trait keyword and then the trait’s name, which is Summary in this case. We’ve also declared the trait as pub so that crates depending on this crate can make use of this trait too, as we’ll see in a few examples. Inside the curly brackets, we declare the method signatures that describe the behaviors of the types that implement this trait, which in this case is fn summarize(&amp;self) -&gt; String.\nAfter the method signature, instead of providing an implementation within curly brackets, we use a semicolon. Each type implementing this trait must provide its own custom behavior for the body of the method. The compiler will enforce that any type that has the Summary trait will have the method summarize defined with this signature exactly.\nA trait can have multiple methods in its body: the method signatures are listed one per line and each line ends in a semicolon.\nImplementing a Trait on a Type\nNow that we’ve defined the desired signatures of the Summary trait’s methods, we can implement it on the types in our media aggregator. Listing 10-13 shows an implementation of the Summary trait on the NewsArticle struct that uses the headline, the author, and the location to create the return value of summarize. For the Tweet struct, we define summarize as the username followed by the entire text of the tweet, assuming that tweet content is already limited to 280 characters.\nFilename: src/lib.rs\npub struct NewsArticle {\n    pub headline: String,\n    pub location: String,\n    pub author: String,\n    pub content: String,\n}\n\nimpl Summary for NewsArticle {\n    fn summarize(&amp;self) -&gt; String {\n        format!(\"{}, by {} ({})\", self.headline, self.author, self.location)\n    }\n}\n\npub struct Tweet {\n    pub username: String,\n    pub content: String,\n    pub reply: bool,\n    pub retweet: bool,\n}\n\nimpl Summary for Tweet {\n    fn summarize(&amp;self) -&gt; String {\n        format!(\"{}: {}\", self.username, self.content)\n    }\n}\n\nListing 10-13: Implementing the Summary trait on the NewsArticle and Tweet types\nImplementing a trait on a type is similar to implementing regular methods. The difference is that after impl, we put the trait name we want to implement, then use the for keyword, and then specify the name of the type we want to implement the trait for. Within the impl block, we put the method signatures that the trait definition has defined. Instead of adding a semicolon after each signature, we use curly brackets and fill in the method body with the specific behavior that we want the methods of the trait to have for the particular type.\nNow that the library has implemented the Summary trait on NewsArticle and Tweet, users of the crate can call the trait methods on instances of NewsArticle and Tweet in the same way we call regular methods. The only difference is that the user must bring the trait into scope as well as the types. Here’s an example of how a binary crate could use our aggregator library crate:\nuse aggregator::{Summary, Tweet};\n\nfn main() {\n    let tweet = Tweet {\n        username: String::from(\"horse_ebooks\"),\n        content: String::from(\n            \"of course, as you probably already know, people\",\n        ),\n        reply: false,\n        retweet: false,\n    };\n\n    println!(\"1 new tweet: {}\", tweet.summarize());\n}\n\nThis code prints 1 new tweet: horse_ebooks: of course, as you probably already know, people.\nOther crates that depend on the aggregator crate can also bring the Summary trait into scope to implement Summary on their own types. One restriction to note is that we can implement a trait on a type only if at least one of the trait or the type is local to our crate. For example, we can implement standard library traits like Display on a custom type like Tweet as part of our aggregator crate functionality, because the type Tweet is local to our aggregator crate. We can also implement Summary on Vec&lt;T&gt; in our aggregator crate, because the trait Summary is local to our aggregator crate.\nBut we can’t implement external traits on external types. For example, we can’t implement the Display trait on Vec&lt;T&gt; within our aggregator crate, because Display and Vec&lt;T&gt; are both defined in the standard library and aren’t local to our aggregator crate. This restriction is part of a property called coherence, and more specifically the orphan rule, so named because the parent type is not present. This rule ensures that other people’s code can’t break your code and vice versa. Without the rule, two crates could implement the same trait for the same type, and Rust wouldn’t know which implementation to use.\nDefault Implementations\nSometimes it’s useful to have default behavior for some or all of the methods in a trait instead of requiring implementations for all methods on every type. Then, as we implement the trait on a particular type, we can keep or override each method’s default behavior.\nIn Listing 10-14 we specify a default string for the summarize method of the Summary trait instead of only defining the method signature, as we did in Listing 10-12.\nFilename: src/lib.rs\npub trait Summary {\n    fn summarize(&amp;self) -&gt; String {\n        String::from(\"(Read more...)\")\n    }\n}\n\nListing 10-14: Defining a Summary trait with a default implementation of the summarize method\nTo use a default implementation to summarize instances of NewsArticle, we specify an empty impl block with impl Summary for NewsArticle {}.\nEven though we’re no longer defining the summarize method on NewsArticle directly, we’ve provided a default implementation and specified that NewsArticle implements the Summary trait. As a result, we can still call the summarize method on an instance of NewsArticle, like this:\n    let article = NewsArticle {\n        headline: String::from(\"Penguins win the Stanley Cup Championship!\"),\n        location: String::from(\"Pittsburgh, PA, USA\"),\n        author: String::from(\"Iceburgh\"),\n        content: String::from(\n            \"The Pittsburgh Penguins once again are the best \\\n             hockey team in the NHL.\",\n        ),\n    };\n\n    println!(\"New article available! {}\", article.summarize());\n\nThis code prints New article available! (Read more...).\nCreating a default implementation doesn’t require us to change anything about the implementation of Summary on Tweet in Listing 10-13. The reason is that the syntax for overriding a default implementation is the same as the syntax for implementing a trait method that doesn’t have a default implementation.\nDefault implementations can call other methods in the same trait, even if those other methods don’t have a default implementation. In this way, a trait can provide a lot of useful functionality and only require implementors to specify a small part of it. For example, we could define the Summary trait to have a summarize_author method whose implementation is required, and then define a summarize method that has a default implementation that calls the summarize_author method:\npub trait Summary {\n    fn summarize_author(&amp;self) -&gt; String;\n\n    fn summarize(&amp;self) -&gt; String {\n        format!(\"(Read more from {}...)\", self.summarize_author())\n    }\n}\n\nTo use this version of Summary, we only need to define summarize_author when we implement the trait on a type:\nimpl Summary for Tweet {\n    fn summarize_author(&amp;self) -&gt; String {\n        format!(\"@{}\", self.username)\n    }\n}\n\nAfter we define summarize_author, we can call summarize on instances of the Tweet struct, and the default implementation of summarize will call the definition of summarize_author that we’ve provided. Because we’ve implemented summarize_author, the Summary trait has given us the behavior of the summarize method without requiring us to write any more code.\n    let tweet = Tweet {\n        username: String::from(\"horse_ebooks\"),\n        content: String::from(\n            \"of course, as you probably already know, people\",\n        ),\n        reply: false,\n        retweet: false,\n    };\n\n    println!(\"1 new tweet: {}\", tweet.summarize());\n\nThis code prints 1 new tweet: (Read more from @horse_ebooks...).\nNote that it isn’t possible to call the default implementation from an overriding implementation of that same method.\nTraits as Parameters\nNow that you know how to define and implement traits, we can explore how to use traits to define functions that accept many different types. We'll use the Summary trait we implemented on the NewsArticle and Tweet types in Listing 10-13 to define a notify function that calls the summarize method on its item parameter, which is of some type that implements the Summary trait. To do this, we use the impl Trait syntax, like this:\npub fn notify(item: &amp;impl Summary) {\n    println!(\"Breaking news! {}\", item.summarize());\n}\n\nInstead of a concrete type for the item parameter, we specify the impl keyword and the trait name. This parameter accepts any type that implements the specified trait. In the body of notify, we can call any methods on item that come from the Summary trait, such as summarize. We can call notify and pass in any instance of NewsArticle or Tweet. Code that calls the function with any other type, such as a String or an i32, won’t compile because those types don’t implement Summary.\nTrait Bound Syntax\nThe impl Trait syntax works for straightforward cases but is actually syntax sugar for a longer form known as a trait bound; it looks like this:\npub fn notify&lt;T: Summary&gt;(item: &amp;T) {\n    println!(\"Breaking news! {}\", item.summarize());\n}\n\nThis longer form is equivalent to the example in the previous section but is more verbose. We place trait bounds with the declaration of the generic type parameter after a colon and inside angle brackets.\nThe impl Trait syntax is convenient and makes for more concise code in simple cases, while the fuller trait bound syntax can express more complexity in other cases. For example, we can have two parameters that implement Summary. Doing so with the impl Trait syntax looks like this:\npub fn notify(item1: &amp;impl Summary, item2: &amp;impl Summary) {\n\nUsing impl Trait is appropriate if we want this function to allow item1 and item2 to have different types (as long as both types implement Summary). If we want to force both parameters to have the same type, however, we must use a trait bound, like this:\npub fn notify&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) {\n\nThe generic type T specified as the type of the item1 and item2 parameters constrains the function such that the concrete type of the value passed as an argument for item1 and item2 must be the same.\nSpecifying Multiple Trait Bounds with the + Syntax\nWe can also specify more than one trait bound. Say we wanted notify to use display formatting as well as summarize on item: we specify in the notify definition that item must implement both Display and Summary. We can do so using the + syntax:\npub fn notify(item: &amp;(impl Summary + Display)) {\n\nThe + syntax is also valid with trait bounds on generic types:\npub fn notify&lt;T: Summary + Display&gt;(item: &amp;T) {\n\nWith the two trait bounds specified, the body of notify can call summarize and use {} to format item.\nClearer Trait Bounds with where Clauses\nUsing too many trait bounds has its downsides. Each generic has its own trait bounds, so functions with multiple generic type parameters can contain lots of trait bound information between the function’s name and its parameter list, making the function signature hard to read. For this reason, Rust has alternate syntax for specifying trait bounds inside a where clause after the function signature. So instead of writing this:\nfn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: &amp;T, u: &amp;U) -&gt; i32 {\n\nwe can use a where clause, like this:\nfn some_function&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32\nwhere\n    T: Display + Clone,\n    U: Clone + Debug,\n{\n\nThis function’s signature is less cluttered: the function name, parameter list, and return type are close together, similar to a function without lots of trait bounds.\nReturning Types that Implement Traits\nWe can also use the impl Trait syntax in the return position to return a value of some type that implements a trait, as shown here:\nfn returns_summarizable() -&gt; impl Summary {\n    Tweet {\n        username: String::from(\"horse_ebooks\"),\n        content: String::from(\n            \"of course, as you probably already know, people\",\n        ),\n        reply: false,\n        retweet: false,\n    }\n}\n\nBy using impl Summary for the return type, we specify that the returns_summarizable function returns some type that implements the Summary trait without naming the concrete type. In this case, returns_summarizable returns a Tweet, but the code calling this function doesn’t need to know that.\nThe ability to specify a return type only by the trait it implements is especially useful in the context of closures and iterators, which we cover in Chapter 13. Closures and iterators create types that only the compiler knows or types that are very long to specify. The impl Trait syntax lets you concisely specify that a function returns some type that implements the Iterator trait without needing to write out a very long type.\nHowever, you can only use impl Trait if you’re returning a single type. For example, this code that returns either a NewsArticle or a Tweet with the return type specified as impl Summary wouldn’t work:\nfn returns_summarizable(switch: bool) -&gt; impl Summary {\n    if switch {\n        NewsArticle {\n            headline: String::from(\n                \"Penguins win the Stanley Cup Championship!\",\n            ),\n            location: String::from(\"Pittsburgh, PA, USA\"),\n            author: String::from(\"Iceburgh\"),\n            content: String::from(\n                \"The Pittsburgh Penguins once again are the best \\\n                 hockey team in the NHL.\",\n            ),\n        }\n    } else {\n        Tweet {\n            username: String::from(\"horse_ebooks\"),\n            content: String::from(\n                \"of course, as you probably already know, people\",\n            ),\n            reply: false,\n            retweet: false,\n        }\n    }\n}\n\nReturning either a NewsArticle or a Tweet isn’t allowed due to restrictions around how the impl Trait syntax is implemented in the compiler. We’ll cover how to write a function with this behavior in the “Using Trait Objects That Allow for Values of Different Types” section of Chapter 17.\nUsing Trait Bounds to Conditionally Implement Methods\nBy using a trait bound with an impl block that uses generic type parameters, we can implement methods conditionally for types that implement the specified traits. For example, the type Pair&lt;T&gt; in Listing 10-15 always implements the new function to return a new instance of Pair&lt;T&gt; (recall from the “Defining Methods” section of Chapter 5 that Self is a type alias for the type of the impl block, which in this case is Pair&lt;T&gt;). But in the next impl block, Pair&lt;T&gt; only implements the cmp_display method if its inner type T implements the PartialOrd trait that enables comparison and the Display trait that enables printing.\nFilename: src/lib.rs\nuse std::fmt::Display;\n\nstruct Pair&lt;T&gt; {\n    x: T,\n    y: T,\n}\n\nimpl&lt;T&gt; Pair&lt;T&gt; {\n    fn new(x: T, y: T) -&gt; Self {\n        Self { x, y }\n    }\n}\n\nimpl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; {\n    fn cmp_display(&amp;self) {\n        if self.x &gt;= self.y {\n            println!(\"The largest member is x = {}\", self.x);\n        } else {\n            println!(\"The largest member is y = {}\", self.y);\n        }\n    }\n}\n\nListing 10-15: Conditionally implementing methods on a generic type depending on trait bounds\nWe can also conditionally implement a trait for any type that implements another trait. Implementations of a trait on any type that satisfies the trait bounds are called blanket implementations and are extensively used in the Rust standard library. For example, the standard library implements the ToString trait on any type that implements the Display trait. The impl block in the standard library looks similar to this code:\nimpl&lt;T: Display&gt; ToString for T {\n    // --snip--\n}\n\nBecause the standard library has this blanket implementation, we can call the to_string method defined by the ToString trait on any type that implements the Display trait. For example, we can turn integers into their corresponding String values like this because integers implement Display:\nlet s = 3.to_string();\n\nBlanket implementations appear in the documentation for the trait in the “Implementors” section.\nTraits and trait bounds let us write code that uses generic type parameters to reduce duplication but also specify to the compiler that we want the generic type to have particular behavior. The compiler can then use the trait bound information to check that all the concrete types used with our code provide the correct behavior. In dynamically typed languages, we would get an error at runtime if we called a method on a type which didn’t define the method. But Rust moves these errors to compile time so we’re forced to fix the problems before our code is even able to run. Additionally, we don’t have to write code that checks for behavior at runtime because we’ve already checked at compile time. Doing so improves performance without having to give up the flexibility of generics.\n\nValidating References with Lifetimes\nLifetimes are another kind of generic that we’ve already been using. Rather than ensuring that a type has the behavior we want, lifetimes ensure that references are valid as long as we need them to be.\nOne detail we didn’t discuss in the “References and Borrowing” section in Chapter 4 is that every reference in Rust has a lifetime, which is the scope for which that reference is valid. Most of the time, lifetimes are implicit and inferred, just like most of the time, types are inferred. We only must annotate types when multiple types are possible. In a similar way, we must annotate lifetimes when the lifetimes of references could be related in a few different ways. Rust requires us to annotate the relationships using generic lifetime parameters to ensure the actual references used at runtime will definitely be valid.\nAnnotating lifetimes is not even a concept most other programming languages have, so this is going to feel unfamiliar. Although we won’t cover lifetimes in their entirety in this chapter, we’ll discuss common ways you might encounter lifetime syntax so you can get comfortable with the concept.\nPreventing Dangling References with Lifetimes\nThe main aim of lifetimes is to prevent dangling references, which cause a program to reference data other than the data it’s intended to reference. Consider the program in Listing 10-16, which has an outer scope and an inner scope.\nfn main() {\n    let r;\n\n    {\n        let x = 5;\n        r = &amp;x;\n    }\n\n    println!(\"r: {}\", r);\n}\n\nListing 10-16: An attempt to use a reference whose value has gone out of scope\n\nNote: The examples in Listings 10-16, 10-17, and 10-23 declare variables without giving them an initial value, so the variable name exists in the outer scope. At first glance, this might appear to be in conflict with Rust’s having no null values. However, if we try to use a variable before giving it a value, we’ll get a compile-time error, which shows that Rust indeed does not allow null values.\n\nThe outer scope declares a variable named r with no initial value, and the inner scope declares a variable named x with the initial value of 5. Inside the inner scope, we attempt to set the value of r as a reference to x. Then the inner scope ends, and we attempt to print the value in r. This code won’t compile because the value r is referring to has gone out of scope before we try to use it. Here is the error message:\n$ cargo run\n   Compiling chapter10 v0.1.0 (file:///projects/chapter10)\nerror[E0597]: `x` does not live long enough\n --&gt; src/main.rs:6:13\n  |\n6 |         r = &amp;x;\n  |             ^^ borrowed value does not live long enough\n7 |     }\n  |     - `x` dropped here while still borrowed\n8 |\n9 |     println!(\"r: {}\", r);\n  |                       - borrow later used here\n\nFor more information about this error, try `rustc --explain E0597`.\nerror: could not compile `chapter10` due to previous error\n\nThe variable x doesn’t “live long enough.” The reason is that x will be out of scope when the inner scope ends on line 7. But r is still valid for the outer scope; because its scope is larger, we say that it “lives longer.” If Rust allowed this code to work, r would be referencing memory that was deallocated when x went out of scope, and anything we tried to do with r wouldn’t work correctly. So how does Rust determine that this code is invalid? It uses a borrow checker.\nThe Borrow Checker\nThe Rust compiler has a borrow checker that compares scopes to determine whether all borrows are valid. Listing 10-17 shows the same code as Listing 10-16 but with annotations showing the lifetimes of the variables.\nfn main() {\n    let r;                // ---------+-- 'a\n                          //          |\n    {                     //          |\n        let x = 5;        // -+-- 'b  |\n        r = &amp;x;           //  |       |\n    }                     // -+       |\n                          //          |\n    println!(\"r: {}\", r); //          |\n}                         // ---------+\n\nListing 10-17: Annotations of the lifetimes of r and x, named 'a and 'b, respectively\nHere, we’ve annotated the lifetime of r with 'a and the lifetime of x with 'b. As you can see, the inner 'b block is much smaller than the outer 'a lifetime block. At compile time, Rust compares the size of the two lifetimes and sees that r has a lifetime of 'a but that it refers to memory with a lifetime of 'b. The program is rejected because 'b is shorter than 'a: the subject of the reference doesn’t live as long as the reference.\nListing 10-18 fixes the code so it doesn’t have a dangling reference and compiles without any errors.\nfn main() {\n    let x = 5;            // ----------+-- 'b\n                          //           |\n    let r = &amp;x;           // --+-- 'a  |\n                          //   |       |\n    println!(\"r: {}\", r); //   |       |\n                          // --+       |\n}                         // ----------+\n\nListing 10-18: A valid reference because the data has a longer lifetime than the reference\nHere, x has the lifetime 'b, which in this case is larger than 'a. This means r can reference x because Rust knows that the reference in r will always be valid while x is valid.\nNow that you know where the lifetimes of references are and how Rust analyzes lifetimes to ensure references will always be valid, let’s explore generic lifetimes of parameters and return values in the context of functions.\nGeneric Lifetimes in Functions\nWe’ll write a function that returns the longer of two string slices. This function will take two string slices and return a single string slice. After we’ve implemented the longest function, the code in Listing 10-19 should print The longest string is abcd.\nFilename: src/main.rs\nfn main() {\n    let string1 = String::from(\"abcd\");\n    let string2 = \"xyz\";\n\n    let result = longest(string1.as_str(), string2);\n    println!(\"The longest string is {}\", result);\n}\n\nListing 10-19: A main function that calls the longest function to find the longer of two string slices\nNote that we want the function to take string slices, which are references, rather than strings, because we don’t want the longest function to take ownership of its parameters. Refer to the “String Slices as Parameters” section in Chapter 4 for more discussion about why the parameters we use in Listing 10-19 are the ones we want.\nIf we try to implement the longest function as shown in Listing 10-20, it won’t compile.\nFilename: src/main.rs\nfn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {\n    if x.len() &gt; y.len() {\n        x\n    } else {\n        y\n    }\n}\n\nListing 10-20: An implementation of the longest function that returns the longer of two string slices but does not yet compile\nInstead, we get the following error that talks about lifetimes:\n$ cargo run\n   Compiling chapter10 v0.1.0 (file:///projects/chapter10)\nerror[E0106]: missing lifetime specifier\n --&gt; src/main.rs:9:33\n  |\n9 | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {\n  |               ----     ----     ^ expected named lifetime parameter\n  |\n  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`\nhelp: consider introducing a named lifetime parameter\n  |\n9 | fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {\n  |           ++++     ++          ++          ++\n\nFor more information about this error, try `rustc --explain E0106`.\nerror: could not compile `chapter10` due to previous error\n\nThe help text reveals that the return type needs a generic lifetime parameter on it because Rust can’t tell whether the reference being returned refers to x or y. Actually, we don’t know either, because the if block in the body of this function returns a reference to x and the else block returns a reference to y!\nWhen we’re defining this function, we don’t know the concrete values that will be passed into this function, so we don’t know whether the if case or the else case will execute. We also don’t know the concrete lifetimes of the references that will be passed in, so we can’t look at the scopes as we did in Listings 10-17 and 10-18 to determine whether the reference we return will always be valid. The borrow checker can’t determine this either, because it doesn’t know how the lifetimes of x and y relate to the lifetime of the return value. To fix this error, we’ll add generic lifetime parameters that define the relationship between the references so the borrow checker can perform its analysis.\nLifetime Annotation Syntax\nLifetime annotations don’t change how long any of the references live. Rather, they describe the relationships of the lifetimes of multiple references to each other without affecting the lifetimes. Just as functions can accept any type when the signature specifies a generic type parameter, functions can accept references with any lifetime by specifying a generic lifetime parameter.\nLifetime annotations have a slightly unusual syntax: the names of lifetime parameters must start with an apostrophe (') and are usually all lowercase and very short, like generic types. Most people use the name 'a for the first lifetime annotation. We place lifetime parameter annotations after the &amp; of a reference, using a space to separate the annotation from the reference’s type.\nHere are some examples: a reference to an i32 without a lifetime parameter, a reference to an i32 that has a lifetime parameter named 'a, and a mutable reference to an i32 that also has the lifetime 'a.\n&amp;i32        // a reference\n&amp;'a i32     // a reference with an explicit lifetime\n&amp;'a mut i32 // a mutable reference with an explicit lifetime\n\nOne lifetime annotation by itself doesn’t have much meaning, because the annotations are meant to tell Rust how generic lifetime parameters of multiple references relate to each other. Let’s examine how the lifetime annotations relate to each other in the context of the longest function.\nLifetime Annotations in Function Signatures\nTo use lifetime annotations in function signatures, we need to declare the generic lifetime parameters inside angle brackets between the function name and the parameter list, just as we did with generic type parameters.\nWe want the signature to express the following constraint: the returned reference will be valid as long as both the parameters are valid. This is the relationship between lifetimes of the parameters and the return value. We’ll name the lifetime 'a and then add it to each reference, as shown in Listing 10-21.\nFilename: src/main.rs\nfn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {\n    if x.len() &gt; y.len() {\n        x\n    } else {\n        y\n    }\n}\n\nListing 10-21: The longest function definition specifying that all the references in the signature must have the same lifetime 'a\nThis code should compile and produce the result we want when we use it with the main function in Listing 10-19.\nThe function signature now tells Rust that for some lifetime 'a, the function takes two parameters, both of which are string slices that live at least as long as lifetime 'a. The function signature also tells Rust that the string slice returned from the function will live at least as long as lifetime 'a. In practice, it means that the lifetime of the reference returned by the longest function is the same as the smaller of the lifetimes of the values referred to by the function arguments. These relationships are what we want Rust to use when analyzing this code.\nRemember, when we specify the lifetime parameters in this function signature, we’re not changing the lifetimes of any values passed in or returned. Rather, we’re specifying that the borrow checker should reject any values that don’t adhere to these constraints. Note that the longest function doesn’t need to know exactly how long x and y will live, only that some scope can be substituted for 'a that will satisfy this signature.\nWhen annotating lifetimes in functions, the annotations go in the function signature, not in the function body. The lifetime annotations become part of the contract of the function, much like the types in the signature. Having function signatures contain the lifetime contract means the analysis the Rust compiler does can be simpler. If there’s a problem with the way a function is annotated or the way it is called, the compiler errors can point to the part of our code and the constraints more precisely. If, instead, the Rust compiler made more inferences about what we intended the relationships of the lifetimes to be, the compiler might only be able to point to a use of our code many steps away from the cause of the problem.\nWhen we pass concrete references to longest, the concrete lifetime that is substituted for 'a is the part of the scope of x that overlaps with the scope of y. In other words, the generic lifetime 'a will get the concrete lifetime that is equal to the smaller of the lifetimes of x and y. Because we’ve annotated the returned reference with the same lifetime parameter 'a, the returned reference will also be valid for the length of the smaller of the lifetimes of x and y.\nLet’s look at how the lifetime annotations restrict the longest function by passing in references that have different concrete lifetimes. Listing 10-22 is a straightforward example.\nFilename: src/main.rs\nfn main() {\n    let string1 = String::from(\"long string is long\");\n\n    {\n        let string2 = String::from(\"xyz\");\n        let result = longest(string1.as_str(), string2.as_str());\n        println!(\"The longest string is {}\", result);\n    }\n}\n\nListing 10-22: Using the longest function with references to String values that have different concrete lifetimes\nIn this example, string1 is valid until the end of the outer scope, string2 is valid until the end of the inner scope, and result references something that is valid until the end of the inner scope. Run this code, and you’ll see that the borrow checker approves; it will compile and print The longest string is long string is long.\nNext, let’s try an example that shows that the lifetime of the reference in result must be the smaller lifetime of the two arguments. We’ll move the declaration of the result variable outside the inner scope but leave the assignment of the value to the result variable inside the scope with string2. Then we’ll move the println! that uses result to outside the inner scope, after the inner scope has ended. The code in Listing 10-23 will not compile.\nFilename: src/main.rs\nfn main() {\n    let string1 = String::from(\"long string is long\");\n    let result;\n    {\n        let string2 = String::from(\"xyz\");\n        result = longest(string1.as_str(), string2.as_str());\n    }\n    println!(\"The longest string is {}\", result);\n}\n\nListing 10-23: Attempting to use result after string2 has gone out of scope\nWhen we try to compile this code, we get this error:\n$ cargo run\n   Compiling chapter10 v0.1.0 (file:///projects/chapter10)\nerror[E0597]: `string2` does not live long enough\n --&gt; src/main.rs:6:44\n  |\n6 |         result = longest(string1.as_str(), string2.as_str());\n  |                                            ^^^^^^^^^^^^^^^^ borrowed value does not live long enough\n7 |     }\n  |     - `string2` dropped here while still borrowed\n8 |     println!(\"The longest string is {}\", result);\n  |                                          ------ borrow later used here\n\nFor more information about this error, try `rustc --explain E0597`.\nerror: could not compile `chapter10` due to previous error\n\nThe error shows that for result to be valid for the println! statement, string2 would need to be valid until the end of the outer scope. Rust knows this because we annotated the lifetimes of the function parameters and return values using the same lifetime parameter 'a.\nAs humans, we can look at this code and see that string1 is longer than string2 and therefore result will contain a reference to string1. Because string1 has not gone out of scope yet, a reference to string1 will still be valid for the println! statement. However, the compiler can’t see that the reference is valid in this case. We’ve told Rust that the lifetime of the reference returned by the longest function is the same as the smaller of the lifetimes of the references passed in. Therefore, the borrow checker disallows the code in Listing 10-23 as possibly having an invalid reference.\nTry designing more experiments that vary the values and lifetimes of the references passed in to the longest function and how the returned reference is used. Make hypotheses about whether or not your experiments will pass the borrow checker before you compile; then check to see if you’re right!\nThinking in Terms of Lifetimes\nThe way in which you need to specify lifetime parameters depends on what your function is doing. For example, if we changed the implementation of the longest function to always return the first parameter rather than the longest string slice, we wouldn’t need to specify a lifetime on the y parameter. The following code will compile:\nFilename: src/main.rs\nfn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;str) -&gt; &amp;'a str {\n    x\n}\n\nWe’ve specified a lifetime parameter 'a for the parameter x and the return type, but not for the parameter y, because the lifetime of y does not have any relationship with the lifetime of x or the return value.\nWhen returning a reference from a function, the lifetime parameter for the return type needs to match the lifetime parameter for one of the parameters. If the reference returned does not refer to one of the parameters, it must refer to a value created within this function. However, this would be a dangling reference because the value will go out of scope at the end of the function. Consider this attempted implementation of the longest function that won’t compile:\nFilename: src/main.rs\nfn longest&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str {\n    let result = String::from(\"really long string\");\n    result.as_str()\n}\n\nHere, even though we’ve specified a lifetime parameter 'a for the return type, this implementation will fail to compile because the return value lifetime is not related to the lifetime of the parameters at all. Here is the error message we get:\n$ cargo run\n   Compiling chapter10 v0.1.0 (file:///projects/chapter10)\nerror[E0515]: cannot return reference to local variable `result`\n  --&gt; src/main.rs:11:5\n   |\n11 |     result.as_str()\n   |     ^^^^^^^^^^^^^^^ returns a reference to data owned by the current function\n\nFor more information about this error, try `rustc --explain E0515`.\nerror: could not compile `chapter10` due to previous error\n\nThe problem is that result goes out of scope and gets cleaned up at the end of the longest function. We’re also trying to return a reference to result from the function. There is no way we can specify lifetime parameters that would change the dangling reference, and Rust won’t let us create a dangling reference. In this case, the best fix would be to return an owned data type rather than a reference so the calling function is then responsible for cleaning up the value.\nUltimately, lifetime syntax is about connecting the lifetimes of various parameters and return values of functions. Once they’re connected, Rust has enough information to allow memory-safe operations and disallow operations that would create dangling pointers or otherwise violate memory safety.\nLifetime Annotations in Struct Definitions\nSo far, the structs we’ve defined all hold owned types. We can define structs to hold references, but in that case we would need to add a lifetime annotation on every reference in the struct’s definition. Listing 10-24 has a struct named ImportantExcerpt that holds a string slice.\nFilename: src/main.rs\nstruct ImportantExcerpt&lt;'a&gt; {\n    part: &amp;'a str,\n}\n\nfn main() {\n    let novel = String::from(\"Call me Ishmael. Some years ago...\");\n    let first_sentence = novel.split('.').next().expect(\"Could not find a '.'\");\n    let i = ImportantExcerpt {\n        part: first_sentence,\n    };\n}\n\nListing 10-24: A struct that holds a reference, requiring a lifetime annotation\nThis struct has the single field part that holds a string slice, which is a reference. As with generic data types, we declare the name of the generic lifetime parameter inside angle brackets after the name of the struct so we can use the lifetime parameter in the body of the struct definition. This annotation means an instance of ImportantExcerpt can’t outlive the reference it holds in its part field.\nThe main function here creates an instance of the ImportantExcerpt struct that holds a reference to the first sentence of the String owned by the variable novel. The data in novel exists before the ImportantExcerpt instance is created. In addition, novel doesn’t go out of scope until after the ImportantExcerpt goes out of scope, so the reference in the ImportantExcerpt instance is valid.\nLifetime Elision\nYou’ve learned that every reference has a lifetime and that you need to specify lifetime parameters for functions or structs that use references. However, in Chapter 4 we had a function in Listing 4-9, shown again in Listing 10-25, that compiled without lifetime annotations.\nFilename: src/lib.rs\nfn first_word(s: &amp;str) -&gt; &amp;str {\n    let bytes = s.as_bytes();\n\n    for (i, &amp;item) in bytes.iter().enumerate() {\n        if item == b' ' {\n            return &amp;s[0..i];\n        }\n    }\n\n    &amp;s[..]\n}\n\nListing 10-25: A function we defined in Listing 4-9 that compiled without lifetime annotations, even though the parameter and return type are references\nThe reason this function compiles without lifetime annotations is historical: in early versions (pre-1.0) of Rust, this code wouldn’t have compiled because every reference needed an explicit lifetime. At that time, the function signature would have been written like this:\nfn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {\n\nAfter writing a lot of Rust code, the Rust team found that Rust programmers were entering the same lifetime annotations over and over in particular situations. These situations were predictable and followed a few deterministic patterns. The developers programmed these patterns into the compiler’s code so the borrow checker could infer the lifetimes in these situations and wouldn’t need explicit annotations.\nThis piece of Rust history is relevant because it’s possible that more deterministic patterns will emerge and be added to the compiler. In the future, even fewer lifetime annotations might be required.\nThe patterns programmed into Rust’s analysis of references are called the lifetime elision rules. These aren’t rules for programmers to follow; they’re a set of particular cases that the compiler will consider, and if your code fits these cases, you don’t need to write the lifetimes explicitly.\nThe elision rules don’t provide full inference. If Rust deterministically applies the rules but there is still ambiguity as to what lifetimes the references have, the compiler won’t guess what the lifetime of the remaining references should be. Instead of guessing, the compiler will give you an error that you can resolve by adding the lifetime annotations.\nLifetimes on function or method parameters are called input lifetimes, and lifetimes on return values are called output lifetimes.\nThe compiler uses three rules to figure out the lifetimes of the references when there aren’t explicit annotations. The first rule applies to input lifetimes, and the second and third rules apply to output lifetimes. If the compiler gets to the end of the three rules and there are still references for which it can’t figure out lifetimes, the compiler will stop with an error. These rules apply to fn definitions as well as impl blocks.\nThe first rule is that the compiler assigns a lifetime parameter to each parameter that’s a reference. In other words, a function with one parameter gets one lifetime parameter: fn foo&lt;'a&gt;(x: &amp;'a i32); a function with two parameters gets two separate lifetime parameters: fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32); and so on.\nThe second rule is that, if there is exactly one input lifetime parameter, that lifetime is assigned to all output lifetime parameters: fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32.\nThe third rule is that, if there are multiple input lifetime parameters, but one of them is &amp;self or &amp;mut self because this is a method, the lifetime of self is assigned to all output lifetime parameters. This third rule makes methods much nicer to read and write because fewer symbols are necessary.\nLet’s pretend we’re the compiler. We’ll apply these rules to figure out the lifetimes of the references in the signature of the first_word function in Listing 10-25. The signature starts without any lifetimes associated with the references:\nfn first_word(s: &amp;str) -&gt; &amp;str {\n\nThen the compiler applies the first rule, which specifies that each parameter gets its own lifetime. We’ll call it 'a as usual, so now the signature is this:\nfn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;str {\n\nThe second rule applies because there is exactly one input lifetime. The second rule specifies that the lifetime of the one input parameter gets assigned to the output lifetime, so the signature is now this:\nfn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {\n\nNow all the references in this function signature have lifetimes, and the compiler can continue its analysis without needing the programmer to annotate the lifetimes in this function signature.\nLet’s look at another example, this time using the longest function that had no lifetime parameters when we started working with it in Listing 10-20:\nfn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {\n\nLet’s apply the first rule: each parameter gets its own lifetime. This time we have two parameters instead of one, so we have two lifetimes:\nfn longest&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;str {\n\nYou can see that the second rule doesn’t apply because there is more than one input lifetime. The third rule doesn’t apply either, because longest is a function rather than a method, so none of the parameters are self. After working through all three rules, we still haven’t figured out what the return type’s lifetime is. This is why we got an error trying to compile the code in Listing 10-20: the compiler worked through the lifetime elision rules but still couldn’t figure out all the lifetimes of the references in the signature.\nBecause the third rule really only applies in method signatures, we’ll look at lifetimes in that context next to see why the third rule means we don’t have to annotate lifetimes in method signatures very often.\nLifetime Annotations in Method Definitions\nWhen we implement methods on a struct with lifetimes, we use the same syntax as that of generic type parameters shown in Listing 10-11. Where we declare and use the lifetime parameters depends on whether they’re related to the struct fields or the method parameters and return values.\nLifetime names for struct fields always need to be declared after the impl keyword and then used after the struct’s name, because those lifetimes are part of the struct’s type.\nIn method signatures inside the impl block, references might be tied to the lifetime of references in the struct’s fields, or they might be independent. In addition, the lifetime elision rules often make it so that lifetime annotations aren’t necessary in method signatures. Let’s look at some examples using the struct named ImportantExcerpt that we defined in Listing 10-24.\nFirst, we’ll use a method named level whose only parameter is a reference to self and whose return value is an i32, which is not a reference to anything:\nimpl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {\n    fn level(&amp;self) -&gt; i32 {\n        3\n    }\n}\n\nThe lifetime parameter declaration after impl and its use after the type name are required, but we’re not required to annotate the lifetime of the reference to self because of the first elision rule.\nHere is an example where the third lifetime elision rule applies:\nimpl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {\n    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {\n        println!(\"Attention please: {}\", announcement);\n        self.part\n    }\n}\n\nThere are two input lifetimes, so Rust applies the first lifetime elision rule and gives both &amp;self and announcement their own lifetimes. Then, because one of the parameters is &amp;self, the return type gets the lifetime of &amp;self, and all lifetimes have been accounted for.\nThe Static Lifetime\nOne special lifetime we need to discuss is 'static, which denotes that the affected reference can live for the entire duration of the program. All string literals have the 'static lifetime, which we can annotate as follows:\nlet s: &amp;'static str = \"I have a static lifetime.\";\n\nThe text of this string is stored directly in the program’s binary, which is always available. Therefore, the lifetime of all string literals is 'static.\nYou might see suggestions to use the 'static lifetime in error messages. But before specifying 'static as the lifetime for a reference, think about whether the reference you have actually lives the entire lifetime of your program or not, and whether you want it to. Most of the time, an error message suggesting the 'static lifetime results from attempting to create a dangling reference or a mismatch of the available lifetimes. In such cases, the solution is fixing those problems, not specifying the 'static lifetime.\nGeneric Type Parameters, Trait Bounds, and Lifetimes Together\nLet’s briefly look at the syntax of specifying generic type parameters, trait bounds, and lifetimes all in one function!\nuse std::fmt::Display;\n\nfn longest_with_an_announcement&lt;'a, T&gt;(\n    x: &amp;'a str,\n    y: &amp;'a str,\n    ann: T,\n) -&gt; &amp;'a str\nwhere\n    T: Display,\n{\n    println!(\"Announcement! {}\", ann);\n    if x.len() &gt; y.len() {\n        x\n    } else {\n        y\n    }\n}\n\nThis is the longest function from Listing 10-21 that returns the longer of two string slices. But now it has an extra parameter named ann of the generic type T, which can be filled in by any type that implements the Display trait as specified by the where clause. This extra parameter will be printed using {}, which is why the Display trait bound is necessary. Because lifetimes are a type of generic, the declarations of the lifetime parameter 'a and the generic type parameter T go in the same list inside the angle brackets after the function name.\nSummary\nWe covered a lot in this chapter! Now that you know about generic type parameters, traits and trait bounds, and generic lifetime parameters, you’re ready to write code without repetition that works in many different situations. Generic type parameters let you apply the code to different types. Traits and trait bounds ensure that even though the types are generic, they’ll have the behavior the code needs. You learned how to use lifetime annotations to ensure that this flexible code won’t have any dangling references. And all of this analysis happens at compile time, which doesn’t affect runtime performance!\nBelieve it or not, there is much more to learn on the topics we discussed in this chapter: Chapter 17 discusses trait objects, which are another way to use traits. There are also more complex scenarios involving lifetime annotations that you will only need in very advanced scenarios; for those, you should read the Rust Reference. But next, you’ll learn how to write tests in Rust so you can make sure your code is working the way it should.\n\n","id":"http://127.0.0.1:1111/rust/chapter4-10/","title":"4-10"},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"body":"소유권 이해\n소유권은 Rust의 가장 고유한 기능이며 나머지 언어에 깊은 영향을 미칩니다. 이를 통해 Rust는 가비지 수집기가 필요 없이 메모리 안전을 보장할 수 있으므로 소유권이 작동하는 방식을 이해하는 것이 중요합니다. 이 장에서 우리는 차용, 슬라이스, Rust가 메모리에 데이터를 배치하는 방법과 같은 몇 가지 관련 기능뿐만 아니라 소유권에 대해 이야기할 것입니다.\n\n소유권이란 무엇입니까?\n소유권은 Rust 프로그램이 메모리를 관리하는 방식을 지배하는 일련의 규칙입니다. 모든 프로그램은 실행하는 동안 컴퓨터의 메모리를 사용하는 방식을 관리해야 합니다. 일부 언어에는 프로그램이 실행될 때 더 이상 사용되지 않는 메모리를 정기적으로 찾는 가비지 수집 기능이 있습니다. 다른 언어에서는 프로그래머가 명시적으로 메모리를 할당하고 해제해야 합니다. Rust는 세 번째 접근 방식을 사용합니다. 메모리는 컴파일러가 확인하는 일련의 규칙을 사용하여 소유권 시스템을 통해 관리됩니다. 규칙 중 하나라도 위반되면 프로그램이 컴파일되지 않습니다. 소유권의 어떤 기능도 프로그램이 실행되는 동안 느려지지 않습니다.\n소유권은 많은 프로그래머에게 새로운 개념이기 때문에 익숙해지는 데 시간이 걸립니다. 좋은 소식은 Rust와 소유권 시스템의 규칙에 대한 경험이 많을수록 안전하고 효율적인 코드를 자연스럽게 개발하는 것이 더 쉬워진다는 것입니다. 견디어 내다!\n소유권을 이해하면 Rust를 고유하게 만드는 기능을 이해하기 위한 견고한 기반을 갖게 됩니다. 이 장에서는 매우 일반적인 데이터 구조인 문자열에 초점을 맞춘 몇 가지 예제를 통해 소유권을 배웁니다.\n\n스택과 힙\n많은 프로그래밍 언어에서는 스택과 힙에 대해 자주 생각할 필요가 없습니다. 그러나 Rust와 같은 시스템 프로그래밍 언어에서는 값이 스택에 있는지 힙에 있는지에 따라 언어의 작동 방식과 특정 결정을 내려야 하는 이유가 달라집니다. 소유권의 일부는 이 장의 뒷부분에서 스택과 힙과 관련하여 설명할 것이므로 준비를 위해 간단히 설명합니다.\n스택과 힙은 모두 코드에서 런타임에 사용할 수 있는 메모리의 일부이지만 서로 다른 방식으로 구성됩니다. 스택은 값을 가져온 순서대로 저장하고 반대 순서로 값을 제거합니다. 이것을 last in, first out 이라고 합니다. 접시 더미를 생각해 보십시오. 접시를 더 추가하면 더미 위에 놓고 접시가 필요하면 위에서 하나를 치웁니다. 중간이나 바닥에서 접시를 추가하거나 제거해도 작동하지 않습니다! 데이터를 추가하는 것을 스택에 밀어 넣는 것을 , 데이터를 제거하는 것을 스택에서 팝하는 것을 말합니다. 스택에 저장된 모든 데이터는 알려지고 고정된 크기를 가져야 합니다. 컴파일 시 크기를 알 수 없거나 크기가 변경될 수 있는 데이터는 대신 힙에 저장해야 합니다.\n힙은 덜 조직적입니다. 힙에 데이터를 넣을 때 일정량의 공간을 요청합니다. 메모리 할당자는 힙에서 충분히 큰 빈 지점을 찾아 사용 중인 것으로 표시하고 해당 위치의 주소인 포인터를 반환합니다. 이 프로세스를 힙에 할당 이라고 하며 때로는 그냥 할당 으로 축약됩니다.(스택에 값을 푸시하는 것은 할당으로 간주되지 않습니다). 힙에 대한 포인터는 알려진 고정 크기이므로 포인터를 스택에 저장할 수 있지만 실제 데이터를 원할 때는 포인터를 따라야 합니다. 식당에 앉아 있다고 생각해보세요. 들어갈 때 그룹의 인원수를 말하면 호스트가 모든 사람에게 맞는 빈 테이블을 찾아 그곳으로 안내합니다. 그룹의 누군가가 늦게 오면 그들은 당신을 찾기 위해 당신이 어디에 앉았는지 물어볼 수 있습니다.\n할당자가 새 데이터를 저장할 위치를 검색할 필요가 없기 때문에 스택에 푸시하는 것이 힙에 할당하는 것보다 빠릅니다. 해당 위치는 항상 스택의 맨 위에 있습니다. 상대적으로 힙에 공간을 할당하려면 할당자가 먼저 데이터를 보유할 수 있을 만큼 충분히 큰 공간을 찾은 다음 다음 할당을 준비하기 위해 기록을 수행해야 하기 때문에 더 많은 작업이 필요합니다.\n스택에 있는 데이터에 액세스하려면 포인터를 따라가야 하므로 힙에 있는 데이터에 액세스하는 것이 스택에 있는 데이터에 액세스하는 것보다 느립니다. 최신 프로세서는 메모리에서 덜 점프하면 더 빠릅니다. 비유를 계속해서 많은 테이블에서 주문을 받는 식당의 서버를 생각해 보십시오. 다음 테이블로 이동하기 전에 한 테이블에서 모든 주문을 받는 것이 가장 효율적입니다. 테이블 A에서 주문을 받은 다음 테이블 B에서 주문을 받고, 다시 A에서 주문을 받고, 다시 B에서 주문을 받는 것은 훨씬 더 느린 프로세스입니다. 마찬가지로, 프로세서는 다른 데이터와 멀리 떨어져 있는 데이터(힙에 있을 수 있으므로)보다 가까운 데이터(스택에 있는 데이터)에 대해 작업하는 경우 작업을 더 잘 수행할 수 있습니다.\n코드가 함수를 호출하면 함수에 전달된 값(힙의 데이터에 대한 포인터 포함)과 함수의 로컬 변수가 스택으로 푸시됩니다. 함수가 끝나면 해당 값이 스택에서 제거됩니다.\n코드의 어떤 부분이 힙에서 어떤 데이터를 사용하는지 추적하고, 힙에서 중복 데이터의 양을 최소화하고, 공간이 부족하지 않도록 힙에서 사용하지 않는 데이터를 정리하는 것은 소유권이 해결하는 모든 문제입니다. 소유권을 이해하면 스택과 힙에 대해 자주 생각할 필요가 없지만 소유권의 주요 목적이 힙 데이터를 관리하는 것임을 알면 소유권이 작동하는 방식을 설명하는 데 도움이 될 수 있습니다.\n\n소유권 규칙\n먼저 소유권 규정을 살펴보겠습니다. 이러한 규칙을 설명하는 예제를 통해 작업할 때 이러한 규칙을 염두에 두십시오.\n\nRust의 각 값에는 소유자가 있습니다.\n한 번에 한 명의 소유자만 있을 수 있습니다.\n소유자가 범위를 벗어나면 값이 삭제됩니다.\n\n변수 범위\n이제 우리는 기본 Rust 구문을 지나쳤으므로 예제에 모든 fn main() { 코드를 포함하지 않을 것입니다. 따라서 다음 예제를 수동으로 main 함수 안에 넣어야 합니다. . 결과적으로 우리의 예제는 좀 더 간결해지고 상용구 코드가 아닌 실제 세부 사항에 집중할 수 있습니다.\n소유권의 첫 번째 예로서 일부 변수의 범위를 살펴보겠습니다. 범위는 항목이 유효한 프로그램 내의 범위입니다. 다음 변수를 사용하십시오.\nlet s = `hello`;\n\n변수 s는 문자열 리터럴을 참조하며 문자열 값은 프로그램의 텍스트에 하드코딩됩니다. 변수는 선언된 시점부터 현재 범위가 끝날 때까지 유효합니다. 목록 4-1은 변수 s가 유효한 위치에 주석이 달린 프로그램을 보여줍니다.\n    {                      // s is not valid here, it’s not yet declared\n        let s = `hello`;   // s is valid from this point forward\n\n        // do stuff with s\n    }                      // this scope is now over, and s is no longer valid\n\n목록 4-1: 변수와 변수가 유효한 범위\n즉, 여기에는 두 가지 중요한 시점이 있습니다.\n\ns가 범위 에 포함 되면 유효합니다.\n범위를 벗어날 때까지 유효합니다.\n\n이 시점에서 범위 간의 관계와 변수가 유효한 시기는 다른 프로그래밍 언어와 유사합니다. 이제 문자열 유형을 도입하여 이러한 이해를 바탕으로 빌드하겠습니다.\n문자열 유형\n소유권 규칙을 설명하려면 3장의 데이터 유형 섹션에서 다룬 것보다 더 복잡한 데이터 유형이 필요합니다. 이전에 다룬 유형은 알려진 크기이며 스택에 저장하고 꺼낼 수 있습니다. 코드의 다른 부분이 다른 범위에서 동일한 값을 사용해야 하는 경우 새롭고 독립적인 인스턴스를 만들기 위해 신속하고 간단하게 복사할 수 있습니다. 그러나 우리는 힙에 저장된 데이터를 살펴보고 Rust가 해당 데이터를 정리할 시기를 어떻게 아는지 살펴보고자 합니다. 문자열 유형이 좋은 예입니다.\n소유권과 관련된 문자열 부분에 집중하겠습니다. 이러한 측면은 표준 라이브러리에서 제공하든 사용자가 생성하든 관계없이 다른 복합 데이터 유형에도 적용됩니다. 8장 에서 문자열에 대해 더 깊이 논의할 것입니다.\n우리는 문자열 값이 우리 프로그램에 하드코딩되는 문자열 리터럴을 이미 보았습니다. 문자열 리터럴은 편리하지만 텍스트를 사용하려는 모든 상황에 적합하지는 않습니다. 한 가지 이유는 그것들이 불변이라는 것입니다. 다른 하나는 코드를 작성할 때 모든 문자열 값을 알 수 있는 것은 아니라는 것입니다. 예를 들어 사용자 입력을 받아 저장하려면 어떻게 해야 할까요? 이러한 상황을 위해 Rust에는 두 번째 문자열 유형인 String이 있습니다. 이 유형은 힙에 할당된 데이터를 관리하므로 컴파일 시 알 수 없는 양의 텍스트를 저장할 수 있습니다. 다음과 같이 from 함수를 사용하여 문자열 리터럴에서 문자열을 만들 수 있습니다.\nlet s = String::from(`hello`);\n\n이중 콜론 :: 연산자를 사용하면 string_from과 같은 일종의 이름을 사용하는 대신 String 유형 아래에서 이 특정 from 함수의 이름을 지정할 수 있습니다. 이 구문은 5장의 메서드 구문 섹션과 7장의 모듈 트리에서 항목을 참조하기 위한 경로 에서 모듈의 네임스페이스에 대해 설명할 때 더 자세히 설명합니다.\n이러한 종류의 문자열은 변경될 수 있습니다 .\n    let mut s = String::from(`hello`);\n\n    s.push_str(`, world!`); // push_str() appends a literal to a String\n\n    println!(`{}`, s); // This will print `hello, world!`\n\n차이점은 무엇입니까? 문자열은 변경할 수 있지만 리터럴은 변경할 수 없는 이유는 무엇입니까? 차이점은 이 두 가지 유형이 메모리를 처리하는 방식입니다.\n메모리 및 할당\n문자열 리터럴의 경우 컴파일 시간에 내용을 알기 때문에 텍스트가 최종 실행 파일에 직접 하드코딩됩니다. 이것이 문자열 리터럴이 빠르고 효율적인 이유입니다. 그러나 이러한 속성은 문자열 리터럴의 불변성에서만 나옵니다. 불행하게도 우리는 컴파일 타임에 크기를 알 수 없고 프로그램을 실행하는 동안 크기가 변경될 수 있는 각 텍스트 조각에 대한 메모리 덩어리를 바이너리에 넣을 수 없습니다.\n문자열 유형을 사용하여 변경 가능하고 확장 가능한 텍스트 조각을 지원하려면 컴파일 시간에 알 수 없는 내용을 보관할 메모리 양을 힙에 할당해야 합니다. 이는 다음을 의미합니다.\n\n런타임 시 메모리 할당자에서 메모리를 요청해야 합니다.\n문자열 작업이 완료되면 이 메모리를 할당자에게 반환하는 방법이 필요합니다.\n\n첫 번째 부분은 우리가 수행합니다. String::from을 호출하면 해당 구현이 필요한 메모리를 요청합니다. 이것은 프로그래밍 언어에서 거의 보편적입니다.\n그러나 두 번째 부분은 다릅니다. 가비지 컬렉터(GC) 가 있는 언어에서 GC는 더 이상 사용되지 않는 메모리를 추적하고 정리하므로 우리는 그것에 대해 생각할 필요가 없습니다. GC가 없는 대부분의 언어에서 메모리를 더 이상 사용하지 않는 시기를 식별하고 메모리를 요청한 것처럼 명시적으로 해제하는 코드를 호출하는 것은 우리의 책임입니다. 이를 올바르게 수행하는 것은 역사적으로 어려운 프로그래밍 문제였습니다. 잊어버리면 메모리를 낭비하게 됩니다. 너무 일찍 수행하면 유효하지 않은 변수가 생깁니다. 두 번 하면 그것도 버그입니다. 정확히 하나의 할당과 정확히 하나의 자유를 쌍으로 연결해야 합니다.\nRust는 다른 경로를 취합니다. 메모리를 소유한 변수가 범위를 벗어나면 메모리가 자동으로 반환됩니다. 다음은 문자열 리터럴 대신 문자열을 사용하는 Listing 4-1의 범위 예제 버전입니다.\n    {\n        let s = String::from(`hello`); // s is valid from this point forward\n\n        // do stuff with s\n    }                                  // this scope is now over, and s is no\n                                       // longer valid\n\nString이 할당자에게 필요한 메모리를 반환할 수 있는 자연스러운 지점이 있습니다. s가 범위를 벗어날 때입니다. 변수가 범위를 벗어나면 Rust는 우리를 위해 특별한 함수를 호출합니다. 이 함수를 drop 이라고 하며 String의 작성자가 메모리를 반환하는 코드를 넣을 수 있는 곳입니다. Rust는 닫는 중괄호에서 자동으로 drop을 호출합니다.\n\n참고: C++에서 항목의 수명이 끝날 때 리소스 할당을 취소하는 이 패턴을 리소스 획득이 초기화(RAII) 라고도 합니다. Rust의 드롭 기능은 RAII 패턴을 사용해 본 적이 있다면 익숙할 것입니다.\n\n이 패턴은 Rust 코드 작성 방식에 지대한 영향을 미칩니다. 지금 당장은 간단해 보일 수 있지만 여러 변수가 힙에 할당한 데이터를 사용하도록 하려는 더 복잡한 상황에서는 코드의 동작이 예상치 못한 것일 수 있습니다. 이제 그러한 상황 중 일부를 살펴보겠습니다.\nMove와 상호 작용하는 변수 및 데이터\n여러 변수는 Rust에서 다른 방식으로 동일한 데이터와 상호 작용할 수 있습니다. 목록 4-2에서 정수를 사용하는 예를 살펴보겠습니다.\n    let x = 5;\n    let y = x;\n\n목록 4-2: 변수 x의 정수 값을 y에 할당\n이것이 무엇을 하는지 짐작할 수 있을 것입니다. 값 5를 x에 바인딩합니다. 그런 다음 x의 값을 복사하여 y에 바인딩합니다.” 이제 두 개의 변수 x와 y가 있고 둘 다 5입니다. 정수는 알려진 고정 크기를 가진 단순한 값이고 이 두 5` 값이 스택에 푸시되기 때문에 이것이 실제로 일어나고 있는 일입니다.\n이제 문자열 버전을 살펴보겠습니다.\n    let s1 = String::from(`hello`);\n    let s2 = s1;\n\n이것은 매우 유사해 보이기 때문에 작동 방식이 동일할 것이라고 가정할 수 있습니다. 즉, 두 번째 줄은 s1의 값을 복사하여 s2에 바인딩합니다. 그러나 이것은 실제로 일어나는 일이 아닙니다.\n표지 아래 문자열에 무슨 일이 일어나고 있는지 보려면 그림 4-1을 살펴보십시오. 문자열은 왼쪽에 표시된 것처럼 세 부분으로 구성됩니다. 문자열의 내용을 보유하는 메모리에 대한 포인터, 길이 및 용량입니다. 이 데이터 그룹은 스택에 저장됩니다. 오른쪽에는 내용을 보유하는 힙의 메모리가 있습니다.\n\n그림 4-1: s1에 바인딩된 hello 값을 보유하는 문자열의 메모리 표현\n길이는 문자열의 내용이 현재 사용 중인 메모리 양(바이트)입니다. 용량은 문자열이 할당자로부터 받은 총 메모리 양(바이트)입니다. 길이와 용량의 차이는 중요하지만 이 맥락에서는 중요하지 않으므로 지금은 용량을 무시해도 됩니다.\ns1을 s2에 할당하면 문자열 데이터가 복사됩니다. 즉, 스택에 있는 포인터, 길이 및 용량을 복사합니다. 포인터가 참조하는 힙에 데이터를 복사하지 않습니다. 즉, 메모리의 데이터 표현은 그림 4-2와 같습니다.\n\n그림 4-2: s1의 포인터, 길이 및 용량의 복사본이 있는 변수 s2의 메모리 표현\n표현은 그림 4-3처럼 보이지 않습니다 . Rust가 대신 힙 데이터도 복사했다면 메모리는 어떻게 생겼을 것입니다. Rust가 이렇게 하면 힙의 데이터가 큰 경우 s2 = s1 작업은 런타임 성능 측면에서 매우 비쌀 수 있습니다.\n\n그림 4-3: Rust가 힙 데이터도 복사한 경우 s2 = s1이 무엇을 할 수 있는지에 대한 또 다른 가능성\n이전에 우리는 변수가 범위를 벗어나면 Rust가 자동으로 drop 함수를 호출하고 해당 변수에 대한 힙 메모리를 정리한다고 말했습니다. 그러나 그림 4-2는 동일한 위치를 가리키는 두 데이터 포인터를 보여줍니다. 이것은 문제입니다. s2와 s1이 범위를 벗어나면 둘 다 동일한 메모리를 해제하려고 합니다. 이것은 이중 자유 오류로 알려져 있으며 이전에 언급한 메모리 안전 버그 중 하나입니다. 메모리를 두 번 해제하면 메모리 손상이 발생하여 잠재적으로 보안 취약성이 발생할 수 있습니다.\n메모리 안전을 보장하기 위해 let s2 = s1; 줄 다음에 Rust는 s1을 더 이상 유효하지 않은 것으로 간주합니다. 따라서 Rust는 s1이 범위를 벗어날 때 아무것도 해제할 필요가 없습니다. s2가 생성된 후 s1을 사용하려고 하면 어떤 일이 발생하는지 확인하십시오. 작동하지 않습니다:\n    let s1 = String::from(`hello`);\n    let s2 = s1;\n\n    println!(`{}, world!`, s1);\n\nRust가 무효화된 참조를 사용하지 못하게 하기 때문에 다음과 같은 오류가 발생합니다.\n$ cargo run\n   Compiling ownership v0.1.0 (file:///projects/ownership)\nerror[E0382]: borrow of moved value: `s1`\n --&gt; src/main.rs:5:28\n  |\n2 |     let s1 = String::from(`hello`);\n  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait\n3 |     let s2 = s1;\n  |              -- value moved here\n4 |\n5 |     println!(`{}, world!`, s1);\n  |                            ^^ value borrowed here after move\n  |\n  = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)\nhelp: consider cloning the value if the performance cost is acceptable\n  |\n3 |     let s2 = s1.clone();\n  |                ++++++++\n\nFor more information about this error, try `rustc --explain E0382`.\nerror: could not compile `ownership` due to previous error\n\n다른 언어로 작업하면서 얕은 복사 와 깊은 복사라는 용어를 들어본 적이 있다면 데이터를 복사하지 않고 포인터, 길이, 용량을 복사한다는 개념은 아마도 얕은 복사를 하는 것처럼 들릴 것입니다. 그러나 Rust는 첫 번째 변수도 무효화하기 때문에 얕은 복사본이라고 하는 대신 이동 이라고 합니다 . 이 예에서는 s1이 s2로 이동되었다고 말합니다. 따라서 실제로 일어나는 일은 그림 4-4에 나와 있습니다.\n\n그림 4-4: s1이 무효화된 후 메모리의 표현\n그것은 우리의 문제를 해결합니다! s2만 유효하면 범위를 벗어나면 단독으로 메모리를 해제하고 완료됩니다.\n추가로 이것이 암시하는 디자인 선택이 있습니다: Rust는 데이터의 깊은 복사본을 자동으로 생성하지 않습니다. 따라서 자동 복사는 런타임 성능 측면에서 저렴하다고 가정할 수 있습니다.\n클론과 상호 작용하는 변수 및 데이터\n스택 데이터뿐만 아니라 String의 힙 데이터를 깊이 복사하려는 경우 clone이라는 일반적인 방법을 사용할 수 있습니다 . 5장에서 메서드 구문에 대해 논의하겠지만 메서드는 많은 프로그래밍 언어에서 공통적인 기능이기 때문에 이전에 본 적이 있을 것입니다.\n다음은 작동 중인 복제 방법의 예입니다.\n    let s1 = String::from(`hello`);\n    let s2 = s1.clone();\n\n    println!(`s1 = {}, s2 = {}`, s1, s2);\n\n이것은 잘 작동하며 힙 데이터가 복사 되는 그림 4-3에 표시된 동작을 명시적으로 생성합니다.\n복제에 대한 호출을 보면 임의의 코드가 실행되고 있고 해당 코드가 비쌀 수 있음을 알 수 있습니다. 뭔가 다른 일이 벌어지고 있다는 시각적 지표입니다.\n스택 전용 데이터: 복사\n우리가 아직 이야기하지 않은 또 다른 주름이 있습니다. 정수를 사용하는 이 코드(목록 4-2에 그 일부가 표시됨)는 작동하고 유효합니다.\n    let x = 5;\n    let y = x;\n\n    println!(`x = {}, y = {}`, x, y);\n\n그러나 이 코드는 우리가 방금 배운 것과 모순되는 것 같습니다. 복제에 대한 호출이 없지만 x는 여전히 유효하고 y로 이동되지 않았습니다.\n그 이유는 컴파일 타임에 알려진 크기를 갖는 정수와 같은 유형이 스택에 완전히 저장되기 때문에 실제 값의 복사본을 빠르게 만들 수 있기 때문입니다. 즉, 변수 y를 만든 후에 x가 유효하지 않도록 할 이유가 없습니다. 즉, 여기에서는 깊은 복사와 얕은 복사 사이에 차이가 없으므로 복제라고 부르는 것은 일반적인 얕은 복사와 다른 작업을 수행하지 않으며 생략할 수 있습니다.\nRust에는 복사 특성이라는 특수 주석이 있습니다. 정수와 마찬가지로 스택에 저장된 유형에 배치할 수 있습니다(특성에 대한 자세한 내용은 10장 에서 설명 ). 유형이 복사 특성을 구현하는 경우 이를 사용하는 변수는 이동하지 않고 사소하게 복사되어 다른 변수에 할당된 후에도 여전히 유효합니다.\n러스트는 유형 또는 그 부분이 Drop 특성을 구현한 경우 Copy로 유형에 주석을 달지 못하게 합니다. 값이 범위를 벗어나고 해당 유형에 복사 주석을 추가할 때 유형에 특별한 일이 발생해야 하는 경우 컴파일 타임 오류가 발생합니다. 특성을 구현하기 위해 유형에 복사 주석을 추가하는 방법에 대해 알아보려면 부록 C의 파생 가능한 특성을 참조하세요.\n그렇다면 복사 특성을 구현하는 유형은 무엇입니까? 지정된 유형에 대한 설명서를 확인하여 확인할 수 있지만 일반적으로 간단한 스칼라 값 그룹은 복사를 구현할 수 있으며 할당이 필요하거나 리소스의 일부 형식은 복사를 구현할 수 없습니다. 다음은 복사를 구현하는 몇 가지 유형입니다.\n\nu32와 같은 모든 정수 유형.\n값이 true 및 false인 부울 유형 bool.\nf64와 같은 모든 부동 소수점 유형.\n문자 유형 char.\n튜플(복사도 구현하는 유형만 포함하는 경우). 예를 들어 (i32, i32)는 복사를 구현하지만 (i32, String)은 구현하지 않습니다.\n\n소유권 및 기능\n함수에 값을 전달하는 메커니즘은 변수에 값을 할당할 때와 비슷합니다. 변수를 함수에 전달하면 할당과 마찬가지로 이동하거나 복사합니다. 목록 4-3에는 변수가 범위에 들어가고 나가는 위치를 보여주는 몇 가지 주석이 있는 예제가 있습니다.\n파일 이름: src/main.rs\nfn main() {\n    let s = String::from(`hello`);  // s comes into scope\n\n    takes_ownership(s);             // s's value moves into the function...\n                                    // ... and so is no longer valid here\n\n    let x = 5;                      // x comes into scope\n\n    makes_copy(x);                  // x would move into the function,\n                                    // but i32 is Copy, so it's okay to still\n                                    // use x afterward\n\n} // Here, x goes out of scope, then s. But because s's value was moved, nothing\n  // special happens.\n\nfn takes_ownership(some_string: String) { // some_string comes into scope\n    println!(`{}`, some_string);\n} // Here, some_string goes out of scope and `drop` is called. The backing\n  // memory is freed.\n\nfn makes_copy(some_integer: i32) { // some_integer comes into scope\n    println!(`{}`, some_integer);\n} // Here, some_integer goes out of scope. Nothing special happens.\n\n목록 4-3: 소유권과 범위가 주석으로 표시된 함수\ntakes_ownership을 호출한 후에 s를 사용하려고 하면 Rust에서 컴파일 타임 오류가 발생합니다. 이러한 정적 검사는 실수로부터 우리를 보호합니다. s 및 x를 사용하는 코드를 main에 추가하여 사용할 수 있는 위치와 소유권 규칙에 따라 사용할 수 없는 위치를 확인하십시오.\n반환 값 및 범위\n반환 값은 소유권을 이전할 수도 있습니다. Listing 4-4는 Listing 4-3과 유사한 주석을 사용하여 일부 값을 반환하는 함수의 예를 보여줍니다.\n파일 이름: src/main.rs\nfn main() {\n    let s1 = gives_ownership();         // gives_ownership moves its return\n                                        // value into s1\n\n    let s2 = String::from(`hello`);     // s2 comes into scope\n\n    let s3 = takes_and_gives_back(s2);  // s2 is moved into\n                                        // takes_and_gives_back, which also\n                                        // moves its return value into s3\n} // Here, s3 goes out of scope and is dropped. s2 was moved, so nothing\n  // happens. s1 goes out of scope and is dropped.\n\nfn gives_ownership() -&gt; String {             // gives_ownership will move its\n                                             // return value into the function\n                                             // that calls it\n\n    let some_string = String::from(`yours`); // some_string comes into scope\n\n    some_string                              // some_string is returned and\n                                             // moves out to the calling\n                                             // function\n}\n\n// This function takes a String and returns one\nfn takes_and_gives_back(a_string: String) -&gt; String { // a_string comes into\n                                                      // scope\n\n    a_string  // a_string is returned and moves out to the calling function\n}\n\nListing 4-4: 반환 값의 소유권 이전\n변수의 소유권은 매번 동일한 패턴을 따릅니다. 다른 변수에 값을 할당하면 변수가 이동합니다. 힙에 데이터를 포함하는 변수가 범위를 벗어나면 데이터의 소유권이 다른 변수로 이동되지 않는 한 삭제로 값이 정리됩니다.\n이것이 작동하는 동안 소유권을 가져간 다음 모든 기능에 대한 소유권을 반환하는 것은 약간 지루합니다. 함수가 값을 사용하지만 소유권은 가지지 않으려면 어떻게 해야 할까요? 반환하려는 함수 본문의 결과 데이터 외에도 다시 사용하려는 경우 전달하는 모든 항목도 다시 전달해야 한다는 점은 매우 성가신 일입니다.\nRust는 Listing 4-5에 표시된 것처럼 튜플을 사용하여 여러 값을 반환할 수 있습니다.\n파일 이름: src/main.rs\nfn main() {\n    let s1 = String::from(`hello`);\n\n    let (s2, len) = calculate_length(s1);\n\n    println!(`The length of '{}' is {}.`, s2, len);\n}\n\nfn calculate_length(s: String) -&gt; (String, usize) {\n    let length = s.len(); // len() returns the length of a String\n\n    (s, length)\n}\n\n목록 4-5: 매개변수 소유권 반환\n그러나 이것은 일반적이어야 하는 개념에 대해 너무 많은 의식과 많은 작업입니다. 운 좋게도 Rust에는 소유권을 이전하지 않고 값을 사용하는 참조라는 기능이 있습니다 .\n\n참조 및 차용\nListing 4-5에 있는 튜플 코드의 문제는 호출 함수에 String을 반환해야 calculate_length를 호출한 후에도 String을 계속 사용할 수 있다는 것입니다. 계산_길이. 대신 문자열 값에 대한 참조를 제공할 수 있습니다. 참조 는 해당 주소에 저장된 데이터에 액세스하기 위해 따를 수 있는 주소라는 점에서 포인터와 같습니다. 해당 데이터는 다른 변수가 소유합니다. 포인터와 달리 참조는 해당 참조의 수명 동안 특정 유형의 유효한 값을 가리키도록 보장됩니다.\n다음은 값의 소유권을 가져오는 대신 개체에 대한 참조를 매개 변수로 포함하는 calculate_length 함수를 정의하고 사용하는 방법입니다.\n파일 이름: src/main.rs\nfn main() {\n    let s1 = String::from(`hello`);\n\n    let len = calculate_length(&amp;s1);\n\n    println!(`The length of '{}' is {}.`, s1, len);\n}\n\nfn calculate_length(s: &amp;String) -&gt; usize {\n    s.len()\n}\n\n먼저 변수 선언의 모든 튜플 코드와 함수 반환 값이 사라진 것을 확인하십시오. 둘째, &amp;s1을 calculate_length에 전달하고 정의에서 String이 아닌 &amp;String을 사용합니다. 이러한 앰퍼샌드는 참조를 나타내며 소유권을 갖지 않고 일부 값을 참조할 수 있습니다. 그림 4-5는 이 개념을 보여줍니다.\n\n그림 4-5: String s1을 가리키는 &amp;String s 다이어그램\n\n참고: &amp;를 사용한 참조의 반대는 역 참조 연산자 *를 사용하여 수행되는 역참조입니다. 8장에서 역참조 연산자의 일부 사용법을 살펴보고 15장에서 역참조에 대한 자세한 내용을 논의합니다.\n\n여기서 함수 호출을 자세히 살펴보겠습니다.\n    let s1 = String::from(`hello`);\n\n    let len = calculate_length(&amp;s1);\n\n&amp;s1 구문을 사용하면 s1 값을 참조하지만 소유하지는 않는 참조 를 만들 수 있습니다. 소유하지 않기 때문에 참조가 사용을 중지해도 가리키는 값은 삭제되지 않습니다.\n마찬가지로 함수의 시그니처는 &amp;를 사용하여 매개변수 s의 유형이 참조임을 나타냅니다. 몇 가지 설명 주석을 추가해 보겠습니다.\nfn calculate_length(s: &amp;String) -&gt; usize { // s is a reference to a String\n    s.len()\n} // Here, s goes out of scope. But because it does not have ownership of what\n  // it refers to, it is not dropped.\n\n변수 s가 유효한 범위는 모든 함수 매개 변수의 범위와 동일하지만 s는 소유권이 없기 때문에 s가 사용 중지될 때 참조가 가리키는 값은 삭제되지 않습니다. 함수에 실제 값 대신 매개 변수로 참조가 있으면 소유권을 가져본 적이 없기 때문에 소유권을 돌려주기 위해 값을 반환할 필요가 없습니다.\n참조 차용 을 만드는 작업을 호출합니다. 실생활에서와 마찬가지로 사람이 무언가를 소유하고 있으면 그 사람에게서 빌릴 수 있습니다. 끝나면 돌려줘야 합니다. 당신은 그것을 소유하지 않습니다.\n그렇다면 빌린 것을 수정하려고 하면 어떻게 될까요? 목록 4-6의 코드를 사용해 보십시오. 스포일러 경고: 작동하지 않습니다!\n파일 이름: src/main.rs\nfn main() {\n    let s = String::from(`hello`);\n\n    change(&amp;s);\n}\n\nfn change(some_string: &amp;String) {\n    some_string.push_str(`, world`);\n}\n\n목록 4-6: 빌린 값 수정 시도\n오류는 다음과 같습니다.\n$ cargo run\n   Compiling ownership v0.1.0 (file:///projects/ownership)\nerror[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&amp;` reference\n --&gt; src/main.rs:8:5\n  |\n7 | fn change(some_string: &amp;String) {\n  |                        ------- help: consider changing this to be a mutable reference: `&amp;mut String`\n8 |     some_string.push_str(`, world`);\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `some_string` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable\n\nFor more information about this error, try `rustc --explain E0596`.\nerror: could not compile `ownership` due to previous error\n\n변수가 기본적으로 불변인 것처럼 참조도 마찬가지입니다. 우리는 우리가 참조하는 것을 수정할 수 없습니다.\n변경 가능한 참조\n목록 4-6의 코드를 수정하여 변경 가능한 참조 대신 사용하는 몇 가지 작은 조정만으로 빌린 값을 수정할 수 있습니다.\n파일 이름: src/main.rs\nfn main() {\n    let mut s = String::from(`hello`);\n\n    change(&amp;mut s);\n}\n\nfn change(some_string: &amp;mut String) {\n    some_string.push_str(`, world`);\n}\n\n먼저 s를 mut로 변경합니다. 그런 다음 change 함수를 호출하는 &amp;mut s로 변경 가능한 참조를 만들고 some_string: &amp;mut String으로 변경 가능한 참조를 허용하도록 함수 시그니처를 업데이트합니다. 이것은 변경 기능이 빌린 값을 변경한다는 것을 매우 분명하게 합니다.\n변경 가능한 참조에는 한 가지 큰 제한이 있습니다. 값에 대한 변경 가능한 참조가 있는 경우 해당 값에 대한 다른 참조를 가질 수 없습니다. s에 대한 두 개의 변경 가능한 참조를 만들려고 시도하는 이 코드는 실패합니다.\n파일 이름: src/main.rs\n    let mut s = String::from(`hello`);\n\n    let r1 = &amp;mut s;\n    let r2 = &amp;mut s;\n\n    println!(`{}, {}`, r1, r2);\n\n오류는 다음과 같습니다.\n$ cargo run\n   Compiling ownership v0.1.0 (file:///projects/ownership)\nerror[E0499]: cannot borrow `s` as mutable more than once at a time\n --&gt; src/main.rs:5:14\n  |\n4 |     let r1 = &amp;mut s;\n  |              ------ first mutable borrow occurs here\n5 |     let r2 = &amp;mut s;\n  |              ^^^^^^ second mutable borrow occurs here\n6 |\n7 |     println!(`{}, {}`, r1, r2);\n  |                        -- first borrow later used here\n\nFor more information about this error, try `rustc --explain E0499`.\nerror: could not compile `ownership` due to previous error\n\n이 오류는 s를 한 번에 두 번 이상 가변으로 빌릴 수 없기 때문에 이 코드가 유효하지 않다고 말합니다. 첫 번째 변경 가능한 차용은 r1에 있으며 println!에서 사용될 때까지 지속되어야 합니다. r1로.\n동일한 데이터에 대한 여러 가변 참조를 동시에 금지하는 제한은 매우 통제된 방식으로 변형을 허용합니다. 대부분의 언어에서는 원할 때마다 변경할 수 있기 때문에 새로운 Rustacean이 어려움을 겪고 있습니다. 이 제한을 갖는 이점은 Rust가 컴파일 시간에 데이터 경합을 방지할 수 있다는 것입니다. 데이터 경쟁은 경쟁 조건과 유사하며 다음 세 가지 동작이 발생할 때 발생합니다.\n\n두 개 이상의 포인터가 동시에 동일한 데이터에 액세스합니다.\n적어도 하나의 포인터가 데이터에 쓰는 데 사용되고 있습니다.\n데이터에 대한 액세스를 동기화하는 데 사용되는 메커니즘이 없습니다.\n\n데이터 경합은 정의되지 않은 동작을 유발하며 런타임 시 추적하려고 할 때 진단 및 수정이 어려울 수 있습니다. Rust는 데이터 경합으로 코드를 컴파일하는 것을 거부함으로써 이 문제를 방지합니다!\n항상 그렇듯이 중괄호를 사용하여 새 스코프를 생성할 수 있으므로 동시 참조가 아닌 여러 변경 가능한 참조를 허용할 수 있습니다.\n    let mut s = String::from(`hello`);\n\n    {\n        let r1 = &amp;mut s;\n    } // r1 goes out of scope here, so we can make a new reference with no problems.\n\n    let r2 = &amp;mut s;\n\nRust는 변경 가능한 참조와 변경 불가능한 참조를 결합하기 위해 유사한 규칙을 적용합니다. 이 코드는 오류를 발생시킵니다.\n    let mut s = String::from(`hello`);\n\n    let r1 = &amp;s; // no problem\n    let r2 = &amp;s; // no problem\n    let r3 = &amp;mut s; // BIG PROBLEM\n\n    println!(`{}, {}, and {}`, r1, r2, r3);\n\n오류는 다음과 같습니다.\n$ cargo run\n   Compiling ownership v0.1.0 (file:///projects/ownership)\nerror[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable\n --&gt; src/main.rs:6:14\n  |\n4 |     let r1 = &amp;s; // no problem\n  |              -- immutable borrow occurs here\n5 |     let r2 = &amp;s; // no problem\n6 |     let r3 = &amp;mut s; // BIG PROBLEM\n  |              ^^^^^^ mutable borrow occurs here\n7 |\n8 |     println!(`{}, {}, and {}`, r1, r2, r3);\n  |                                -- immutable borrow later used here\n\nFor more information about this error, try `rustc --explain E0502`.\nerror: could not compile `ownership` due to previous error\n\n아휴! 또한 동일한 값에 대한 불변 참조가 있는 동안에는 가변 참조를 가질 수 없습니다.\n불변 참조의 사용자는 값이 갑자기 변경될 것이라고 기대하지 않습니다! 그러나 데이터를 읽기만 하는 사람은 다른 사람의 데이터 읽기에 영향을 줄 수 없기 때문에 여러 불변 참조가 허용됩니다.\n참조의 범위는 도입된 위치에서 시작하여 해당 참조가 마지막으로 사용된 시간까지 계속됩니다. 예를 들어, 이 코드는 가변 참조가 도입되기 전에 불변 참조의 마지막 사용인 println!이 발생하기 때문에 컴파일됩니다.\n    let mut s = String::from(`hello`);\n\n    let r1 = &amp;s; // no problem\n    let r2 = &amp;s; // no problem\n    println!(`{} and {}`, r1, r2);\n    // variables r1 and r2 will not be used after this point\n\n    let r3 = &amp;mut s; // no problem\n    println!(`{}`, r3);\n\n불변 참조 r1 및 r2의 범위는 println! 다음에 끝납니다. 변경 가능한 참조 r3이 생성되기 전 마지막으로 사용되는 위치입니다. 이러한 범위는 겹치지 않으므로 이 코드가 허용됩니다. 컴파일러는 범위가 끝나기 전 지점에서 참조가 더 이상 사용되지 않는다는 것을 알 수 있습니다.\n차용 오류가 때때로 실망스러울 수 있지만, 잠재적인 버그를 일찍(런타임이 아닌 컴파일 타임에) 지적하고 문제가 있는 곳을 정확히 보여주는 것은 Rust 컴파일러라는 점을 기억하십시오. 그러면 데이터가 생각했던 것과 다른 이유를 추적할 필요가 없습니다.\n매달린 참조\n포인터가 있는 언어에서는 해당 메모리에 대한 포인터를 유지하면서 일부 메모리를 해제하여 댕글링 포인터 (다른 사람에게 제공되었을 수 있는 메모리의 위치를 참조하는 포인터)를 잘못 생성하기 쉽습니다. 대조적으로 Rust에서 컴파일러는 참조가 댕글링 참조가 되지 않도록 보장합니다. 일부 데이터에 대한 참조가 있는 경우 컴파일러는 데이터에 대한 참조가 범위를 벗어나기 전에 데이터가 범위를 벗어나지 않도록 합니다.\n러스트가 어떻게 컴파일 타임 오류를 방지하는지 알아보기 위해 댕글링 참조를 생성해 봅시다:\n파일 이름: src/main.rs\nfn main() {\n    let reference_to_nothing = dangle();\n}\n\nfn dangle() -&gt; &amp;String {\n    let s = String::from(`hello`);\n\n    &amp;s\n}\n\n오류는 다음과 같습니다.\n$ cargo run\n   Compiling ownership v0.1.0 (file:///projects/ownership)\nerror[E0106]: missing lifetime specifier\n --&gt; src/main.rs:5:16\n  |\n5 | fn dangle() -&gt; &amp;String {\n  |                ^ expected named lifetime parameter\n  |\n  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\nhelp: consider using the `'static` lifetime\n  |\n5 | fn dangle() -&gt; &amp;'static String {\n  |                 +++++++\n\nFor more information about this error, try `rustc --explain E0106`.\nerror: could not compile `ownership` due to previous error\n\n이 오류 메시지는 아직 다루지 않은 기능인 수명을 나타냅니다. 10장에서 수명에 대해 자세히 논의할 것입니다. 그러나 수명에 대한 부분을 무시하면 메시지에는 이 코드가 문제인 이유에 대한 핵심이 포함되어 있습니다.\nthis function's return type contains a borrowed value, but there is no value\nfor it to be borrowed from\n\ndangle 코드의 각 단계에서 정확히 어떤 일이 발생하는지 자세히 살펴보겠습니다.\n파일 이름: src/main.rs\nfn dangle() -&gt; &amp;String { // dangle returns a reference to a String\n\n    let s = String::from(`hello`); // s is a new String\n\n    &amp;s // we return a reference to the String, s\n} // Here, s goes out of scope, and is dropped. Its memory goes away.\n  // Danger!\n\ndangle 내부에 s가 생성되기 때문에 dangle의 코드가 완료되면 s가 할당 해제됩니다. 그러나 우리는 그것에 대한 참조를 반환하려고 했습니다. 이는 이 참조가 잘못된 문자열을 가리키고 있음을 의미합니다. 좋지 않아! Rust는 우리가 이것을 하도록 허용하지 않을 것입니다.\n여기서 해결책은 문자열을 직접 반환하는 것입니다.\nfn no_dangle() -&gt; String {\n    let s = String::from(`hello`);\n\n    s\n}\n\n아무 문제 없이 작동합니다. 소유권이 이동되고 할당이 취소되지 않습니다.\n참조 규칙\n참조에 대해 논의한 내용을 요약해 보겠습니다.\n\n주어진 시간에 하나 의 가변 참조 또는 여러 불변 참조를 가질 수 있습니다.\n참조는 항상 유효해야 합니다.\n\n다음으로 다른 종류의 참조인 슬라이스를 살펴보겠습니다.\n\n슬라이스 유형\n슬라이스를 사용하면 전체 컬렉션이 아닌 컬렉션의 연속적인 요소 시퀀스를 참조할 수 있습니다. 슬라이스는 일종의 참조이므로 소유권이 없습니다.\n여기에 작은 프로그래밍 문제가 있습니다. 공백으로 구분된 단어 문자열을 사용하고 해당 문자열에서 찾은 첫 번째 단어를 반환하는 함수를 작성하세요. 함수가 문자열에서 공백을 찾지 못하면 전체 문자열이 한 단어여야 하므로 전체 문자열이 반환되어야 합니다.\n슬라이스가 해결하는 문제를 이해하기 위해 슬라이스를 사용하지 않고 이 함수의 시그니처를 작성하는 방법을 살펴보겠습니다.\nfn first_word(s: &amp;String) -&gt; ?\n\nfirst_word 함수는 매개변수로 &amp;String을 가집니다. 우리는 소유권을 원하지 않으므로 괜찮습니다. 그러나 우리는 무엇을 반환해야 합니까? 문자열의 일부 에 대해 말할 방법이 없습니다. 그러나 공백으로 표시된 단어 끝의 인덱스를 반환할 수 있습니다. Listing 4-7과 같이 시도해 봅시다.\n파일 이름: src/main.rs\nfn first_word(s: &amp;String) -&gt; usize {\n    let bytes = s.as_bytes();\n\n    for (i, &amp;item) in bytes.iter().enumerate() {\n        if item == b' ' {\n            return i;\n        }\n    }\n\n    s.len()\n}\n\n목록 4-7: 바이트 인덱스 값을 String 매개변수로 반환하는 first_word 함수\n요소별로 문자열 요소를 살펴보고 값이 공백인지 확인해야 하므로 as_bytes 메서드를 사용하여 문자열을 바이트 배열로 변환합니다.\n    let bytes = s.as_bytes();\n\n다음으로 iter 메서드를 사용하여 바이트 배열에 대한 반복자를 만듭니다.\n    for (i, &amp;item) in bytes.iter().enumerate() {\n\n13장 에서 이터레이터에 대해 더 자세히 논의할 것입니다. 지금은 iter가 컬렉션의 각 요소를 반환하는 메서드이고 enumerate가 iter의 결과를 래핑하고 대신 튜플의 일부로 각 요소를 반환한다는 것을 알아두세요. enumerate에서 반환된 튜플의 첫 번째 요소는 인덱스이고 두 번째 요소는 요소에 대한 참조입니다. 지수를 직접 계산하는 것보다 조금 더 편리합니다.\nenumerate 메서드는 튜플을 반환하기 때문에 패턴을 사용하여 해당 튜플을 분해할 수 있습니다. 6장 에서 패턴에 대해 더 논의할 것입니다. for 루프에서 튜플의 인덱스에 i가 있고 튜플의 단일 바이트에 &amp;item이 있는 패턴을 지정합니다. .iter().enumerate()에서 요소에 대한 참조를 가져오므로 패턴에서 &amp;를 사용합니다.\nfor 루프 내에서 바이트 리터럴 구문을 사용하여 공백을 나타내는 바이트를 검색합니다. 공백을 찾으면 위치를 반환합니다. 그렇지 않으면 s.len()을 사용하여 문자열의 길이를 반환합니다.\n        if item == b' ' {\n            return i;\n        }\n    }\n\n    s.len()\n\n이제 문자열에서 첫 번째 단어의 끝 인덱스를 찾을 수 있는 방법이 있지만 문제가 있습니다. 자체적으로 usize를 반환하지만 &amp;String 컨텍스트에서 의미 있는 숫자일 뿐입니다. 즉, 문자열과는 별개의 값이기 때문에 앞으로도 유효하다는 보장이 없습니다. 목록 4-7의 first_word 함수를 사용하는 목록 4-8의 프로그램을 고려하십시오.\n파일 이름: src/main.rs\nfn main() {\n    let mut s = String::from(`hello world`);\n\n    let word = first_word(&amp;s); // word will get the value 5\n\n    s.clear(); // this empties the String, making it equal to ``\n\n    // word still has the value 5 here, but there's no more string that\n    // we could meaningfully use the value 5 with. word is now totally invalid!\n}\n\n목록 4-8: first_word 함수 호출 결과 저장 및 문자열 내용 변경\n이 프로그램은 오류 없이 컴파일되며 s.clear()를 호출한 후 word를 사용한 경우에도 오류가 발생합니다. word는 s의 상태와 전혀 연결되어 있지 않기 때문에 word는 여전히 값 5를 포함합니다. 변수 s와 함께 값 5를 사용하여 첫 번째 단어를 추출하려고 시도할 수 있지만 word에 5를 저장한 이후로 s의 내용이 변경되었기 때문에 이것은 버그가 됩니다.\nword의 인덱스가 s의 데이터와 동기화되지 않는 것에 대해 걱정하는 것은 지루하고 오류가 발생하기 쉽습니다! second_word 함수를 작성하면 이러한 인덱스를 관리하기가 훨씬 더 어려워집니다. 서명은 다음과 같아야 합니다.\nfn second_word(s: &amp;String) -&gt; (usize, usize) {\n\n이제 우리는 시작 및 종료 인덱스를 추적하고 있으며 특정 상태의 데이터에서 계산되었지만 해당 상태에 전혀 연결되지 않은 더 많은 값을 가지고 있습니다. 동기화를 유지해야 하는 세 개의 관련 없는 변수가 떠다니고 있습니다.\n운 좋게도 Rust는 이 문제에 대한 해결책을 가지고 있습니다: 스트링 슬라이스입니다.\n스트링 슬라이스\n문자열 조각은 문자열의 일부에 대한 참조이며 다음과 같습니다.\n    let s = String::from(`hello world`);\n\n    let hello = &amp;s[0..5];\n    let world = &amp;s[6..11];\n\n전체 문자열에 대한 참조가 아니라 hello는 추가 [0..5] 비트에 지정된 문자열 부분에 대한 참조입니다. [starting_index..ending_index]를 지정하여 괄호 안의 범위를 사용하여 슬라이스를 만듭니다. 여기서 starting_index는 슬라이스의 첫 번째 위치이고 ending_index는 슬라이스의 마지막 위치보다 하나 더 많습니다. 내부적으로 슬라이스 데이터 구조는 ending_index에서 starting_index를 뺀 값에 해당하는 슬라이스의 시작 위치와 길이를 저장합니다. 따라서 let world = &amp;s[6..11];의 경우 world는 길이 값이 5인 s의 인덱스 6에 있는 바이트에 대한 포인터를 포함하는 슬라이스입니다.\n그림 4-6은 이를 다이어그램으로 보여줍니다.\n\n그림 4-6: 문자열의 일부를 참조하는 문자열 슬라이스\nRust의 .. 범위 구문을 사용하여 인덱스 0에서 시작하려면 두 마침표 앞에 값을 놓을 수 있습니다. 즉, 다음과 같습니다.\nlet s = String::from(`hello`);\n\nlet slice = &amp;s[0..2];\nlet slice = &amp;s[..2];\n\n마찬가지로 슬라이스에 문자열의 마지막 바이트가 포함되어 있으면 후행 숫자를 삭제할 수 있습니다. 즉, 다음과 같이 동일합니다.\nlet s = String::from(`hello`);\n\nlet len = s.len();\n\nlet slice = &amp;s[3..len];\nlet slice = &amp;s[3..];\n\n두 값을 모두 삭제하여 전체 문자열의 조각을 가져올 수도 있습니다. 따라서 이들은 동일합니다.\nlet s = String::from(`hello`);\n\nlet len = s.len();\n\nlet slice = &amp;s[0..len];\nlet slice = &amp;s[..];\n\n\n참고: 문자열 슬라이스 범위 인덱스는 유효한 UTF-8 문자 경계에서 발생해야 합니다. 멀티바이트 문자 중간에 문자열 조각을 만들려고 하면 프로그램이 오류와 함께 종료됩니다. 문자열 조각을 소개하기 위해 이 섹션에서는 ASCII만 가정합니다. UTF-8 처리에 대한 자세한 내용은 8장의 UTF-8 인코딩된 텍스트를 문자열로 저장 섹션에 있습니다.\n\n이 모든 정보를 염두에 두고 슬라이스를 반환하도록 first_word를 다시 작성해 보겠습니다. 문자열 조각을 나타내는 유형은 &amp;str로 작성됩니다.\n파일 이름: src/main.rs\nfn first_word(s: &amp;String) -&gt; &amp;str {\n    let bytes = s.as_bytes();\n\n    for (i, &amp;item) in bytes.iter().enumerate() {\n        if item == b' ' {\n            return &amp;s[0..i];\n        }\n    }\n\n    &amp;s[..]\n}\n\n우리는 Listing 4-7에서 했던 것과 같은 방법으로 단어의 끝에 대한 색인을 얻습니다. 공백의 첫 번째 항목을 찾는 것입니다. 공백을 찾으면 문자열의 시작과 공백의 인덱스를 시작 및 끝 인덱스로 사용하여 문자열 슬라이스를 반환합니다.\n이제 first_word를 호출하면 기본 데이터에 연결된 단일 값을 반환합니다. 값은 슬라이스의 시작점에 대한 참조와 슬라이스의 요소 수로 구성됩니다.\n슬라이스를 반환하는 것은 second_word 함수에서도 작동합니다.\nfn second_word(s: &amp;String) -&gt; &amp;str {\n\n이제 컴파일러가 문자열에 대한 참조가 유효한지 확인하기 때문에 엉망으로 만들기 훨씬 더 어려운 간단한 API가 있습니다. Listing 4-8에 있는 프로그램의 버그를 기억하십니까? 첫 번째 단어의 끝에 인덱스를 얻었지만 문자열을 지워서 인덱스가 유효하지 않게 되었을 때의 버그를 기억하십니까? 해당 코드는 논리적으로 잘못되었지만 즉각적인 오류는 표시되지 않았습니다. 빈 문자열과 함께 첫 번째 단어 색인을 계속 사용하려고 하면 나중에 문제가 나타납니다. 슬라이스는 이 버그를 불가능하게 만들고 코드에 문제가 있음을 훨씬 빨리 알려줍니다. first_word의 슬라이스 버전을 사용하면 컴파일 타임 오류가 발생합니다.\n파일 이름: src/main.rs\nfn main() {\n    let mut s = String::from(`hello world`);\n\n    let word = first_word(&amp;s);\n\n    s.clear(); // error!\n\n    println!(`the first word is: {}`, word);\n}\n\n다음은 컴파일러 오류입니다.\n$ cargo run\n   Compiling ownership v0.1.0 (file:///projects/ownership)\nerror[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable\n  --&gt; src/main.rs:18:5\n   |\n16 |     let word = first_word(&amp;s);\n   |                           -- immutable borrow occurs here\n17 |\n18 |     s.clear(); // error!\n   |     ^^^^^^^^^ mutable borrow occurs here\n19 |\n20 |     println!(`the first word is: {}`, word);\n   |                                       ---- immutable borrow later used here\n\nFor more information about this error, try `rustc --explain E0502`.\nerror: could not compile `ownership` due to previous error\n\n무언가에 대한 불변 참조가 있으면 가변 참조도 사용할 수 없다는 차용 규칙을 상기하십시오. clear는 String을 잘라야 하기 때문에 변경 가능한 참조를 가져와야 합니다. println! clear에 대한 호출이 word의 참조를 사용한 후에는 변경 불가능한 참조가 해당 시점에서 여전히 활성 상태여야 합니다. Rust는 clear의 변경 가능한 참조와 word의 변경 불가능한 참조가 동시에 존재하는 것을 허용하지 않으며 컴파일이 실패합니다. Rust는 API를 사용하기 쉽게 만들었을 뿐만 아니라 컴파일 시간에 전체 오류 클래스를 제거했습니다!\n슬라이스로서의 문자열 리터럴\n바이너리 내부에 저장되는 문자열 리터럴에 대해 이야기했던 것을 기억하십시오. 이제 슬라이스에 대해 알았으므로 문자열 리터럴을 제대로 이해할 수 있습니다.\nlet s = `Hello, world!`;\n\n여기서 s의 유형은 &amp;str입니다. 바이너리의 특정 지점을 가리키는 슬라이스입니다. 이것이 문자열 리터럴이 불변인 이유이기도 합니다. &amp;str은 변경할 수 없는 참조입니다.\n문자열 조각을 매개변수로\n리터럴과 문자열 값의 조각을 사용할 수 있다는 사실을 알면 first_word에서 한 가지 더 개선할 수 있으며 이것이 시그니처입니다.\nfn first_word(s: &amp;String) -&gt; &amp;str {\n\n더 경험이 많은 Rustacean은 &amp;String 값과 &amp;str 값 모두에 대해 동일한 함수를 사용할 수 있기 때문에 목록 4-9에 표시된 서명을 대신 작성할 것입니다.\nfn first_word(s: &amp;str) -&gt; &amp;str {\n\nListing 4-9: s 매개변수 유형에 문자열 슬라이스를 사용하여 first_word 함수 개선\n문자열 슬라이스가 있으면 직접 전달할 수 있습니다. 문자열이 있는 경우 문자열 조각이나 문자열에 대한 참조를 전달할 수 있습니다. 이러한 유연성은 15장의 암시적 역참조 강제 변환 섹션 에서 다룰 기능인 역참조 강제를 활용합니다.\n문자열에 대한 참조 대신 문자열 슬라이스를 사용하도록 함수를 정의하면 기능 손실 없이 API가 더 일반적이고 유용해집니다.\n파일 이름: src/main.rs\nfn main() {\n    let my_string = String::from(`hello world`);\n\n    // `first_word` works on slices of `String`s, whether partial or whole\n    let word = first_word(&amp;my_string[0..6]);\n    let word = first_word(&amp;my_string[..]);\n    // `first_word` also works on references to `String`s, which are equivalent\n    // to whole slices of `String`s\n    let word = first_word(&amp;my_string);\n\n    let my_string_literal = `hello world`;\n\n    // `first_word` works on slices of string literals, whether partial or whole\n    let word = first_word(&amp;my_string_literal[0..6]);\n    let word = first_word(&amp;my_string_literal[..]);\n\n    // Because string literals *are* string slices already,\n    // this works too, without the slice syntax!\n    let word = first_word(my_string_literal);\n}\n\n다른 조각\n상상할 수 있듯이 스트링 슬라이스는 스트링에 따라 다릅니다. 그러나 보다 일반적인 슬라이스 유형도 있습니다. 다음 배열을 고려하십시오.\nlet a = [1, 2, 3, 4, 5];\n\n문자열의 일부를 참조하려는 것처럼 배열의 일부를 참조하고 싶을 수도 있습니다. 우리는 이렇게 할 것입니다:\nlet a = [1, 2, 3, 4, 5];\n\nlet slice = &amp;a[1..3];\n\nassert_eq!(slice, &amp;[2, 3]);\n\n이 슬라이스의 유형은 &amp;[i32]입니다. 첫 번째 요소에 대한 참조와 길이를 저장하여 스트링 슬라이스와 동일한 방식으로 작동합니다. 모든 종류의 다른 컬렉션에 대해 이러한 종류의 슬라이스를 사용하게 됩니다. 8장에서 벡터에 대해 이야기할 때 이러한 모음에 대해 자세히 논의할 것입니다.\n요약\n소유권, 차용 및 슬라이스의 개념은 컴파일 타임에 Rust 프로그램의 메모리 안전을 보장합니다. Rust 언어는 다른 시스템 프로그래밍 언어와 같은 방식으로 메모리 사용을 제어할 수 있지만, 데이터 소유자가 범위를 벗어날 때 데이터 소유자가 해당 데이터를 자동으로 정리하면 추가 코드를 작성하고 디버깅할 필요가 없습니다. 이 컨트롤을 얻으려면.\n소유권은 Rust의 다른 많은 부분이 작동하는 방식에 영향을 미치므로 책의 나머지 부분에서 이러한 개념에 대해 더 자세히 이야기할 것입니다. 5장으로 이동하여 구조체에서 데이터 조각을 함께 그룹화하는 방법을 살펴보겠습니다.\n\n구조체를 사용하여 관련 데이터 구조화\nstruct 또는 structure 는 함께 패키징하고 의미 있는 그룹을 구성하는 여러 관련 값의 이름 을 지정할 수 있는 사용자 정의 데이터 유형입니다. 객체 지향 언어에 익숙하다면 구조체는 객체의 데이터 속성과 같습니다. 이 장에서는 튜플과 구조체를 비교 및 대조하여 이미 알고 있는 내용을 기반으로 구축하고 구조체가 데이터를 그룹화하는 더 좋은 방법인 경우를 보여줍니다.\n구조체를 정의하고 인스턴스화하는 방법을 보여줍니다. 구조체 유형과 관련된 동작을 지정하기 위해 관련 함수, 특히 methods 라는 관련 함수를 정의하는 방법에 대해 설명합니다. 구조체와 열거형(6장에서 논의)은 Rust의 컴파일 시간 유형 검사를 최대한 활용하기 위해 프로그램 도메인에서 새 유형을 생성하기 위한 빌딩 블록입니다.\n\n구조체 정의 및 인스턴스화\n구조체는 튜플 유형 섹션 에서 논의한 튜플과 유사하며 둘 다 여러 관련 값을 보유합니다. 튜플과 마찬가지로 구조체의 조각은 다른 유형일 수 있습니다. 튜플과 달리 구조체에서는 값이 의미하는 바가 명확하도록 각 데이터 조각의 이름을 지정합니다. 이러한 이름을 추가한다는 것은 구조체가 튜플보다 더 유연하다는 것을 의미합니다. 인스턴스 값을 지정하거나 액세스하기 위해 데이터 순서에 의존할 필요가 없습니다.\n구조체를 정의하려면 키워드 struct를 입력하고 전체 구조체의 이름을 지정합니다. 구조체의 이름은 함께 그룹화되는 데이터 조각의 중요성을 설명해야 합니다. 그런 다음 중괄호 안에 필드라고 하는 데이터 조각의 이름과 유형을 정의 합니다 . 예를 들어 Listing 5-1은 사용자 계정에 대한 정보를 저장하는 구조체를 보여줍니다.\n파일 이름: src/main.rs\nstruct User {\n    active: bool,\n    username: String,\n    email: String,\n    sign_in_count: u64,\n}\n\n목록 5-1: 사용자 구조체 정의\n구조체를 정의한 후 사용하려면 각 필드에 구체적인 값을 지정하여 해당 구조체의 인스턴스를 만듭니다. 구조체의 이름을 명시하여 인스턴스를 생성한 다음 key: value 쌍을 포함하는 중괄호를 추가합니다. 여기서 키는 필드의 이름이고 값은 해당 필드에 저장하려는 데이터입니다. 구조체에서 선언한 것과 동일한 순서로 필드를 지정할 필요가 없습니다. 즉, 구조체 정의는 유형에 대한 일반적인 템플릿과 같으며 인스턴스는 유형의 값을 생성하기 위해 특정 데이터로 해당 템플릿을 채웁니다. 예를 들어 Listing 5-2와 같이 특정 사용자를 선언할 수 있습니다.\n파일 이름: src/main.rs\nfn main() {\n    let user1 = User {\n        active: true,\n        username: String::from(`someusername123`),\n        email: String::from(`someone@example.com`),\n        sign_in_count: 1,\n    };\n}\n\n목록 5-2: User 구조체의 인스턴스 만들기\n구조체에서 특정 값을 얻으려면 점 표기법을 사용합니다. 예를 들어 이 사용자의 이메일 주소에 액세스하려면 user1.email을 사용합니다. 인스턴스가 변경 가능한 경우 점 표기법을 사용하고 특정 필드에 할당하여 값을 변경할 수 있습니다. Listing 5-3은 변경 가능한 User 인스턴스의 email 필드 값을 변경하는 방법을 보여줍니다.\n파일 이름: src/main.rs\nfn main() {\n    let mut user1 = User {\n        active: true,\n        username: String::from(`someusername123`),\n        email: String::from(`someone@example.com`),\n        sign_in_count: 1,\n    };\n\n    user1.email = String::from(`anotheremail@example.com`);\n}\n\nListing 5-3: User 인스턴스의 email 필드 값 변경\n전체 인스턴스는 변경 가능해야 합니다. Rust는 특정 필드만 가변으로 표시하는 것을 허용하지 않습니다. 모든 표현식과 마찬가지로 구조체의 새 인스턴스를 함수 본문의 마지막 표현식으로 구성하여 해당 새 인스턴스를 암시적으로 반환할 수 있습니다.\nListing 5-4는 주어진 이메일과 사용자 이름으로 User 인스턴스를 반환하는 build_user 함수를 보여줍니다. 활성 필드는 true 값을 가져오고 sign_in_count는 1 값을 가져옵니다.\n파일 이름: src/main.rs\nfn build_user(email: String, username: String) -&gt; User {\n    User {\n        active: true,\n        username: username,\n        email: email,\n        sign_in_count: 1,\n    }\n}\n\nListing 5-4: 이메일과 사용자 이름을 받아 User 인스턴스를 반환하는 build_user 함수\n구조체 필드와 같은 이름으로 함수 매개변수의 이름을 지정하는 것은 의미가 있지만 email 및 username 필드 이름과 변수를 반복해야 하는 것은 약간 지루합니다. 구조체에 더 많은 필드가 있는 경우 각 이름을 반복하면 훨씬 더 짜증이 날 것입니다. 다행히도 편리한 속기가 있습니다!\n필드 초기화 약어 사용\n목록 5-4에서 매개변수 이름과 구조체 필드 이름이 정확히 동일하기 때문에 필드 초기화 약식 구문을 사용하여 build_user를 다시 작성할 수 있습니다. 이렇게 하면 정확히 동일하게 작동하지만 username 및 Listing 5-5와 같이 email.\n파일 이름: src/main.rs\nfn build_user(email: String, username: String) -&gt; User {\n    User {\n        active: true,\n        username,\n        email,\n        sign_in_count: 1,\n    }\n}\n\n목록 5-5: username 및 email 매개변수가 구조체 필드와 이름이 같기 때문에 필드 초기화 약어를 사용하는 build_user 함수\n여기서는 email이라는 필드가 있는 User 구조체의 새 인스턴스를 만듭니다. 이메일 필드의 값을 build_user 함수의 이메일 매개변수 값으로 설정하려고 합니다. email 필드와 email 매개변수의 이름이 같기 때문에 email: email이 아닌 email만 작성하면 됩니다.\nStruct Update 구문을 사용하여 다른 인스턴스에서 인스턴스 생성\n다른 인스턴스의 값 대부분을 포함하지만 일부는 변경하는 구조체의 새 인스턴스를 만드는 것이 종종 유용합니다. 구조체 업데이트 구문을 사용하여 이 작업을 수행할 수 있습니다.\n먼저 Listing 5-6에서 업데이트 구문 없이 정기적으로 user2에 새 User 인스턴스를 생성하는 방법을 보여줍니다. email에 새 값을 설정하지만 그 외에는 Listing 5-2에서 생성한 user1의 동일한 값을 사용합니다.\n파일 이름: src/main.rs\nfn main() {\n    // --snip--\n\n    let user2 = User {\n        active: user1.active,\n        username: user1.username,\n        email: String::from(`another@example.com`),\n        sign_in_count: user1.sign_in_count,\n    };\n}\n\n목록 5-6: user1의 값 중 하나를 사용하여 새 User 인스턴스 만들기\n구조체 업데이트 구문을 사용하면 Listing 5-7과 같이 더 적은 코드로 동일한 효과를 얻을 수 있습니다. 구문 ..은 명시적으로 설정되지 않은 나머지 필드가 지정된 인스턴스의 필드와 동일한 값을 갖도록 지정합니다.\n파일 이름: src/main.rs\nfn main() {\n    // --snip--\n\n    let user2 = User {\n        email: String::from(`another@example.com`),\n        ..user1\n    };\n}\n\n목록 5-7: 구조체 업데이트 구문을 사용하여 User 인스턴스에 대한 새 email 값을 설정하지만 user1의 나머지 값을 사용\n목록 5-7의 코드는 또한 이메일에 대해 다른 값을 갖지만 user1의 username, active 및 sign_in_count 필드에 대해 동일한 값을 갖는 user2에 인스턴스를 생성합니다. ..user1은 나머지 필드가 user1의 해당 필드에서 값을 가져와야 함을 지정하기 위해 마지막에 와야 하지만 순서에 상관없이 원하는 만큼 많은 필드에 대한 값을 지정하도록 선택할 수 있습니다. 구조체 정의에 있는 필드의\n구조체 업데이트 구문은 할당처럼 =를 사용합니다. 이동과 상호 작용하는 변수 및 데이터 섹션 에서 본 것처럼 데이터를 이동하기 때문입니다. 이 예제에서는 user1의 username 필드에 있는 String이 user2로 이동되었기 때문에 user2를 생성한 후 더 이상 user1을 전체적으로 사용할 수 없습니다. user2에 email과 username 모두에 대해 새 String 값을 지정하여 user1에서 active 및 sign_in_count 값만 사용한 경우 user1은 생성 후에도 여전히 유효합니다. 사용자2. 활성 및 sign_in_count는 모두 복사 특성을 구현하는 유형입니다.\n명명된 필드 없이 튜플 구조체를 사용하여 다른 유형 만들기\nRust는 또한 튜플 구조체 라고 하는 튜플과 비슷하게 보이는 구조체를 지원합니다. 튜플 구조체에는 구조체 이름이 제공하는 추가 의미가 있지만 해당 필드와 연결된 이름은 없습니다. 오히려 그들은 단지 필드의 유형을 가지고 있습니다. 튜플 구조체는 전체 튜플에 이름을 지정하고 튜플을 다른 튜플과 다른 유형으로 만들고 싶을 때 그리고 일반 구조체에서와 같이 각 필드의 이름을 지정하는 것이 장황하거나 중복될 때 유용합니다.\n튜플 구조체를 정의하려면 struct 키워드로 시작하고 구조체 이름 뒤에 튜플의 유형이 옵니다. 예를 들어 여기에서는 Color와 Point라는 두 개의 튜플 구조체를 정의하고 사용합니다.\n파일 이름: src/main.rs\nstruct Color(i32, i32, i32);\nstruct Point(i32, i32, i32);\n\nfn main() {\n    let black = Color(0, 0, 0);\n    let origin = Point(0, 0, 0);\n}\n\n검은색 및 원점 값은 서로 다른 튜플 구조체의 인스턴스이기 때문에 서로 다른 유형입니다. 정의하는 각 구조체는 구조체 내의 필드가 동일한 유형을 가질 수 있더라도 고유한 유형입니다. 예를 들어 색상 유형의 매개변수를 사용하는 함수는 두 유형 모두 세 개의 i32 값으로 구성되어 있어도 점을 인수로 사용할 수 없습니다. 그렇지 않으면 튜플 구조체 인스턴스는 개별 조각으로 분해할 수 있고 .를 사용할 수 있다는 점에서 튜플과 유사합니다. 개별 값에 액세스하기 위한 인덱스가 뒤따릅니다.\n필드가 없는 단위 유사 구조체\n필드가 없는 구조체를 정의할 수도 있습니다! 이들은 튜플 유형 섹션 에서 언급한 단위 유형인 ()와 유사하게 동작하기 때문에 단위 유사 구조체 라고 합니다. 단위와 같은 구조체는 일부 유형에 특성을 구현해야 하지만 유형 자체에 저장하려는 데이터가 없을 때 유용할 수 있습니다. 특성에 대해서는 10장에서 논의할 것입니다. 다음은 AlwaysEqual이라는 단위 구조체를 선언하고 인스턴스화하는 예입니다.\n파일 이름: src/main.rs\nstruct AlwaysEqual;\n\nfn main() {\n    let subject = AlwaysEqual;\n}\n\nAlwaysEqual을 정의하려면 struct 키워드, 원하는 이름, 세미콜론을 사용합니다. 중괄호나 괄호가 필요하지 않습니다! 그런 다음 유사한 방식으로 subject 변수에서 AlwaysEqual 인스턴스를 얻을 수 있습니다. 중괄호나 괄호 없이 정의한 이름을 사용합니다. 나중에 AlwaysEqual의 모든 인스턴스가 항상 다른 유형의 모든 인스턴스와 동일하도록 이 유형에 대한 동작을 구현하여 테스트 목적으로 알려진 결과를 가질 것이라고 상상해 보십시오. 해당 동작을 구현하는 데 데이터가 필요하지 않습니다! 10장에서 특성을 정의하고 유닛과 같은 구조체를 포함하여 모든 유형에서 구현하는 방법을 볼 수 있습니다.\n\n구조체 데이터의 소유권\nListing 5-1의 User 구조체 정의에서 우리는 &amp;str 문자열 슬라이스 유형이 아닌 소유된 String 유형을 사용했습니다. 이것은 이 구조체의 각 인스턴스가 모든 데이터를 소유하고 전체 구조체가 유효한 한 해당 데이터가 유효하기를 원하기 때문에 의도적인 선택입니다.\n구조체가 다른 것이 소유한 데이터에 대한 참조를 저장하는 것도 가능하지만 그렇게 하려면 10장에서 논의할 Rust 기능인 lifetimes 를 사용해야 합니다. 수명은 구조체가 참조하는 데이터가 다음과 같이 유효한지 확인합니다. 구조체가 있는 한. 다음과 같이 수명을 지정하지 않고 구조체에 참조를 저장하려고 한다고 가정해 보겠습니다. 이것은 작동하지 않습니다:\n파일 이름: src/main.rs\nstruct User {\n    active: bool,\n    username: &amp;str,\n    email: &amp;str,\n    sign_in_count: u64,\n}\n\nfn main() {\n    let user1 = User {\n        active: true,\n        username: `someusername123`,\n        email: `someone@example.com`,\n        sign_in_count: 1,\n    };\n}\n\n컴파일러는 수명 지정자가 필요하다고 불평합니다.\n$ cargo run\n   Compiling structs v0.1.0 (file:///projects/structs)\nerror[E0106]: missing lifetime specifier\n --&gt; src/main.rs:3:15\n  |\n3 |     username: &amp;str,\n  |               ^ expected named lifetime parameter\n  |\nhelp: consider introducing a named lifetime parameter\n  |\n1 ~ struct User&lt;'a&gt; {\n2 |     active: bool,\n3 ~     username: &amp;'a str,\n  |\n\nerror[E0106]: missing lifetime specifier\n --&gt; src/main.rs:4:12\n  |\n4 |     email: &amp;str,\n  |            ^ expected named lifetime parameter\n  |\nhelp: consider introducing a named lifetime parameter\n  |\n1 ~ struct User&lt;'a&gt; {\n2 |     active: bool,\n3 |     username: &amp;str,\n4 ~     email: &amp;'a str,\n  |\n\nFor more information about this error, try `rustc --explain E0106`.\nerror: could not compile `structs` due to 2 previous errors\n\n10장에서 구조체에 참조를 저장할 수 있도록 이러한 오류를 수정하는 방법에 대해 논의하지만 지금은 &amp;str과 같은 참조 대신 String과 같은 소유 유형을 사용하여 이러한 오류를 수정합니다.\n\n\n구조체를 사용한 예제 프로그램\n언제 구조체를 사용해야 하는지 이해하기 위해 직사각형의 면적을 계산하는 프로그램을 작성해 봅시다. 단일 변수를 사용하여 시작한 다음 구조체를 대신 사용할 때까지 프로그램을 리팩터링합니다.\n픽셀로 지정된 직사각형의 너비와 높이를 가져오고 직사각형의 면적을 계산하는 직사각형 이라는 Cargo로 새로운 바이너리 프로젝트를 만들어 봅시다. Listing 5-8은 우리 프로젝트의 src/main.rs 에서 정확히 그것을 수행하는 한 가지 방법이 있는 짧은 프로그램을 보여줍니다.\n파일 이름: src/main.rs\nfn main() {\n    let width1 = 30;\n    let height1 = 50;\n\n    println!(\n        `The area of the rectangle is {} square pixels.`,\n        area(width1, height1)\n    );\n}\n\nfn area(width: u32, height: u32) -&gt; u32 {\n    width * height\n}\n\n목록 5-8: 별도의 너비 및 높이 변수로 지정된 사각형의 면적 계산\n이제 cargo run을 사용하여 이 프로그램을 실행합니다.\n$ cargo run\n   Compiling rectangles v0.1.0 (file:///projects/rectangles)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.42s\n     Running `target/debug/rectangles`\nThe area of the rectangle is 1500 square pixels.\n\n이 코드는 각 치수와 함께 area 함수를 호출하여 사각형의 면적을 파악하는 데 성공했지만 이 코드를 명확하고 읽기 쉽게 만들기 위해 더 많은 작업을 수행할 수 있습니다.\n이 코드의 문제는 area의 서명에서 분명합니다.\nfn area(width: u32, height: u32) -&gt; u32 {\n\narea 함수는 하나의 직사각형의 면적을 계산하기로 되어 있지만, 우리가 작성한 함수에는 두 개의 매개변수가 있고 매개변수가 관련되어 있다는 것이 우리 프로그램의 어느 곳에서도 명확하지 않습니다. 너비와 높이를 함께 그룹화하는 것이 더 읽기 쉽고 관리하기 쉽습니다. 우리는 이미 3장의 튜플 유형 섹션에서 튜플을 사용하여 이를 수행할 수 있는 한 가지 방법에 대해 논의했습니다.\n튜플로 리팩토링\n목록 5-9는 튜플을 사용하는 프로그램의 다른 버전을 보여줍니다.\n파일 이름: src/main.rs\nfn main() {\n    let rect1 = (30, 50);\n\n    println!(\n        `The area of the rectangle is {} square pixels.`,\n        area(rect1)\n    );\n}\n\nfn area(dimensions: (u32, u32)) -&gt; u32 {\n    dimensions.0 * dimensions.1\n}\n\n목록 5-9: 튜플로 사각형의 너비와 높이 지정하기\n어떤 면에서는 이 프로그램이 더 좋습니다. 튜플을 사용하면 약간의 구조를 추가할 수 있으며 이제 하나의 인수만 전달합니다. 그러나 또 다른 방식으로 이 버전은 덜 명확합니다. 튜플은 요소의 이름을 지정하지 않으므로 튜플의 일부를 인덱싱해야 하므로 계산이 덜 명확해집니다.\n너비와 높이를 섞는 것은 면적 계산에 문제가 되지 않지만 화면에 사각형을 그리려면 중요합니다! 너비는 튜플 인덱스 0이고 높이는 튜플 인덱스 1이라는 점을 명심해야 합니다. 이것은 다른 사람이 우리 코드를 사용한다면 알아내고 기억하기가 훨씬 더 어려울 것입니다. 코드에서 데이터의 의미를 전달하지 않았기 때문에 이제 오류를 도입하기가 더 쉬워졌습니다.\n구조체로 리팩토링: 더 많은 의미 추가\n구조체를 사용하여 데이터에 레이블을 지정하여 의미를 추가합니다. Listing 5-10에 표시된 것처럼 사용 중인 튜플을 전체 이름과 부분 이름이 있는 구조체로 변환할 수 있습니다.\n파일 이름: src/main.rs\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n\n    println!(\n        `The area of the rectangle is {} square pixels.`,\n        area(&amp;rect1)\n    );\n}\n\nfn area(rectangle: &amp;Rectangle) -&gt; u32 {\n    rectangle.width * rectangle.height\n}\n\nListing 5-10: Rectangle 구조체 정의하기\n여기서 우리는 구조체를 정의하고 이름을 Rectangle로 지정했습니다. 중괄호 안에 너비 및 높이 필드를 정의했으며 둘 다 u32 유형을 가집니다. 그런 다음 main에서 너비가 30이고 높이가 50인 Rectangle의 특정 인스턴스를 만들었습니다.\n우리의 area 함수는 이제 rectangle이라는 이름의 매개변수 하나를 사용하여 정의되며, 그 유형은 Rectangle 구조체 인스턴스의 불변 차용입니다. 4장에서 언급했듯이 소유권을 갖기보다 구조체를 빌리고 싶습니다. 이런 식으로 main은 소유권을 유지하고 rect1을 계속 사용할 수 있습니다. 이것이 우리가 함수 서명에서 &amp;를 사용하고 함수를 호출하는 이유입니다.\narea 함수는 Rectangle 인스턴스의 width 및 height 필드에 액세스합니다(차용한 구조체 인스턴스의 필드에 액세스해도 필드 값이 이동하지 않으므로 구조체 차용을 자주 볼 수 있습니다). 면적에 대한 함수 서명은 이제 정확히 너비 및 높이 필드를 사용하여 직사각형의 면적을 계산합니다. 이것은 너비와 높이가 서로 관련되어 있음을 전달하고 0과 1의 튜플 인덱스 값을 사용하는 대신 값에 설명적인 이름을 부여합니다. 이것은 명확성을 위한 승리입니다.\n파생 특성으로 유용한 기능 추가\n프로그램을 디버깅하고 모든 필드의 값을 보는 동안 Rectangle의 인스턴스를 인쇄할 수 있다면 유용할 것입니다. Listing 5-11은 println! 매크로는 이전 장에서 사용한 것과 같습니다. 그러나 이것은 작동하지 않습니다.\n파일 이름: src/main.rs\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n\n    println!(`rect1 is {}`, rect1);\n}\n\nListing 5-11: Rectangle 인스턴스 인쇄 시도\n이 코드를 컴파일하면 다음 핵심 메시지와 함께 오류가 발생합니다.\nerror[E0277]: `Rectangle` doesn't implement `std::fmt::Display`\n\nprintln! 매크로는 많은 종류의 서식을 지정할 수 있으며 기본적으로 중괄호는 println! 디스플레이로 알려진 형식 사용: 최종 사용자가 직접 사용하기 위한 출력. 지금까지 본 기본 유형은 기본적으로 디스플레이를 구현합니다. 사용자에게 1 또는 다른 기본 유형을 표시하려는 방법은 한 가지뿐이기 때문입니다. 그러나 구조체를 사용하면 println! 더 많은 표시 가능성이 있기 때문에 출력 형식이 명확하지 않습니다. 쉼표를 원하십니까? 중괄호를 인쇄하시겠습니까? 모든 필드를 표시해야 합니까? 이러한 모호성으로 인해 Rust는 우리가 원하는 것을 추측하려고 시도하지 않으며 구조체에는 println!과 함께 사용할 Display 구현이 제공되지 않습니다. 및 {} 자리 표시자.\n오류를 계속 읽으면 다음과 같은 유용한 메모를 찾을 수 있습니다.\n   = help: the trait `std::fmt::Display` is not implemented for `Rectangle`\n   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\n\n해 보자! println! 매크로 호출은 이제 println!(rect1 is {:?}, rect1);처럼 보입니다. 지정자 :? 넣기 중괄호 안에 println! 디버그라는 출력 형식을 사용하려고 합니다. 디버그 특성을 사용하면 개발자에게 유용한 방식으로 구조체를 인쇄할 수 있으므로 코드를 디버깅하는 동안 해당 값을 볼 수 있습니다.\n이 변경으로 코드를 컴파일합니다. 드랏! 여전히 오류가 발생합니다.\nerror[E0277]: `Rectangle` doesn't implement `Debug`\n\n그러나 다시 컴파일러는 다음과 같은 유용한 정보를 제공합니다.\n   = help: the trait `Debug` is not implemented for `Rectangle`\n   = note: add `#[derive(Debug)]` to `Rectangle` or manually `impl Debug for Rectangle`\n\nRust에는 디버깅 정보를 출력하는 기능이 포함 되어 있지만 구조체에서 해당 기능을 사용할 수 있도록 명시적으로 선택해야 합니다. 이를 위해 Listing 5-12에 표시된 것처럼 구조체 정의 바로 앞에 외부 속성 #[derive(Debug)]를 추가합니다.\n파일 이름: src/main.rs\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n\n    println!(`rect1 is {:?}`, rect1);\n}\n\nListing 5-12: Debug 트레이트를 유도하기 위한 속성 추가 및 디버그 포매팅을 사용하여 Rectangle 인스턴스 인쇄\n이제 프로그램을 실행하면 오류가 발생하지 않으며 다음과 같은 결과가 표시됩니다.\n$ cargo run\n   Compiling rectangles v0.1.0 (file:///projects/rectangles)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.48s\n     Running `target/debug/rectangles`\nrect1 is Rectangle { width: 30, height: 50 }\n\n멋진! 가장 예쁜 출력은 아니지만 이 인스턴스에 대한 모든 필드의 값을 표시하므로 디버깅 중에 확실히 도움이 됩니다. 더 큰 구조체가 있는 경우 좀 더 읽기 쉬운 출력을 갖는 것이 유용합니다. 이 경우 println!에서 {:?} 대신 {:#?}를 사용할 수 있습니다. 끈. 이 예에서 {:#?} 스타일을 사용하면 다음이 출력됩니다.\n$ cargo run\n   Compiling rectangles v0.1.0 (file:///projects/rectangles)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.48s\n     Running `target/debug/rectangles`\nrect1 is Rectangle {\n    width: 30,\n    height: 50,\n}\n\n디버그 형식을 사용하여 값을 출력하는 또 다른 방법은 dbg! 식의 소유권을 갖는 매크로 (참조를 취하는 println!와 반대)는 dbg! 매크로 호출은 해당 식의 결과 값과 함께 코드에서 발생하고 값의 소유권을 반환합니다.\n\n참고: dbg! 매크로는 표준 출력 콘솔 스트림(stdout)에 인쇄하는 println!과 달리 표준 오류 콘솔 스트림(stderr)에 인쇄합니다. 12장의 표준 출력 대신 표준 오류에 오류 메시지 쓰기 섹션에서 stderr 및 stdout에 대해 자세히 설명합니다.\n\n다음은 rect1의 전체 구조체 값뿐만 아니라 width 필드에 할당되는 값에 관심이 있는 예입니다.\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nfn main() {\n    let scale = 2;\n    let rect1 = Rectangle {\n        width: dbg!(30 * scale),\n        height: 50,\n    };\n\n    dbg!(&amp;rect1);\n}\n\ndbg!를 넣을 수 있습니다. 30 * scale이라는 표현과 dbg! 표현식 값의 소유권을 반환하면 width 필드는 dbg! 거기에 전화하십시오. 우리는 dbg!를 원하지 않습니다. rect1의 소유권을 가져오므로 다음 호출에서 rect1에 대한 참조를 사용합니다. 이 예제의 출력은 다음과 같습니다.\n$ cargo run\n   Compiling rectangles v0.1.0 (file:///projects/rectangles)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.61s\n     Running `target/debug/rectangles`\n[src/main.rs:10] 30 * scale = 60\n[src/main.rs:14] &amp;rect1 = Rectangle {\n    width: 60,\n    height: 50,\n}\n\n첫 번째 출력 비트는 src/main.rs 라인 10에서 30 * scale 표현식을 디버깅하고 있으며 결과 값은 60입니다(정수에 대해 구현된 디버그 형식은 값만). dbg! src/main.rs 의 14번째 줄에 있는 호출은 Rectangle 구조체인 &amp;rect1의 값을 출력합니다. 이 출력은 직사각형 유형의 예쁜 디버그 형식을 사용합니다. dbg! 매크로는 코드가 수행하는 작업을 파악하려고 할 때 정말 유용할 수 있습니다!\nRust는 Debug 특성 외에도 사용자 지정 유형에 유용한 동작을 추가할 수 있는 derive 특성과 함께 사용할 여러 특성을 제공했습니다. 이러한 특성과 행동은 부록 C 에 나열되어 있습니다. 10장에서 사용자 지정 동작으로 이러한 특성을 구현하는 방법과 고유한 특성을 만드는 방법을 다룰 것입니다. 파생 이외의 많은 특성도 있습니다. 자세한 정보는 Rust 참조 문서의 속성 섹션을 참조하세요 .\n우리의 면적 함수는 매우 구체적입니다. 직사각형의 면적만 계산합니다. 다른 유형에서는 작동하지 않으므로 이 동작을 직사각형 구조체에 더 밀접하게 연결하는 것이 도움이 될 것입니다. area 함수를 Rectangle 유형에 정의된 area 메서드 로 전환하여 이 코드를 계속 리팩터링하는 방법을 살펴보겠습니다.\n\n메서드 구문\n메서드는 함수와 유사합니다. fn 키워드와 이름으로 메서드를 선언하고 매개 변수와 반환 값을 가질 수 있으며 메서드가 다른 곳에서 호출될 때 실행되는 일부 코드를 포함합니다. 함수와 달리 메서드는 구조체( 각각 6장 과 17장 에서 다루는 열거형 또는 특성 개체 )의 컨텍스트 내에서 정의되며 첫 번째 매개변수는 항상 self입니다. struct 메소드가 호출되고 있습니다.\n방법 정의\n목록 5-13과 같이 Rectangle 인스턴스를 매개변수로 갖는 area 함수를 변경하고 Rectangle 구조체에 정의된 area 메서드를 대신 만들어 보겠습니다.\n파일 이름: src/main.rs\n#[derive(Debug)]\nstruct Rectangle {\n    width: u32,\n    height: u32,\n}\n\nimpl Rectangle {\n    fn area(&amp;self) -&gt; u32 {\n        self.width * self.height\n    }\n}\n\nfn main() {\n    let rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n\n    println!(\n        `The area of the rectangle is {} square pixels.`,\n        rect1.area()\n    );\n}\n\nListing 5-13: Rectangle 구조체에 area 메서드 정의하기\nRectangle 컨텍스트 내에서 함수를 정의하기 위해 Rectangle에 대한 impl(구현) 블록을 시작합니다. 이 impl 블록 내의 모든 것은 직사각형 유형과 연결됩니다. 그런 다음 impl 중괄호 내에서 area 함수를 이동하고 서명 및 본문 내의 모든 위치에서 첫 번째(이 경우에만) 매개 변수를 self로 변경합니다. area 함수를 호출하고 rect1을 인수로 전달한 main에서 메서드 구문을 대신 사용하여 Rectangle 인스턴스에서 area 메서드를 호출할 수 있습니다. 메서드 구문은 인스턴스 다음에 옵니다. 점을 추가하고 그 뒤에 메서드 이름, 괄호 및 인수를 추가합니다.\narea의 시그니처에서 rectangle: &amp;Rectangle 대신 &amp;self를 사용합니다. &amp;self는 실제로 self: &amp;Self의 줄임말입니다. impl 블록 내에서 Self 유형은 impl 블록이 있는 유형의 별칭입니다. 메소드는 첫 번째 매개변수에 대해 Self 유형의 self라는 이름의 매개변수를 가져야 합니다. 그래서 Rust는 첫 번째 매개변수 자리에 self라는 이름으로 이것을 축약할 수 있게 합니다. rectangle: &amp;Rectangle에서 했던 것처럼 이 메서드가 Self 인스턴스를 빌린다는 것을 나타내기 위해 self 속기 앞에 &amp;를 사용해야 합니다. 메서드는 자체의 소유권을 가져갈 수 있고 자기를 불변으로 빌릴 수 있습니다.\n함수 버전에서 &amp;Rectangle을 사용한 것과 같은 이유로 여기에서 &amp;self를 선택했습니다. 소유권을 갖고 싶지 않고 구조체의 데이터를 쓰는 것이 아니라 읽기만 원합니다. 메소드가 수행하는 작업의 일부로 메소드를 호출한 인스턴스를 변경하려면 첫 번째 매개변수로 &amp;mut self를 사용합니다. 첫 번째 매개 변수로 self만 사용하여 인스턴스 소유권을 가져오는 메서드는 거의 없습니다. 이 기술은 일반적으로 메서드가 self를 다른 것으로 변환하고 변환 후 호출자가 원래 인스턴스를 사용하지 못하게 하려는 경우에 사용됩니다.\n메서드 구문을 제공하고 모든 메서드 서명에서 self 유형을 반복하지 않아도 되는 것 외에도 함수 대신 메서드를 사용하는 주된 이유는 구성을 위한 것입니다. 우리는 미래의 코드 사용자가 우리가 제공하는 라이브러리의 다양한 위치에서 직사각형의 기능을 검색하도록 하는 대신 유형의 인스턴스로 수행할 수 있는 모든 작업을 하나의 impl 블록에 넣었습니다.\n구조체의 필드 중 하나와 동일한 이름을 메서드에 지정하도록 선택할 수 있습니다. 예를 들어, width라는 이름을 가진 Rectangle에 메소드를 정의할 수 있습니다.\n파일 이름: src/main.rs\nimpl Rectangle {\n    fn width(&amp;self) -&gt; bool {\n        self.width &gt; 0\n    }\n}\n\nfn main() {\n    let rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n\n    if rect1.width() {\n        println!(`The rectangle has a nonzero width; it is {}`, rect1.width);\n    }\n}\n\n여기서 인스턴스의 width 필드 값이 0보다 크면 true를 반환하고 값이 0이면 false를 반환하도록 width 메서드를 선택합니다. 필드를 사용할 수 있습니다. 어떤 목적을 위해 동일한 이름의 메서드 내에서. main에서 rect1.width 뒤에 괄호가 있으면 Rust는 width 메서드를 의미한다는 것을 압니다. 우리가 괄호를 사용하지 않을 때 Rust는 우리가 너비 필드를 의미한다는 것을 압니다.\n항상 그런 것은 아니지만 종종 메서드에 필드와 동일한 이름을 지정하면 필드의 값만 반환하고 다른 작업은 수행하지 않기를 원합니다. 이와 같은 메서드를 getters 라고 하며 Rust는 일부 다른 언어처럼 구조체 필드에 자동으로 구현하지 않습니다. Getter는 필드를 비공개로 만들 수 있지만 메서드는 공개할 수 있으므로 유형의 공개 API의 일부로 해당 필드에 대한 읽기 전용 액세스를 활성화할 수 있기 때문에 유용합니다. 7장 에서 public과 private이 무엇인지, 필드나 메서드를 public 또는 private으로 지정하는 방법에 대해 설명합니다.\n\n-&gt; 연산자는 어디에 있습니까?\nC 및 C++에서는 메서드를 호출하는 데 두 가지 다른 연산자가 사용됩니다. .를 사용합니다. 개체에 대한 메서드를 직접 호출하는 경우 -&gt; 개체에 대한 포인터에서 메서드를 호출하고 먼저 포인터를 역참조해야 하는 경우. 즉, object가 포인터라면 object-&gt;something()은 (*object).something()과 유사하다.\nRust에는 -&gt; 연산자와 동등한 것이 없습니다. 대신 Rust에는 자동 참조 및 역참조 라는 기능이 있습니다. 메소드를 호출하는 것은 러스트에서 이러한 동작을 하는 몇 안 되는 위치 중 하나입니다.\n작동 방식은 다음과 같습니다: object.something()으로 메서드를 호출하면 Rust는 자동으로 &amp;, &amp;mut 또는 *를 추가하여 object가 메서드의 시그니처와 일치하도록 합니다. 즉, 다음은 동일합니다.\np1.distance(&amp;p2);\n(&amp;p1).distance(&amp;p2);\n\n첫 번째 것이 훨씬 깨끗해 보입니다. 이 자동 참조 동작은 메서드에 명확한 수신자(self 유형)가 있기 때문에 작동합니다. 메서드의 리시버와 이름이 주어지면 Rust는 메서드가 읽기(&amp;self)인지, 변경(&amp;mut self)인지, 소모(self)인지 확실히 파악할 수 있습니다. Rust가 메서드 리시버에 대한 차용을 암시적으로 만든다는 사실은 실제로 소유권을 인체 공학적으로 만드는 데 큰 부분을 차지합니다.\n\n매개변수가 더 많은 방법\nRectangle 구조체에 두 번째 메서드를 구현하여 메서드 사용을 연습해 봅시다. 이번에는 Rectangle의 인스턴스가 Rectangle의 다른 인스턴스를 가져오고 두 번째 Rectangle이 self(첫 번째 Rectangle)에 완전히 맞으면 true를 반환하도록 합니다. 그렇지 않으면 false를 반환해야 합니다. 즉, 일단 can_hold 메소드를 정의하면 Listing 5-14에 표시된 프로그램을 작성할 수 있기를 원합니다.\n파일 이름: src/main.rs\nfn main() {\n    let rect1 = Rectangle {\n        width: 30,\n        height: 50,\n    };\n    let rect2 = Rectangle {\n        width: 10,\n        height: 40,\n    };\n    let rect3 = Rectangle {\n        width: 60,\n        height: 45,\n    };\n\n    println!(`Can rect1 hold rect2? {}`, rect1.can_hold(&amp;rect2));\n    println!(`Can rect1 hold rect3? {}`, rect1.can_hold(&amp;rect3));\n}\n\n목록 5-14: 아직 작성되지 않은 can_hold 메서드 사용\nrect2의 두 치수가 rect1의 치수보다 작지만 rect3이 rect1보다 넓기 때문에 예상 출력은 다음과 같습니다.\nCan rect1 hold rect2? true\nCan rect1 hold rect3? false\n\n우리는 메서드를 정의하고 싶다는 것을 알고 있으므로 impl Rectangle 블록 내에 있을 것입니다. 메서드 이름은 can_hold이고 다른 Rectangle의 불변 차용을 매개변수로 사용합니다. 메서드를 호출하는 코드를 보면 매개변수의 유형이 무엇인지 알 수 있습니다. rect1.can_hold(&amp;rect2)는 &amp;rect2를 전달합니다. . 우리는 rect2를 읽기만 하면 되고(쓰기가 아닌 변경 가능한 빌림이 필요함을 의미함) main이 rect2의 소유권을 유지하여 호출 후 다시 사용할 수 있기를 원하기 때문에 이는 의미가 있습니다. can_hold방법.can_hold의 반환 값은 부울입니다. 구현 시 self의 너비와 높이가 각각 다른 Rectangle의 너비와 높이보다 큰지 여부를 확인합니다. Listing 5-15에 표시된 Listing 5-13의 impl블록에 새로운can_hold` 메소드를 추가해 보겠습니다.\n파일 이름: src/main.rs\nimpl Rectangle {\n    fn area(&amp;self) -&gt; u32 {\n        self.width * self.height\n    }\n\n    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {\n        self.width &gt; other.width &amp;&amp; self.height &gt; other.height\n    }\n}\n\nListing 5-15: 다른 Rectangle 인스턴스를 매개변수로 사용하는 Rectangle의 can_hold 메서드 구현\n목록 5-14의 main 함수로 이 코드를 실행하면 원하는 출력을 얻을 수 있습니다. 메서드는 서명에 self 매개변수 뒤에 추가하는 여러 매개변수를 사용할 수 있으며 이러한 매개변수는 함수의 매개변수처럼 작동합니다.\n관련 기능\nimpl 블록 내에서 정의된 모든 함수는 impl 다음에 이름이 지정된 유형과 연관되기 때문에 연관된 함수 라고 합니다. 작업할 유형의 인스턴스가 필요하지 않기 때문에 첫 번째 매개변수로 self가 없는(따라서 메소드가 아닌) 연관된 함수를 정의할 수 있습니다. 우리는 이미 String 유형에 정의된 String::from 함수와 같은 하나의 함수를 사용했습니다.\n메서드가 아닌 관련 함수는 구조체의 새 인스턴스를 반환하는 생성자에 자주 사용됩니다. 이들은 종종 new라고 불리지만 new는 특별한 이름이 아니며 언어에 내장되어 있지 않습니다. 예를 들어, 하나의 치수 매개변수를 갖고 너비와 높이 모두로 사용하는 square라는 관련 함수를 제공하도록 선택할 수 있으므로 동일한 값을 두 번 지정하지 않고 정사각형 Rectangle을 더 쉽게 만들 수 있습니다. :\n파일 이름: src/main.rs\nimpl Rectangle {\n    fn square(size: u32) -&gt; Self {\n        Self {\n            width: size,\n            height: size,\n        }\n    }\n}\n\n반환 유형과 함수 본문의 Self 키워드는 impl 키워드 뒤에 나타나는 유형의 별칭이며 이 경우에는 Rectangle입니다.\n이 관련 함수를 호출하려면 구조체 이름과 함께 :: 구문을 사용합니다. let sq = 직사각형::square(3); 예입니다. 이 함수는 구조체에 의해 네임스페이스가 지정됩니다. :: 구문은 관련 함수와 모듈에서 생성된 네임스페이스 모두에 사용됩니다. 7장 에서 모듈에 대해 논의할 것입니다.\n다중 impl 블록\n각 구조체는 여러 impl 블록을 가질 수 있습니다. 예를 들어, Listing 5-15는 Listing 5-16에 표시된 코드와 동일하며 각 메소드는 자체 impl 블록에 있습니다.\nimpl Rectangle {\n    fn area(&amp;self) -&gt; u32 {\n        self.width * self.height\n    }\n}\n\nimpl Rectangle {\n    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {\n        self.width &gt; other.width &amp;&amp; self.height &gt; other.height\n    }\n}\n\nListing 5-16: 여러 impl 블록을 사용하여 Listing 5-15 재작성\n여기서는 이러한 메서드를 여러 impl 블록으로 분리할 이유가 없지만 유효한 구문입니다. 제네릭 타입과 특성에 대해 논의하는 10장에서 여러 개의 impl 블록이 유용한 경우를 보게 될 것입니다.\n요약\n구조체를 사용하면 도메인에 의미 있는 사용자 지정 유형을 만들 수 있습니다. 구조체를 사용하면 연결된 데이터 조각을 서로 연결하고 각 조각의 이름을 지정하여 코드를 명확하게 만들 수 있습니다. impl 블록에서 유형과 연결된 함수를 정의할 수 있으며 메서드는 구조체 인스턴스의 동작을 지정할 수 있는 일종의 연결된 함수입니다.\n그러나 구조체가 사용자 지정 유형을 생성할 수 있는 유일한 방법은 아닙니다. Rust의 열거형 기능을 사용하여 도구 상자에 다른 도구를 추가해 보겠습니다.\n\n열거형 및 패턴 일치\n이 장에서는 열거 형 이라고도 하는 열거 형 에 대해 살펴보겠습니다. 열거형을 사용하면 가능한 변형을 열거하여 유형을 정의할 수 있습니다. 먼저 열거형을 정의하고 사용하여 열거형이 데이터와 함께 의미를 인코딩하는 방법을 보여줍니다. 다음으로 옵션이라는 특히 유용한 열거형을 살펴보겠습니다. 이 열거형은 값이 무언가가 될 수도 있고 없을 수도 있음을 나타냅니다. 그런 다음 일치 식의 패턴 일치를 통해 열거형의 서로 다른 값에 대해 서로 다른 코드를 쉽게 실행할 수 있는 방법을 살펴보겠습니다. 마지막으로 if let 구문이 코드에서 열거형을 처리하는 데 사용할 수 있는 또 다른 편리하고 간결한 관용구인 방법을 다룰 것입니다.\n\n열거형 정의\n구조체가 너비와 높이가 있는 직사각형과 같이 관련 필드와 데이터를 함께 그룹화하는 방법을 제공하는 경우 열거형은 값이 가능한 값 집합 중 하나라고 말하는 방법을 제공합니다. 예를 들어, 직사각형은 원과 삼각형을 포함하는 가능한 도형 세트 중 하나라고 말하고 싶을 수 있습니다. 이를 위해 Rust는 이러한 가능성을 열거형으로 인코딩할 수 있도록 합니다.\n코드로 표현하고 싶은 상황을 살펴보고 이 경우 열거형이 구조체보다 유용하고 더 적합한 이유를 살펴보겠습니다. IP 주소로 작업해야 한다고 가정해 보겠습니다. 현재 IP 주소에는 버전 4와 버전 6의 두 가지 주요 표준이 사용됩니다. 이것이 우리 프로그램이 접하게 될 IP 주소에 대한 유일한 가능성이기 때문에 가능한 모든 변형을 열거 할 수 있으며 여기에서 열거가 이름을 얻습니다.\n모든 IP 주소는 버전 4 또는 버전 6 주소일 수 있지만 동시에 둘 다일 수는 없습니다. IP 주소의 이러한 속성은 enum 값이 변형 중 하나일 수 있기 때문에 enum 데이터 구조를 적절하게 만듭니다. 버전 4 및 버전 6 주소는 여전히 기본적으로 IP 주소이므로 코드가 모든 종류의 IP 주소에 적용되는 상황을 처리할 때 동일한 유형으로 취급되어야 합니다.\nIpAddrKind 열거형을 정의하고 IP 주소가 될 수 있는 V4 및 V6 종류를 나열하여 이 개념을 코드로 표현할 수 있습니다. 열거형의 변형은 다음과 같습니다.\nenum IpAddrKind {\n    V4,\n    V6,\n}\n\nIpAddrKind는 이제 코드의 다른 곳에서 사용할 수 있는 사용자 정의 데이터 유형입니다.\n열거형 값\n다음과 같이 IpAddrKind의 두 변형 각각의 인스턴스를 만들 수 있습니다.\n    let four = IpAddrKind::V4;\n    let six = IpAddrKind::V6;\n\n열거형의 변형은 해당 식별자 아래에 네임스페이스가 지정되며 이중 콜론을 사용하여 둘을 구분합니다. 이것은 이제 IpAddrKind::V4 및 IpAddrKind::V6 값이 모두 IpAddrKind와 같이 동일한 유형이기 때문에 유용합니다. 그런 다음 예를 들어 IpAddrKind를 사용하는 함수를 정의할 수 있습니다.\nfn route(ip_kind: IpAddrKind) {}\n\n그리고 우리는 이 함수를 두 변형으로 호출할 수 있습니다:\n    route(IpAddrKind::V4);\n    route(IpAddrKind::V6);\n\n열거형을 사용하면 더 많은 이점이 있습니다. IP 주소 유형에 대해 더 생각해 보면 현재 실제 IP 주소 데이터를 저장할 방법이 없습니다. 우리는 그것이 어떤 종류 인지 만 알고 있습니다. 5장에서 구조체에 대해 방금 배웠다면 목록 6-1에 표시된 대로 구조체를 사용하여 이 문제를 해결하고 싶은 유혹을 느낄 수 있습니다.\n    enum IpAddrKind {\n        V4,\n        V6,\n    }\n\n    struct IpAddr {\n        kind: IpAddrKind,\n        address: String,\n    }\n\n    let home = IpAddr {\n        kind: IpAddrKind::V4,\n        address: String::from(`127.0.0.1`),\n    };\n\n    let loopback = IpAddr {\n        kind: IpAddrKind::V6,\n        address: String::from(`::1`),\n    };\n\n목록 6-1: struct를 사용하여 데이터 및 IP 주소의 IpAddrKind 변형 저장\n여기에서 IpAddrKind 유형의 kind 필드(이전에 정의한 enum)와 String 유형의 address 필드가 있는 구조체 IpAddr를 정의했습니다. 이 구조체에는 두 개의 인스턴스가 있습니다. 첫 번째는 home이며 127.0.0.1의 관련 주소 데이터와 함께 종류로 IpAddrKind::V4 값을 가집니다. 두 번째 인스턴스는 루프백입니다. 종류 값인 V6으로 IpAddrKind의 다른 변형이 있으며 이와 연결된 주소 ::1이 있습니다. 구조체를 사용하여 종류 및 주소 값을 함께 묶었으므로 이제 변형이 값과 연결됩니다.\n그러나 열거형만 사용하여 동일한 개념을 나타내는 것이 더 간결합니다. 구조체 내부의 열거형보다 데이터를 각 열거형 변형에 직접 넣을 수 있습니다. IpAddr 열거형의 이 새로운 정의는 V4 및 V6 변형 모두 연결된 문자열 값을 가질 것이라고 말합니다.\n    enum IpAddr {\n        V4(String),\n        V6(String),\n    }\n\n    let home = IpAddr::V4(String::from(`127.0.0.1`));\n\n    let loopback = IpAddr::V6(String::from(`::1`));\n\n열거형의 각 변형에 직접 데이터를 첨부하므로 추가 구조체가 필요하지 않습니다. 여기에서 열거형의 작동 방식에 대한 또 다른 세부 정보를 더 쉽게 볼 수 있습니다. 우리가 정의하는 각 열거형 변형의 이름도 열거형의 인스턴스를 구성하는 함수가 됩니다. 즉, IpAddr::V4()는 String 인수를 사용하고 IpAddr 유형의 인스턴스를 반환하는 함수 호출입니다. 열거형을 정의한 결과로 정의된 이 생성자 함수를 자동으로 얻습니다.\n구조체 대신 열거형을 사용하면 또 다른 이점이 있습니다. 각 변형에는 연결된 데이터의 유형과 양이 다를 수 있습니다. 버전 4 IP 주소에는 항상 0에서 255 사이의 값을 갖는 4개의 숫자 구성 요소가 있습니다. V4 주소를 4개의 u8 값으로 저장하고 싶지만 V6 주소를 하나의 문자열 값으로 표현하려면 구조체로는 할 수 없습니다. 열거형은 이 경우를 쉽게 처리합니다.\n    enum IpAddr {\n        V4(u8, u8, u8, u8),\n        V6(String),\n    }\n\n    let home = IpAddr::V4(127, 0, 0, 1);\n\n    let loopback = IpAddr::V6(String::from(`::1`));\n\n버전 4 및 버전 6 IP 주소를 저장하기 위해 데이터 구조를 정의하는 여러 가지 방법을 보여주었습니다. 그러나 밝혀진 바와 같이 IP 주소를 저장하고 어떤 종류인지 인코딩하려는 것은 너무 일반적이어서 표준 라이브러리에 우리가 사용할 수 있는 정의가 있습니다! 표준 라이브러리가 IpAddr을 정의하는 방법을 살펴보겠습니다. 여기에는 우리가 정의하고 사용한 정확한 열거형 및 변형이 있지만 각각에 대해 다르게 정의되는 두 개의 서로 다른 구조체의 형태로 변형 내부에 주소 데이터를 포함합니다. 변종:\nstruct Ipv4Addr {\n    // --snip--\n}\n\nstruct Ipv6Addr {\n    // --snip--\n}\n\nenum IpAddr {\n    V4(Ipv4Addr),\n    V6(Ipv6Addr),\n}\n\n이 코드는 예를 들어 문자열, 숫자 유형 또는 구조체와 같은 열거형 변형 내에 모든 종류의 데이터를 넣을 수 있음을 보여줍니다. 다른 열거형을 포함할 수도 있습니다! 또한 표준 라이브러리 유형은 종종 여러분이 생각하는 것보다 훨씬 더 복잡하지 않습니다.\n표준 라이브러리에 IpAddr에 대한 정의가 포함되어 있지만 표준 라이브러리의 정의를 범위로 가져오지 않았기 때문에 여전히 충돌 없이 자체 정의를 만들고 사용할 수 있습니다. 유형을 범위로 가져오는 방법에 대해서는 7장에서 자세히 설명합니다.\nListing 6-2에 있는 enum의 또 다른 예를 살펴보겠습니다. 이것은 변형에 다양한 유형이 내장되어 있습니다.\nenum Message {\n    Quit,\n    Move { x: i32, y: i32 },\n    Write(String),\n    ChangeColor(i32, i32, i32),\n}\n\n목록 6-2: 각각 다른 양과 유형의 값을 저장하는 변형이 있는 메시지 열거형\n이 열거형에는 유형이 다른 네 가지 변형이 있습니다.\n\n종료에는 이와 관련된 데이터가 전혀 없습니다.\n이동에는 구조체와 마찬가지로 명명된 필드가 있습니다.\n쓰기에는 단일 문자열이 포함됩니다.\nChangeColor에는 3개의 i32 값이 포함됩니다.\n\n목록 6-2에 있는 것과 같은 변형으로 열거형을 정의하는 것은 열거형이 struct 키워드를 사용하지 않고 모든 변형이 Message 유형 아래에 함께 그룹화된다는 점을 제외하면 다른 종류의 구조체 정의를 정의하는 것과 유사합니다. 다음 구조체는 이전 열거형 변형이 보유하는 것과 동일한 데이터를 보유할 수 있습니다.\nstruct QuitMessage; // unit struct\nstruct MoveMessage {\n    x: i32,\n    y: i32,\n}\nstruct WriteMessage(String); // tuple struct\nstruct ChangeColorMessage(i32, i32, i32); // tuple struct\n\n그러나 각각 고유한 유형이 있는 서로 다른 구조체를 사용하는 경우 Listing 6-2에 정의된 Message 열거형으로 할 수 있는 것처럼 이러한 종류의 메시지를 받는 함수를 쉽게 정의할 수 없습니다. 단일 유형입니다.\n열거형과 구조체 사이에는 또 다른 유사점이 있습니다. impl을 사용하여 구조체에 대한 메서드를 정의할 수 있는 것처럼 열거형에 대한 메서드도 정의할 수 있습니다. 다음은 Message 열거형에서 정의할 수 있는 call이라는 메서드입니다.\n    impl Message {\n        fn call(&amp;self) {\n            // method body would be defined here\n        }\n    }\n\n    let m = Message::Write(String::from(`hello`));\n    m.call();\n\n메서드 본문은 self를 사용하여 메서드를 호출한 값을 가져옵니다. 이 예에서 우리는 Message::Write(String::from(hello)) 값을 갖는 변수 m을 생성했으며 이것이 self가  m.call()이 실행될 때 메소드를 호출합니다.\n매우 일반적이고 유용한 표준 라이브러리의 또 다른 열거형인 Option을 살펴보겠습니다.\n옵션 열거형과 Null 값에 대한 이점\n이 섹션에서는 표준 라이브러리에서 정의한 또 다른 열거형인 Option의 사례 연구를 살펴봅니다. 옵션 유형은 값이 무언가가 될 수도 있고 아무것도 아닐 수도 있는 매우 일반적인 시나리오를 인코딩합니다.\n예를 들어 비어 있지 않은 목록의 첫 번째 항목을 요청하면 값을 받게 됩니다. 빈 목록의 첫 번째 항목을 요청하면 아무것도 얻지 못합니다. 유형 시스템 측면에서 이 개념을 표현하면 처리해야 하는 모든 사례를 처리했는지 여부를 컴파일러에서 확인할 수 있습니다. 이 기능은 다른 프로그래밍 언어에서 매우 일반적인 버그를 방지할 수 있습니다.\n프로그래밍 언어 설계는 종종 어떤 기능을 포함하는지에 따라 생각되지만 제외하는 기능도 중요합니다. Rust에는 다른 많은 언어에 있는 null 기능이 없습니다. Null 은 값이 없다는 의미의 값입니다. null이 있는 언어에서 변수는 항상 null 또는 null이 아닌 두 가지 상태 중 하나일 수 있습니다.\n2009년 프레젠테이션 Null References: The Billion Dollar Mistake에서 null의 발명가인 Tony Hoare는 다음과 같이 말했습니다.\n\n나는 그것을 나의 10억 달러짜리 실수라고 부른다. 그 당시 저는 객체 지향 언어의 참조를 위한 최초의 포괄적인 유형 시스템을 설계하고 있었습니다. 내 목표는 컴파일러가 자동으로 검사를 수행하여 모든 참조 사용이 절대적으로 안전하도록 하는 것이었습니다. 하지만 구현하기가 너무 쉽기 때문에 null 참조를 넣고 싶은 유혹을 뿌리칠 수 없었습니다. 이로 인해 수많은 오류, 취약성 및 시스템 충돌이 발생했으며 지난 40년 동안 아마도 10억 달러의 고통과 피해를 입혔을 것입니다.\n\nnull 값의 문제는 null 값을 null이 아닌 값으로 사용하려고 하면 일종의 오류가 발생한다는 것입니다. 이 null 또는 null이 아닌 속성은 널리 퍼져 있기 때문에 이러한 종류의 오류를 만들기가 매우 쉽습니다.\n그러나 null이 표현하려는 개념은 여전히 유용합니다. null은 현재 유효하지 않거나 어떤 이유로 없는 값입니다.\n문제는 실제로 개념이 아니라 특정 구현에 있습니다. 따라서 Rust에는 null이 없지만 존재하거나 존재하지 않는 값의 개념을 인코딩할 수 있는 열거형이 있습니다. 이 열거형은 옵션이며 표준 라이브러리에 의해 다음과 같이 정의됩니다.\nenum Option&lt;T&gt; {\n    None,\n    Some(T),\n}\n\n옵션 열거형은 너무 유용해서 서문에 포함되어 있습니다. 명시적으로 범위로 가져올 필요가 없습니다. 해당 변형도 서문에 포함되어 있습니다. 옵션: 없이 Some 및 None을 직접 사용할 수 있습니다. :접두어입니다.옵션열거형은 여전히 일반 열거형이며Some(T)및None은 여전히 Option 유형의 변형입니다..\n구문은 우리가 아직 이야기하지 않은 Rust의 기능입니다. 제네릭 유형 매개변수이며, 제네릭에 대해서는 10장에서 자세히 다룰 것입니다. 지금은는 Option 열거형의 Some 변형이 모든 유형의 데이터 한 조각을 보유할 수 있으며 T 대신 사용되는 각 구체적인 유형이 전체 Option을 만든다는 것을 의미합니다.다른 유형을 입력하십시오. 다음은옵션` 값을 사용하여 숫자 유형과 문자열 유형을 보유하는 몇 가지 예입니다.\n    let some_number = Some(5);\n    let some_char = Some('e');\n\n    let absent_number: Option&lt;i32&gt; = None;\n\nsome_number의 타입은 Option입니다.. some_char의 유형은 Option, 이는 다른 유형입니다. Some변형 내부에 값을 지정했기 때문에 Rust는 이러한 유형을 추론할 수 있습니다.absent_number의 경우 Rust는 전체 Option유형에 주석을 달도록 요구합니다. 컴파일러는 추론할 수 없습니다. 해당Some변종이None값만 보고 보유할 유형 여기서 우리는absent_number가 Option 유형임을 의미한다고 Rust에 알립니다..\n일부 값이 있을 때 값이 존재하고 그 값이 일부 내에 있음을 알 수 있습니다. None 값이 있는 경우 어떤 의미에서는 null과 같은 의미입니다. 즉, 유효한 값이 없습니다. 그렇다면 왜 옵션 null을 갖는 것보다 낫습니까?\n요컨대, 옵션와 T(여기서 T는 모든 유형일 수 있음)가 서로 다른 유형이므로 컴파일러는 옵션을 사용하도록 허용하지 않습니다.값이 확실히 유효한 값인 것처럼. 예를 들어 이 코드는i8을 Option에 추가하려고 하기 때문에 컴파일되지 않습니다.:\n    let x: i8 = 5;\n    let y: Option&lt;i8&gt; = Some(5);\n\n    let sum = x + y;\n\n이 코드를 실행하면 다음과 같은 오류 메시지가 나타납니다.\n$ cargo run\n   Compiling enums v0.1.0 (file:///projects/enums)\nerror[E0277]: cannot add `Option&lt;i8&gt;` to `i8`\n --&gt; src/main.rs:5:17\n  |\n5 |     let sum = x + y;\n  |                 ^ no implementation for `i8 + Option&lt;i8&gt;`\n  |\n  = help: the trait `Add&lt;Option&lt;i8&gt;&gt;` is not implemented for `i8`\n  = help: the following other types implement trait `Add&lt;Rhs&gt;`:\n            &lt;&amp;'a i8 as Add&lt;i8&gt;&gt;\n            &lt;&amp;i8 as Add&lt;&amp;i8&gt;&gt;\n            &lt;i8 as Add&lt;&amp;i8&gt;&gt;\n            &lt;i8 as Add&gt;\n\nFor more information about this error, try `rustc --explain E0277`.\nerror: could not compile `enums` due to previous error\n\n극심한! 사실상 이 오류 메시지는 Rust가 i8과 옵션을 추가하는 방법을 이해하지 못한다는 것을 의미합니다.서로 다른 유형이기 때문입니다. Rust에서 i8과 같은 유형의 값이 있을 때 컴파일러는 항상 유효한 값을 가지고 있는지 확인합니다. 해당 값을 사용하기 전에 null을 확인하지 않고도 자신 있게 진행할 수 있습니다. . 옵션이 있는 경우에만(또는 우리가 작업 중인 어떤 유형의 값이든) 값이 없을 가능성에 대해 걱정해야 하며 컴파일러는 값을 사용하기 전에 해당 사례를 처리하는지 확인합니다.\n즉, 옵션을 변환해야 합니다.T 작업을 수행하기 전에 T로. 일반적으로 이것은 null과 관련된 가장 일반적인 문제 중 하나를 파악하는 데 도움이 됩니다. 실제로는 null이 아니지만 null이 아니라고 가정합니다.\nnull이 아닌 값을 잘못 가정하는 위험을 제거하면 코드에 대한 확신을 가질 수 있습니다. null일 수 있는 값을 가지려면 해당 값의 유형을 옵션으로 만들어 명시적으로 옵트인해야 합니다.. 그런 다음 해당 값을 사용할 때 값이 null인 경우를 명시적으로 처리해야 합니다. 값이 옵션이 아닌 유형을 갖는 모든 위치`, 값이 null이 아니라고 안전하게 가정할 수 있습니다. 이는 Rust가 null의 보급을 제한하고 Rust 코드의 안전성을 높이기 위한 의도적인 설계 결정이었습니다.\n따라서 Option 유형의 값이 있을 때 Some 변형에서 T 값을 어떻게 얻습니까?그 값을 사용할 수 있도록?옵션[enum에는 다양한 상황에서 유용한 많은 메서드가 있습니다. 설명서](https://doc.rust-lang.org/std/option/enum.Option.html) 에서 확인할 수 있습니다.옵션의 메서드에 익숙해지기`는 Rust와의 여정에 매우 유용할 것입니다.\n일반적으로 옵션을 사용하기 위해서는값, 각 변형을 처리할 코드가 필요합니다.Some(T)값이 있을 때만 실행되는 일부 코드가 필요하며 이 코드는 내부T를 사용할 수 있습니다. 일부를 원합니다. 없음값이 있고 해당 코드에 사용 가능한T값이 없는 경우에만 실행할 다른 코드일치` 식은 열거형과 함께 사용할 때 바로 이 작업을 수행하는 제어 흐름 구조입니다. 가지고 있는 열거형의 변형에 따라 다른 코드이며 해당 코드는 일치하는 값 내부의 데이터를 사용할 수 있습니다.\n\n일치 제어 흐름 구성\nRust에는 일련의 패턴과 값을 비교한 다음 어떤 패턴이 일치하는지에 따라 코드를 실행할 수 있는 일치라는 매우 강력한 제어 흐름 구조가 있습니다. 패턴은 리터럴 값, 변수 이름, 와일드카드 및 기타 여러 항목으로 구성될 수 있습니다. 18장에서는 모든 종류의 패턴과 그 기능을 다룹니다. 일치의 힘은 패턴의 표현력과 컴파일러가 가능한 모든 사례가 처리되었음을 확인한다는 사실에서 비롯됩니다.\n일치 표현을 동전 분류 기계와 같다고 생각하십시오. 동전은 다양한 크기의 구멍이 있는 트랙을 따라 미끄러져 내려오고 각 동전은 맞는 첫 번째 구멍을 통해 떨어집니다. 같은 방식으로 값은 일치의 각 패턴을 통과하고 첫 번째 패턴에서 값이 적합하고 실행 중에 사용되는 관련 코드 블록에 값이 떨어집니다.\n동전이라고 하면 일치를 사용하여 예를 들어 보겠습니다! Listing 6-3과 같이 미지의 미국 동전을 가져와 계수기와 유사한 방식으로 어떤 동전인지 결정하고 그 값을 센트 단위로 반환하는 함수를 작성할 수 있습니다.\nenum Coin {\n    Penny,\n    Nickel,\n    Dime,\n    Quarter,\n}\n\nfn value_in_cents(coin: Coin) -&gt; u8 {\n    match coin {\n        Coin::Penny =&gt; 1,\n        Coin::Nickel =&gt; 5,\n        Coin::Dime =&gt; 10,\n        Coin::Quarter =&gt; 25,\n    }\n}\n\n목록 6-3: 열거형 및 열거형의 변형을 패턴으로 갖는 일치 식\nvalue_in_cents 함수에서 일치를 분석해 보겠습니다. 먼저 match 키워드와 표현식을 나열합니다. 이 경우 값은 coin입니다. 이것은 if와 함께 사용되는 조건식과 매우 유사해 보이지만 큰 차이점이 있습니다. if를 사용하면 조건이 부울 값으로 평가되어야 하지만 여기서는 모든 유형이 될 수 있습니다. 이 예제에서 coin의 유형은 첫 번째 줄에서 정의한 Coin 열거형입니다.\n다음은 일치 암입니다. 팔은 패턴과 일부 코드의 두 부분으로 구성됩니다. 여기에서 첫 번째 팔에는 Coin::Penny 값인 패턴이 있고 패턴과 실행할 코드를 구분하는 =&gt; 연산자가 있습니다. 이 경우 코드는 값 1일 뿐입니다. 각 팔은 쉼표로 다음 팔과 구분됩니다.\n일치 표현식이 실행되면 결과 값을 각 팔의 패턴과 순서대로 비교합니다. 패턴이 값과 일치하면 해당 패턴과 연결된 코드가 실행됩니다. 해당 패턴이 값과 일치하지 않으면 동전 분류기에서와 같이 실행이 다음 팔로 계속됩니다. 우리는 필요한 만큼 많은 팔을 가질 수 있습니다: Listing 6-3에서 일치에는 4개의 팔이 있습니다.\n각 암과 연관된 코드는 식이며 일치하는 암에서 식의 결과 값은 전체 일치 식에 대해 반환되는 값입니다.\n매치 암 코드가 짧으면 일반적으로 중괄호를 사용하지 않습니다. Listing 6-3에서 각 암은 값을 반환합니다. 매치 암에서 여러 줄의 코드를 실행하려면 중괄호를 사용해야 하며 암 다음에 오는 쉼표는 선택 사항입니다. 예를 들어 다음 코드는 Lucky penny!를 인쇄합니다. 메서드가 Coin::Penny로 호출될 때마다 블록의 마지막 값인 1을 반환합니다.\nfn value_in_cents(coin: Coin) -&gt; u8 {\n    match coin {\n        Coin::Penny =&gt; {\n            println!(`Lucky penny!`);\n            1\n        }\n        Coin::Nickel =&gt; 5,\n        Coin::Dime =&gt; 10,\n        Coin::Quarter =&gt; 25,\n    }\n}\n\n값에 바인딩되는 패턴\n일치 암의 또 다른 유용한 기능은 패턴과 일치하는 값 부분에 바인딩할 수 있다는 것입니다. 열거형 변형에서 값을 추출할 수 있는 방법입니다.\n예를 들어 열거형 변형 중 하나를 변경하여 내부에 데이터를 보관하도록 하겠습니다. 1999년부터 2008년까지 미국은 한 면에 50개 주마다 다른 디자인의 쿼터를 주조했습니다. 다른 주화에는 주 디자인이 없으므로 분기에만 이 추가 가치가 있습니다. Listing 6-4에서 수행한 것처럼 내부에 저장된 UsState 값을 포함하도록 Quarter 변형을 변경하여 이 정보를 enum에 추가할 수 있습니다.\n#[derive(Debug)] // so we can inspect the state in a minute\nenum UsState {\n    Alabama,\n    Alaska,\n    // --snip--\n}\n\nenum Coin {\n    Penny,\n    Nickel,\n    Dime,\n    Quarter(UsState),\n}\n\n목록 6-4: Quarter 변형이 UsState 값도 포함하는 Coin 열거형\n친구가 50개의 주 쿼터를 모두 수집하려고 한다고 상상해 봅시다. 동전 유형별로 느슨한 거스름돈을 정렬하는 동안 각 분기와 관련된 주 이름을 불러서 친구가 가지고 있지 않은 것이 있으면 컬렉션에 추가할 수 있습니다.\n이 코드의 일치 표현식에서 변형 Coin::Quarter의 값과 일치하는 패턴에 state라는 변수를 추가합니다. Coin::Quarter가 일치하면 state 변수는 해당 분기의 상태 값에 바인딩됩니다. 그런 다음 해당 팔의 코드에서 다음과 같이 상태를 사용할 수 있습니다.\nfn value_in_cents(coin: Coin) -&gt; u8 {\n    match coin {\n        Coin::Penny =&gt; 1,\n        Coin::Nickel =&gt; 5,\n        Coin::Dime =&gt; 10,\n        Coin::Quarter(state) =&gt; {\n            println!(`State quarter from {:?}!`, state);\n            25\n        }\n    }\n}\n\nvalue_in_cents(Coin::Quarter(UsState::Alaska))를 호출하면 coin은 Coin::Quarter(UsState::Alaska)가 됩니다. 해당 값을 각 일치 부문과 비교할 때 Coin::Quarter(state)에 도달할 때까지 일치하는 항목이 없습니다. 이 시점에서 state에 대한 바인딩은 UsState::Alaska 값이 됩니다. 그런 다음 println!에서 해당 바인딩을 사용할 수 있습니다. Quarter에 대한 Coin 열거형 변형에서 내부 상태 값을 가져옵니다.\n옵션과 일치\n이전 섹션에서 Option을 사용할 때 Some 케이스에서 내부 T 값을 가져오고 싶었습니다.; 옵션을 처리할 수도 있습니다. Coin열거형과 마찬가지로match를 사용합니다! 동전을 비교하는 대신 Option의 변형을 비교하겠습니다.이지만 일치` 표현식이 작동하는 방식은 동일하게 유지됩니다.\n옵션을 받는 함수를 작성하고 싶다고 가정해 보겠습니다.내부에 값이 있으면 해당 값에 1을 더합니다. 내부에 값이 없으면 함수는없음` 값을 반환하고 어떤 작업도 수행하지 않아야 합니다.\n이 함수는 match 덕분에 작성하기가 매우 쉽고 Listing 6-5와 같습니다.\n    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {\n        match x {\n            None =&gt; None,\n            Some(i) =&gt; Some(i + 1),\n        }\n    }\n\n    let five = Some(5);\n    let six = plus_one(five);\n    let none = plus_one(None);\n\n목록 6-5: 옵션에 일치 표현식을 사용하는 함수`\nplus_one의 첫 번째 실행을 자세히 살펴보겠습니다. plus_one(five)를 호출하면 plus_one 본문의 변수 x는 Some(5) 값을 갖게 됩니다. 그런 다음 이를 각 매치 부문과 비교합니다.\n            None =&gt; None,\n\nSome(5) 값은 패턴 None과 일치하지 않으므로 다음 단계로 계속 진행합니다.\n            Some(i) =&gt; Some(i + 1),\n\nSome(5)는 Some(i)와 일치합니까? 그렇습니다! 동일한 변형이 있습니다. i는 Some에 포함된 값에 바인딩되므로 i는 값 5를 사용합니다. 그런 다음 매치 암의 코드가 실행되므로 i 값에 1을 더하고 총 6이 포함된 새로운 Some 값을 생성합니다.\n이제 Listing 6-5에서 x가 None인 plus_one의 두 번째 호출을 살펴보겠습니다. 일치를 입력하고 첫 번째 팔과 비교합니다.\n            None =&gt; None,\n\n일치합니다! 추가할 값이 없으므로 프로그램이 중지되고 =&gt; 오른쪽에 None 값이 반환됩니다. 첫 번째 팔이 일치했기 때문에 다른 팔은 비교되지 않습니다.\n일치와 열거형을 결합하면 많은 상황에서 유용합니다. Rust 코드에서 이 패턴을 많이 볼 수 있습니다. 열거형과 일치하고 변수를 내부 데이터에 바인딩한 다음 이를 기반으로 코드를 실행합니다. 처음에는 조금 까다롭지만 익숙해지면 모든 언어로 제공되기를 바랄 것입니다. 지속적으로 사용자가 선호하는 제품입니다.\n일치는 철저합니다\n우리가 논의해야 할 일치의 또 다른 측면이 있습니다. 팔의 패턴은 모든 가능성을 커버해야 합니다. 버그가 있고 컴파일되지 않는 plus_one 함수의 이 버전을 고려하십시오.\n    fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {\n        match x {\n            Some(i) =&gt; Some(i + 1),\n        }\n    }\n\n우리는 없음 사례를 처리하지 않았으므로 이 코드는 버그를 일으킬 것입니다. 운 좋게도 Rust가 잡는 방법을 알고 있는 버그입니다. 이 코드를 컴파일하려고 하면 다음 오류가 발생합니다.\n$ cargo run\n   Compiling enums v0.1.0 (file:///projects/enums)\nerror[E0004]: non-exhaustive patterns: `None` not covered\n --&gt; src/main.rs:3:15\n  |\n3 |         match x {\n  |               ^ pattern `None` not covered\n  |\nnote: `Option&lt;i32&gt;` defined here\n --&gt; /rustc/d5a82bbd26e1ad8b7401f6a718a9c57c96905483/library/core/src/option.rs:518:1\n  |\n  = note: \n/rustc/d5a82bbd26e1ad8b7401f6a718a9c57c96905483/library/core/src/option.rs:522:5: not covered\n  = note: the matched value is of type `Option&lt;i32&gt;`\nhelp: ensure that all possible cases are being handled by adding a match arm with a wildcard pattern or an explicit pattern as shown\n  |\n4 ~             Some(i) =&gt; Some(i + 1),\n5 ~             None =&gt; todo!(),\n  |\n\nFor more information about this error, try `rustc --explain E0004`.\nerror: could not compile `enums` due to previous error\n\nRust는 우리가 모든 가능한 경우를 다루지 않았다는 것과 우리가 어떤 패턴을 잊어버렸는지 알고 있습니다! Rust의 일치는 철저 합니다. 코드가 유효하려면 마지막 가능성을 모두 소진해야 합니다. 특히 옵션의 경우, Rust는 우리가 없음` 사례를 명시적으로 처리하는 것을 잊는 것을 방지할 때 null이 있을 수 있는 값을 가지고 있다고 가정하는 것을 방지하여 앞에서 논의한 수십억 달러의 실수를 불가능하게 만듭니다.\n범용 패턴 및 _ 자리 표시자\n열거형을 사용하면 몇 가지 특정 값에 대해 특별한 작업을 수행할 수도 있지만 다른 모든 값에 대해서는 하나의 기본 작업을 수행합니다. 주사위 굴림에서 3을 굴리면 플레이어가 움직이지 않고 대신 새 멋진 모자를 받는 게임을 구현한다고 상상해 보십시오. 7이 나오면 플레이어는 멋진 모자를 잃습니다. 다른 모든 값의 경우 플레이어는 게임 보드에서 해당 수의 공간을 이동합니다. 다음은 임의의 값이 아닌 하드코딩된 주사위 굴림의 결과와 본문이 없는 함수로 표현되는 다른 모든 논리를 사용하여 논리를 구현하는 일치입니다. 왜냐하면 실제로 구현하는 것은 이 예제의 범위를 벗어나기 때문입니다.\n    let dice_roll = 9;\n    match dice_roll {\n        3 =&gt; add_fancy_hat(),\n        7 =&gt; remove_fancy_hat(),\n        other =&gt; move_player(other),\n    }\n\n    fn add_fancy_hat() {}\n    fn remove_fancy_hat() {}\n    fn move_player(num_spaces: u8) {}\n\n처음 두 팔의 경우 패턴은 리터럴 값 3 및 7입니다. 다른 모든 가능한 값을 포함하는 마지막 팔의 경우 패턴은 기타라는 이름을 지정하기 위해 선택한 변수입니다. 기타 암에 대해 실행되는 코드는 변수를 move_player 함수에 전달하여 사용합니다.\n이 코드는 u8이 가질 수 있는 모든 가능한 값을 나열하지 않았지만 마지막 패턴이 구체적으로 나열되지 않은 모든 값과 일치하기 때문에 컴파일됩니다. 이 범용 패턴은 일치가 철저해야 한다는 요구 사항을 충족합니다. 패턴이 순서대로 평가되기 때문에 포괄적인 팔을 마지막에 두어야 합니다. catch-all arm을 더 일찍 넣으면 다른 arm은 실행되지 않으므로, catch-all 후에 arm을 추가하면 Rust가 경고합니다!\nRust는 또한 포괄적인 것을 원하지만 포괄적인 패턴의 값을 사용하고 싶지 않을 때 사용할 수 있는 패턴이 있습니다. _는 모든 값과 일치하고 해당 값에 바인딩되지 않는 특수 패턴입니다. 이는 Rust에게 우리가 그 값을 사용하지 않을 것임을 알려주므로 Rust는 사용하지 않는 변수에 대해 경고하지 않습니다.\n게임의 규칙을 변경해 보겠습니다. 이제 3이나 7이 아닌 다른 것을 굴리면 다시 굴려야 합니다. 더 이상 범용 값을 사용할 필요가 없으므로 other라는 변수 대신 _를 사용하도록 코드를 변경할 수 있습니다.\n    let dice_roll = 9;\n    match dice_roll {\n        3 =&gt; add_fancy_hat(),\n        7 =&gt; remove_fancy_hat(),\n        _ =&gt; reroll(),\n    }\n\n    fn add_fancy_hat() {}\n    fn remove_fancy_hat() {}\n    fn reroll() {}\n\n이 예제는 또한 마지막 팔의 다른 모든 값을 명시적으로 무시하기 때문에 완전성 요구 사항을 충족합니다. 우리는 아무것도 잊지 않았습니다.\n마지막으로 게임의 규칙을 한 번 더 변경하여 3이나 7 이외의 것을 굴려도 자신의 차례에 아무 일도 일어나지 않도록 하겠습니다. 튜플 유형 섹션 에서 ) _ 팔과 함께 가는 코드:\n    let dice_roll = 9;\n    match dice_roll {\n        3 =&gt; add_fancy_hat(),\n        7 =&gt; remove_fancy_hat(),\n        _ =&gt; (),\n    }\n\n    fn add_fancy_hat() {}\n    fn remove_fancy_hat() {}\n\n여기에서 우리는 명시적으로 이전 버전의 패턴과 일치하지 않는 다른 값을 사용하지 않을 것이며 이 경우 어떤 코드도 실행하고 싶지 않다고 명시적으로 말하고 있습니다.\n패턴과 일치에 대한 자세한 내용은 18장 에서 다룰 것입니다. 지금은 일치 표현이 다소 장황한 상황에서 유용할 수 있는 if let 구문으로 넘어갈 것입니다.\n\nif let을 사용한 간결한 제어 흐름\nif let 구문을 사용하면 if와 let을 덜 장황한 방식으로 결합하여 나머지 패턴은 무시하면서 하나의 패턴과 일치하는 값을 처리할 수 있습니다. Listing 6-6에서 옵션에 일치하는 프로그램을 고려하십시오. config_max변수의 값이지만 값이Some` 변형인 경우에만 코드를 실행하려고 합니다.\n    let config_max = Some(3u8);\n    match config_max {\n        Some(max) =&gt; println!(`The maximum is configured to be {}`, max),\n        _ =&gt; (),\n    }\n\n목록 6-6: 값이 Some인 경우에만 코드 실행에 관심이 있는 일치\n값이 Some이면 패턴의 변수 max에 값을 바인딩하여 Some 변형의 값을 출력합니다. 우리는 None 값으로 아무 것도 하고 싶지 않습니다. 일치 표현을 만족시키려면 하나의 변형만 처리한 후 _ =&gt; ()를 추가해야 하는데, 이는 추가하기 귀찮은 상용구 코드입니다.\n대신 if let을 사용하여 더 짧게 작성할 수 있습니다. 다음 코드는 목록 6-6의 일치와 동일하게 작동합니다.\n    let config_max = Some(3u8);\n    if let Some(max) = config_max {\n        println!(`The maximum is configured to be {}`, max);\n    }\n\nif let 구문은 패턴과 등호로 구분된 표현식을 사용합니다. 이것은 일치와 같은 방식으로 작동하며, 일치에 표현이 주어지고 패턴이 첫 번째 암입니다. 이 경우 패턴은 Some(max)이고 max는 Some 내부의 값에 바인딩됩니다. 그런 다음 해당 match 팔에서 max를 사용한 것과 같은 방식으로 if let 블록의 본문에서 max를 사용할 수 있습니다. 값이 패턴과 일치하지 않으면 if let 블록의 코드가 실행되지 않습니다.\nif let을 사용하면 타이핑, 들여쓰기, 상용구 코드가 줄어듭니다. 그러나 일치가 시행하는 철저한 검사를 잃게 됩니다. match와 if let 중에서 선택하는 것은 특정 상황에서 수행하는 작업과 간결함을 얻는 것이 철저한 확인을 잃는 것에 대한 적절한 절충안인지 여부에 따라 다릅니다.\n즉, 값이 하나의 패턴과 일치할 때 코드를 실행한 다음 다른 모든 값을 무시하는 일치에 대한 구문 설탕으로 if let을 생각할 수 있습니다.\nif let과 함께 else를 포함할 수 있습니다. else와 함께 사용되는 코드 블록은 if let 및 else와 동일한 match 표현식에서 _ 케이스와 함께 사용되는 코드 블록과 동일합니다. Listing 6-4에서 Quarter 변형이 UsState 값을 포함하는 Coin 열거형 정의를 상기하십시오. 분기 상태를 알리는 동시에 우리가 보는 모든 비 분기 동전을 세고 싶다면 다음과 같이 일치 표현식을 사용하여 계산할 수 있습니다.\n    let mut count = 0;\n    match coin {\n        Coin::Quarter(state) =&gt; println!(`State quarter from {:?}!`, state),\n        _ =&gt; count += 1,\n    }\n\n또는 다음과 같이 if let 및 else 표현식을 사용할 수 있습니다.\n    let mut count = 0;\n    if let Coin::Quarter(state) = coin {\n        println!(`State quarter from {:?}!`, state);\n    } else {\n        count += 1;\n    }\n\n프로그램에 일치를 사용하여 표현하기에는 너무 장황한 논리가 있는 상황이 있는 경우 if let도 Rust 도구 상자에 있음을 기억하십시오.\n요약\n이제 열거형을 사용하여 열거된 값 세트 중 하나가 될 수 있는 사용자 정의 유형을 만드는 방법을 다루었습니다. 우리는 표준 라이브러리의 옵션 type은 유형 시스템을 사용하여 오류를 방지하는 데 도움이 됩니다. enum 값에 데이터가 있는 경우 처리해야 하는 사례 수에 따라 match 또는 if let을 사용하여 해당 값을 추출하고 사용할 수 있습니다.\nRust 프로그램은 이제 구조체와 열거형을 사용하여 도메인의 개념을 표현할 수 있습니다. API에서 사용할 사용자 정의 유형을 생성하면 유형 안전성이 보장됩니다. 컴파일러는 특정 함수가 각 함수가 기대하는 유형의 값만 얻도록 합니다.\n사용자에게 사용하기 쉽고 사용자에게 필요한 것만 정확하게 노출하는 잘 구성된 API를 사용자에게 제공하기 위해 이제 Rust의 모듈을 살펴보겠습니다.\n\n패키지, 크레이트 및 모듈로 성장하는 프로젝트 관리\n대규모 프로그램을 작성할 때 코드 구성이 점점 더 중요해집니다. 관련 기능을 그룹화하고 고유한 기능으로 코드를 분리하면 특정 기능을 구현하는 코드를 찾을 위치와 기능 작동 방식을 변경하기 위해 이동해야 하는 위치를 명확히 할 수 있습니다.\n지금까지 우리가 작성한 프로그램은 하나의 파일에 하나의 모듈에 있었습니다. 프로젝트가 커짐에 따라 코드를 여러 모듈로 분할한 다음 여러 파일로 분할하여 구성해야 합니다. 패키지는 여러 바이너리 크레이트와 선택적으로 하나의 라이브러리 크레이트를 포함할 수 있습니다. 패키지가 커짐에 따라 외부 종속성이 되는 별도의 크레이트로 부품을 추출할 수 있습니다. 이 장에서는 이러한 모든 기술을 다룹니다. 함께 발전하는 상호 관련된 일련의 패키지로 구성된 대규모 프로젝트의 경우 Cargo는 작업 공간을 제공하며 이에 대해서는 14장의 Cargo 작업 공간 섹션 에서 다룰 것입니다.\n또한 구현 세부 사항을 캡슐화하여 더 높은 수준에서 코드를 재사용할 수 있도록 합니다. 작업을 구현하면 다른 코드가 구현 작동 방식을 알 필요 없이 공용 인터페이스를 통해 코드를 호출할 수 있습니다. 코드를 작성하는 방식에 따라 다른 코드에서 사용할 수 있도록 공개되는 부분과 변경 권한이 있는 개인 구현 세부 정보인 부분이 정의됩니다. 이것은 머리 속에 간직해야 하는 세부 사항의 양을 제한하는 또 다른 방법입니다.\n관련 개념은 범위입니다. 코드가 작성되는 중첩 컨텍스트에는 범위 내로 정의되는 일련의 이름이 있습니다. 코드를 읽고 쓰고 컴파일할 때 프로그래머와 컴파일러는 특정 지점의 특정 이름이 변수, 함수, 구조체, 열거형, 모듈, 상수 또는 기타 항목을 참조하는지 여부와 해당 항목이 무엇을 의미하는지 알아야 합니다. 범위를 생성하고 범위에 포함되거나 포함되지 않는 이름을 변경할 수 있습니다. 동일한 범위에 동일한 이름을 가진 두 개의 항목이 있을 수 없습니다. 이름 충돌을 해결하기 위한 도구를 사용할 수 있습니다.\nRust에는 어떤 세부 정보가 노출되고 어떤 세부 정보가 비공개인지, 프로그램의 각 범위에 어떤 이름이 있는지 등 코드 구성을 관리할 수 있는 여러 기능이 있습니다. 모듈 시스템 이라고도 통칭하는 이러한 기능에는 다음이 포함됩니다.\n\n패키지: 상자 를 만들고 테스트하고 공유할 수 있는 Cargo 기능\n상자: 라이브러리 또는 실행 파일을 생성하는 모듈 트리\n모듈 및 사용: 경로의 구성, 범위 및 개인정보 보호를 제어할 수 있습니다.\n경로: 구조체, 함수 또는 모듈과 같은 항목의 이름을 지정하는 방법\n\n이 장에서는 이러한 모든 기능을 다루고, 상호 작용하는 방법에 대해 설명하고, 범위를 관리하는 데 사용하는 방법을 설명합니다. 마지막에는 모듈 시스템에 대한 확실한 이해가 있어야 하며 프로처럼 스코프를 다룰 수 있어야 합니다!\n\n패키지 및 크레이트\n우리가 다룰 모듈 시스템의 첫 번째 부분은 패키지와 크레이트입니다.\n크레이트 는 Rust 컴파일러가 한 번에 고려하는 가장 작은 양의 코드입니다. cargo 대신 rustc를 실행하고 단일 소스 코드 파일을 전달하더라도(1장의 Rust 프로그램 작성 및 실행 섹션에서 끝까지 수행한 것처럼) 컴파일러는 해당 파일을 다음과 같이 간주합니다. 상자. 크레이트는 모듈을 포함할 수 있으며 모듈은 크레이트와 함께 컴파일되는 다른 파일에서 정의될 수 있습니다. 다음 섹션에서 살펴보겠습니다.\n크레이트는 바이너리 크레이트 또는 라이브러리 크레이트의 두 가지 형태 중 하나로 올 수 있습니다. 바이너리 크레이트는 명령줄 프로그램이나 서버와 같이 실행할 수 있는 실행 파일로 컴파일할 수 있는 프로그램입니다. 각각에는 실행 파일이 실행될 때 발생하는 일을 정의하는 main이라는 함수가 있어야 합니다. 지금까지 우리가 만든 모든 크레이트는 바이너리 크레이트였습니다.\n라이브러리 크레이트에는 메인 기능이 없으며 실행 파일로 컴파일되지 않습니다. 대신 여러 프로젝트와 공유할 기능을 정의합니다. 예를 들어 2장 에서 사용한 rand 크레이트는 난수를 생성하는 기능을 제공합니다. Rustaceans가 크레이트라고 말하는 대부분의 경우 라이브러리 크레이트를 의미하며 라이브러리의 일반적인 프로그래밍 개념과 상호 교환적으로 크레이트를 사용합니다.\n크레이트 루트는 Rust 컴파일러 가 시작하고 크레이트의 루트 모듈을 구성하는 소스 파일입니다.\n패키지 는 일련의 기능을 제공하는 하나 이상의 상자 묶음입니다. 패키지에는 이러한 상자를 만드는 방법을 설명하는 Cargo.toml 파일이 포함되어 있습니다. Cargo는 실제로 코드를 빌드하는 데 사용했던 명령줄 도구용 바이너리 크레이트를 포함하는 패키지입니다. Cargo 패키지에는 바이너리 크레이트가 의존하는 라이브러리 크레이트도 포함되어 있습니다. 다른 프로젝트는 Cargo 명령줄 도구가 사용하는 것과 동일한 논리를 사용하기 위해 Cargo 라이브러리 크레이트에 의존할 수 있습니다.\n패키지는 원하는 만큼 많은 바이너리 크레이트를 포함할 수 있지만 최대 하나의 라이브러리 크레이트만 포함할 수 있습니다. 패키지는 라이브러리든 바이너리 크레이트든 적어도 하나의 크레이트를 포함해야 합니다.\n패키지를 만들 때 어떤 일이 발생하는지 살펴보겠습니다. 먼저 cargo new 명령을 입력합니다.\n$ cargo new my-project\n     Created binary (application) `my-project` package\n$ ls my-project\nCargo.toml\nsrc\n$ ls my-project/src\nmain.rs\n\ncargo new를 실행한 후 ls를 사용하여 Cargo가 생성하는 것을 확인합니다. 프로젝트 디렉토리에는 패키지를 제공하는 Cargo.toml 파일이 있습니다. main.rs를 포함하는 src 디렉토리 도 있습니다. 텍스트 편집기에서 Cargo.toml을 열고 src/main.rs 에 대한 언급이 없음에 유의하십시오 . Cargo는 src/main.rs가 패키지와 같은 이름을 가진 바이너리 크레이트의 크레이트 루트라는 규칙을 따릅니다. 마찬가지로 Cargo는 패키지 디렉토리에 src/lib.rs가 포함되어 있으면 패키지에 패키지와 동일한 이름의 라이브러리 크레이트가 포함되어 있고 *src/lib.rs가 포함되어 있음을 알고 있습니다.*상자 루트입니다. Cargo는 크레이트 루트 파일을 rustc에 전달하여 라이브러리 또는 바이너리를 빌드합니다.\n여기에는 src/main.rs 만 포함하는 패키지가 있습니다. 즉, my-project라는 이름의 바이너리 크레이트만 포함되어 있습니다. 패키지에 src/main.rs 및 src/lib.rs 가 포함되어 있으면 패키지와 동일한 이름을 가진 바이너리와 라이브러리라는 두 개의 크레이트가 있습니다. 패키지는 src/bin 디렉토리에 파일을 배치하여 여러 바이너리 크레이트를 가질 수 있습니다. 각 파일은 별도의 바이너리 크레이트가 됩니다.\n\n범위 및 프라이버시를 제어하기 위한 모듈 정의\n이 섹션에서는 모듈과 모듈 시스템의 다른 부분, 즉 항목 이름을 지정할 수 있는 경로 에 대해 설명합니다. 경로를 범위로 가져오는 use 키워드; 항목을 공개하기 위한 pub 키워드. 또한 as 키워드, 외부 패키지 및 glob 연산자에 대해서도 설명합니다.\n먼저 나중에 코드를 구성할 때 쉽게 참조할 수 있도록 규칙 목록부터 시작하겠습니다. 그러면 각 규칙에 대해 자세히 설명하겠습니다.\n모듈 치트 시트\n여기에서는 모듈, 경로, use 키워드 및 pub 키워드가 컴파일러에서 작동하는 방법과 대부분의 개발자가 코드를 구성하는 방법에 대한 빠른 참조를 제공합니다. 우리는 이 장 전체에서 이러한 각 규칙의 예를 살펴보겠지만 모듈이 작동하는 방식을 상기시키기 위해 참조하기에 좋은 곳입니다.\n\n\n크레이트 루트에서 시작 : 크레이트를 컴파일할 때 컴파일러는 먼저 크레이트 루트 파일(일반적으로 라이브러리 크레이트의 경우 src/lib.rs 또는 바이너리 크레이트의 경우 src/main.rs )에서 컴파일할 코드를 찾습니다.\n\n\n모듈 선언\n: 크레이트 루트 파일에서 새 모듈을 선언할 수 있습니다. 예를 들어 garden 모듈을 다음과 같이 선언합니다.\nmod garden;\n\n. 컴파일러는 다음 위치에서 모듈의 코드를 찾습니다.\n\n인라인, mod garden 다음의 세미콜론을 대체하는 중괄호 내\nsrc/garden.rs 파일에서\nsrc/garden/mod.rs 파일에서\n\n\n\n하위 모듈 선언\n: 크레이트 루트 이외의 모든 파일에서 하위 모듈을 선언할 수 있습니다. 예를 들어 다음과 같이 선언할 수 있습니다.\nmod vegetables;\n\n~에\nsrc/garden.rs\n. 컴파일러는 다음 위치에서 상위 모듈의 이름이 지정된 디렉토리 내에서 하위 모듈의 코드를 찾습니다.\n\n인라인, 세미콜론 대신 중괄호 안에 있는 mod vegetables 바로 뒤에\nsrc/garden/vegetables.rs 파일에서\nsrc/garden/vegetables/mod.rs 파일에서\n\n\n\n모듈의 코드 경로 : 모듈이 크레이트의 일부가 되면, 개인 정보 보호 규칙이 허용하는 한 코드 경로를 사용하여 동일한 크레이트의 다른 곳에서 해당 모듈의 코드를 참조할 수 있습니다. 예를 들어 정원 야채 모듈의 Asparagus 유형은 crate::garden::vegetables::Asparagus에서 찾을 수 있습니다.\n\n\n비공개 대 공개 : 모듈 내의 코드는 기본적으로 상위 모듈에서 비공개입니다. 모듈을 공개하려면 mod 대신 pub mod로 모듈을 선언하십시오. 공용 모듈 내의 항목도 공용으로 만들려면 선언 전에 pub를 사용하십시오.\n\n\nuse 키워드 : 범위 내에서 use 키워드는 긴 경로의 반복을 줄이기 위해 항목에 대한 바로 가기를 만듭니다. crate::garden::vegetables::Asparagus를 참조할 수 있는 모든 범위에서 use crate::garden::vegetables::Asparagus;로 바로 가기를 만들 수 있습니다. 그런 다음 범위에서 해당 유형을 사용하려면 Asparagus만 작성하면 됩니다.\n\n\n여기에서 이러한 규칙을 설명하는 backyard라는 이름의 바이너리 크레이트를 만듭니다. backyard라고도 하는 크레이트의 디렉토리에는 다음 파일과 디렉토리가 포함되어 있습니다.\nbackyard\n├── Cargo.lock\n├── Cargo.toml\n└── src\n    ├── garden\n    │   └── vegetables.rs\n    ├── garden.rs\n    └── main.rs\n\n이 경우 크레이트 루트 파일은 src/main.rs 이며 다음을 포함합니다:\n파일 이름: src/main.rs\nuse crate::garden::vegetables::Asparagus;\n\npub mod garden;\n\nfn main() {\n    let plant = Asparagus {};\n    println!(`I'm growing {:?}!`, plant);\n}\n\n펍 모드 가든; line은 src/garden.rs 에서 찾은 코드를 포함하도록 컴파일러에 지시합니다.\n파일명: src/garden.rs\npub mod vegetables;\n\n여기 pub mod vegetables; src/garden/vegetables.rs 의 코드 도 포함되어 있음을 의미합니다. 해당 코드는 다음과 같습니다.\n#[derive(Debug)]\npub struct Asparagus {}\n\n이제 이러한 규칙에 대해 자세히 알아보고 실제로 시연해 보겠습니다.\n관련 코드를 모듈로 그룹화\n모듈을 사용 하면 가독성과 손쉬운 재사용을 위해 크레이트 내에서 코드를 구성할 수 있습니다. 모듈은 또한 모듈 내의 코드가 기본적으로 비공개이기 때문에 항목의 프라이버시를 제어할 수 있습니다. 개인 항목은 외부에서 사용할 수 없는 내부 구현 세부 정보입니다. 우리는 모듈과 그 안에 있는 항목을 공개하도록 선택할 수 있습니다. 이렇게 하면 외부 코드가 모듈을 사용하고 의존할 수 있도록 노출됩니다.\n예를 들어 레스토랑의 기능을 제공하는 라이브러리 크레이트를 작성해 보겠습니다. 우리는 함수의 서명을 정의하지만 식당 구현보다는 코드 구성에 집중하기 위해 본문을 비워 둡니다.\n레스토랑 업계에서 레스토랑의 일부는 프론트 오브 하우스(front of house) , 다른 일부는 백 오브 하우스(back of house) 라고 합니다. 집 앞은 고객이 있는 곳입니다. 여기에는 호스트가 고객을 앉히고 서버가 주문 및 지불을 받고 바텐더가 음료를 만드는 곳이 포함됩니다. 백오브하우스는 셰프와 요리사가 주방에서 일하고, 식기 세척기가 청소하고, 관리자가 관리 업무를 수행하는 곳입니다.\n이러한 방식으로 크레이트를 구성하기 위해 함수를 중첩된 모듈로 구성할 수 있습니다. cargo new restaurant --lib를 실행하여 restaurant라는 새 라이브러리를 만듭니다. 그런 다음 목록 7-1의 코드를 src/lib.rs 에 입력하여 일부 모듈 및 함수 서명을 정의합니다. 집 앞 부분은 다음과 같습니다.\n파일 이름: src/lib.rs\nmod front_of_house {\n    mod hosting {\n        fn add_to_waitlist() {}\n\n        fn seat_at_table() {}\n    }\n\n    mod serving {\n        fn take_order() {}\n\n        fn serve_order() {}\n\n        fn take_payment() {}\n    }\n}\n\n목록 7-1: 함수를 포함하는 다른 모듈을 포함하는 front_of_house 모듈\nmod 키워드 뒤에 모듈 이름(이 경우 front_of_house)을 사용하여 모듈을 정의합니다. 그러면 모듈 본문이 중괄호 안에 들어갑니다. 모듈 내부에 hosting 및 serving 모듈이 있는 경우와 같이 다른 모듈을 배치할 수 있습니다. 모듈은 또한 구조체, 열거형, 상수, 특성 및 목록 7-1에서와 같이 함수와 같은 다른 항목에 대한 정의를 보유할 수 있습니다.\n모듈을 사용하여 관련 정의를 함께 그룹화하고 관련 이유를 명명할 수 있습니다. 이 코드를 사용하는 프로그래머는 모든 정의를 읽을 필요 없이 그룹을 기반으로 코드를 탐색할 수 있으므로 관련된 정의를 더 쉽게 찾을 수 있습니다. 이 코드에 새로운 기능을 추가하는 프로그래머는 프로그램을 체계적으로 유지하기 위해 코드를 어디에 배치해야 하는지 알 것입니다.\n앞에서 우리는 src/main.rs 와 src/lib.rs를 크레이트 루트라고 부른다고 언급했습니다. 이름이 붙은 이유는 이 두 파일 중 하나의 내용이 모듈 트리로 알려진 크레이트 모듈 구조의 루트에서 크레이트라는 모듈을 형성하기 때문입니다.\n목록 7-2는 목록 7-1의 구조에 대한 모듈 트리를 보여줍니다.\ncrate\n └── front_of_house\n     ├── hosting\n     │   ├── add_to_waitlist\n     │   └── seat_at_table\n     └── serving\n         ├── take_order\n         ├── serve_order\n         └── take_payment\n\n목록 7-2: 목록 7-1의 코드에 대한 모듈 트리\n이 트리는 일부 모듈이 서로 중첩되는 방식을 보여줍니다. 예를 들어 hosting은 front_of_house 내부에 중첩됩니다. 트리는 또한 일부 모듈이 서로 형제 임을 보여줍니다. 즉, 동일한 모듈에서 정의된다는 의미입니다. hosting 및 serving은 front_of_house 내에 정의된 형제입니다. 모듈 A가 모듈 B 안에 포함되어 있으면 모듈 A는 모듈 B의 자식 이고 모듈 B는 모듈 A의 부모 라고 말합니다. 전체 모듈 트리는 crate라는 암시적 모듈 아래에 뿌리를 두고 있습니다.\n모듈 트리는 컴퓨터에 있는 파일 시스템의 디렉토리 트리를 상기시킬 수 있습니다. 이것은 매우 적절한 비교입니다! 파일 시스템의 디렉토리와 마찬가지로 모듈을 사용하여 코드를 구성합니다. 그리고 디렉토리의 파일과 마찬가지로 모듈을 찾을 방법이 필요합니다.\n\n모듈 트리에서 항목을 참조하기 위한 경로\nRust가 모듈 트리에서 항목을 찾을 위치를 보여주기 위해 파일 시스템을 탐색할 때 경로를 사용하는 것과 같은 방식으로 경로를 사용합니다. 함수를 호출하려면 경로를 알아야 합니다.\n경로는 두 가지 형식을 취할 수 있습니다.\n\n절대 경로는 크레이트 루트에서 시작하는 전체 경로입니다. 외부 크레이트의 코드의 경우 절대 경로는 크레이트 이름으로 시작하고 현재 크레이트의 코드의 경우 리터럴 크레이트로 시작합니다.\n상대 경로는 현재 모듈에서 시작하여 self, super 또는 현재 모듈의 식별자를 사용합니다.\n\n절대 경로와 상대 경로 모두 이중 콜론(::)으로 구분된 하나 이상의 식별자 뒤에 옵니다.\n목록 7-1로 돌아가서 add_to_waitlist 함수를 호출하고 싶다고 합시다. 이것은 add_to_waitlist 함수의 경로가 무엇인지 묻는 것과 같습니다. 목록 7-3에는 일부 모듈과 함수가 제거된 목록 7-1이 포함되어 있습니다.\n크레이트 루트에 정의된 새 함수 eat_at_restaurant에서 add_to_waitlist 함수를 호출하는 두 가지 방법을 보여줍니다. 이러한 경로는 정확하지만 이 예제를 있는 그대로 컴파일하지 못하게 하는 또 다른 문제가 남아 있습니다. 잠시 후에 그 이유를 설명하겠습니다.\neat_at_restaurant 함수는 라이브러리 크레이트의 공개 API의 일부이므로 pub 키워드로 표시합니다. [pub 키워드를 사용하여 경로 노출](https://doc.rust-lang.org/book/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#exposing-paths-with-the-pub-keyword) 섹션 에서 pub`에 대해 자세히 설명합니다.\n파일 이름: src/lib.rs\nmod front_of_house {\n    mod hosting {\n        fn add_to_waitlist() {}\n    }\n}\n\npub fn eat_at_restaurant() {\n    // Absolute path\n    crate::front_of_house::hosting::add_to_waitlist();\n\n    // Relative path\n    front_of_house::hosting::add_to_waitlist();\n}\n\n목록 7-3: 절대 경로와 상대 경로를 사용하여 add_to_waitlist 함수 호출\neat_at_restaurant에서 add_to_waitlist 함수를 처음 호출할 때 절대 경로를 사용합니다. add_to_waitlist 기능은 eat_at_restaurant와 같은 크레이트에 정의되어 있습니다. 즉, crate 키워드를 사용하여 절대 경로를 시작할 수 있습니다. 그런 다음 add_to_waitlist로 이동할 때까지 각 연속 모듈을 포함합니다. 동일한 구조를 가진 파일 시스템을 상상할 수 있습니다. add_to_waitlist 프로그램을 실행하기 위해 /front_of_house/hosting/add_to_waitlist 경로를 지정합니다. 크레이트 루트에서 시작하기 위해 크레이트 이름을 사용하는 것은 쉘의 파일 시스템 루트에서 시작하기 위해 /를 사용하는 것과 같습니다.\n두 번째로 eat_at_restaurant에서 add_to_waitlist를 호출할 때는 상대 경로를 사용합니다. 경로는 eat_at_restaurant와 동일한 수준의 모듈 트리에 정의된 모듈 이름인 front_of_house로 시작합니다. 여기서 동등한 파일 시스템은 front_of_house/hosting/add_to_waitlist 경로를 사용합니다. 모듈 이름으로 시작하는 것은 경로가 상대적임을 의미합니다.\n상대 경로를 사용할지 절대 경로를 사용할지 선택하는 것은 프로젝트를 기반으로 결정하며 항목 정의 코드를 항목을 사용하는 코드와 별도로 또는 함께 이동할 가능성이 더 높은지에 따라 달라집니다. 예를 들어 front_of_house 모듈과 eat_at_restaurant 함수를 customer_experience라는 모듈로 이동하면 절대 경로를 add_to_waitlist로 업데이트해야 하지만 상대 경로는 여전히 유효합니다. 그러나 eat_at_restaurant 함수를 별도로 dining이라는 모듈로 이동하면 add_to_waitlist 호출에 대한 절대 경로는 동일하게 유지되지만 상대 경로는 업데이트해야 합니다.\n목록 7-3을 컴파일하고 왜 아직 컴파일되지 않는지 알아봅시다! 우리가 얻은 오류는 Listing 7-4에 나와 있습니다.\n$ cargo build\n   Compiling restaurant v0.1.0 (file:///projects/restaurant)\nerror[E0603]: module `hosting` is private\n --&gt; src/lib.rs:9:28\n  |\n9 |     crate::front_of_house::hosting::add_to_waitlist();\n  |                            ^^^^^^^ private module\n  |\nnote: the module `hosting` is defined here\n --&gt; src/lib.rs:2:5\n  |\n2 |     mod hosting {\n  |     ^^^^^^^^^^^\n\nerror[E0603]: module `hosting` is private\n  --&gt; src/lib.rs:12:21\n   |\n12 |     front_of_house::hosting::add_to_waitlist();\n   |                     ^^^^^^^ private module\n   |\nnote: the module `hosting` is defined here\n  --&gt; src/lib.rs:2:5\n   |\n2  |     mod hosting {\n   |     ^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0603`.\nerror: could not compile `restaurant` due to 2 previous errors\n\nListing 7-4: Listing 7-3의 코드를 빌드할 때 발생하는 컴파일러 오류\n오류 메시지는 모듈 호스팅이 비공개라고 말합니다. 다시 말해, 우리는 hosting 모듈과 add_to_waitlist 함수에 대한 올바른 경로를 가지고 있지만 Rust는 개인 섹션에 대한 액세스 권한이 없기 때문에 우리가 사용하도록 허용하지 않습니다. Rust에서 모든 항목(함수, 메서드, 구조체, 열거형, 모듈 및 상수)은 기본적으로 부모 모듈에 대해 비공개입니다. 함수나 구조체와 같은 항목을 비공개로 만들고 싶다면 모듈에 넣습니다.\n상위 모듈의 항목은 하위 모듈 내의 개인 항목을 사용할 수 없지만 하위 모듈의 항목은 상위 모듈의 항목을 사용할 수 있습니다. 하위 모듈은 구현 세부 정보를 래핑하고 숨기지만 하위 모듈은 정의된 컨텍스트를 볼 수 있기 때문입니다. 우리의 은유를 계속하기 위해 프라이버시 규칙을 레스토랑의 백오피스와 같다고 생각하십시오. 그곳에서 일어나는 일은 레스토랑 고객에게만 공개되지만 사무실 관리자는 자신이 운영하는 레스토랑에서 모든 것을 보고 할 수 있습니다.\nRust는 내부 구현 세부 사항을 숨기는 것이 기본값이 되도록 모듈 시스템 기능을 이런 방식으로 선택했습니다. 이렇게 하면 외부 코드를 손상시키지 않고 변경할 수 있는 내부 코드 부분을 알 수 있습니다. 그러나 Rust는 항목을 공개하기 위해 pub 키워드를 사용하여 자식 모듈 코드의 내부 부분을 외부 조상 모듈에 노출하는 옵션을 제공합니다.\npub 키워드로 경로 노출\nListing 7-4에서 호스팅 모듈이 비공개라는 오류로 돌아가 봅시다. 부모 모듈의 eat_at_restaurant 함수가 자식 모듈의 add_to_waitlist 함수에 액세스하기를 원하므로 목록 7-5에 표시된 것처럼 pub 키워드로 hosting 모듈을 표시합니다.\n파일 이름: src/lib.rs\nmod front_of_house {\n    pub mod hosting {\n        fn add_to_waitlist() {}\n    }\n}\n\npub fn eat_at_restaurant() {\n    // Absolute path\n    crate::front_of_house::hosting::add_to_waitlist();\n\n    // Relative path\n    front_of_house::hosting::add_to_waitlist();\n}\n\nListing 7-5: eat_at_restaurant에서 사용하기 위해 hosting 모듈을 pub으로 선언\n안타깝게도 Listing 7-5의 코드는 Listing 7-6과 같이 여전히 오류를 발생시킵니다.\n$ cargo build\n   Compiling restaurant v0.1.0 (file:///projects/restaurant)\nerror[E0603]: function `add_to_waitlist` is private\n --&gt; src/lib.rs:9:37\n  |\n9 |     crate::front_of_house::hosting::add_to_waitlist();\n  |                                     ^^^^^^^^^^^^^^^ private function\n  |\nnote: the function `add_to_waitlist` is defined here\n --&gt; src/lib.rs:3:9\n  |\n3 |         fn add_to_waitlist() {}\n  |         ^^^^^^^^^^^^^^^^^^^^\n\nerror[E0603]: function `add_to_waitlist` is private\n  --&gt; src/lib.rs:12:30\n   |\n12 |     front_of_house::hosting::add_to_waitlist();\n   |                              ^^^^^^^^^^^^^^^ private function\n   |\nnote: the function `add_to_waitlist` is defined here\n  --&gt; src/lib.rs:3:9\n   |\n3  |         fn add_to_waitlist() {}\n   |         ^^^^^^^^^^^^^^^^^^^^\n\nFor more information about this error, try `rustc --explain E0603`.\nerror: could not compile `restaurant` due to 2 previous errors\n\nListing 7-6: Listing 7-5의 코드를 빌드할 때 발생하는 컴파일러 오류\n무슨 일이에요? mod hosting 앞에 pub 키워드를 추가하면 모듈이 공개됩니다. 이 변경으로 front_of_house에 액세스할 수 있으면 hosting에 액세스할 수 있습니다. 그러나 호스팅의 내용은 여전히 비공개입니다. 모듈을 공개한다고 해서 내용이 공개되는 것은 아닙니다. 모듈의 pub 키워드는 상위 모듈의 코드가 내부 코드에 액세스하지 않고 참조만 허용합니다. 모듈은 컨테이너이기 때문에 모듈을 공개하는 것만으로는 할 수 있는 일이 많지 않습니다. 더 나아가 모듈 내의 항목 중 하나 이상을 공개하도록 선택해야 합니다.\n목록 7-6의 오류는 add_to_waitlist 함수가 비공개라고 말합니다. 개인 정보 보호 규칙은 구조체, 열거형, 함수 및 메서드와 모듈에 적용됩니다.\n목록 7-7에서와 같이 정의 앞에 pub 키워드를 추가하여 add_to_waitlist 함수를 공용으로 만들어 보겠습니다.\n파일 이름: src/lib.rs\nmod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {}\n    }\n}\n\npub fn eat_at_restaurant() {\n    // Absolute path\n    crate::front_of_house::hosting::add_to_waitlist();\n\n    // Relative path\n    front_of_house::hosting::add_to_waitlist();\n}\n\n목록 7-7: mod hosting 및 fn add_to_waitlist에 pub 키워드를 추가하면 eat_at_restaurant에서 함수를 호출할 수 있습니다.\n이제 코드가 컴파일됩니다! pub 키워드를 추가하면 개인 정보 보호 규칙과 관련하여 add_to_waitlist에서 이러한 경로를 사용할 수 있는 이유를 알아보기 위해 절대 경로와 상대 경로를 살펴보겠습니다.\n절대 경로에서 크레이트 모듈 트리의 루트인 크레이트로 시작합니다. front_of_house 모듈은 크레이트 루트에 정의되어 있습니다. front_of_house는 공개되지 않지만 eat_at_restaurant 함수는 front_of_house와 동일한 모듈에서 정의되기 때문에(즉, eat_at_restaurant와 front_of_house는 형제임) eat_at_restaurant에서 front_of_house를 참조할 수 있습니다. . 다음은 pub으로 표시된 hosting 모듈입니다. hosting의 상위 모듈에 액세스할 수 있으므로 hosting에 액세스할 수 있습니다. 마지막으로, add_to_waitlist 함수는 pub로 표시되고 부모 모듈에 액세스할 수 있으므로 이 함수 호출이 작동합니다!\n상대 경로에서 논리는 첫 번째 단계를 제외하고는 절대 경로와 동일합니다. 경로는 크레이트 루트에서 시작하지 않고 front_of_house에서 시작합니다. front_of_house 모듈은 eat_at_restaurant와 동일한 모듈 내에서 정의되므로 eat_at_restaurant가 정의된 모듈에서 시작하는 상대 경로가 작동합니다. 그런 다음 hosting 및 add_to_waitlist가 pub로 표시되기 때문에 나머지 경로가 작동하고 이 함수 호출이 유효합니다!\n다른 프로젝트에서 코드를 사용할 수 있도록 라이브러리 크레이트를 공유할 계획이라면 공개 API는 크레이트 사용자가 코드와 상호 작용할 수 있는 방법을 결정하는 계약입니다. 사람들이 당신의 크레이트에 더 쉽게 의존할 수 있도록 공개 API에 대한 변경 사항을 관리하는 것과 관련하여 많은 고려 사항이 있습니다. 이러한 고려 사항은 이 책의 범위를 벗어납니다. 이 주제에 관심이 있다면 Rust API 가이드라인 을 참조하세요 .\n\n바이너리 및 라이브러리가 포함된 패키지에 대한 모범 사례\n우리는 패키지가 src/main.rs 바이너리 크레이트 루트와 src/lib.rs 라이브러리 크레이트 루트를 모두 포함할 수 있으며 두 크레이트 모두 기본적으로 패키지 이름을 가질 것이라고 언급했습니다. 일반적으로 라이브러리와 바이너리 크레이트를 모두 포함하는 이 패턴을 가진 패키지는 바이너리 크레이트에 라이브러리 크레이트로 코드를 호출하는 실행 파일을 시작하기에 충분한 코드만 있습니다. 이렇게 하면 라이브러리 크레이트의 코드를 공유할 수 있으므로 다른 프로젝트에서 패키지가 제공하는 대부분의 기능을 활용할 수 있습니다.\n모듈 트리는 src/lib.rs 에 정의되어야 합니다. 그런 다음 패키지 이름으로 경로를 시작하여 바이너리 크레이트에서 공용 항목을 사용할 수 있습니다. 바이너리 크레이트는 완전히 외부에 있는 크레이트가 라이브러리 크레이트를 사용하는 것처럼 라이브러리 크레이트의 사용자가 됩니다. 공용 API만 사용할 수 있습니다. 이는 좋은 API를 설계하는 데 도움이 됩니다. 당신은 저자일 뿐만 아니라 고객이기도 합니다!\n12장 에서는 바이너리 크레이트와 라이브러리 크레이트를 모두 포함하는 명령줄 프로그램을 사용하여 이 조직적 관행을 시연할 것입니다.\n\nsuper로 상대 경로 시작\n경로 시작 부분에 super를 사용하여 현재 모듈이나 크레이트 루트가 아닌 상위 모듈에서 시작하는 상대 경로를 구성할 수 있습니다. 이것은 .. 구문으로 파일 시스템 경로를 시작하는 것과 같습니다. super를 사용하면 부모 모듈에 있는 것으로 알고 있는 항목을 참조할 수 있으므로 모듈이 부모와 밀접하게 관련되어 있을 때 모듈 트리를 쉽게 재정렬할 수 있지만 부모는 언젠가 모듈 트리의 다른 곳으로 이동할 수 있습니다.\n셰프가 잘못된 주문을 수정하고 직접 고객에게 가져오는 상황을 모델링하는 Listing 7-8의 코드를 고려하십시오. back_of_house 모듈에 정의된 fix_incorrect_order 함수는 super로 시작하는 deliver_order에 대한 경로를 지정하여 상위 모듈에 정의된 deliver_order 함수를 호출합니다.\n파일 이름: src/lib.rs\nfn deliver_order() {}\n\nmod back_of_house {\n    fn fix_incorrect_order() {\n        cook_order();\n        super::deliver_order();\n    }\n\n    fn cook_order() {}\n}\n\n목록 7-8: super로 시작하는 상대 경로를 사용하여 함수 호출\nfix_incorrect_order 함수는 back_of_house 모듈에 있으므로 super를 사용하여 back_of_house의 상위 모듈로 이동할 수 있습니다. 이 경우 루트인 crate입니다. 거기에서 deliver_order를 찾아 찾습니다. 성공! 우리는 back_of_house 모듈과 deliver_order 기능이 서로 같은 관계를 유지하고 상자의 모듈 트리를 재구성하기로 결정하면 함께 이동할 가능성이 있다고 생각합니다. 따라서 우리는 super를 사용하여 이 코드가 다른 모듈로 이동될 경우 향후에 코드를 업데이트할 위치가 줄어들게 됩니다.\n구조체와 열거형을 공개하기\n또한 pub을 사용하여 구조체 및 열거형을 공용으로 지정할 수 있지만 구조체 및 열거형과 함께 pub를 사용하는 데 추가로 몇 가지 세부 정보가 있습니다. 구조체 정의 전에 pub를 사용하면 구조체를 공개하지만 구조체의 필드는 여전히 비공개입니다. 사례별로 각 필드를 공개하거나 공개하지 않을 수 있습니다. 목록 7-9에서 공개 toast 필드와 비공개 seasonal_fruit 필드가 있는 공개 back_of_house::Breakfast 구조체를 정의했습니다. 이것은 고객이 식사와 함께 제공되는 빵의 종류를 선택할 수 있는 레스토랑의 경우를 모델로 하지만 요리사는 계절과 재고에 따라 식사와 함께 제공되는 과일을 결정합니다. 사용 가능한 과일은 빠르게 변경되므로 고객은 과일을 선택할 수 없으며 어떤 과일을 얻을지 알 수도 없습니다.\n파일 이름: src/lib.rs\nmod back_of_house {\n    pub struct Breakfast {\n        pub toast: String,\n        seasonal_fruit: String,\n    }\n\n    impl Breakfast {\n        pub fn summer(toast: &amp;str) -&gt; Breakfast {\n            Breakfast {\n                toast: String::from(toast),\n                seasonal_fruit: String::from(`peaches`),\n            }\n        }\n    }\n}\n\npub fn eat_at_restaurant() {\n    // Order a breakfast in the summer with Rye toast\n    let mut meal = back_of_house::Breakfast::summer(`Rye`);\n    // Change our mind about what bread we'd like\n    meal.toast = String::from(`Wheat`);\n    println!(`I'd like {} toast please`, meal.toast);\n\n    // The next line won't compile if we uncomment it; we're not allowed\n    // to see or modify the seasonal fruit that comes with the meal\n    // meal.seasonal_fruit = String::from(`blueberries`);\n}\n\nListing 7-9: 일부 공개 필드와 일부 비공개 필드가 있는 구조체\nback_of_house::Breakfast 구조체의 toast 필드가 공개되어 있기 때문에 eat_at_restaurant에서 점 표기법을 사용하여 toast 필드에 쓰고 읽을 수 있습니다. seasonal_fruit가 비공개이기 때문에 eat_at_restaurant에서 seasonal_fruit 필드를 사용할 수 없습니다. seasonal_fruit 필드 값을 수정하는 줄의 주석을 제거하여 어떤 오류가 발생하는지 확인하십시오!\n또한 back_of_house::Breakfast에는 전용 필드가 있기 때문에 구조체는 Breakfast(여기서는 summer라고 함)의 인스턴스를 구성하는 공용 관련 함수를 제공해야 합니다. Breakfast에 이러한 기능이 없으면 eat_at_restaurant에서 비공개 seasonal_fruit 필드의 값을 설정할 수 없기 때문에 eat_at_restaurant에서 Breakfast 인스턴스를 생성할 수 없습니다.\n반대로 열거형을 공개하면 모든 변형이 공개됩니다. Listing 7-10과 같이 enum 키워드 앞에 pub만 있으면 됩니다.\n파일 이름: src/lib.rs\nmod back_of_house {\n    pub enum Appetizer {\n        Soup,\n        Salad,\n    }\n}\n\npub fn eat_at_restaurant() {\n    let order1 = back_of_house::Appetizer::Soup;\n    let order2 = back_of_house::Appetizer::Salad;\n}\n\n목록 7-10: 열거형을 공개로 지정하면 모든 변형이 공개됩니다.\nAppetizer 열거형을 공개했기 때문에 eat_at_restaurant에서 Soup 및 Salad 변형을 사용할 수 있습니다.\n열거형은 해당 변형이 공개되지 않는 한 그다지 유용하지 않습니다. 모든 경우에 pub로 모든 열거형 변형에 주석을 달아야 하는 것은 성가신 일이므로 열거형 변형의 기본값은 공개입니다. 구조체는 필드가 공개되지 않아도 유용한 경우가 많으므로 구조체 필드는 pub로 주석이 지정되지 않는 한 기본적으로 모든 것이 비공개라는 일반적인 규칙을 따릅니다.\n우리가 다루지 않은 pub와 관련된 또 다른 상황이 있습니다. 그것은 우리의 마지막 모듈 시스템 기능인 use 키워드입니다. 먼저 use 자체를 다룬 다음 pub와 use를 결합하는 방법을 보여줍니다.\n\nuse 키워드를 사용하여 경로를 범위로 가져오기\n함수를 호출하는 경로를 작성해야 하는 것은 불편하고 반복적으로 느껴질 수 있습니다. 목록 7-7에서 add_to_waitlist 함수에 대한 절대 경로를 선택했는지 상대 경로를 선택했는지에 관계없이 add_to_waitlist를 호출할 때마다 front_of_house 및 hosting도 지정해야 했습니다. 다행스럽게도 이 프로세스를 단순화하는 방법이 있습니다. use 키워드를 사용하여 경로에 대한 바로 가기를 한 번 만든 다음 범위의 다른 모든 곳에서 더 짧은 이름을 사용할 수 있습니다.\n목록 7-11에서 crate::front_of_house::hosting 모듈을 eat_at_restaurant 함수의 범위로 가져오므로 eat_at_restaurant에서 add_to_waitlist 함수를 호출하려면 hosting::add_to_waitlist만 지정하면 됩니다. `.\n파일 이름: src/lib.rs\nmod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {}\n    }\n}\n\nuse crate::front_of_house::hosting;\n\npub fn eat_at_restaurant() {\n    hosting::add_to_waitlist();\n}\n\n목록 7-11: use를 사용하여 모듈을 범위로 가져오기\n범위에 use와 경로를 추가하는 것은 파일 시스템에서 심볼릭 링크를 만드는 것과 유사합니다. 크레이트 루트에 use crate::front_of_house::hosting을 추가함으로써 hosting 모듈이 크레이트 루트에 정의된 것처럼 이제 해당 범위에서 hosting이 유효한 이름이 됩니다. 사용으로 범위에 포함된 경로는 다른 경로와 마찬가지로 개인 정보도 확인합니다.\n사용은 사용이 발생하는 특정 범위에 대한 바로 가기만 생성한다는 점에 유의하십시오. 목록 7-12는 eat_at_restaurant 함수를 customer라는 이름의 새 하위 모듈로 이동합니다. 이 모듈은 use 문과 다른 범위이므로 함수 본문이 컴파일되지 않습니다.\n파일 이름: src/lib.rs\nmod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {}\n    }\n}\n\nuse crate::front_of_house::hosting;\n\nmod customer {\n    pub fn eat_at_restaurant() {\n        hosting::add_to_waitlist();\n    }\n}\n\n목록 7-12: use 문은 해당 범위 내에서만 적용됩니다.\n컴파일러 오류는 바로 가기가 고객 모듈 내에서 더 이상 적용되지 않음을 보여줍니다.\n$ cargo build\n   Compiling restaurant v0.1.0 (file:///projects/restaurant)\nwarning: unused import: `crate::front_of_house::hosting`\n --&gt; src/lib.rs:7:5\n  |\n7 | use crate::front_of_house::hosting;\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0433]: failed to resolve: use of undeclared crate or module `hosting`\n  --&gt; src/lib.rs:11:9\n   |\n11 |         hosting::add_to_waitlist();\n   |         ^^^^^^^ use of undeclared crate or module `hosting`\n\nFor more information about this error, try `rustc --explain E0433`.\nwarning: `restaurant` (lib) generated 1 warning\nerror: could not compile `restaurant` due to previous error; 1 warning emitted\n\n사용이 해당 범위에서 더 이상 사용되지 않는다는 경고도 있습니다! 이 문제를 해결하려면 customer 모듈 내에서 use를 이동하거나 하위 customer 모듈 내에서 super::hosting을 사용하여 상위 모듈의 바로 가기를 참조하십시오.\n관용적인 사용 경로 만들기\nListing 7-11에서 왜 우리가 use crate::front_of_house::hosting을 지정한 다음 use 경로를 지정하지 않고 eat_at_restaurant에서 hosting::add_to_waitlist를 호출했는지 궁금할 수 있습니다. add_to_waitlist 함수를 사용하여 Listing 7-13과 같은 결과를 얻을 수 있습니다.\n파일 이름: src/lib.rs\nmod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {}\n    }\n}\n\nuse crate::front_of_house::hosting::add_to_waitlist;\n\npub fn eat_at_restaurant() {\n    add_to_waitlist();\n}\n\n목록 7-13: use를 사용하여 add_to_waitlist 함수를 범위로 가져오기\nListing 7-11과 7-13 모두 동일한 작업을 수행하지만 Listing 7-11은 use를 사용하여 함수를 범위로 가져오는 관용적인 방법입니다. use를 사용하여 함수의 상위 모듈을 범위로 가져오는 것은 함수를 호출할 때 상위 모듈을 지정해야 함을 의미합니다. 함수를 호출할 때 부모 모듈을 지정하면 전체 경로의 반복을 최소화하면서 함수가 로컬로 정의되지 않았음을 분명히 할 수 있습니다. 목록 7-13의 코드는 add_to_waitlist가 정의된 위치가 명확하지 않습니다.\n반면에 구조체, 열거형 및 기타 항목을 use로 가져올 때는 전체 경로를 지정하는 것이 관용적입니다. 목록 7-14는 표준 라이브러리의 HashMap 구조체를 바이너리 크레이트의 범위로 가져오는 관용적인 방법을 보여줍니다.\n파일 이름: src/main.rs\nuse std::collections::HashMap;\n\nfn main() {\n    let mut map = HashMap::new();\n    map.insert(1, 2);\n}\n\nListing 7-14: 관용적인 방식으로 HashMap을 범위로 가져오기\n이 관용구 뒤에 강력한 이유가 있는 것은 아닙니다. 등장한 관례일 뿐이고 사람들은 이러한 방식으로 Rust 코드를 읽고 쓰는 데 익숙해졌습니다.\n이 관용구의 예외는 Rust가 허용하지 않기 때문에 use 문을 사용하여 이름이 같은 두 항목을 범위로 가져오는 경우입니다. 목록 7-15는 이름은 같지만 상위 모듈이 다른 두 개의 결과 유형을 범위로 가져오는 방법과 이를 참조하는 방법을 보여줍니다.\n파일 이름: src/lib.rs\nuse std::fmt;\nuse std::io;\n\nfn function1() -&gt; fmt::Result {\n    // --snip--\n}\n\nfn function2() -&gt; io::Result&lt;()&gt; {\n    // --snip--\n}\n\n목록 7-15: 이름이 같은 두 유형을 동일한 범위로 가져오려면 부모 모듈을 사용해야 합니다.\n보시다시피 상위 모듈을 사용하면 두 가지 결과 유형이 구별됩니다. 대신에 우리가 use std::fmt::Result와 use std::io::Result를 지정했다면, 우리는 같은 범위에 두 개의 Result 유형을 가지게 될 것이고 러스트는 언제 우리가 의미하는 것이 무엇인지 알지 못할 것입니다. 우리는 결과를 사용했습니다.\nas 키워드로 새 이름 제공\nuse를 사용하여 동일한 이름의 두 유형을 동일한 범위로 가져오는 문제에 대한 또 다른 솔루션이 있습니다. 경로 뒤에 유형에 대해 as 및 새 로컬 이름 또는 alias 를 지정할 수 있습니다. Listing 7-16은 as를 사용하여 두 개의 Result 유형 중 하나의 이름을 변경하여 Listing 7-15의 코드를 작성하는 또 다른 방법을 보여줍니다.\n파일 이름: src/lib.rs\nuse std::fmt::Result;\nuse std::io::Result as IoResult;\n\nfn function1() -&gt; Result {\n    // --snip--\n}\n\nfn function2() -&gt; IoResult&lt;()&gt; {\n    // --snip--\n}\n\nListing 7-16: as 키워드를 사용하여 범위로 가져올 때 유형 이름 바꾸기\n두 번째 use 문에서 우리는 std::io::Result 유형에 대해 IoResult라는 새 이름을 선택했습니다. 이는 std::fmt의 Result와 충돌하지 않습니다. 또한 범위에 포함되었습니다. Listing 7-15와 Listing 7-16은 관용적인 것으로 간주되므로 선택은 여러분에게 달려 있습니다!\npub use로 이름을 다시 내보내기\nuse 키워드를 사용하여 이름을 범위로 가져오면 새 범위에서 사용할 수 있는 이름은 비공개입니다. 코드 범위에 정의된 것처럼 해당 이름을 참조하도록 코드를 호출하는 코드를 활성화하려면 pub와 use를 결합할 수 있습니다. 이 기술을 재내보내기라고 부르는 이유는 항목을 범위로 가져오는 동시에 다른 사람이 해당 항목을 범위로 가져올 수 있도록 만들기 때문입니다.\nListing 7-17은 루트 모듈의 use가 pub use로 변경된 Listing 7-11의 코드를 보여줍니다.\n파일 이름: src/lib.rs\nmod front_of_house {\n    pub mod hosting {\n        pub fn add_to_waitlist() {}\n    }\n}\n\npub use crate::front_of_house::hosting;\n\npub fn eat_at_restaurant() {\n    hosting::add_to_waitlist();\n}\n\n목록 7-17: pub use를 사용하여 새 범위에서 사용할 모든 코드에 사용할 수 있는 이름 만들기\n이 변경 전에는 외부 코드에서 restaurant::front_of_house::hosting::add_to_waitlist() 경로를 사용하여 add_to_waitlist 함수를 호출해야 했습니다. 이제 이 pub use가 루트 모듈에서 hosting 모듈을 다시 내보냈으므로 이제 외부 코드에서 restaurant::hosting::add_to_waitlist() 경로를 대신 사용할 수 있습니다.\n다시 내보내기는 코드의 내부 구조가 코드를 호출하는 프로그래머가 도메인에 대해 생각하는 방식과 다를 때 유용합니다. 예를 들어, 이 식당 은유에서 식당을 운영하는 사람들은 집 앞과 집 뒤를 생각합니다. 그러나 레스토랑을 방문하는 고객은 아마도 그러한 용어로 레스토랑의 부분에 대해 생각하지 않을 것입니다. pub use를 사용하면 하나의 구조로 코드를 작성할 수 있지만 다른 구조를 노출할 수 있습니다. 이렇게 하면 라이브러리에서 작업하는 프로그래머와 라이브러리를 호출하는 프로그래머를 위해 라이브러리가 잘 정리됩니다. 14장의 ``pub use 로 편리한 공용 API 내보내기 섹션 에서 pub use의 또 다른 예와 이것이 크레이트 문서에 미치는 영향을 살펴보겠습니다.\n외부 패키지 사용\n2장에서 우리는 임의의 숫자를 얻기 위해 rand라는 외부 패키지를 사용하는 추측 게임 프로젝트를 프로그래밍했습니다. 프로젝트에서 rand를 사용하기 위해 Cargo.toml 에 다음 행을 추가했습니다.\n파일 이름: Cargo.toml\nrand = `0.8.5`\n\nCargo.toml 에 rand를 종속 항목으로 추가하면 Cargo가 crates.io 에서 rand 패키지와 모든 종속 항목을 다운로드 하고 프로젝트에서 rand를 사용할 수 있도록 합니다.\n그런 다음 rand 정의를 패키지 범위로 가져오기 위해 상자 이름 rand로 시작하는 use 행을 추가하고 범위로 가져오고자 하는 항목을 나열했습니다. 2장의 난수 생성 섹션 에서 Rng 특성을 범위로 가져오고 rand::thread_rng 함수를 호출했습니다.\nuse rand::Rng;\n\nfn main() {\n    let secret_number = rand::thread_rng().gen_range(1..=100);\n}\n\nRust 커뮤니티의 구성원은 crates.io 에서 사용할 수 있는 많은 패키지를 만들었습니다. 패키지에 패키지를 가져오려면 패키지의 Cargo.toml 파일에 패키지를 나열하고 use를 사용하여 상자에서 항목을 범위로 가져옵니다. .\n표준 std 라이브러리는 패키지 외부에 있는 크레이트이기도 합니다. 표준 라이브러리는 Rust 언어와 함께 제공되기 때문에 std를 포함하도록 Cargo.toml을 변경할 필요가 없습니다. 그러나 항목을 패키지 범위로 가져오려면 사용으로 참조해야 합니다. 예를 들어 HashMap의 경우 다음 행을 사용합니다.\nuse std::collections::HashMap;\n\n이것은 표준 라이브러리 크레이트의 이름인 std로 시작하는 절대 경로입니다.\n중첩된 경로를 사용하여 큰 사용 목록 정리\n동일한 크레이트 또는 동일한 모듈에 정의된 여러 항목을 사용하는 경우 각 항목을 한 줄에 나열하면 파일에서 세로 공간을 많이 차지할 수 있습니다. 예를 들어 목록 2-4의 추측 게임에 있는 두 개의 use 문은 std의 항목을 범위로 가져옵니다.\n파일 이름: src/main.rs\n// --snip--\nuse std::cmp::Ordering;\nuse std::io;\n// --snip--\n\n대신 중첩된 경로를 사용하여 동일한 항목을 한 줄의 범위로 가져올 수 있습니다. Listing 7-18과 같이 경로의 공통 부분을 지정하고 두 개의 콜론을 지정한 다음 서로 다른 경로 부분의 목록 주위에 중괄호를 지정하여 이를 수행합니다.\n파일 이름: src/main.rs\n// --snip--\nuse std::{cmp::Ordering, io};\n// --snip--\n\nListing 7-18: 동일한 접두사를 가진 여러 항목을 범위로 가져오는 중첩 경로 지정\n더 큰 프로그램에서 중첩된 경로를 사용하여 동일한 크레이트 또는 모듈에서 많은 항목을 범위로 가져오면 필요한 별도의 use 문 수를 크게 줄일 수 있습니다!\n경로의 모든 수준에서 중첩 경로를 사용할 수 있습니다. 이는 하위 경로를 공유하는 두 개의 use 문을 결합할 때 유용합니다. 예를 들어 Listing 7-19는 두 개의 use 문을 보여줍니다. 하나는 std::io를 범위로 가져오고 다른 하나는 std::io::Write를 범위로 가져옵니다.\n파일 이름: src/lib.rs\nuse std::io;\nuse std::io::Write;\n\n목록 7-19: 하나가 다른 하나의 하위 경로인 두 개의 use 문\n이 두 경로의 공통 부분은 std::io이며 이것이 완전한 첫 번째 경로입니다. 이 두 경로를 하나의 use 문으로 병합하려면 Listing 7-20에 표시된 것처럼 중첩된 경로에서 self를 사용할 수 있습니다.\n파일 이름: src/lib.rs\nuse std::io::{self, Write};\n\n목록 7-20: 목록 7-19의 경로를 하나의 use 문으로 결합\n이 줄은 std::io 및 std::io::Write를 범위로 가져옵니다.\n글롭 연산자\n경로에 정의된 모든 공용 항목을 범위로 가져오려면 해당 경로 뒤에 * glob 연산자를 지정할 수 있습니다.\nuse std::collections::*;\n\n이 use 문은 std::collections에 정의된 모든 공용 항목을 현재 범위로 가져옵니다. glob 연산자를 사용할 때 주의하십시오! Glob은 범위 내에 어떤 이름이 있고 프로그램에서 사용된 이름이 정의된 위치를 구분하기 어렵게 만들 수 있습니다.\nglob 연산자는 테스트 중인 모든 항목을 tests 모듈로 가져오기 위해 테스트할 때 자주 사용됩니다. 11장의 테스트 작성 방법 섹션 에서 이에 대해 이야기하겠습니다. glob 연산자는 때때로 prelude 패턴의 일부로 사용되기도 합니다. 해당 패턴에 대한 자세한 내용은 표준 라이브러리 문서를 참조하십시오.\n\n모듈을 다른 파일로 분리\n지금까지 이 장의 모든 예제는 하나의 파일에 여러 모듈을 정의했습니다. 모듈이 커지면 해당 정의를 별도의 파일로 이동하여 코드를 더 쉽게 탐색할 수 있습니다.\n예를 들어, 여러 식당 모듈이 있는 Listing 7-17의 코드부터 시작해 봅시다. 크레이트 루트 파일에 모든 모듈을 정의하는 대신 모듈을 파일로 추출합니다. 이 경우 크레이트 루트 파일은 src/lib.rs 이지만 이 절차는 크레이트 루트 파일이 src/main.rs 인 바이너리 크레이트에서도 작동합니다.\n먼저 front_of_house 모듈을 자체 파일로 추출합니다. front_of_house 모듈의 중괄호 안에 있는 코드를 제거하고 mod front_of_house;만 남깁니다. 선언, 그래서 src/lib.rs는 목록 7-21에 표시된 코드를 포함합니다. 목록 7-22에서 src/front_of_house.rs 파일을 생성할 때까지는 컴파일되지 않습니다.\n파일 이름: src/lib.rs\nmod front_of_house;\n\npub use crate::front_of_house::hosting;\n\npub fn eat_at_restaurant() {\n    hosting::add_to_waitlist();\n}\n\nListing 7-21: 본문이 src/front_of_house.rs 에 있는 front_of_house 모듈 선언\n다음으로 목록 7-22에 표시된 것처럼 중괄호 안에 있던 코드를 src/front_of_house.rs 라는 새 파일에 배치합니다. 컴파일러는 front_of_house라는 이름의 크레이트 루트에서 모듈 선언을 발견했기 때문에 이 파일을 살펴봐야 한다는 것을 압니다.\n파일 이름: src/front_of_house.rs\npub mod hosting {\n    pub fn add_to_waitlist() {}\n}\n\n목록 7-22: src/front_of_house.rs 의 front_of_house 모듈 내부 정의\n모듈 트리에서 한 번만 mod 선언을 사용하여 파일을 로드하면 됩니다. 컴파일러가 파일이 프로젝트의 일부임을 알게 되면(그리고 모듈 트리에서 mod 문을 넣은 위치로 인해 코드가 상주하는 위치를 알게 되면) 프로젝트의 다른 파일은 다음을 사용하여 로드된 파일의 코드를 참조해야 합니다. 모듈 트리에서 항목을 참조하기 위한 경로 섹션 에서 설명한 대로 선언된 위치의 경로입니다. 즉, mod는 다른 프로그래밍 언어에서 볼 수 있는 include 작업이 아닙니다.\n다음으로 호스팅 모듈을 자체 파일로 추출합니다. hosting은 루트 모듈이 아닌 front_of_house의 하위 모듈이기 때문에 프로세스가 약간 다릅니다. 호스팅을 위한 파일을 모듈 트리의 조상 이름을 따서 명명될 새 디렉토리(이 경우 src/front_of_house/ ) 에 배치합니다.\n호스팅 이동을 시작하려면 호스팅 모듈의 선언만 포함하도록 src/front_of_house.rs를 변경합니다.\n파일 이름: src/front_of_house.rs\npub mod hosting;\n\n그런 다음 hosting 모듈에서 만든 정의를 포함하기 위해 src/front_of_house 디렉터리와 hosting.rs 파일을 만듭니다.\n파일 이름: src/front_of_house/hosting.rs\npub fn add_to_waitlist() {}\n\n대신에 hosting.rs를 src 디렉토리 에 넣으면 컴파일러는 hosting.rs 코드가 front_of_house 모듈의 자식으로 선언되지 않고 크레이트 루트에 선언된 hosting 모듈에 있을 것으로 예상합니다. 어떤 모듈의 코드를 검사할 파일에 대한 컴파일러의 규칙은 디렉토리와 파일이 모듈 트리와 더 밀접하게 일치함을 의미합니다.\n\n대체 파일 경로\n지금까지 Rust 컴파일러가 사용하는 가장 관용적인 파일 경로를 다루었지만 Rust는 이전 스타일의 파일 경로도 지원합니다. 크레이트 루트에 선언된 front_of_house라는 모듈의 경우 컴파일러는 다음에서 모듈의 코드를 찾습니다.\n\nsrc/front_of_house.rs (우리가 다룬 것)\nsrc/front_of_house/mod.rs (이전 스타일, 여전히 지원되는 경로)\n\nfront_of_house의 하위 모듈인 hosting이라는 모듈의 경우 컴파일러는 다음에서 모듈의 코드를 찾습니다.\n\nsrc/front_of_house/hosting.rs (우리가 다룬 것)\nsrc/front_of_house/hosting/mod.rs (이전 스타일, 계속 지원되는 경로)\n\n동일한 모듈에 대해 두 스타일을 모두 사용하면 컴파일러 오류가 발생합니다. 동일한 프로젝트의 서로 다른 모듈에 대해 두 가지 스타일을 혼합하여 사용할 수 있지만 프로젝트를 탐색하는 사람들에게 혼동을 줄 수 있습니다.\nmod.rs 라는 이름의 파일을 사용하는 스타일의 주요 단점은 프로젝트가 mod.rs 라는 이름의 많은 파일로 끝날 수 있다는 것입니다. 이는 편집기에서 파일을 동시에 열 때 혼동될 수 있습니다.\n\n각 모듈의 코드를 별도의 파일로 옮겼으며 모듈 트리는 그대로 유지됩니다. eat_at_restaurant의 함수 호출은 정의가 다른 파일에 있더라도 수정하지 않고 작동합니다. 이 기술을 사용하면 모듈의 크기가 커짐에 따라 모듈을 새 파일로 이동할 수 있습니다.\nsrc/lib.rs 의 pub use crate::front_of_house::hosting 문도 변경되지 않았으며 use는 크레이트의 일부로 컴파일되는 파일에 영향을 미치지 않습니다. mod 키워드는 모듈을 선언하고 Rust는 해당 모듈에 들어가는 코드의 모듈과 동일한 이름을 가진 파일을 찾습니다.\n요약\nRust를 사용하면 패키지를 여러 크레이트로 분할하고 크레이트를 모듈로 분할하여 한 모듈에 정의된 항목을 다른 모듈에서 참조할 수 있습니다. 절대 또는 상대 경로를 지정하여 이를 수행할 수 있습니다. 이러한 경로는 use 문을 사용하여 범위로 가져올 수 있으므로 해당 범위에서 항목을 여러 번 사용하는 경우 더 짧은 경로를 사용할 수 있습니다. 모듈 코드는 기본적으로 비공개이지만 pub 키워드를 추가하여 정의를 공개할 수 있습니다.\n다음 장에서는 깔끔하게 정리된 코드에서 사용할 수 있는 표준 라이브러리의 일부 컬렉션 데이터 구조를 살펴보겠습니다.\n\n공통 컬렉션\nRust의 표준 라이브러리에는 collections 라는 매우 유용한 데이터 구조가 많이 포함되어 있습니다. 대부분의 다른 데이터 유형은 하나의 특정 값을 나타내지만 컬렉션에는 여러 값이 포함될 수 있습니다. 기본 제공 배열 및 튜플 유형과 달리 이러한 컬렉션이 가리키는 데이터는 힙에 저장됩니다. 즉, 데이터 양은 컴파일 타임에 알 필요가 없으며 프로그램 실행에 따라 늘어나거나 줄어들 수 있습니다. 컬렉션 종류마다 기능과 비용이 다르며 현재 상황에 적합한 컬렉션을 선택하는 것은 시간이 지남에 따라 발전하게 될 기술입니다. 이 장에서는 Rust 프로그램에서 매우 자주 사용되는 세 가지 모음에 대해 논의할 것입니다.\n\n벡터 를 사용하면 가변 개수의 값을 서로 옆에 저장할 수 있습니다.\n문자열 은 문자 모음입니다. 앞에서 문자열 유형에 대해 언급했지만 이 장에서는 이에 대해 자세히 설명합니다.\n해시 맵을 사용 하면 값을 특정 키와 연결할 수 있습니다. map 이라는 보다 일반적인 데이터 구조의 특정 구현입니다.\n\n표준 라이브러리에서 제공하는 다른 종류의 컬렉션에 대해 알아보려면 설명서를 참조하십시오 .\n벡터, 문자열 및 해시 맵을 만들고 업데이트하는 방법과 각 항목을 특별하게 만드는 방법에 대해 설명합니다.\n\n벡터를 사용하여 값 목록 저장\n우리가 살펴볼 첫 번째 컬렉션 유형은 Vec*, 벡터* 라고도 합니다. 벡터를 사용하면 모든 값을 메모리에 나란히 배치하는 단일 데이터 구조에 둘 이상의 값을 저장할 수 있습니다. 벡터는 동일한 유형의 값만 저장할 수 있습니다. 벡터는 다음과 같은 경우에 유용합니다. 파일의 텍스트 줄이나 장바구니의 항목 가격과 같은 항목 목록입니다.\n새 벡터 만들기\n새로운 빈 벡터를 생성하기 위해 목록 8-1에 표시된 것처럼 Vec::new 함수를 호출합니다.\n    let v: Vec&lt;i32&gt; = Vec::new();\n\n목록 8-1: i32 유형의 값을 담을 새 빈 벡터 만들기\n여기에 유형 주석을 추가했습니다. 우리가 이 벡터에 어떤 값도 삽입하지 않기 때문에 Rust는 우리가 어떤 종류의 요소를 저장하려고 하는지 알지 못합니다. 이것은 중요한 포인트입니다. 벡터는 제네릭을 사용하여 구현됩니다. 10장에서 고유한 유형으로 제네릭을 사용하는 방법을 다룰 것입니다. 지금은 Vec 표준 라이브러리에서 제공하는 유형은 모든 유형을 보유할 수 있습니다. 특정 유형을 보유하기 위해 벡터를 만들 때 꺾쇠 괄호 안에 유형을 지정할 수 있습니다. Listing 8-1에서 Rust에게 Vec의 v는 i32 유형의 요소를 보유합니다.\n더 자주 Vec 초기 값을 사용하면 Rust는 저장하려는 값의 유형을 추론하므로 이 유형 주석을 거의 수행할 필요가 없습니다. Rust는 vec! 매크로를 편리하게 제공하며, 이 매크로는 사용자가 지정한 값을 보유하는 새 벡터를 생성합니다. . 목록 8-2는 새로운 Vec[는 값 1, 2 및 3을 포함합니다. 정수 유형은 i32입니다. 3장의 데이터 유형](https://doc.rust-lang.org/book/ch03-02-data-types.html#data-types) 섹션 에서 논의한 것처럼 이것이 기본 정수 유형이기 때문입니다.\n    let v = vec![1, 2, 3];\n\n목록 8-2: 값을 포함하는 새 벡터 만들기\n초기 i32 값을 제공했기 때문에 Rust는 v의 유형이 Vec임을 추론할 수 있습니다.`, 타입 어노테이션은 필요하지 않습니다. 다음으로 벡터를 수정하는 방법을 살펴보겠습니다.\n벡터 업데이트\n벡터를 생성한 다음 여기에 요소를 추가하려면 Listing 8-3과 같이 push 방법을 사용할 수 있습니다.\n    let mut v = Vec::new();\n\n    v.push(5);\n    v.push(6);\n    v.push(7);\n    v.push(8);\n\nListing 8-3: push 방법을 사용하여 벡터에 값 추가\n모든 변수와 마찬가지로 값을 변경하려면 3장에서 설명한 것처럼 mut 키워드를 사용하여 변경 가능하게 만들어야 합니다. 내부에 배치하는 숫자는 모두 i32 유형이고 Rust 데이터에서 이것을 추론하므로 Vec이 필요하지 않습니다.` 주석.\n벡터의 요소 읽기\n벡터에 저장된 값을 참조하는 방법에는 인덱싱을 통하거나 get 메서드를 사용하는 두 가지 방법이 있습니다. 다음 예제에서는 명확성을 높이기 위해 이러한 함수에서 반환되는 값의 유형에 주석을 달았습니다.\n목록 8-4는 인덱싱 구문과 get 방법을 사용하여 벡터의 값에 액세스하는 두 가지 방법을 보여줍니다.\n    let v = vec![1, 2, 3, 4, 5];\n\n    let third: &amp;i32 = &amp;v[2];\n    println!(`The third element is {third}`);\n\n    let third: Option&lt;&amp;i32&gt; = v.get(2);\n    match third {\n        Some(third) =&gt; println!(`The third element is {third}`),\n        None =&gt; println!(`There is no third element.`),\n    }\n\n목록 8-4: 인덱싱 구문 또는 get 메서드를 사용하여 벡터의 항목에 액세스\n여기에 몇 가지 세부 사항을 기록하십시오. 벡터는 0부터 시작하여 숫자로 인덱싱되기 때문에 인덱스 값 2를 사용하여 세 번째 요소를 얻습니다. &amp; 및 []를 사용하면 인덱스 값에 있는 요소에 대한 참조를 제공합니다. 인수로 전달된 인덱스와 함께 get 메서드를 사용하면 match와 함께 사용할 수 있는 Option&lt;&amp;T&gt;를 얻습니다.\nRust가 요소를 참조하는 이 두 가지 방법을 제공하는 이유는 기존 요소 범위 밖의 인덱스 값을 사용하려고 할 때 프로그램이 동작하는 방식을 선택할 수 있도록 하기 위함입니다. 예를 들어, 목록 8-5에 표시된 것처럼 5개 요소의 벡터가 있고 각 기술을 사용하여 인덱스 100의 요소에 액세스하려고 하면 어떤 일이 발생하는지 봅시다.\n    let v = vec![1, 2, 3, 4, 5];\n\n    let does_not_exist = &amp;v[100];\n    let does_not_exist = v.get(100);\n\n목록 8-5: 5개의 요소를 포함하는 벡터에서 인덱스 100의 요소에 액세스 시도\n이 코드를 실행할 때 첫 번째 [] 메서드는 존재하지 않는 요소를 참조하기 때문에 프로그램을 패닉 상태로 만듭니다. 이 방법은 벡터의 끝을 지나 요소에 액세스하려는 시도가 있는 경우 프로그램을 중단시키려는 경우에 가장 적합합니다.\nget 메서드에 벡터 외부에 있는 인덱스가 전달되면 당황하지 않고 None을 반환합니다. 벡터 범위를 벗어난 요소에 액세스하는 것이 정상적인 상황에서 가끔 발생할 수 있는 경우 이 방법을 사용합니다. 그러면 코드는 6장에서 설명한 대로 Some(&amp;element) 또는 없음을 처리하는 논리를 갖게 됩니다. 예를 들어 인덱스는 사람이 숫자를 입력하는 것에서 나올 수 있습니다. 사용자가 실수로 너무 큰 숫자를 입력하여 프로그램이 없음 값을 얻는 경우 사용자에게 현재 벡터에 몇 개의 항목이 있는지 알려주고 유효한 값을 입력할 수 있는 또 다른 기회를 제공할 수 있습니다. 오타로 인해 프로그램이 충돌하는 것보다 더 사용자 친화적일 것입니다!\n프로그램에 유효한 참조가 있는 경우 차용 검사기는 소유권 및 차용 규칙(4장에서 다룸)을 시행하여 이 참조 및 벡터 내용에 대한 다른 참조가 유효한지 확인합니다. 동일한 범위에서 가변 및 불변 참조를 가질 수 없다는 규칙을 상기하십시오. 이 규칙은 벡터의 첫 번째 요소에 대한 불변 참조를 보유하고 끝에 요소를 추가하려고 시도하는 목록 8-6에 적용됩니다. 이 프로그램은 나중에 함수에서 해당 요소를 참조하려고 하면 작동하지 않습니다.\n    let mut v = vec![1, 2, 3, 4, 5];\n\n    let first = &amp;v[0];\n\n    v.push(6);\n\n    println!(`The first element is: {first}`);\n\n목록 8-6: 항목에 대한 참조를 유지하면서 벡터에 요소 추가 시도\n이 코드를 컴파일하면 다음 오류가 발생합니다.\n$ cargo run\n   Compiling collections v0.1.0 (file:///projects/collections)\nerror[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable\n --&gt; src/main.rs:6:5\n  |\n4 |     let first = &amp;v[0];\n  |                  - immutable borrow occurs here\n5 |\n6 |     v.push(6);\n  |     ^^^^^^^^^ mutable borrow occurs here\n7 |\n8 |     println!(`The first element is: {first}`);\n  |                                      ----- immutable borrow later used here\n\nFor more information about this error, try `rustc --explain E0502`.\nerror: could not compile `collections` due to previous error\n\n목록 8-6의 코드는 제대로 작동하는 것처럼 보일 수 있습니다. 왜 첫 번째 요소에 대한 참조가 벡터의 끝에서 변경 사항에 관심을 가져야 합니까? 이 오류는 벡터가 작동하는 방식 때문입니다. 벡터가 메모리에서 서로 옆에 있는 값을 넣기 때문에 벡터 끝에 새 요소를 추가하려면 새 메모리를 할당하고 이전 요소를 새 공간에 복사해야 할 수 있습니다. 벡터가 현재 저장된 위치에 모든 요소를 나란히 놓을 공간이 충분하지 않습니다. 이 경우 첫 번째 요소에 대한 참조는 할당 해제된 메모리를 가리킵니다. 차용 규칙은 프로그램이 그러한 상황에서 종료되는 것을 방지합니다.\n\n참고: Vec의 구현 세부 사항에 대한 자세한 내용은` 유형, “The Rustonomicon” 참조 .\n\n벡터의 값에 대한 반복\n벡터의 각 요소에 차례로 액세스하려면 인덱스를 사용하여 한 번에 하나씩 액세스하는 대신 모든 요소를 반복합니다. 목록 8-7은 i32 값의 벡터에 있는 각 요소에 대한 불변 참조를 가져오고 인쇄하기 위해 for 루프를 사용하는 방법을 보여줍니다.\n    let v = vec![100, 32, 57];\n    for i in &amp;v {\n        println!(`{i}`);\n    }\n\n목록 8-7: for 루프를 사용하여 요소를 반복하여 벡터의 각 요소 인쇄\n모든 요소를 변경하기 위해 가변 벡터의 각 요소에 대한 가변 참조를 반복할 수도 있습니다. 목록 8-8의 for 루프는 각 요소에 50을 추가합니다.\n    let mut v = vec![100, 32, 57];\n    for i in &amp;mut v {\n        *i += 50;\n    }\n\n목록 8-8: 벡터의 요소에 대한 변경 가능한 참조에 대한 반복\n가변 참조가 참조하는 값을 변경하려면 += 연산자를 사용하기 전에 * 역참조 연산자를 사용하여 i의 값을 가져와야 합니다. 역참조 연산자에 대한 자세한 내용은 15장의 역참조 연산자를 사용하여 값에 대한 포인터 추적 섹션 에서 설명합니다.\n불변이든 가변이든 벡터를 반복하는 것은 빌림 검사기의 규칙 때문에 안전합니다. Listing 8-7 및 Listing 8-8의 for 루프 본문에서 항목을 삽입하거나 제거하려고 시도하면 Listing 8-6의 코드에서 얻은 것과 유사한 컴파일러 오류가 발생합니다. for 루프가 보유한 벡터에 대한 참조는 전체 벡터의 동시 수정을 방지합니다.\n열거형을 사용하여 여러 유형 저장\n벡터는 동일한 유형의 값만 저장할 수 있습니다. 이는 불편할 수 있습니다. 다양한 유형의 항목 목록을 저장해야 하는 사용 사례가 분명히 있습니다. 다행스럽게도 열거형의 변형은 동일한 열거형 유형으로 정의되므로 다른 유형의 요소를 나타내기 위해 하나의 유형이 필요할 때 열거형을 정의하고 사용할 수 있습니다!\n예를 들어 행의 일부 열에 정수, 일부 부동 소수점 숫자 및 일부 문자열이 포함된 스프레드시트의 행에서 값을 가져오고 싶다고 가정해 보겠습니다. 변형이 다른 값 유형을 보유할 열거형을 정의할 수 있으며 모든 열거형 변형은 동일한 유형, 즉 열거형으로 간주됩니다. 그런 다음 해당 열거형을 보유할 벡터를 생성할 수 있으므로 궁극적으로 다른 유형을 보유합니다. Listing 8-9에서 이를 증명했습니다.\n    enum SpreadsheetCell {\n        Int(i32),\n        Float(f64),\n        Text(String),\n    }\n\n    let row = vec![\n        SpreadsheetCell::Int(3),\n        SpreadsheetCell::Text(String::from(`blue`)),\n        SpreadsheetCell::Float(10.12),\n    ];\n\nListing 8-9: 하나의 벡터에 다른 유형의 값을 저장하는 enum 정의\nRust는 각 요소를 저장하는 데 필요한 힙의 메모리 양을 정확히 알기 위해 컴파일 시간에 벡터에 어떤 유형이 있는지 알아야 합니다. 또한 이 벡터에서 어떤 유형이 허용되는지 명시해야 합니다. Rust가 벡터가 어떤 유형이든 가질 수 있도록 허용했다면, 하나 이상의 유형이 벡터의 요소에 대해 수행되는 작업에서 오류를 일으킬 가능성이 있습니다. 열거형과 일치 표현식을 사용한다는 것은 6장에서 논의한 것처럼 Rust가 컴파일 타임에 가능한 모든 경우를 처리한다는 것을 의미합니다.\n프로그램이 벡터에 저장하기 위해 런타임에 얻을 수 있는 전체 유형 세트를 모른다면 enum 기술이 작동하지 않습니다. 대신 17장에서 다룰 특성 개체를 사용할 수 있습니다.\n벡터를 사용하는 가장 일반적인 방법에 대해 논의했으므로 Vec에 정의된 모든 유용한 방법에 대한 API 문서를 검토하십시오.예를 들어 push 외에도 pop 메서드는 마지막 요소를 제거하고 반환합니다.\n벡터를 삭제하면 요소가 삭제됨\n다른 구조체와 마찬가지로 벡터는 목록 8-10에 설명된 대로 범위를 벗어나면 해제됩니다.\n    {\n        let v = vec![1, 2, 3, 4];\n\n        // do stuff with v\n    } // &lt;- v goes out of scope and is freed here\n\nListing 8-10: 벡터와 해당 요소가 놓이는 위치 표시\n벡터가 삭제되면 모든 내용도 삭제됩니다. 즉, 보유하고 있는 정수가 정리됩니다. 차용 검사기는 벡터 자체가 유효한 동안에만 벡터 내용에 대한 참조가 사용되는지 확인합니다.\n다음 컬렉션 유형인 문자열로 이동하겠습니다!\n\nUTF-8로 인코딩된 텍스트를 문자열과 함께 저장\n4장에서 문자열에 대해 이야기했지만 이제 더 자세히 살펴보겠습니다. 새로운 Rustacean은 일반적으로 세 가지 이유의 조합으로 문자열에 집착합니다: 가능한 오류를 노출하는 Rust의 성향, 문자열은 많은 프로그래머가 인정하는 것보다 더 복잡한 데이터 구조, UTF-8입니다. 이러한 요소는 다른 프로그래밍 언어에서 왔을 때 어렵게 보일 수 있는 방식으로 결합됩니다.\n문자열은 바이트 모음으로 구현되고 해당 바이트가 텍스트로 해석될 때 유용한 기능을 제공하는 일부 메서드로 구현되기 때문에 모음의 맥락에서 문자열에 대해 논의합니다. 이 섹션에서는 생성, 업데이트 및 읽기와 같은 모든 컬렉션 유형이 갖는 문자열에 대한 작업에 대해 설명합니다. 또한 문자열이 다른 컬렉션과 다른 방식, 즉 사람과 컴퓨터가 문자열 데이터를 해석하는 방식의 차이로 인해 문자열에 대한 인덱싱이 복잡해지는 방식에 대해서도 설명합니다.\n문자열이란 무엇입니까?\n먼저 문자열 이라는 용어의 의미를 정의합니다. Rust는 핵심 언어에 단 하나의 문자열 유형을 가지고 있는데, 이는 일반적으로 차용된 형식 &amp;str에서 볼 수 있는 문자열 슬라이스 str입니다. 4장에서 다른 곳에 저장된 일부 UTF-8 인코딩 문자열 데이터에 대한 참조인 문자열 슬라이스에 대해 이야기했습니다. 예를 들어 문자열 리터럴은 프로그램의 바이너리에 저장되므로 문자열 조각입니다.\n핵심 언어로 코딩되지 않고 Rust의 표준 라이브러리에서 제공하는 문자열 유형은 확장 가능하고 변경 가능하며 소유된 UTF-8 인코딩 문자열 유형입니다. Rustacean이 Rust에서 문자열을 언급할 때, 그들은 문자열 또는 문자열 슬라이스 &amp;str 유형 중 하나를 참조할 수 있습니다. 이 섹션은 주로 문자열에 관한 것이지만 Rust의 표준 라이브러리에서 두 가지 유형이 많이 사용되며 문자열과 문자열 슬라이스는 모두 UTF-8로 인코딩됩니다.\n새 문자열 만들기\nVec에서 사용할 수 있는 많은 동일한 작업는 String과 함께 사용할 수 있습니다. String은 실제로 일부 추가 보증, 제한 및 기능이 있는 바이트 벡터 주위의 래퍼로 구현되기 때문입니다. Vec과 동일한 방식으로 작동하는 함수의 예입니다. 및 String은 목록 8-11에 표시된 것처럼 인스턴스를 생성하는 새 함수입니다.\n    let mut s = String::new();\n\n목록 8-11: 비어 있는 새 문자열 만들기\n이 줄은 데이터를 로드할 수 있는 s라는 새 빈 문자열을 만듭니다. 종종 문자열을 시작하려는 초기 데이터가 있습니다. 이를 위해 문자열 리터럴처럼 Display 특성을 구현하는 모든 유형에서 사용할 수 있는 to_string 메서드를 사용합니다. 목록 8-12는 두 가지 예를 보여줍니다.\n    let data = `initial contents`;\n\n    let s = data.to_string();\n\n    // the method also works on a literal directly:\n    let s = `initial contents`.to_string();\n\n목록 8-12: to_string 메서드를 사용하여 문자열 리터럴에서 문자열 생성\n이 코드는 초기 내용을 포함하는 문자열을 생성합니다.\n문자열 리터럴에서 문자열을 생성하기 위해 String::from 함수를 사용할 수도 있습니다. 목록 8-13의 코드는 to_string을 사용하는 목록 8-12의 코드와 동일합니다.\n    let s = String::from(`initial contents`);\n\nListing 8-13: String::from 함수를 사용하여 문자열 리터럴에서 String 생성\n문자열은 매우 많은 용도로 사용되기 때문에 문자열에 대해 다양한 일반 API를 사용하여 많은 옵션을 제공할 수 있습니다. 그들 중 일부는 중복되는 것처럼 보일 수 있지만 모두 자리가 있습니다! 이 경우 String::from과 to_string은 동일한 작업을 수행하므로 어떤 것을 선택하느냐는 스타일과 가독성의 문제입니다.\n문자열은 UTF-8로 인코딩되어 있으므로 Listing 8-14와 같이 적절하게 인코딩된 데이터를 문자열에 포함할 수 있습니다.\n    let hello = String::from(`السلام عليكم`);\n    let hello = String::from(`Dobrý den`);\n    let hello = String::from(`Hello`);\n    let hello = String::from(`שָׁלוֹם`);\n    let hello = String::from(`नमस्ते`);\n    let hello = String::from(`こんにちは`);\n    let hello = String::from(`안녕하세요`);\n    let hello = String::from(`你好`);\n    let hello = String::from(`Olá`);\n    let hello = String::from(`Здравствуйте`);\n    let hello = String::from(`Hola`);\n\nListing 8-14: 다양한 언어로 된 인사말을 문자열에 저장하기\n이들은 모두 유효한 문자열 값입니다.\n문자열 업데이트\n문자열은 Vec의 내용과 마찬가지로 크기가 커지고 내용이 변경될 수 있습니다., 더 많은 데이터를 푸시하면 추가로 +연산자 또는format!매크로를 사용하여문자열` 값을 연결할 수 있습니다.\npush_str 및 push를 사용하여 문자열에 추가\nListing 8-15와 같이 문자열 조각을 추가하기 위해 push_str 메서드를 사용하여 문자열을 늘릴 수 있습니다.\n    let mut s = String::from(`foo`);\n    s.push_str(`bar`);\n\n목록 8-15: push_str 메서드를 사용하여 문자열 슬라이스를 문자열에 추가\n이 두 줄 뒤에 s는 foobar를 포함합니다. push_str 메서드는 매개변수의 소유권을 반드시 갖고 싶지 않기 때문에 문자열 슬라이스를 사용합니다. 예를 들어 Listing 8-16의 코드에서 s1에 내용을 추가한 후 s2를 사용할 수 있기를 원합니다.\n    let mut s1 = String::from(`foo`);\n    let s2 = `bar`;\n    s1.push_str(s2);\n    println!(`s2 is {s2}`);\n\n목록 8-16: 문자열에 내용을 추가한 후 문자열 슬라이스 사용\npush_str 메서드가 s2의 소유권을 가져간 경우 마지막 줄에 해당 값을 인쇄할 수 없습니다. 그러나 이 코드는 예상대로 작동합니다!\n푸시 방법은 단일 문자를 매개변수로 사용하여 문자열에 추가합니다. Listing 8-17은 push 메소드를 사용하여 문자 l을 String에 추가합니다.\n    let mut s = String::from(`lo`);\n    s.push('l');\n\n목록 8-17: push를 사용하여 문자열 값에 문자 하나 추가\n결과적으로 s에는 lol이 포함됩니다.\n+ 연산자 또는 형식! 매크로\n종종 두 개의 기존 문자열을 결합하고 싶을 것입니다. 그렇게 하는 한 가지 방법은 목록 8-18에 표시된 것처럼 + 연산자를 사용하는 것입니다.\n    let s1 = String::from(`Hello, `);\n    let s2 = String::from(`world!`);\n    let s3 = s1 + &amp;s2; // note s1 has been moved here and can no longer be used\n\nListing 8-18: + 연산자를 사용하여 두 개의 String 값을 새로운 String 값으로 결합\n문자열 s3에는 Hello, world!가 포함됩니다. 추가 후 s1이 더 이상 유효하지 않은 이유와 s2에 대한 참조를 사용한 이유는 + 연산자를 사용할 때 호출되는 메서드의 시그니처와 관련이 있습니다. + 연산자는 서명이 다음과 같은 추가 방법을 사용합니다.\nfn add(self, s: &amp;str) -&gt; String {\n\n표준 라이브러리에서 제네릭 및 관련 유형을 사용하여 정의된 추가를 볼 수 있습니다. 여기서 우리는 문자열 값으로 이 메서드를 호출할 때 발생하는 구체적인 유형으로 대체했습니다. 10장에서 제네릭에 대해 논의할 것입니다. 이 서명은 + 연산자의 까다로운 부분을 이해하는 데 필요한 단서를 제공합니다.\n첫째, s2에는 &amp;가 있습니다. 즉, 첫 번째 문자열에 두 번째 문자열의 참조를 추가한다는 의미입니다. 이는 add 함수의 s 매개변수 때문입니다. &amp;str만 String에 추가할 수 있습니다. 두 개의 문자열 값을 함께 추가할 수 없습니다. 하지만 잠깐만요. &amp;s2의 유형은 add에 대한 두 번째 매개변수에 지정된 &amp;str이 아니라 &amp;String입니다. 그렇다면 Listing 8-18이 컴파일되는 이유는 무엇입니까?\nadd 호출에서 &amp;s2를 사용할 수 있는 이유는 컴파일러가 &amp;String 인수를 &amp;str로 강제 할 수 있기 때문입니다. 우리가 add 메소드를 호출할 때, Rust는 여기서 &amp;s2를 &amp;s2[..]로 바꾸는 역참조 강제를 사용합니다. 15장에서 역참조 강제에 대해 더 자세히 논의할 것입니다. add는 s 매개변수의 소유권을 가지지 않기 때문에 s2는 이 작업 후에도 여전히 유효한 문자열입니다.\n둘째, 서명에서 add가 self의 소유권을 갖는 것을 볼 수 있습니다. self에는 &amp;가 없기 때문입니다. 이는 Listing 8-18의 s1이 add 호출로 이동되고 그 이후에는 더 이상 유효하지 않음을 의미합니다. 따라서 let s3 = s1 + &amp;s2; 두 문자열을 모두 복사하고 새 문자열을 만드는 것처럼 보이지만 이 문은 실제로 s1의 소유권을 가져오고 s2 내용의 복사본을 추가한 다음 결과의 소유권을 반환합니다. 즉, 복사를 많이 하는 것처럼 보이지만 그렇지 않습니다. 구현은 복사보다 효율적입니다.\n여러 문자열을 연결해야 하는 경우 + 연산자의 동작이 다루기 어려워집니다.\n    let s1 = String::from(`tic`);\n    let s2 = String::from(`tac`);\n    let s3 = String::from(`toe`);\n\n    let s = s1 + `-` + &amp;s2 + `-` + &amp;s3;\n\n이 시점에서 s는 tic-tac-toe가 됩니다. 모든 + 및 ``` 문자를 사용하면 무슨 일이 일어나고 있는지 보기가 어렵습니다. 더 복잡한 문자열 결합을 위해 대신 포맷!을 사용할 수 있습니다. 매크로:\n    let s1 = String::from(`tic`);\n    let s2 = String::from(`tac`);\n    let s3 = String::from(`toe`);\n\n    let s = format!(`{s1}-{s2}-{s3}`);\n\n이 코드는 또한 s를 tic-tac-toe로 설정합니다. 포맷! 매크로는 println!처럼 작동하지만 출력을 화면에 인쇄하는 대신 내용이 포함된 문자열을 반환합니다. 포맷!을 사용하는 코드 버전 훨씬 읽기 쉽고 형식! 매크로는 이 호출이 해당 매개변수의 소유권을 가지지 않도록 참조를 사용합니다.\n문자열로 인덱싱\n다른 많은 프로그래밍 언어에서 인덱스로 참조하여 문자열의 개별 문자에 액세스하는 것은 유효하고 일반적인 작업입니다. 그러나 Rust에서 인덱싱 구문을 사용하여 문자열의 일부에 액세스하려고 하면 오류가 발생합니다. Listing 8-19의 유효하지 않은 코드를 고려하십시오.\n    let s1 = String::from(`hello`);\n    let h = s1[0];\n\nListing 8-19: 문자열로 인덱싱 구문 사용 시도\n이 코드는 다음 오류를 발생시킵니다.\n$ cargo run\n   Compiling collections v0.1.0 (file:///projects/collections)\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n --&gt; src/main.rs:3:13\n  |\n3 |     let h = s1[0];\n  |             ^^^^^ `String` cannot be indexed by `{integer}`\n  |\n  = help: the trait `Index&lt;{integer}&gt;` is not implemented for `String`\n  = help: the following other types implement trait `Index&lt;Idx&gt;`:\n            &lt;String as Index&lt;RangeFrom&lt;usize&gt;&gt;&gt;\n            &lt;String as Index&lt;RangeFull&gt;&gt;\n            &lt;String as Index&lt;RangeInclusive&lt;usize&gt;&gt;&gt;\n            &lt;String as Index&lt;RangeTo&lt;usize&gt;&gt;&gt;\n            &lt;String as Index&lt;RangeToInclusive&lt;usize&gt;&gt;&gt;\n            &lt;String as Index&lt;std::ops::Range&lt;usize&gt;&gt;&gt;\n\nFor more information about this error, try `rustc --explain E0277`.\nerror: could not compile `collections` due to previous error\n\n오류와 메모는 이야기를 말해줍니다. Rust 문자열은 인덱싱을 지원하지 않습니다. 하지만 왜 안돼? 이 질문에 답하기 위해 우리는 Rust가 문자열을 메모리에 저장하는 방법을 논의할 필요가 있습니다.\n내부 대표\n문자열은 Vec에 대한 래퍼입니다.`. Listing 8-14에서 적절하게 인코딩된 UTF-8 예제 문자열 중 일부를 살펴보겠습니다. 먼저 다음과 같습니다.\n    let hello = String::from(`Hola`);\n\n이 경우 len은 4가 됩니다. 즉, 문자열 Hola를 저장하는 벡터의 길이는 4바이트입니다. 이러한 각 문자는 UTF-8로 인코딩될 때 1바이트를 사용합니다. 그러나 다음 줄은 당신을 놀라게 할 수 있습니다. (이 문자열은 아라비아 숫자 3이 아닌 대문자 키릴 문자 Ze로 시작합니다.)\n    let hello = String::from(`Здравствуйте`);\n\n문자열의 길이를 묻는 질문에 12라고 답할 수 있습니다. 사실 Rust의 대답은 24입니다. UTF-8로 Здравствуйте를 인코딩하는 데 걸리는 바이트 수입니다. 해당 문자열의 각 유니코드 스칼라 값은 2바이트의 저장 공간을 차지하기 때문입니다. . 따라서 문자열의 바이트에 대한 인덱스가 항상 유효한 유니코드 스칼라 값과 상관되지는 않습니다. 시연을 위해 다음과 같은 잘못된 Rust 코드를 고려하십시오.\nlet hello = `Здравствуйте`;\nlet answer = &amp;hello[0];\n\n당신은 이미 대답이 첫 글자인 З가 아니라는 것을 알고 있습니다. UTF-8로 인코딩하면 З의 첫 번째 바이트는 208이고 두 번째 바이트는 151이므로 answer는 실제로 208이어야 하지만 208은 유효하지 않습니다. 캐릭터 자체. 208을 반환하는 것은 사용자가 이 문자열의 첫 번째 문자를 요청한 경우 원하는 것이 아닐 가능성이 높습니다. 그러나 이것은 Rust가 바이트 인덱스 0에 있는 유일한 데이터입니다. 사용자는 일반적으로 문자열에 라틴 문자만 포함되어 있어도 바이트 값이 반환되는 것을 원하지 않습니다. 바이트 값을 반환하면 h가 아니라 104를 반환합니다.\n그렇다면 대답은 예상치 못한 값을 반환하고 즉시 발견되지 않을 수 있는 버그를 유발하지 않기 위해 Rust가 이 코드를 전혀 컴파일하지 않고 개발 프로세스 초기에 오해를 방지한다는 것입니다.\n바이트 및 스칼라 값과 문자소 클러스터! 어머!\nUTF-8에 대한 또 다른 요점은 실제로 Rust의 관점에서 문자열을 보는 세 가지 관련 방법이 있다는 것입니다: 바이트, 스칼라 값 및 문자소 클러스터(우리가 문자라고 부르는 것에 가장 가까운 것 ) .\nDevanagari 스크립트에 쓰여진 힌디어 단어 namaste를 보면 다음과 같이 u8 값의 벡터로 저장됩니다.\n[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,\n224, 165, 135]\n\n그것은 18바이트이며 컴퓨터가 궁극적으로 이 데이터를 저장하는 방법입니다. Rust의 char 유형인 유니코드 스칼라 값으로 보면 해당 바이트는 다음과 같습니다.\n['न', 'म', 'स', '्', 'त', 'े']\n\n여기에는 6개의 char 값이 있지만 네 번째와 여섯 번째는 문자가 아닙니다. 자체적으로 의미가 없는 분음 부호입니다. 마지막으로, 그것들을 문자소 클러스터로 보면 힌디어 단어를 구성하는 4개의 문자라고 부르는 것을 얻을 수 있습니다.\n[`न`, `म`, `स्`, `ते`]\n\nRust는 컴퓨터가 저장하는 원시 문자열 데이터를 해석하는 다양한 방법을 제공하므로 데이터가 어떤 인간 언어로 되어 있는지에 관계없이 각 프로그램이 필요한 해석을 선택할 수 있습니다.\nRust가 문자를 얻기 위해 문자열로 색인하는 것을 허용하지 않는 마지막 이유는 색인 작업이 항상 일정한 시간(O(1))이 걸릴 것으로 예상되기 때문입니다. 그러나 문자열로 성능을 보장하는 것은 불가능합니다. 왜냐하면 Rust는 얼마나 많은 유효한 문자가 있는지 확인하기 위해 내용을 처음부터 인덱스까지 살펴봐야 하기 때문입니다.\n문자열 슬라이싱\n문자열 인덱싱 작업의 반환 유형(바이트 값, 문자, 문자소 클러스터 또는 문자열 슬라이스)이 무엇인지 명확하지 않기 때문에 문자열로 인덱싱하는 것은 좋지 않은 생각인 경우가 많습니다. 문자열 슬라이스를 생성하기 위해 인덱스를 사용해야 한다면 Rust는 더 구체적으로 지정하도록 요청합니다.\n단일 숫자와 함께 []를 사용하여 인덱싱하는 대신 범위와 함께 []를 사용하여 특정 바이트를 포함하는 문자열 슬라이스를 만들 수 있습니다.\nlet hello = `Здравствуйте`;\n\nlet s = &amp;hello[0..4];\n\n여기서 s는 문자열의 처음 4바이트를 포함하는 &amp;str입니다. 앞서 우리는 이러한 각 문자가 2바이트이며 s가 Зд가 됨을 의미한다고 언급했습니다.\n&amp;hello[0..1]과 같은 것으로 문자 바이트의 일부만 슬라이스하려고 하면 Rust는 벡터에서 유효하지 않은 인덱스에 액세스하는 것과 같은 방식으로 런타임에 패닉을 일으킬 것입니다.\n$ cargo run\n   Compiling collections v0.1.0 (file:///projects/collections)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.43s\n     Running `target/debug/collections`\nthread 'main' panicked at 'byte index 1 is not a char boundary; it is inside 'З' (bytes 0..2) of `Здравствуйте`', src/main.rs:4:14\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\n범위를 사용하여 스트링 슬라이스를 만들면 프로그램이 중단될 수 있으므로 주의해야 합니다.\n문자열 반복 방법\n문자열 조각에서 작동하는 가장 좋은 방법은 문자 또는 바이트를 원하는지 여부를 명시하는 것입니다. 개별 유니코드 스칼라 값의 경우 chars 메서드를 사용합니다. Зд에서 chars를 호출하면 char 유형의 두 값을 분리하고 반환하며 결과를 반복하여 각 요소에 액세스할 수 있습니다.\nfor c in `Зд`.chars() {\n    println!(`{c}`);\n}\n\n이 코드는 다음을 인쇄합니다.\nЗ\nд\n\n또는 bytes 메서드는 도메인에 적합할 수 있는 각 원시 바이트를 반환합니다.\nfor b in `Зд`.bytes() {\n    println!(`{b}`);\n}\n\n이 코드는 이 문자열을 구성하는 4바이트를 인쇄합니다.\n208\n151\n208\n180\n\n그러나 유효한 유니코드 스칼라 값은 1바이트 이상으로 구성될 수 있음을 기억하십시오.\nDevanagari 스크립트를 사용하여 문자열에서 문자소 클러스터를 가져오는 것은 복잡하므로 이 기능은 표준 라이브러리에서 제공되지 않습니다. 필요한 기능인 경우 crates.io 에서 크레이트를 사용할 수 있습니다.\n문자열은 그렇게 간단하지 않습니다\n요약하면 문자열은 복잡합니다. 다른 프로그래밍 언어는 이러한 복잡성을 프로그래머에게 제시하는 방법에 대해 다른 선택을 합니다. Rust는 문자열 데이터의 올바른 처리를 모든 Rust 프로그램의 기본 동작으로 만들기로 선택했습니다. 이는 프로그래머가 UTF-8 데이터를 미리 처리하는 데 더 많은 생각을 해야 한다는 것을 의미합니다. 이러한 트레이드오프는 다른 프로그래밍 언어에서 명백한 것보다 더 많은 문자열의 복잡성을 드러내지만 개발 수명 주기 후반에 비ASCII 문자와 관련된 오류를 처리하지 않아도 됩니다.\n좋은 소식은 표준 라이브러리가 이러한 복잡한 상황을 올바르게 처리하는 데 도움이 되는 String 및 &amp;str 유형으로 구성된 많은 기능을 제공한다는 것입니다. 문자열에서 검색하기 위한 contains 및 문자열의 일부를 다른 문자열로 대체하기 위한 replace와 같은 유용한 메서드에 대한 설명서를 확인하십시오.\n조금 덜 복잡한 것으로 전환해 봅시다: 해시 맵!\n\n해시 맵에 연관된 값과 함께 키 저장\n공통 컬렉션의 마지막은 해시 맵 입니다. HashMap&lt;K, V&gt; 유형 은 이러한 키와 값을 메모리에 배치하는 방법을 결정하는 해싱 함수를 사용하여 K 유형의 키를 V 유형의 값에 대한 매핑을 저장합니다. 많은 프로그래밍 언어가 이러한 종류의 데이터 구조를 지원하지만 몇 가지 예를 들면 해시, 맵, 객체, 해시 테이블, 사전 또는 연관 배열과 같은 다른 이름을 사용하는 경우가 많습니다.\n해시 맵은 벡터와 마찬가지로 인덱스를 사용하지 않고 모든 유형의 키를 사용하여 데이터를 조회하려는 경우에 유용합니다. 예를 들어 게임에서 각 키가 팀의 이름이고 값이 각 팀의 점수인 해시 맵에서 각 팀의 점수를 추적할 수 있습니다. 팀 이름이 주어지면 점수를 검색할 수 있습니다.\n이 섹션에서는 해시 맵의 기본 API를 살펴보겠지만 표준 라이브러리에서 HashMap&lt;K, V&gt;에 정의된 함수에는 더 많은 장점이 숨어 있습니다. 항상 그렇듯이 자세한 내용은 표준 라이브러리 문서를 확인하세요.\n새 해시 맵 생성\n빈 해시 맵을 만드는 한 가지 방법은 new를 사용하고 insert로 요소를 추가하는 것입니다. 목록 8-20에서 이름이 Blue 및 Yellow 인 두 팀의 점수를 추적하고 있습니다. 파란색 팀은 10점으로 시작하고 노란색 팀은 50점으로 시작합니다.\n    use std::collections::HashMap;\n\n    let mut scores = HashMap::new();\n\n    scores.insert(String::from(`Blue`), 10);\n    scores.insert(String::from(`Yellow`), 50);\n\n목록 8-20: 새 해시 맵 생성 및 일부 키와 값 삽입\n먼저 표준 라이브러리의 컬렉션 부분에서 HashMap을 사용해야 합니다. 세 가지 공통 컬렉션 중에서 가장 적게 사용되는 컬렉션이므로 서곡에서 자동으로 범위에 포함된 기능에 포함되지 않습니다. 해시 맵도 표준 라이브러리의 지원이 적습니다. 예를 들어 이를 구성하는 내장 매크로가 없습니다.\n벡터와 마찬가지로 해시 맵은 데이터를 힙에 저장합니다. 이 HashMap에는 String 유형의 키와 i32 유형의 값이 있습니다. 벡터와 마찬가지로 해시 맵은 동질적입니다. 모든 키는 서로 같은 유형이어야 하고 모든 값은 같은 유형이어야 합니다.\n해시 맵의 값에 액세스\n목록 8-21에 표시된 것처럼 get 메서드에 키를 제공하여 해시 맵에서 값을 가져올 수 있습니다.\n    use std::collections::HashMap;\n\n    let mut scores = HashMap::new();\n\n    scores.insert(String::from(`Blue`), 10);\n    scores.insert(String::from(`Yellow`), 50);\n\n    let team_name = String::from(`Blue`);\n    let score = scores.get(&amp;team_name).copied().unwrap_or(0);\n\n목록 8-21: 해시 맵에 저장된 Blue 팀의 점수에 액세스\n여기에서 점수는 파란색 팀과 관련된 값을 가지며 결과는 10이 됩니다. get 메서드는 Option&lt;&amp;V&gt;를 반환합니다. 해시 맵에 해당 키에 대한 값이 없으면 get은 None을 반환합니다. 이 프로그램은 옵션을 얻기 위해 복사됨을 호출하여 옵션을 처리합니다. 옵션&lt;&amp;i32&gt; 대신 unwrap_or를 사용하여 scores에 키에 대한 항목이 없는 경우 score를 0으로 설정합니다.\nfor 루프를 사용하여 벡터와 유사한 방식으로 해시 맵의 각 키/값 쌍을 반복할 수 있습니다.\n    use std::collections::HashMap;\n\n    let mut scores = HashMap::new();\n\n    scores.insert(String::from(`Blue`), 10);\n    scores.insert(String::from(`Yellow`), 50);\n\n    for (key, value) in &amp;scores {\n        println!(`{key}: {value}`);\n    }\n\n이 코드는 임의의 순서로 각 쌍을 인쇄합니다.\nYellow: 50\nBlue: 10\n\n해시 맵 및 소유권\ni32와 같이 복사 특성을 구현하는 유형의 경우 값이 해시 맵에 복사됩니다. 문자열과 같은 소유된 값의 경우 목록 8-22에 표시된 것처럼 값이 이동되고 해시 맵이 해당 값의 소유자가 됩니다.\n    use std::collections::HashMap;\n\n    let field_name = String::from(`Favorite color`);\n    let field_value = String::from(`Blue`);\n\n    let mut map = HashMap::new();\n    map.insert(field_name, field_value);\n    // field_name and field_value are invalid at this point, try using them and\n    // see what compiler error you get!\n\nListing 8-22: 키와 값이 삽입되면 해시 맵이 소유함을 보여줌\n변수 field_name 및 field_value가 삽입 호출로 해시 맵으로 이동된 후에는 사용할 수 없습니다.\n값에 대한 참조를 해시 맵에 삽입하면 값이 해시 맵으로 이동되지 않습니다. 참조가 가리키는 값은 적어도 해시 맵이 유효한 동안에는 유효해야 합니다. 10장의 수명이 있는 참조 유효성 검사 섹션 에서 이러한 문제에 대해 자세히 설명합니다.\n해시 맵 업데이트\n키와 값 쌍의 수는 증가할 수 있지만 각 고유 키는 한 번에 하나의 값만 연결할 수 있습니다(반대의 경우도 마찬가지입니다. 예를 들어 파란색 팀과 노란색 팀 모두  점수해시 맵).\n해시 맵의 데이터를 변경하려면 키에 이미 할당된 값이 있는 경우를 처리하는 방법을 결정해야 합니다. 이전 값을 완전히 무시하고 이전 값을 새 값으로 바꿀 수 있습니다. 이전 값을 유지하고 새 값을 무시하고 키에 이미 값이 없는 경우에만 새 값을 추가할 수 있습니다. 또는 이전 값과 새 값을 결합할 수 있습니다. 각 작업을 수행하는 방법을 살펴보겠습니다!\n값 덮어쓰기\n키와 값을 해시 맵에 삽입한 다음 동일한 키를 다른 값으로 삽입하면 해당 키와 연결된 값이 대체됩니다. Listing 8-23의 코드가 insert를 두 번 호출하더라도 Blue 팀의 키 값을 두 번 모두 삽입하기 때문에 해시 맵에는 하나의 키/값 쌍만 포함됩니다.\n    use std::collections::HashMap;\n\n    let mut scores = HashMap::new();\n\n    scores.insert(String::from(`Blue`), 10);\n    scores.insert(String::from(`Blue`), 25);\n\n    println!(`{:?}`, scores);\n\nListing 8-23: 저장된 값을 특정 키로 바꾸기\n이 코드는 {Blue: 25}를 인쇄합니다. 10의 원래 값을 덮어썼습니다.\n키가 없는 경우에만 키와 값 추가\n특정 키가 값과 함께 해시 맵에 이미 존재하는지 확인한 후 다음 조치를 취하는 것이 일반적입니다. 키가 해시 맵에 존재하는 경우 기존 값은 그대로 유지되어야 합니다. 키가 없으면 키와 값을 삽입합니다.\n해시 맵에는 확인하려는 키를 매개변수로 사용하는 항목이라는 특수 API가 있습니다. entry 메서드의 반환 값은 존재하거나 존재하지 않을 수 있는 값을 나타내는 Entry라는 열거형입니다. Yellow 팀의 키에 연결된 값이 있는지 확인하고 싶다고 가정해 보겠습니다. 그렇지 않은 경우 값 50을 삽입하고 Blue 팀에도 동일하게 삽입하려고 합니다. entry API를 사용하는 코드는 Listing 8-24와 같습니다.\n    use std::collections::HashMap;\n\n    let mut scores = HashMap::new();\n    scores.insert(String::from(`Blue`), 10);\n\n    scores.entry(String::from(`Yellow`)).or_insert(50);\n    scores.entry(String::from(`Blue`)).or_insert(50);\n\n    println!(`{:?}`, scores);\n\nListing 8-24: entry 메서드를 사용하여 키에 아직 값이 없는 경우에만 삽입\nEntry의 or_insert 메소드는 해당 Entry 키가 존재하는 경우 해당 Entry 키의 값에 대한 변경 가능한 참조를 반환하고, 그렇지 않은 경우 이 키의 새 값으로 매개변수를 삽입하고 변경 가능한 참조를 반환하도록 정의됩니다. 새로운 가치에. 이 기술은 논리를 직접 작성하는 것보다 훨씬 깨끗하며, 추가로 차용 검사기와 더 잘 작동합니다.\n목록 8-24의 코드를 실행하면 {Yellow: 50, Blue: 10}가 인쇄됩니다. entry에 대한 첫 번째 호출은 노란색 팀에 이미 값이 없기 때문에 값이 50인 노란색 팀의 키를 삽입합니다. entry에 대한 두 번째 호출은 Blue 팀이 이미 값 10을 가지고 있기 때문에 해시 맵을 변경하지 않습니다.\n이전 값을 기반으로 값 업데이트\n해시 맵의 또 다른 일반적인 사용 사례는 키 값을 조회한 다음 이전 값을 기반으로 업데이트하는 것입니다. 예를 들어 Listing 8-25는 각 단어가 일부 텍스트에 나타나는 횟수를 세는 코드를 보여줍니다. 단어를 키로 사용하는 해시 맵을 사용하고 해당 단어를 본 횟수를 추적하기 위해 값을 증가시킵니다. 단어를 처음 본 경우 먼저 값 0을 삽입합니다.\n    use std::collections::HashMap;\n\n    let text = `hello world wonderful world`;\n\n    let mut map = HashMap::new();\n\n    for word in text.split_whitespace() {\n        let count = map.entry(word).or_insert(0);\n        *count += 1;\n    }\n\n    println!(`{:?}`, map);\n\nListing 8-25: 단어와 카운트를 저장하는 해시 맵을 사용하여 단어의 발생 횟수 세기\n이 코드는 {world: 2, hello: 1, wonderful: 1}을 인쇄합니다. 동일한 키/값 쌍이 다른 순서로 인쇄된 것을 볼 수 있습니다. 해시 맵에서 값 액세스 섹션에서 해시 맵을 반복하는 것이 임의의 순서로 발생한다는 것을 기억하십시오.\nsplit_whitespace 메서드는 text 값의 공백으로 구분된 하위 슬라이스에 대한 반복자를 반환합니다. or_insert 메서드는 지정된 키의 값에 대한 변경 가능한 참조(&amp;mut V)를 반환합니다. 여기에서 count 변수에 가변 참조를 저장하므로 해당 값에 할당하려면 먼저 별표(*)를 사용하여 count를 역참조해야 합니다. 변경 가능한 참조는 for 루프의 끝에서 범위를 벗어나므로 이러한 모든 변경은 안전하고 차용 규칙에 의해 허용됩니다.\n해싱 함수\n기본적으로 HashMap은 해시 테이블 1 과 관련된 서비스 거부(DoS) 공격에 대한 저항을 제공할 수 있는 SipHash 라는 해싱 기능을 사용합니다. 이것은 사용 가능한 가장 빠른 해싱 알고리즘은 아니지만 성능 저하와 함께 제공되는 더 나은 보안을 위한 트레이드 오프는 그만한 가치가 있습니다. 코드를 프로파일링하고 기본 해시 함수가 용도에 비해 너무 느린 경우 다른 해시를 지정하여 다른 함수로 전환할 수 있습니다. 해셔 는 BuildHasher 특성을 구현하는 유형입니다. 우리는 10장에서 트레이트와 이를 구현하는 방법에 대해 이야기할 것입니다. 처음부터 자신의 해셔를 구현할 필요는 없습니다. crates.io에는 많은 일반적인 해싱 알고리즘을 구현하는 해셔를 제공하는 다른 Rust 사용자가 공유하는 라이브러리가 있습니다.\n1\nhttps://en.wikipedia.org/wiki/SipHash\n요약\n벡터, 문자열 및 해시 맵은 데이터를 저장, 액세스 및 수정해야 할 때 프로그램에 필요한 많은 기능을 제공합니다. 다음은 해결하기 위해 갖추어야 할 몇 가지 연습입니다.\n\n정수 목록이 주어지면 벡터를 사용하고 목록의 중앙값(정렬할 때 중간 위치의 값)과 최빈값(가장 자주 발생하는 값, 여기에서 해시 맵이 도움이 됨)을 반환합니다.\n문자열을 돼지 라틴어로 변환합니다. 각 단어의 첫 자음이 단어의 끝으로 이동되고 “ay”가 추가되므로 “first”는 “irst-fay”가 됩니다. 모음으로 시작하는 단어는 대신 끝에 hay가 추가됩니다(apple은 apple-hay가 됨). UTF-8 인코딩에 대한 세부 사항을 명심하십시오!\n해시 맵과 벡터를 사용하여 사용자가 회사의 부서에 직원 이름을 추가할 수 있는 텍스트 인터페이스를 만듭니다. 예를 들어 엔지니어링에 Sally 추가 또는 영업에 Amir 추가가 있습니다. 그런 다음 사용자가 부서의 모든 사람 또는 부서별로 회사의 모든 사람 목록을 사전순으로 정렬하여 검색하도록 합니다.\n\n표준 라이브러리 API 문서는 이러한 연습에 도움이 될 벡터, 문자열 및 해시 맵에 있는 메서드를 설명합니다!\n작업이 실패할 수 있는 더 복잡한 프로그램에 들어가고 있으므로 오류 처리에 대해 논의하기에 완벽한 시기입니다. 다음에 그렇게 하겠습니다!\n\n오류 처리\n오류는 소프트웨어의 삶의 사실이므로 Rust에는 문제가 발생하는 상황을 처리하기 위한 여러 기능이 있습니다. 대부분의 경우 Rust는 코드가 컴파일되기 전에 오류 가능성을 인정하고 조치를 취할 것을 요구합니다. 이 요구 사항은 코드를 프로덕션에 배포하기 전에 오류를 발견하고 적절하게 처리하도록 하여 프로그램을 더욱 강력하게 만듭니다!\nRust는 오류를 복구 가능한 오류 와 복구 불가능한 오류의 두 가지 주요 범주로 그룹화합니다. 파일을 찾을 수 없음 오류와 같은 복구 가능한 오류의 경우 사용자에게 문제를 보고하고 작업을 다시 시도하려고 할 가능성이 높습니다. 복구할 수 없는 오류는 항상 버그의 증상입니다. 예를 들어 배열의 끝을 넘어선 위치에 액세스하려고 시도하므로 프로그램을 즉시 중지하려고 합니다.\n대부분의 언어는 이러한 두 종류의 오류를 구분하지 않고 예외와 같은 메커니즘을 사용하여 동일한 방식으로 처리합니다. 녹에는 예외가 없습니다. 대신 복구 가능한 오류에 대한 Result&lt;T, E&gt; 유형과 패닉! 프로그램에서 복구할 수 없는 오류가 발생하면 실행을 중지하는 매크로입니다. 이 장에서는 패닉! 먼저 Result&lt;T, E&gt; 값 반환에 대해 설명합니다. 또한 오류 복구를 시도할지 또는 실행을 중지할지 결정할 때 고려해야 할 사항을 살펴보겠습니다.\n복구할 수 없는 패닉! 오류\n때로는 코드에서 나쁜 일이 발생하고 이에 대해 할 수 있는 일이 없습니다. 이러한 경우 Rust는 패닉! 매크로. 실제로 패닉을 일으키는 방법에는 두 가지가 있습니다. 코드를 패닉 상태로 만드는 작업(예: 끝을 지나 배열에 액세스)을 수행하거나 패닉!을 명시적으로 호출하는 것입니다. 매크로. 두 경우 모두 프로그램에 패닉이 발생합니다. 기본적으로 이러한 패닉은 실패 메시지를 인쇄하고, 풀고, 스택을 정리하고, 종료합니다. 환경 변수를 통해 패닉이 발생할 때 러스트가 호출 스택을 표시하도록 하여 패닉의 원인을 쉽게 추적할 수 있습니다.\n\n패닉에 대한 응답으로 스택 풀기 또는 중단\n기본적으로 패닉이 발생하면 프로그램은 풀기 시작합니다. 즉, Rust가 스택을 백업하고 만나는 각 함수에서 데이터를 정리합니다. 그러나, 이 걷기 및 청소는 많은 작업입니다. 따라서 Rust는 정리하지 않고 프로그램을 종료하는 즉시 중단 의 대안을 선택할 수 있습니다.\n프로그램이 사용하고 있던 메모리는 운영 체제에서 정리해야 합니다. 프로젝트에서 결과 바이너리를 가능한 한 작게 만들어야 하는 경우 Cargo.toml 파일 의 적절한 [profile] 섹션에 panic = 'abort'를 추가하여 패닉 시 해제에서 중단으로 전환할 수 있습니다. . 예를 들어 릴리스 모드에서 패닉 상태에서 중단하려면 다음을 추가하십시오.\n[profile.release]\npanic = 'abort'\n\n\n패닉! 간단한 프로그램에서:\n파일 이름: src/main.rs\nfn main() {\n    panic!(`crash and burn`);\n}\n\n프로그램을 실행하면 다음과 같이 표시됩니다.\n$ cargo run\n   Compiling panic v0.1.0 (file:///projects/panic)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.25s\n     Running `target/debug/panic`\nthread 'main' panicked at 'crash and burn', src/main.rs:2:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\n패닉! 마지막 두 줄에 포함된 오류 메시지가 발생합니다. 첫 번째 줄은 패닉 메시지와 소스 코드에서 패닉이 발생한 위치를 보여줍니다. src/main.rs:2:5 는 두 번째 줄, src/main.rs 파일의 다섯 번째 문자임을 나타냅니다.\n이 경우 표시된 줄은 코드의 일부이며 해당 줄로 이동하면 패닉! 매크로 호출. 다른 경우에는 패닉! 호출은 우리 코드가 호출하는 코드에 있을 수 있으며 오류 메시지에 의해 보고된 파일 이름과 줄 번호는 패닉! 매크로가 호출되지만 결국 패닉! 부르다. panic! 함수의 역추적을 사용할 수 있습니다. 문제를 일으키는 코드 부분을 파악하기 위해 전화가 왔습니다. 다음에 백트레이스에 대해 더 자세히 설명하겠습니다.\n패닉! 역추적\n다른 예를 살펴보고 패닉! 호출은 매크로를 직접 호출하는 코드가 아니라 코드의 버그 때문에 라이브러리에서 발생합니다. 목록 9-1에는 유효한 인덱스 범위를 벗어난 벡터의 인덱스에 액세스하려고 시도하는 코드가 있습니다.\n파일 이름: src/main.rs\nfn main() {\n    let v = vec![1, 2, 3];\n\n    v[99];\n}\n\n목록 9-1: 벡터의 끝을 넘어 요소에 액세스하려고 시도하면 패닉! 호출이 발생합니다.\n여기에서 우리는 벡터의 100번째 요소(인덱싱이 0에서 시작하기 때문에 인덱스 99에 있음)에 액세스하려고 시도하지만 벡터에는 3개의 요소만 있습니다. 이 상황에서 Rust는 당황할 것입니다. []를 사용하면 요소를 반환해야 하지만 유효하지 않은 인덱스를 전달하면 Rust가 반환할 수 있는 올바른 요소가 없습니다.\nC에서 데이터 구조의 끝을 넘어 읽으려는 시도는 정의되지 않은 동작입니다. 메모리가 해당 구조에 속하지 않더라도 데이터 구조의 해당 요소에 해당하는 메모리 위치에 있는 모든 것을 얻을 수 있습니다. 이를 버퍼 오버 읽기 라고 하며 공격자가 데이터 구조 뒤에 저장된 허용되지 않아야 하는 데이터를 읽는 방식으로 인덱스를 조작할 수 있는 경우 보안 취약성을 초래할 수 있습니다.\n이러한 종류의 취약성으로부터 프로그램을 보호하기 위해 존재하지 않는 인덱스에서 요소를 읽으려고 하면 Rust는 실행을 중지하고 계속 진행을 거부합니다. 그것을 시도하고 보자 :\n$ cargo run\n   Compiling panic v0.1.0 (file:///projects/panic)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.27s\n     Running `target/debug/panic`\nthread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', src/main.rs:4:5\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\n이 오류는 색인 99에 액세스하려고 시도하는 main.rs의 4번째 줄을 가리킵니다. 다음 줄은 RUST_BACKTRACE 환경 변수를 설정하여 오류의 원인이 된 정확한 역추적을 얻을 수 있음을 알려줍니다. 역 추적이 지점에 도달하기 위해 호출된 모든 함수의 목록입니다. Rust의 백트레이스는 다른 언어에서와 마찬가지로 작동합니다. 백트레이스를 읽는 핵심은 맨 위에서 시작하여 작성한 파일이 보일 때까지 읽는 것입니다. 그곳이 문제의 발원지입니다. 해당 지점 위의 줄은 코드가 호출한 코드입니다. 아래 줄은 코드를 호출한 코드입니다. 이러한 전후 줄에는 핵심 Rust 코드, 표준 라이브러리 코드 또는 사용 중인 크레이트가 포함될 수 있습니다. RUST_BACKTRACE 환경 변수를 0을 제외한 모든 값으로 설정하여 백트레이스를 가져오도록 합시다. Listing 9-2는 여러분이 보게 될 것과 유사한 출력을 보여줍니다.\n$ RUST_BACKTRACE=1 cargo run\nthread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', src/main.rs:4:5\nstack backtrace:\n   0: rust_begin_unwind\n             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/std/src/panicking.rs:584:5\n   1: core::panicking::panic_fmt\n             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/panicking.rs:142:14\n   2: core::panicking::panic_bounds_check\n             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/panicking.rs:84:5\n   3: &lt;usize as core::slice::index::SliceIndex&lt;[T]&gt;&gt;::index\n             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/slice/index.rs:242:10\n   4: core::slice::index::&lt;impl core::ops::index::Index&lt;I&gt; for [T]&gt;::index\n             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/slice/index.rs:18:9\n   5: &lt;alloc::vec::Vec&lt;T,A&gt; as core::ops::index::Index&lt;I&gt;&gt;::index\n             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/alloc/src/vec/mod.rs:2591:9\n   6: panic::main\n             at ./src/main.rs:4:5\n   7: core::ops::function::FnOnce::call_once\n             at /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/core/src/ops/function.rs:248:5\nnote: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.\n\nListing 9-2: panic! 호출에 의해 생성된 백트레이스 환경 변수 RUST_BACKTRACE가 설정되면 표시됩니다.\n출력이 엄청나네요! 표시되는 정확한 출력은 운영 체제 및 Rust 버전에 따라 다를 수 있습니다. 이 정보로 백트레이스를 얻으려면 디버그 기호를 활성화해야 합니다. 여기에 있는 것처럼 --release 플래그 없이 cargo build 또는 cargo run을 사용할 때 디버그 기호가 기본적으로 활성화됩니다.\n목록 9-2의 출력에서 백트레이스의 6행은 문제를 일으키는 프로젝트의 src/main.rs 4행을 가리킵니다. 프로그램이 패닉 상태가 되는 것을 원하지 않으면 우리가 작성한 파일을 언급하는 첫 번째 줄이 가리키는 위치에서 조사를 시작해야 합니다. 목록 9-1에서 일부러 패닉을 일으키는 코드를 작성했는데 패닉을 해결하는 방법은 벡터 인덱스 범위를 벗어나는 요소를 요청하지 않는 것입니다. 나중에 코드 패닉이 발생하면 패닉을 유발하는 값과 대신 코드가 수행해야 하는 작업을 파악해야 합니다.\n패닉!으로 돌아오겠습니다. 패닉!을 사용해야 할 때와 사용하지 말아야 할 때 [패닉!](https://doc.rust-lang.org/book/ch09-03-to-panic-or-not-to-panic.html#to-panic-or-not-to-panic)  또는 이 장 뒷부분의 [패닉!`` 섹션을 참조하십시오 . ](https://doc.rust-lang.org/book/ch09-03-to-panic-or-not-to-panic.html#to-panic-or-not-to-panic)다음으로 결과`를 사용하여 오류를 복구하는 방법을 살펴보겠습니다.\n\n결과로 복구 가능한 오류\n대부분의 오류는 프로그램을 완전히 중지해야 할 정도로 심각하지 않습니다. 때때로 함수가 실패하면 쉽게 해석하고 대응할 수 있는 이유 때문입니다. 예를 들어 파일을 열려고 하는데 파일이 없기 때문에 해당 작업이 실패하는 경우 프로세스를 종료하는 대신 파일을 만들 수 있습니다.\n2장의 [결과를 사용한 잠재적 실패 처리](https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html#handling-potential-failure-with-result) 에서 결과열거형이 다음과 같이Ok및Err`의 두 가지 변형을 갖는 것으로 정의되었음을 상기하십시오 .\nenum Result&lt;T, E&gt; {\n    Ok(T),\n    Err(E),\n}\n\nT와 E는 제네릭 유형 매개변수입니다. 제네릭에 대해서는 10장에서 자세히 설명하겠습니다. 지금 알아야 할 것은 T가 성공 시 반환될 값의 유형을 나타낸다는 것입니다. Ok 변형 내의 경우이고 E는 Err 변형 내의 실패 사례에서 반환될 오류 유형을 나타냅니다. Result에는 이러한 제네릭 유형 매개변수가 있기 때문에 반환하려는 성공적인 값과 오류 값이 다를 수 있는 다양한 상황에서 Result 유형과 그에 정의된 함수를 사용할 수 있습니다.\n함수가 실패할 수 있으므로 결과 값을 반환하는 함수를 호출해 보겠습니다. 목록 9-3에서 우리는 파일 열기를 시도합니다.\n파일 이름: src/main.rs\nuse std::fs::File;\n\nfn main() {\n    let greeting_file_result = File::open(`hello.txt`);\n}\n\n목록 9-3: 파일 열기\nFile::open의 반환 유형은 Result&lt;T, E&gt;입니다. 일반 매개변수 T는 파일 핸들인 성공 값 std::fs::File의 유형으로 File::open 구현으로 채워졌습니다. 오류 값에 사용된 E 유형은 std::io::Error입니다. 이 반환 유형은 File::open에 대한 호출이 성공하고 읽고 쓸 수 있는 파일 핸들을 반환할 수 있음을 의미합니다. 함수 호출도 실패할 수 있습니다. 예를 들어 파일이 존재하지 않거나 파일에 액세스할 수 있는 권한이 없을 수 있습니다. File::open 함수는 성공 또는 실패 여부를 알려주는 동시에 파일 핸들 또는 오류 정보를 제공하는 방법이 필요합니다. 이 정보는 정확히 결과 열거형이 전달하는 것입니다.\nFile::open이 성공한 경우 변수 greeting_file_result의 값은 파일 핸들을 포함하는 Ok의 인스턴스가 됩니다. 실패한 경우 greeting_file_result의 값은 발생한 오류 종류에 대한 자세한 정보를 포함하는 Err의 인스턴스가 됩니다.\nFile::open 반환 값에 따라 다른 작업을 수행하려면 목록 9-3의 코드에 추가해야 합니다. 목록 9-4는 기본 도구인 6장에서 논의한 일치 표현식을 사용하여 결과를 처리하는 한 가지 방법을 보여줍니다.\n파일 이름: src/main.rs\nuse std::fs::File;\n\nfn main() {\n    let greeting_file_result = File::open(`hello.txt`);\n\n    let greeting_file = match greeting_file_result {\n        Ok(file) =&gt; file,\n        Err(error) =&gt; panic!(`Problem opening the file: {:?}`, error),\n    };\n}\n\n목록 9-4: 반환될 수 있는 결과 변형을 처리하기 위해 일치 표현식 사용\nOption 열거형과 마찬가지로 Result 열거형과 그 변형은 prelude에 의해 범위로 가져왔으므로 Ok 및 Err 변형 앞에 Result::를 지정할 필요가 없습니다. 일치팔에서.\n결과가 Ok이면 이 코드는 Ok 변형에서 내부 file 값을 반환한 다음 해당 파일 핸들 값을 변수 greeting_file에 할당합니다. 일치 후에 파일 핸들을 사용하여 읽거나 쓸 수 있습니다.\nmatch의 다른 부분은 File::open에서 Err 값을 얻는 경우를 처리합니다. 이 예에서는 패닉! 매크로. 현재 디렉터리에 hello.txt 라는 파일이 없고 이 코드를 실행하면 패닉! 매크로:\n$ cargo run\n   Compiling error-handling v0.1.0 (file:///projects/error-handling)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.73s\n     Running `target/debug/error-handling`\nthread 'main' panicked at 'Problem opening the file: Os { code: 2, kind: NotFound, message: `No such file or directory` }', src/main.rs:8:23\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n\n늘 그렇듯이 이 출력은 무엇이 잘못되었는지 정확히 알려줍니다.\n다른 오류에 대한 일치\n목록 9-4의 코드는 패닉! 파일::열기가 실패한 이유에 관계없이. 그러나 실패 이유에 따라 다른 작업을 수행하려고 합니다. 파일이 없기 때문에 File::open이 실패하면 파일을 만들고 새 파일에 대한 핸들을 반환하려고 합니다. 다른 이유로 File::open이 실패한 경우(예: 파일을 열 수 있는 권한이 없었기 때문에) 우리는 여전히 코드가 패닉! Listing 9-4에서와 같은 방식으로. 이를 위해 목록 9-5에 표시된 내부 일치 표현식을 추가합니다.\n파일 이름: src/main.rs\nuse std::fs::File;\nuse std::io::ErrorKind;\n\nfn main() {\n    let greeting_file_result = File::open(`hello.txt`);\n\n    let greeting_file = match greeting_file_result {\n        Ok(file) =&gt; file,\n        Err(error) =&gt; match error.kind() {\n            ErrorKind::NotFound =&gt; match File::create(`hello.txt`) {\n                Ok(fc) =&gt; fc,\n                Err(e) =&gt; panic!(`Problem creating the file: {:?}`, e),\n            },\n            other_error =&gt; {\n                panic!(`Problem opening the file: {:?}`, other_error);\n            }\n        },\n    };\n}\n\nListing 9-5: 다양한 종류의 오류를 다양한 방식으로 처리하기\nFile::open이 Err 변형 내에서 반환하는 값의 유형은 표준 라이브러리에서 제공하는 구조체인 io::Error입니다. 이 구조체에는 io::ErrorKind 값을 가져오기 위해 호출할 수 있는 kind 메서드가 있습니다. 열거형 io::ErrorKind는 표준 라이브러리에서 제공되며 io 작업에서 발생할 수 있는 다양한 종류의 오류를 나타내는 변형이 있습니다. 우리가 사용하려는 변형은 ErrorKind::NotFound이며 열려고 하는 파일이 아직 존재하지 않음을 나타냅니다. 따라서 greeting_file_result에서 일치하지만 error.kind()에서도 내부 일치가 있습니다.\n내부 일치에서 확인하려는 조건은 error.kind()에 의해 반환된 값이 ErrorKind 열거형의 NotFound 변형인지 여부입니다. 그렇다면 File::create로 파일 생성을 시도합니다. 그러나 File::create도 실패할 수 있으므로 내부 일치 식에 두 번째 팔이 필요합니다. 파일을 만들 수 없으면 다른 오류 메시지가 인쇄됩니다. 외부 일치의 두 번째 팔은 동일하게 유지되므로 누락된 파일 오류 외에 다른 오류가 발생하면 프로그램 패닉이 발생합니다.\n\n결과와 함께 일치 사용에 대한 대안\n그것은 많은 일치입니다! 일치 표현은 매우 유용하지만 매우 원시적이기도 합니다. 13장에서는 Result&lt;T, E&gt;에 정의된 많은 메서드와 함께 사용되는 클로저에 대해 배웁니다. 이러한 메서드는 코드에서 Result&lt;T, E&gt; 값을 처리할 때 match를 사용하는 것보다 더 간결할 수 있습니다.\n예를 들어 Listing 9-5에 표시된 것과 동일한 논리를 작성하는 또 다른 방법이 있습니다. 이번에는 클로저와 unwrap_or_else 메서드를 사용합니다.\nuse std::fs::File;\nuse std::io::ErrorKind;\n\nfn main() {\n    let greeting_file = File::open(`hello.txt`).unwrap_or_else(|error| {\n        if error.kind() == ErrorKind::NotFound {\n            File::create(`hello.txt`).unwrap_or_else(|error| {\n                panic!(`Problem creating the file: {:?}`, error);\n            })\n        } else {\n            panic!(`Problem opening the file: {:?}`, error);\n        }\n    });\n}\n\n이 코드는 목록 9-5와 동일한 동작을 갖지만 일치 표현식을 포함하지 않으며 더 읽기 쉽습니다. 13장을 읽은 후 이 예제로 돌아와서 표준 라이브러리 문서에서 unwrap_or_else 메서드를 찾아보십시오. 오류를 처리할 때 더 많은 이러한 메서드를 사용하여 거대한 중첩된 일치 식을 정리할 수 있습니다.\n\nPanic on Error에 대한 바로 가기: unwrap 및 expect\n일치를 사용하는 것은 충분히 잘 작동하지만 약간 장황할 수 있고 항상 의도를 잘 전달하지 못합니다. Result&lt;T, E&gt; 유형에는 다양하고 보다 구체적인 작업을 수행하기 위해 정의된 많은 도우미 메서드가 있습니다. unwrap 메소드는 Listing 9-4에서 작성한 match 표현식처럼 구현된 단축 메소드입니다. 결과 값이 Ok 변형인 경우 unwrap은 Ok 내부의 값을 반환합니다. Result가 Err 변형인 경우 unwrap은 panic! 우리를 위한 매크로 다음은 작동 중인 포장 해제의 예입니다.\n파일 이름: src/main.rs\nuse std::fs::File;\n\nfn main() {\n    let greeting_file = File::open(`hello.txt`).unwrap();\n}\n\nhello.txt 파일 없이 이 코드를 실행하면 패닉! unwrap 메소드가 만드는 호출:\nthread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Os {\ncode: 2, kind: NotFound, message: `No such file or directory` }',\nsrc/main.rs:4:49\n\n마찬가지로 예상 방법을 사용하면 패닉! 에러 메시지. unwrap 대신 expect를 사용하고 좋은 오류 메시지를 제공하면 의도를 전달할 수 있고 패닉의 원인을 더 쉽게 추적할 수 있습니다. 예상 구문은 다음과 같습니다.\n파일 이름: src/main.rs\nuse std::fs::File;\n\nfn main() {\n    let greeting_file = File::open(`hello.txt`)\n        .expect(`hello.txt should be included in this project`);\n}\n\n우리는 unwrap과 같은 방식으로 expect를 사용합니다: 파일 핸들을 반환하거나 panic! 매크로. panic! 호출에서 expect가 사용하는 오류 메시지 기본 panic!이 아니라 expect에 전달하는 매개변수가 됩니다. unwrap이 사용하는 메시지. 다음과 같습니다.\nthread 'main' panicked at 'hello.txt should be included in this project: Os {\ncode: 2, kind: NotFound, message: `No such file or directory` }',\nsrc/main.rs:5:10\n\n프로덕션 품질 코드에서 대부분의 Rustacean은 unwrap이 아닌 expect를 선택하고 작업이 항상 성공할 것으로 예상되는 이유에 대해 더 많은 컨텍스트를 제공합니다. 이렇게 하면 가정이 잘못된 것으로 판명될 경우 디버깅에 사용할 더 많은 정보를 얻을 수 있습니다.\n오류 전파\n함수의 구현이 실패할 수 있는 것을 호출할 때 함수 자체 내에서 오류를 처리하는 대신 호출 코드에 오류를 반환하여 수행할 작업을 결정할 수 있습니다. 이를 오류 전파 라고 하며 코드 컨텍스트에서 사용할 수 있는 것보다 오류를 처리하는 방법을 지시하는 더 많은 정보 또는 논리가 있을 수 있는 호출 코드에 더 많은 제어를 제공합니다.\n예를 들어 Listing 9-6은 파일에서 사용자 이름을 읽는 함수를 보여줍니다. 파일이 존재하지 않거나 읽을 수 없는 경우 이 함수는 함수를 호출한 코드에 해당 오류를 반환합니다.\n파일 이름: src/main.rs\nuse std::fs::File;\nuse std::io::{self, Read};\n\nfn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {\n    let username_file_result = File::open(`hello.txt`);\n\n    let mut username_file = match username_file_result {\n        Ok(file) =&gt; file,\n        Err(e) =&gt; return Err(e),\n    };\n\n    let mut username = String::new();\n\n    match username_file.read_to_string(&amp;mut username) {\n        Ok(_) =&gt; Ok(username),\n        Err(e) =&gt; Err(e),\n    }\n}\n\n목록 9-6: match를 사용하여 호출 코드에 오류를 반환하는 함수\n이 함수는 훨씬 더 짧은 방법으로 작성할 수 있지만 오류 처리를 탐색하기 위해 수동으로 많은 작업을 수행하는 것으로 시작할 것입니다. 마지막에는 더 짧은 방법을 보여드리겠습니다. 먼저 함수의 반환 유형인 Result&lt;String, io::Error&gt;를 살펴보겠습니다. 이는 함수가 Result&lt;T, E&gt; 유형의 값을 반환하고 있음을 의미합니다. 여기서 일반 매개변수 T는 구체적인 유형 String으로 채워지고 일반 유형 E는 다음으로 채워졌습니다. 구체적인 유형 io::Error.\n이 함수가 아무 문제 없이 성공하면 이 함수를 호출하는 코드는 이 함수가 파일에서 읽은 사용자 이름인 문자열을 포함하는 Ok 값을 받습니다. 이 함수에 문제가 발생하면 호출 코드는 문제가 무엇인지에 대한 자세한 정보가 포함된 io::Error 인스턴스를 보유하는 Err 값을 받습니다. 이 함수의 반환 유형으로 io::Error를 선택한 이유는 실패할 수 있는 이 함수의 본문에서 호출하는 두 작업에서 반환된 오류 값의 유형이기 때문입니다. 함수 및read_to_string` 메서드.\n함수 본문은 File::open 함수를 호출하여 시작합니다. 그런 다음 목록 9-4의 일치와 유사한 일치로 결과 값을 처리합니다. File::open이 성공하면 패턴 변수 file의 파일 핸들이 가변 변수 username_file의 값이 되고 함수가 계속됩니다. Err의 경우 panic!을 호출하는 대신 return 키워드를 사용하여 함수 전체에서 일찍 반환하고 File::open의 오류 값을 이제 패턴 변수 e에 전달합니다. `, 이 함수의 오류 값으로 호출 코드로 돌아갑니다.\n따라서 username_file에 파일 핸들이 있으면 함수는 username 변수에 새 String을 생성하고 username_file의 파일 핸들에서 read_to_string 메서드를 호출하여 파일 내용을  사용자 이름. read_to_string 메서드도 File::open이 성공했지만 실패할 수 있으므로 Result를 반환합니다. 따라서 결과를 처리하기 위해 또 다른 일치가 필요합니다. read_to_string이 성공하면 함수가 성공한 것이며 이제 Ok로 래핑된 username에 있는 파일에서 사용자 이름을 반환합니다. read_to_string이 실패하면 match에서 오류 값을 반환한 것과 동일한 방식으로 오류 값을 반환합니다. File::open의 반환 값을 처리했습니다. 그러나 return이라고 명시적으로 말할 필요는 없습니다. 이것이 함수의 마지막 표현식이기 때문입니다.\n이 코드를 호출하는 코드는 사용자 이름이 포함된 Ok 값 또는 io::Error가 포함된 Err 값을 가져오는 것을 처리합니다. 해당 값으로 수행할 작업을 결정하는 것은 호출 코드에 달려 있습니다. 호출 코드가 Err 값을 받으면 패닉!을 호출할 수 있습니다. 예를 들어 프로그램을 충돌시키거나, 기본 사용자 이름을 사용하거나, 파일이 아닌 다른 곳에서 사용자 이름을 조회합니다. 호출 코드가 실제로 무엇을 하려고 하는지에 대한 정보가 충분하지 않으므로 적절하게 처리할 수 있도록 모든 성공 또는 오류 정보를 위쪽으로 전파합니다.\n이러한 오류 전파 패턴은 Rust에서 매우 일반적이어서 Rust는 물음표 연산자 ?를 제공합니다. 이것을 더 쉽게 하기 위해.\n전파 오류의 바로 가기: ? 운영자\nListing 9-7은 Listing 9-6과 동일한 기능을 가진 read_username_from_file의 구현을 보여주지만 이 구현은 ? 운영자.\n파일 이름: src/main.rs\nuse std::fs::File;\nuse std::io::{self, Read};\n\nfn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {\n    let mut username_file = File::open(`hello.txt`)?;\n    let mut username = String::new();\n    username_file.read_to_string(&amp;mut username)?;\n    Ok(username)\n}\n\n목록 9-7: ?를 사용하여 호출 코드에 오류를 반환하는 함수 운영자\n? Listing 9-6에서 결과 값을 처리하기 위해 정의한 일치 표현식과 거의 동일한 방식으로 작동하도록 정의된 결과 값 뒤에 배치됩니다. Result의 값이 Ok이면 Ok 내부의 값이 이 식에서 반환되고 프로그램이 계속됩니다. 값이 Err이면 return 키워드를 사용한 것처럼 전체 함수에서 Err가 반환되어 오류 값이 호출 코드로 전파됩니다.\n목록 9-6의 일치 표현식이 수행하는 것과 ? 연산자는 다음을 수행합니다. ?가 있는 오류 값 호출된 연산자는 표준 라이브러리의 From 특성에 정의된 from 함수를 거치며 값을 한 유형에서 다른 유형으로 변환하는 데 사용됩니다. 때 ? 연산자가 from 함수를 호출하면 받은 오류 유형이 현재 함수의 반환 유형에 정의된 오류 유형으로 변환됩니다. 이는 여러 가지 이유로 부품이 실패하더라도 함수가 실패할 수 있는 모든 방식을 나타내기 위해 함수가 하나의 오류 유형을 반환할 때 유용합니다.\n예를 들어 목록 9-7의 read_username_from_file 함수를 변경하여 우리가 정의한 OurError라는 사용자 지정 오류 유형을 반환할 수 있습니다. [io::Error](io::Error)에서 OurError의 인스턴스를 구성하기 위해 impl From io::Error for OurError도 정의하면 ? read_username_from_file 본문의 연산자 호출은 함수에 더 이상 코드를 추가할 필요 없이 from을 호출하고 오류 유형을 변환합니다.\n목록 9-7의 맥락에서 ? File::open 호출이 끝나면 Ok 내부의 값을 username_file 변수로 반환합니다. 오류가 발생하면 ? 연산자는 전체 함수에서 일찍 반환하고 호출 코드에 Err 값을 제공합니다. ?에도 동일하게 적용됩니다. read_to_string 호출이 끝날 때.\n? 연산자는 많은 상용구를 제거하고 이 함수의 구현을 더 간단하게 만듭니다. Listing 9-8과 같이 ? 바로 뒤에 메소드 호출을 연결하여 이 코드를 더 단축할 수도 있습니다.\n파일 이름: src/main.rs\nuse std::fs::File;\nuse std::io::{self, Read};\n\nfn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {\n    let mut username = String::new();\n\n    File::open(`hello.txt`)?.read_to_string(&amp;mut username)?;\n\n    Ok(username)\n}\n\nListing 9-8: ? 다음에 메서드 호출을 연결합니다. 운영자\nusername에서 새 String 생성을 함수의 시작 부분으로 이동했습니다. 그 부분은 변하지 않았습니다. 변수 username_file을 만드는 대신 read_to_string에 대한 호출을 File::open(hello.txt)?의 결과에 직접 연결했습니다. 우리는 여전히 ? read_to_string 호출이 끝날 때 File::open과 read_to_string이 모두 성공하면 오류를 반환하는 대신 username을 포함하는 Ok 값을 반환합니다. 기능은 Listing 9-6 및 Listing 9-7과 동일합니다. 이것은 그것을 작성하는 다른, 더 인체 공학적인 방법입니다.\n목록 9-9는 fs::read_to_string을 사용하여 이것을 더 짧게 만드는 방법을 보여줍니다.\n파일 이름: src/main.rs\nuse std::fs;\nuse std::io;\n\nfn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {\n    fs::read_to_string(`hello.txt`)\n}\n\n목록 9-9: 파일을 열고 읽는 대신 fs::read_to_string 사용\n파일을 문자열로 읽는 것은 상당히 일반적인 작업이므로 표준 라이브러리는 편리한 fs::read_to_string 함수를 제공하여 파일을 열고 새 문자열을 만들고 파일의 내용을 읽고 그 내용을 문자열, 반환합니다. 물론 fs::read_to_string을 사용하는 것은 모든 오류 처리를 설명할 기회를 주지 않으므로 먼저 긴 방법을 사용했습니다.\n? 통신수는 사용될 수 있습니다\n? 연산자는 반환 유형이 ? 값과 호환되는 함수에서만 사용할 수 있습니다. 에 사용됩니다. 이것은 ? 때문입니다. 연산자는 Listing 9-6에서 정의한 일치 표현식과 같은 방식으로 함수 외부에서 값의 조기 반환을 수행하도록 정의됩니다. 목록 9-6에서 일치는 결과 값을 사용하고 있었고 초기 반환 암은 Err(e) 값을 반환했습니다. 함수의 반환 유형은 이 반환과 호환되도록 결과여야 합니다.\n목록 9-10에서 ?를 사용하면 발생하는 오류를 살펴보겠습니다. 우리가 사용하는 값의 유형과 호환되지 않는 반환 유형이 있는 main 함수의 연산자 ? 에:\n파일 이름: src/main.rs\nuse std::fs::File;\n\nfn main() {\n    let greeting_file = File::open(`hello.txt`)?;\n}\n\n목록 9-10: ? 사용 시도 ()를 반환하는 main 함수에서 컴파일되지 않습니다.\n이 코드는 실패할 수 있는 파일을 엽니다. ? 연산자는 File::open에 의해 반환된 결과 값을 따르지만 이 주요 함수의 반환 유형은 결과가 아니라 ()입니다. 이 코드를 컴파일하면 다음과 같은 오류 메시지가 나타납니다.\n$ cargo run\n   Compiling error-handling v0.1.0 (file:///projects/error-handling)\nerror[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `FromResidual`)\n --&gt; src/main.rs:4:48\n  |\n3 | fn main() {\n  | --------- this function should return `Result` or `Option` to accept `?`\n4 |     let greeting_file = File::open(`hello.txt`)?;\n  |                                                ^ cannot use the `?` operator in a function that returns `()`\n  |\n  = help: the trait `FromResidual&lt;Result&lt;Infallible, std::io::Error&gt;&gt;` is not implemented for `()`\n\nFor more information about this error, try `rustc --explain E0277`.\nerror: could not compile `error-handling` due to previous error\n\n이 오류는 ?만 사용할 수 있음을 나타냅니다. Result, Option 또는 FromResidual을 구현하는 다른 유형을 반환하는 함수의 연산자.\n오류를 수정하려면 두 가지 선택이 있습니다. 한 가지 선택은 ?를 사용하는 값과 호환되도록 함수의 반환 유형을 변경하는 것입니다. 제한이 없는 한 연산자를 켜십시오. 다른 기술은 methods to handle the적절한 방식으로 일치 또는 Result&lt;T, E&gt; Result&lt;T, E&gt; 중 하나를 사용하는 것입니다.\n값과 함께 ?사용할 수 있는 오류 메시지도 언급되었습니다. on 을 Option&lt;T&gt;사용할 때와 마찬가지로 를 반환하는 함수에서만 on 을 사용할 수 있습니다. an에서 호출될 때 연산자 의 동작은 a에서 호출될 때의 동작과 유사합니다. 값이 이면 해당 시점의 함수에서 이 일찍 반환됩니다. 값이 인 경우 내부 값은 표현식의 결과 값이고 함수는 계속됩니다. 목록 9-11에는 주어진 텍스트에서 첫 줄의 마지막 문자를 찾는 함수의 예가 있습니다:?``Result``?``Option``Option``?``Option&lt;T&gt;``Result&lt;T, E&gt;``None``None``Some``Some\nfn last_char_of_first_line(text: &amp;str) -&gt; Option&lt;char&gt; {\n    text.lines().next()?.chars().last()\n}\n\nListing 9-11: 값 ?에 연산자 사용하기Option&lt;T&gt;\n이 함수는 Option&lt;char&gt;거기에 문자가 있을 수도 있고 없을 수도 있기 때문에 반환합니다. 이 코드는 text문자열 슬라이스 인수를 사용하고 lines문자열의 행에 대한 반복자를 반환하는 메서드를 호출합니다. 이 함수는 첫 번째 줄을 검사하기를 원하기 때문에 next반복자에서 첫 번째 값을 가져오기 위해 반복자를 호출합니다. text가 빈 문자열인 경우 에 대한 이 호출은 를 next반환합니다 None. 이 경우 ?중지하고 None에서 반환하는 데 사용합니다 last_char_of_first_line. text가 빈 문자열이 아닌 경우 에서 첫 번째 줄의 문자열 조각을 포함하는 값을 next반환합니다.Some``text\n는 ?문자열 조각을 추출하고 chars해당 문자열 조각을 호출하여 해당 문자의 이터레이터를 얻을 수 있습니다. 이 첫 줄의 마지막 문자에 관심이 있으므로 lastiterator의 마지막 항목을 반환하도록 호출합니다. 예 를 들어 에서와 같이 빈 줄로 시작하지만 다른 줄에 문자가 있는 경우 Option첫 번째 줄이 빈 문자열일 가능성이 있기 때문 입니다. 그러나 첫 번째 줄에 마지막 문자가 있는 경우에는 Variant로 반환됩니다. 중간에 있는 연산자는 이 논리를 간결하게 표현하는 방법을 제공하여 함수를 한 줄로 구현할 수 있도록 합니다. on 연산자를 사용할 수 없다면 더 많은 메서드 호출을 사용하여 이 논리를 구현해야 합니다.text```\\nhi```Some``?``?``Option``match표현.\n를 반환하는 함수에서 ?a에 연산자를 사용할 수 있고 를 반환하는 함수에서 an에 연산자를 사용할 수 있지만 혼합하여 일치시킬 수는 없습니다. 연산자 는 a를 an으로 또는 그 반대로 자동으로 변환하지 않습니다. 이 경우 on 메서드 또는 on 메서드와 같은 메서드를 사용하여 명시적으로 변환을 수행할 수 있습니다.Result``Result``?``Option``Option``?``Result``Option``ok``Result``ok_or``Option\n지금까지 main사용한 모든 함수는 return 입니다 (). 이 main함수는 실행 가능한 프로그램의 시작 및 종료 지점이기 때문에 특별하며 프로그램이 예상대로 작동할 수 있는 반환 유형에 대한 제한이 있습니다.\nmain운 좋게도 Result&lt;(), E&gt;. mainListing 9-12에는 Listing 9-10의 코드가 있지만 반환 유형 of를 be로 변경 하고 끝에 Result&lt;(), Box&lt;dyn Error&gt;&gt;반환 값을 추가했습니다. Ok(())이 코드는 이제 컴파일됩니다.\nuse std::error::Error;\nuse std::fs::File;\n\nfn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {\n    let greeting_file = File::open(`hello.txt`)?;\n\n    Ok(())\n}\n\nListing 9-12: mainreturn으로 변경하면 값 에 연산자 Result&lt;(), E&gt;를 사용할 수 있습니다.?``Result\n유형 Box&lt;dyn Error&gt;은 17장의 다른 유형의 값을 허용하는 특성 개체 사용 섹션 에서 이야기할 특성 개체 입니다. 지금은 모든 종류의 오류를 의미한다고 읽을 수 있습니다. 오류 유형이 있는 함수 에서 값을 사용 하는 것은 모든 값이 조기에 반환될 수 있기 때문에 허용됩니다. 이 함수의 본문은 유형의 오류만 반환하지만 을 지정하면 다른 오류를 반환하는 더 많은 코드가 의 본문에 추가되더라도 이 서명은 계속 정확합니다.Box&lt;dyn Error&gt;``?``Result``main``Box&lt;dyn Error&gt;``Err``main``std::io::Error``Box&lt;dyn Error&gt;``main\nmain`함수가 를 반환 하면 실행 파일은 if 반환 `Result&lt;(), E&gt;`값으로 종료 하고 값을 반환 하면 0이 아닌 값으로 종료합니다. C로 작성된 실행 파일은 종료 시 정수를 반환합니다. 성공적으로 종료된 프로그램은 정수를 반환 하고 오류가 발생한 프로그램은 . Rust는 또한 이 규칙과 호환되도록 실행 파일에서 정수를 반환합니다.`0``main``Ok(())``main``Err``0``0\n\n함수 는 를 반환하는 함수를 포함하는 특성 을main 구현하는 모든 유형을 반환할 수 있습니다. 자신의 유형에 대한 특성 구현에 대한 자세한 내용은 표준 라이브러리 문서를 참조하세요 .std::process::Terminationreport``ExitCode``Termination\n지금까지 를 호출 panic!하거나 반환하는 방법에 대해 자세히 살펴보았 Result으므로 어떤 경우에 어떤 것을 사용하는 것이 적절한지 결정하는 방법에 대한 주제로 돌아가 보겠습니다.\n\n에 panic!또는 하지panic!\npanic!그러면 언제 전화를 걸어야 하고 언제 돌아와야 하는지 어떻게 결정합니까 Result? 코드 패닉이 발생하면 복구할 방법이 없습니다. panic!복구할 수 있는 방법이 있는지 여부에 관계없이 모든 오류 상황을 호출할 수 있지만 호출 코드를 대신하여 상황을 복구할 수 없다는 결정을 내리는 것입니다. 값 을 반환하도록 선택하면 Result호출 코드 옵션을 제공합니다. 호출 코드는 해당 상황에 적합한 방식으로 복구를 시도하도록 선택하거나 Err이 경우 값을 복구할 수 없다고 결정할 수 있으므로 panic!복구 가능한 오류를 호출하여 복구할 수 없는 오류로 전환할 수 있습니다. 따라서 Result실패할 수 있는 함수를 정의할 때 반환은 좋은 기본 선택입니다.\n예제, 프로토타입 코드, 테스트와 같은 상황에서는 Result. 그 이유를 살펴보고 컴파일러는 실패가 불가능하다고 말할 수 없지만 사람은 할 수 있는 상황에 대해 논의해 봅시다. 이 장에서는 라이브러리 코드에서 패닉이 발생하는지 여부를 결정하는 방법에 대한 몇 가지 일반적인 지침으로 결론을 내릴 것입니다.\n예제, 프로토타입 코드 및 테스트\n일부 개념을 설명하기 위해 예제를 작성할 때 강력한 오류 처리 코드를 포함하면 예제가 덜 명확해질 수 있습니다. 예제에서 패닉이 발생할 수 있는 것과 같은 메서드에 대한 호출은 unwrap애플리케이션에서 오류를 처리하기를 원하는 방식에 대한 자리 표시자로 의미되며 나머지 코드가 수행하는 작업에 따라 다를 수 있습니다.\n마찬가지로 unwrap및 expect메서드는 오류 처리 방법을 결정하기 전에 프로토타이핑할 때 매우 편리합니다. 프로그램을 보다 강력하게 만들 준비가 되었을 때 코드에 명확한 마커를 남깁니다.\n테스트에서 메서드 호출이 실패하면 해당 메서드가 테스트 중인 기능이 아니더라도 전체 테스트가 실패하기를 원할 것입니다. panic!테스트가 실패로 표시되는 방식이기 때문에 호출 unwrap또는 expect정확히 발생해야 하는 일입니다.\n컴파일러보다 더 많은 정보를 가지고 있는 경우\n에 값 이 있는지 확인하는 다른 논리가 있거나 unwrap호출 하는 것이 적절할 수도 있지만 그 논리는 컴파일러가 이해하는 것이 아닙니다. 여전히 처리해야 하는 값이 있습니다. 특정 상황에서 논리적으로 불가능하더라도 호출하는 작업은 여전히 일반적으로 실패할 가능성이 있습니다. 코드를 수동으로 검사하여 변형이 없을 것임을 확인할 수 있는 경우 를 호출하는 것이 완벽하게 허용되며 텍스트 에 변형이 없을 것이라고 생각하는 이유를 문서화하는 것이 더 좋습니다. 예를 들면 다음과 같습니다.expect``Result``Ok``Result``Err``unwrap``Err``expect\n    use std::net::IpAddr;\n\n    let home: IpAddr = `127.0.0.1`\n        .parse()\n        .expect(`Hardcoded IP address should be valid`);\n\nIpAddr하드 코딩된 문자열을 구문 분석하여 인스턴스를 생성하고 있습니다. 이것이 유효한 IP 주소임을 알 수 있으므로 여기에서 127.0.0.1사용할 수 있습니다 expect. 그러나 하드코딩된 유효한 문자열이 있다고 해서 메서드의 반환 유형이 변경되지는 않습니다 parse. 우리는 여전히 값을 얻고 컴파일러는 여전히 충분히 똑똑하지 않기 때문에 변형이 가능한 것처럼 Result처리하도록 합니다. 이 문자열이 항상 유효한 IP 주소인지 확인하십시오. IP 주소 문자열이 프로그램에 하드코딩되지 않고 사용자로부터 온 것이므로 오류가 발생할 가능성이 있는 경우 대신 보다 강력한 방식으로 처리해야 합니다. 이 IP 주소가 하드코딩되어 있다는 가정을 언급하면 변경하라는 메시지가 표시됩니다.Result``Err``Result``expect나중에 더 나은 오류 처리 코드를 위해 다른 소스에서 대신 IP 주소를 가져와야 합니다.\n오류 처리 지침\n코드가 잘못된 상태가 될 가능성이 있는 경우 코드를 패닉 상태로 만드는 것이 좋습니다. 이 컨텍스트에서 잘못된 상태 는 유효하지 않은 값, 모순된 값 또는 누락된 값이 코드에 전달되고 다음 중 하나 이상이 발생하는 경우와 같이 일부 가정, 보증, 계약 또는 불변성이 위반된 경우입니다.\n\n잘못된 상태는 사용자가 잘못된 형식으로 데이터를 입력하는 것과 같이 가끔 발생할 수 있는 상황이 아니라 예상치 못한 상태입니다.\n이 시점 이후의 코드는 모든 단계에서 문제를 확인하기보다는 이 잘못된 상태에 있지 않은지에 의존해야 합니다.\n사용하는 유형에 이 정보를 인코딩하는 좋은 방법이 없습니다. 17장의 유형으로서의 인코딩 상태 및 동작 섹션 에서 우리가 의미하는 바의 예를 통해 작업할 것입니다.\n\n누군가가 코드를 호출하고 이치에 맞지 않는 값을 전달하는 경우 라이브러리 사용자가 원하는 작업을 결정할 수 있도록 가능한 경우 오류를 반환하는 것이 가장 좋습니다. 그러나 계속하는 것이 안전하지 않거나 해로울 수 있는 경우 최선의 선택은 panic!라이브러리를 사용하는 사람에게 코드의 버그를 호출하여 경고하여 개발 중에 수정할 수 있도록 하는 것입니다. 마찬가지로 panic!제어할 수 없는 외부 코드를 호출하고 고칠 방법이 없는 잘못된 상태를 반환하는 경우에 종종 적합합니다.\nResult그러나 실패가 예상되는 경우 전화를 거는 것보다 a를 반환하는 것이 더 적절합니다 panic!. 예를 들어 잘못된 형식의 데이터가 제공되는 파서 또는 속도 제한에 도달했음을 나타내는 상태를 반환하는 HTTP 요청이 있습니다. 이러한 경우 a를 반환하는 것은 Result실패가 호출 코드에서 처리 방법을 결정해야 하는 예상 가능성을 나타냅니다.\n코드가 유효하지 않은 값을 사용하여 호출되면 사용자를 위험에 빠뜨릴 수 있는 작업을 수행하는 경우 코드는 먼저 값이 유효한지 확인하고 값이 유효하지 않으면 당황해야 합니다. 이는 주로 안전상의 이유 때문입니다. 유효하지 않은 데이터에 대해 작업을 시도하면 코드가 취약성에 노출될 수 있습니다. panic!이것이 범위를 벗어난 메모리 액세스를 시도하는 경우 표준 라이브러리가 호출하는 주된 이유입니다. 현재 데이터 구조에 속하지 않는 메모리에 액세스하려는 시도는 일반적인 보안 문제입니다. 함수에는 종종 계약이 있습니다.: 입력이 특정 요구 사항을 충족하는 경우에만 해당 동작이 보장됩니다. 계약 위반 시 당황하는 것은 계약 위반이 항상 호출자 측 버그를 나타내며 호출 코드에서 명시적으로 처리해야 하는 일종의 오류가 아니기 때문에 의미가 있습니다. 사실 복구할 코드를 호출하는 합리적인 방법은 없습니다. 호출 프로그래머는 코드를 수정해야 합니다. 기능에 대한 계약, 특히 위반으로 인해 패닉이 발생하는 경우 기능에 대한 API 문서에 설명되어야 합니다.\n그러나 모든 함수에서 많은 오류 검사를 수행하면 장황하고 성가실 수 있습니다. 다행스럽게도 Rust의 유형 시스템(따라서 컴파일러가 수행하는 유형 검사)을 사용하여 많은 검사를 수행할 수 있습니다. 함수에 매개 변수로 특정 유형이 있는 경우 컴파일러에서 유효한 값이 있음을 이미 확인했음을 알고 코드의 논리를 계속 진행할 수 있습니다. 예를 들어, 가 아닌 유형이 있는 경우 Option프로그램은 아무것도 아닌 것보다 있는 것을 기대 합니다. 그러면 코드에서 Some및 에 대한 두 가지 사례를 처리할 필요가 없습니다.None변종: 확실히 값을 갖는 경우는 한 가지뿐입니다. 함수에 아무것도 전달하지 않으려는 코드는 컴파일조차 되지 않으므로 함수는 런타임에 해당 사례를 확인할 필요가 없습니다. 또 다른 예는 매개변수가 절대 음수가 되지 않도록 하는 와 같은 부호 없는 정수 유형을 사용하는 것입니다 u32.\n유효성 검사를 위한 사용자 정의 유형 만들기\nRust의 유형 시스템을 사용하여 한 단계 더 나아가 유효한 값이 있는지 확인하고 유효성 검사를 위한 사용자 지정 유형을 만드는 방법을 살펴보겠습니다. 2장에서 우리 코드가 사용자에게 1에서 100 사이의 숫자를 추측하도록 요청한 추측 게임을 기억하십시오. 우리는 비밀 번호와 비교하여 확인하기 전에 사용자의 추측이 해당 숫자 사이에 있는지 확인하지 않았습니다. 추측이 긍정적이라는 것만 확인했습니다. 이 경우 결과는 그다지 심각하지 않았습니다. 너무 높음 또는 너무 낮음의 결과는 여전히 정확합니다. 그러나 사용자가 유효한 추측으로 안내하고 사용자가 범위를 벗어난 숫자를 추측할 때와 예를 들어 대신 문자를 입력할 때 서로 다른 동작을 갖도록 하는 것은 유용한 개선 사항이 될 것입니다.\n이를 수행하는 한 가지 방법은 잠재적으로 음수를 허용하기 위해 추측을 a i32가 아닌 an으로 구문 분석 u32한 다음 다음과 같이 범위 내에 있는 숫자에 대한 검사를 추가하는 것입니다.\n    loop {\n        // --snip--\n\n        let guess: i32 = match guess.trim().parse() {\n            Ok(num) =&gt; num,\n            Err(_) =&gt; continue,\n        };\n\n        if guess &lt; 1 || guess &gt; 100 {\n            println!(`The secret number will be between 1 and 100.`);\n            continue;\n        }\n\n        match guess.cmp(&amp;secret_number) {\n            // --snip--\n    }\n\n이 if표현식은 값이 범위를 벗어나는지 확인하고 사용자에게 문제에 대해 알리고 continue루프의 다음 반복을 시작하고 다른 추측을 요청하도록 호출합니다. 표현식 후에 1과 100 사이에 있는 비밀 번호를 if비교하여 진행할 수 있습니다.guess``guess\n그러나 이것은 이상적인 해결책이 아닙니다. 프로그램이 1에서 100 사이의 값에서만 작동하는 것이 절대적으로 중요하고 이 요구 사항을 가진 많은 함수가 있는 경우 모든 함수에서 이와 같은 검사를 수행하는 것은 지루할 것입니다. 성능).\n대신 새 유형을 만들고 모든 곳에서 유효성 검사를 반복하는 대신 유형의 인스턴스를 생성하는 함수에 유효성 검사를 넣을 수 있습니다. 이렇게 하면 함수가 서명에 새 유형을 사용하고 수신한 값을 자신 있게 사용할 수 있습니다. 목록 9-13은 함수가 1에서 100 사이의 값을 받는 경우 Guess에만 인스턴스를 생성하는 유형을 정의하는 한 가지 방법을 보여줍니다.Guess``new\npub struct Guess {\n    value: i32,\n}\n\nimpl Guess {\n    pub fn new(value: i32) -&gt; Guess {\n        if value &lt; 1 || value &gt; 100 {\n            panic!(`Guess value must be between 1 and 100, got {}.`, value);\n        }\n\n        Guess { value }\n    }\n\n    pub fn value(&amp;self) -&gt; i32 {\n        self.value\n    }\n}\n\n목록 9-13: Guess1에서 100 사이의 값으로만 계속되는 유형\n먼저, 를 보유하는 Guessnamed 필드가 있는 named 구조체를 정의합니다. 여기에 번호가 저장됩니다.value``i32\n그런 다음 값 의 인스턴스를 생성하는 newon 이라는 관련 함수를 구현합니다. 이 함수는 유형이라는 이름의 매개변수 하나를 갖고 a를 반환하도록 정의됩니다. 함수 본문의 코드는 1과 100 사이인지 확인하기 위해 테스트합니다. 이 테스트를 통과하지 못하면 호출 코드를 작성하는 프로그래머에게 필요한 버그가 있음을 알리는 호출을 합니다. 이 범위 를 벗어나는 를 생성하면 의존하는 계약을 위반하게 되므로 수정합니다. 조건Guess``Guess``new``value``i32``Guess``new``value``value``panic!``Guess``value``Guess::new``Guess::new공개 API 문서에서 패닉에 대해 논의해야 할 수도 있습니다. panic!14장에서 만든 API 문서에서 a의 가능성을 나타내는 문서 규칙을 다룰 것입니다 value. 테스트를 통과하면 필드가 매개변수로 설정된 새 Guess항목 을 value만들고 .value``Guess\nvalue`다음으로 를 빌리고 `self`다른 매개변수가 없으며 를 반환하는 메서드를 구현합니다 `i32`. *이러한 종류의 메서드는 getter* 라고도 하는데 , 그 목적이 해당 필드에서 일부 데이터를 가져와서 반환하는 것이기 때문입니다. `value`구조체 의 필드 가 비공개 이기 때문에 이 공개 메서드가 필요합니다 `Guess`. `value`필드가 비공개여서 `Guess`구조체를 사용하는 코드가 직접 설정할 수 없도록 하는 것이 중요합니다 `value`. 모듈 외부의 코드는 함수를 사용하여 의 인스턴스를 생성 *해야* 하므로 a가 확인하지 않은 a를 가질 수 있는 방법이 없습니다. 함수 의 조건 .`Guess::new``Guess``Guess``value``Guess::new\n\nGuess매개 변수가 있거나 1에서 100 사이의 숫자만 반환하는 함수는 서명에서 an이 아닌 a 를 받거나 반환하며 i32본문에서 추가 검사를 수행할 필요가 없다고 선언할 수 있습니다.\n요약\nRust의 오류 처리 기능은 보다 강력한 코드를 작성하는 데 도움이 되도록 설계되었습니다. 매크로 panic!는 프로그램이 처리할 수 없는 상태에 있음을 알리고 유효하지 않거나 잘못된 값으로 진행하려고 시도하는 대신 프로세스를 중지하도록 지시할 수 있습니다. 열거 Result형은 Rust의 유형 시스템을 사용하여 코드가 복구할 수 있는 방식으로 작업이 실패할 수 있음을 나타냅니다. Result코드를 호출하는 코드에 잠재적인 성공 또는 실패도 처리해야 함을 알리는 데 사용할 수 있습니다. 적절한 상황에서 panic!및 를 사용하면 피할 수 없는 문제에 직면했을 때 코드를 보다 안정적으로 만들 수 있습니다.Result\nOption이제 표준 라이브러리가 및 enum 과 함께 제네릭을 사용하는 유용한 방법을 보았으므로 Result제네릭이 작동하는 방식과 코드에서 이를 사용할 수 있는 방법에 대해 설명하겠습니다.\n\n일반 유형, 특성 및 수명\n모든 프로그래밍 언어에는 개념의 중복을 효과적으로 처리하기 위한 도구가 있습니다. Rust에서 그러한 도구 중 하나는 제네릭 입니다 : 구체적인 유형 또는 기타 속성에 대한 추상 대체물입니다. 코드를 컴파일하고 실행할 때 제네릭의 위치에 무엇이 있는지 모른 채 제네릭의 동작 또는 제네릭이 다른 제네릭과 어떻게 관련되는지 표현할 수 있습니다.\ni32함수는 or 와 같은 구체적인 유형 대신 일부 일반 유형의 매개변수를 사용할 수 있습니다 String. 이는 함수가 알 수 없는 값을 가진 매개변수를 사용하여 여러 구체적인 값에서 동일한 코드를 실행하는 것과 같은 방식입니다. 사실 우리는 이미 6장에서 Option&lt;T&gt;, 8장에서 Vec&lt;T&gt;및 HashMap&lt;K, V&gt;, 9장에서 제네릭을 사용했습니다 Result&lt;T, E&gt;. 이 장에서는 제네릭을 사용하여 고유한 유형, 함수 및 메서드를 정의하는 방법을 살펴봅니다!\n먼저 코드 중복을 줄이기 위해 함수를 추출하는 방법을 검토합니다. 그런 다음 동일한 기술을 사용하여 매개 변수 유형만 다른 두 함수에서 일반 함수를 만듭니다. 또한 구조체 및 열거형 정의에서 제네릭 형식을 사용하는 방법도 설명합니다.\n그런 다음 특성을 사용하여 일반적인 방식으로 동작을 정의하는 방법을 배웁니다. 특성을 일반 유형과 결합하여 모든 유형이 아닌 특정 동작이 있는 유형만 허용하도록 일반 유형을 제한할 수 있습니다.\n마지막으로 수명에 대해 논의할 것입니다. 참조가 서로 어떻게 관련되어 있는지에 대한 컴파일러 정보를 제공하는 다양한 제네릭입니다. 수명을 통해 빌린 값에 대한 충분한 정보를 컴파일러에 제공하여 우리의 도움 없이 할 수 있는 것보다 더 많은 상황에서 참조가 유효하도록 할 수 있습니다.\n함수를 추출하여 중복 제거\n제네릭을 사용하면 특정 유형을 여러 유형을 나타내는 자리 표시자로 대체하여 코드 중복을 제거할 수 있습니다. 제네릭 구문을 살펴보기 전에 먼저 특정 값을 여러 값을 나타내는 자리 표시자로 대체하는 함수를 추출하여 제네릭 형식을 포함하지 않는 방식으로 중복을 제거하는 방법을 살펴보겠습니다. 그런 다음 동일한 기술을 적용하여 일반 함수를 추출합니다! 함수로 추출할 수 있는 중복 코드를 인식하는 방법을 살펴보면 제네릭을 사용할 수 있는 중복 코드를 인식하기 시작할 것입니다.\n목록에서 가장 큰 숫자를 찾는 목록 10-1의 짧은 프로그램으로 시작합니다.\n파일 이름: src/main.rs\nfn main() {\n    let number_list = vec![34, 50, 25, 100, 65];\n\n    let mut largest = &amp;number_list[0];\n\n    for number in &amp;number_list {\n        if number &gt; largest {\n            largest = number;\n        }\n    }\n\n    println!(`The largest number is {}`, largest);\n}\n\nListing 10-1: 숫자 목록에서 가장 큰 숫자 찾기\n정수 목록을 변수에 저장 number_list하고 목록의 첫 번째 숫자에 대한 참조를 라는 변수에 배치합니다 largest. 그런 다음 목록의 모든 숫자를 반복하고 현재 숫자가 에 저장된 숫자보다 크면 largest해당 변수의 참조를 바꿉니다. 그러나 현재 숫자가 지금까지 본 가장 큰 숫자보다 작거나 같으면 변수가 변경되지 않고 코드가 목록의 다음 숫자로 이동합니다. 목록의 모든 숫자를 고려한 후 largest가장 큰 숫자(이 경우 100)를 참조해야 합니다.\n우리는 이제 두 개의 서로 다른 숫자 목록에서 가장 큰 숫자를 찾는 임무를 받았습니다. 이를 위해 Listing 10-1의 코드를 복제하고 Listing 10-2와 같이 프로그램의 서로 다른 두 위치에서 동일한 논리를 사용하도록 선택할 수 있습니다.\n파일 이름: src/main.rs\nfn main() {\n    let number_list = vec![34, 50, 25, 100, 65];\n\n    let mut largest = &amp;number_list[0];\n\n    for number in &amp;number_list {\n        if number &gt; largest {\n            largest = number;\n        }\n    }\n\n    println!(`The largest number is {}`, largest);\n\n    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];\n\n    let mut largest = &amp;number_list[0];\n\n    for number in &amp;number_list {\n        if number &gt; largest {\n            largest = number;\n        }\n    }\n\n    println!(`The largest number is {}`, largest);\n}\n\n목록 10-2: 두 개의 숫자 목록 에서 가장 큰 숫자를 찾는 코드\n이 코드는 작동하지만 코드 복제는 지루하고 오류가 발생하기 쉽습니다. 또한 코드를 변경하고 싶을 때 여러 위치에서 코드를 업데이트해야 한다는 점을 기억해야 합니다.\n이 중복을 제거하기 위해 매개변수에 전달된 정수 목록에서 작동하는 함수를 정의하여 추상화를 만듭니다. 이 솔루션은 코드를 더 명확하게 만들고 목록에서 가장 큰 숫자를 찾는 개념을 추상적으로 표현할 수 있게 해줍니다.\nListing 10-3에서는 가장 큰 수를 찾는 코드를 이라는 함수로 추출합니다 largest. 그런 다음 목록 10-2의 두 목록에서 가장 큰 숫자를 찾는 함수를 호출합니다. i32우리는 미래에 가질 수 있는 다른 값 목록에서도 이 함수를 사용할 수 있습니다.\n파일 이름: src/main.rs\nfn largest(list: &amp;[i32]) -&gt; &amp;i32 {\n    let mut largest = &amp;list[0];\n\n    for item in list {\n        if item &gt; largest {\n            largest = item;\n        }\n    }\n\n    largest\n}\n\nfn main() {\n    let number_list = vec![34, 50, 25, 100, 65];\n\n    let result = largest(&amp;number_list);\n    println!(`The largest number is {}`, result);\n\n    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];\n\n    let result = largest(&amp;number_list);\n    println!(`The largest number is {}`, result);\n}\n\nListing 10-3: 두 목록에서 가장 큰 숫자를 찾는 추상화된 코드\n이 함수에는 함수에 전달할 수 있는 구체적인 값 조각을 나타내는 이라는 largest매개변수가 있습니다. 결과적으로 함수를 호출하면 코드는 전달한 특정 값에서 실행됩니다.list``i32\n요약하면 Listing 10-2에서 Listing 10-3으로 코드를 변경하기 위해 수행한 단계는 다음과 같습니다.\n\n중복 코드를 식별합니다.\n중복 코드를 함수 본문으로 추출하고 함수 서명에서 해당 코드의 입력 및 반환 값을 지정합니다.\n대신 함수를 호출하도록 중복 코드의 두 인스턴스를 업데이트합니다.\n\n다음으로 제네릭과 동일한 단계를 사용하여 코드 중복을 줄입니다. 함수 본문이 list특정 값 대신 추상에서 작동할 수 있는 것과 같은 방식으로 제네릭을 사용하면 코드가 추상 유형에서 작동할 수 있습니다.\n예를 들어, 값 조각에서 가장 큰 항목을 찾는 함수 i32와 값 조각에서 가장 큰 항목을 찾는 함수의 두 가지 함수가 있다고 가정합니다 char. 그 중복을 어떻게 제거할까요? 알아 보자!\n\n일반 데이터 유형\n제네릭을 사용하여 함수 서명 또는 구조체와 같은 항목에 대한 정의를 만든 다음 다양한 구체적인 데이터 유형과 함께 사용할 수 있습니다. 제네릭을 사용하여 함수, 구조체, 열거형 및 메서드를 정의하는 방법을 먼저 살펴보겠습니다. 그런 다음 제네릭이 코드 성능에 미치는 영향에 대해 설명합니다.\n함수 정의에서\n제네릭을 사용하는 함수를 정의할 때 일반적으로 매개 변수의 데이터 유형과 반환 값을 지정하는 함수 서명에 제네릭을 배치합니다. 이렇게 하면 코드가 더 유연해지고 함수 호출자에게 더 많은 기능을 제공하는 동시에 코드 중복을 방지할 수 있습니다.\n우리의 largest함수에 대해 계속해서 Listing 10-4는 슬라이스에서 가장 큰 값을 찾는 두 함수를 보여줍니다. 그런 다음 이들을 제네릭을 사용하는 단일 함수로 결합합니다.\n파일 이름: src/main.rs\nfn largest_i32(list: &amp;[i32]) -&gt; &amp;i32 {\n    let mut largest = &amp;list[0];\n\n    for item in list {\n        if item &gt; largest {\n            largest = item;\n        }\n    }\n\n    largest\n}\n\nfn largest_char(list: &amp;[char]) -&gt; &amp;char {\n    let mut largest = &amp;list[0];\n\n    for item in list {\n        if item &gt; largest {\n            largest = item;\n        }\n    }\n\n    largest\n}\n\nfn main() {\n    let number_list = vec![34, 50, 25, 100, 65];\n\n    let result = largest_i32(&amp;number_list);\n    println!(`The largest number is {}`, result);\n\n    let char_list = vec!['y', 'm', 'a', 'q'];\n\n    let result = largest_char(&amp;char_list);\n    println!(`The largest char is {}`, result);\n}\n\n목록 10-4: 서명의 이름과 유형만 다른 두 함수\n이 함수는 슬라이스에서 largest_i32가장 큰 것을 찾는 Listing 10-3에서 추출한 것입니다. i32이 함수는 슬라이스에서 largest_char가장 큰 것을 찾습니다. char함수 본문은 동일한 코드를 가지고 있으므로 단일 함수에 제네릭 형식 매개 변수를 도입하여 중복을 제거하겠습니다.\n새로운 단일 함수에서 유형을 매개변수화하려면 함수에 대한 값 매개변수와 마찬가지로 유형 매개변수의 이름을 지정해야 합니다. 모든 식별자를 유형 매개변수 이름으로 사용할 수 있습니다. T그러나 관례에 따라 Rust의 유형 매개변수 이름은 짧고 종종 문자일 뿐이며 Rust의 유형 이름 지정 규칙은 UpperCamelCase이기 때문에 사용할 것입니다. 유형의 줄임말은 T대부분의 Rust 프로그래머가 기본적으로 선택하는 것입니다.\n함수 본문에서 매개변수를 사용할 때 컴파일러가 해당 이름의 의미를 알 수 있도록 서명에 매개변수 이름을 선언해야 합니다. 유사하게 함수 시그니처에서 타입 매개변수 이름을 사용할 때 사용하기 전에 타입 매개변수 이름을 선언해야 합니다. 제네릭 함수를 정의하려면 다음과 같이 함수 이름과 매개변수 목록 사이의 largest꺾쇠 괄호 안에 유형 이름 선언을 배치합니다.&lt;&gt;\nfn largest&lt;T&gt;(list: &amp;[T]) -&gt; &amp;T {\n\n우리는 이 정의를 다음과 같이 읽습니다. 함수는 largest일부 유형에 대해 일반적입니다 T. 이 함수에는 list유형 값의 슬라이스인 이라는 이름의 매개변수가 하나 있습니다 T. 이 largest함수는 같은 유형의 값에 대한 참조를 반환합니다 T.\nlargestListing 10-5는 서명에 일반 데이터 유형을 사용하는 결합된 함수 정의를 보여줍니다. i32이 목록은 값 조각 또는 char값으로 함수를 호출하는 방법도 보여줍니다. 이 코드는 아직 컴파일되지 않지만 이 장의 뒷부분에서 수정할 것입니다.\n파일 이름: src/main.rs\nfn largest&lt;T&gt;(list: &amp;[T]) -&gt; &amp;T {\n    let mut largest = &amp;list[0];\n\n    for item in list {\n        if item &gt; largest {\n            largest = item;\n        }\n    }\n\n    largest\n}\n\nfn main() {\n    let number_list = vec![34, 50, 25, 100, 65];\n\n    let result = largest(&amp;number_list);\n    println!(`The largest number is {}`, result);\n\n    let char_list = vec!['y', 'm', 'a', 'q'];\n\n    let result = largest(&amp;char_list);\n    println!(`The largest char is {}`, result);\n}\n\n목록 10-5: largest일반 유형 매개변수를 사용하는 함수; 이것은 아직 컴파일되지 않습니다\n지금 이 코드를 컴파일하면 다음 오류가 발생합니다.\n$ cargo run\n   Compiling chapter10 v0.1.0 (file:///projects/chapter10)\nerror[E0369]: binary operation `&gt;` cannot be applied to type `&amp;T`\n --&gt; src/main.rs:5:17\n  |\n5 |         if item &gt; largest {\n  |            ---- ^ ------- &amp;T\n  |            |\n  |            &amp;T\n  |\nhelp: consider restricting type parameter `T`\n  |\n1 | fn largest&lt;T: std::cmp::PartialOrd&gt;(list: &amp;[T]) -&gt; &amp;T {\n  |             ++++++++++++++++++++++\n\nFor more information about this error, try `rustc --explain E0369`.\nerror: could not compile `chapter10` due to previous error\n\n도움말 텍스트는 특성인 을 언급하며 std::cmp::PartialOrd다음 섹션 에서 특성에 대해 이야기할 것입니다. 지금은 이 오류가 가능한 모든 유형에 대해 본문이 largest작동하지 않음을 나타냅니다 T. T본문에 있는 유형의 값을 비교하고 싶기 때문에 값을 정렬할 수 있는 유형만 사용할 수 있습니다. 비교를 가능하게 하기 위해 표준 라이브러리에는 std::cmp::PartialOrd유형에 대해 구현할 수 있는 특성이 있습니다(이 특성에 대한 자세한 내용은 부록 C 참조). 도움말 텍스트의 제안에 따라 유효한 유형을 T구현하는 유형으로만 제한 PartialOrd하고 이 예제는 컴파일할 것입니다. 표준 라이브러리는 및 PartialOrd모두에서 구현하기 때문입니다.i32``char\n구조체 정의에서\n구문을 사용하여 하나 이상의 필드에서 일반 유형 매개변수를 사용하도록 구조체를 정의할 수도 있습니다 &lt;&gt;. 목록 10-6은 모든 유형의 값을 Point&lt;T&gt;보유 x하고 y조정하는 구조체를 정의합니다.\n파일 이름: src/main.rs\nstruct Point&lt;T&gt; {\n    x: T,\n    y: T,\n}\n\nfn main() {\n    let integer = Point { x: 5, y: 10 };\n    let float = Point { x: 1.0, y: 4.0 };\n}\n\n목록 10-6: 유형의 값을 보유 Point&lt;T&gt;하는 구조체x``y``T\n구조체 정의에서 제네릭을 사용하는 구문은 함수 정의에서 사용되는 구문과 유사합니다. 먼저 구조체 이름 바로 뒤에 꺾쇠 괄호 안에 유형 매개변수의 이름을 선언합니다. 그런 다음 구체적인 데이터 유형을 지정하는 구조체 정의에서 일반 유형을 사용합니다.\n를 정의하기 위해 하나의 제네릭 유형만 사용했기 때문에 Point&lt;T&gt;이 정의에서는 Point&lt;T&gt;구조체가 일부 유형에 대해 제네릭 T하고 필드 x및 필드 y가 유형에 관계없이 동일한 유형임을 나타냅니다. 목록 10-7에서와 같이 다른 유형의 값을 가진 a 인스턴스를 생성하면 Point&lt;T&gt;코드가 컴파일되지 않습니다.\n파일 이름: src/main.rs\nstruct Point&lt;T&gt; {\n    x: T,\n    y: T,\n}\n\nfn main() {\n    let wont_work = Point { x: 5, y: 4.0 };\n}\n\n목록 10-7: 필드 x및 필드는 y둘 다 동일한 일반 데이터 유형을 갖기 때문에 동일한 유형이어야 합니다 T.\n이 예에서 정수 값 5를 에 할당하면 제네릭 형식이 의 이 인스턴스에 대한 정수가 될 것임을 x컴파일러에 알립니다. 그런 다음 와 동일한 유형을 갖도록 정의한 에 대해 4.0을 지정하면 다음과 같은 유형 불일치 오류가 발생합니다.T``Point&lt;T&gt;``y``x\n$ cargo run\n   Compiling chapter10 v0.1.0 (file:///projects/chapter10)\nerror[E0308]: mismatched types\n --&gt; src/main.rs:7:38\n  |\n7 |     let wont_work = Point { x: 5, y: 4.0 };\n  |                                      ^^^ expected integer, found floating-point number\n\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `chapter10` due to previous error\n\n및 가 모두 제네릭이지만 다른 유형을 가질 수 있는 Point구조체를 정의하려면 여러 제네릭 유형 매개변수를 사용할 수 있습니다. 예를 들어 Listing 10-8에서 유형에 대한 정의를 일반으로 변경하고 여기서 is of type 및 is of type 입니다.x``y``Point``T``U``x``T``y``U\n파일 이름: src/main.rs\nstruct Point&lt;T, U&gt; {\n    x: T,\n    y: U,\n}\n\nfn main() {\n    let both_integer = Point { x: 5, y: 10 };\n    let both_float = Point { x: 1.0, y: 4.0 };\n    let integer_and_float = Point { x: 5, y: 4.0 };\n}\n\n목록 10-8: 서로 다른 유형의 값이 될 수 Point&lt;T, U&gt;있도록 두 가지 유형에 대한 제네릭x``y\n이제 표시된 모든 인스턴스가 Point허용됩니다! 정의에서 제네릭 형식 매개 변수를 원하는 만큼 사용할 수 있지만 몇 개 이상 사용하면 코드를 읽기 어려워집니다. 코드에 많은 제네릭 형식이 필요한 경우 코드를 더 작은 조각으로 재구성해야 함을 나타낼 수 있습니다.\n열거형 정의에서\n구조체와 마찬가지로 열거형을 정의하여 변형에 일반 데이터 유형을 담을 수 있습니다. Option&lt;T&gt;6장에서 사용한 표준 라이브러리가 제공하는 열거형을 다시 살펴보겠습니다.\nenum Option&lt;T&gt; {\n    Some(T),\n    None,\n}\n\n이제 이 정의가 더 이해하기 쉬울 것입니다. 보시 Option&lt;T&gt;다시피 열거형은 유형에 대해 일반적 T이며 두 가지 변형이 있습니다. Some하나의 유형 값을 보유하는 T과 None값을 보유하지 않는 변형입니다. 열거형 을 사용하면 Option&lt;T&gt;옵셔널 값의 추상적인 개념을 표현할 수 있고 Option&lt;T&gt;제네릭이기 때문에 옵셔널 값의 타입에 관계없이 이 추상을 사용할 수 있습니다.\n열거형은 여러 제네릭 형식도 사용할 수 있습니다. Result9장에서 사용한 enum 의 정의는 한 가지 예입니다.\nenum Result&lt;T, E&gt; {\n    Ok(T),\n    Err(E),\n}\n\n열거 형은 두 가지 유형 및 Result에 대해 일반적 이며 두 가지 변형이 있습니다. 유형의 값을 보유하는 과 유형의 값을 보유하는 . 이 정의는 성공(일부 유형의 값 반환 ) 또는 실패(일부 유형의 오류 반환 ) 작업이 있는 모든 곳에서 enum 을 사용하는 것을 편리하게 만듭니다. 사실 이것은 목록 9-3에서 파일을 여는 데 사용한 것입니다. 파일이 성공적으로 열렸을 때 유형으로 채워지고 파일을 여는 데 문제가 있을 때 유형으로 채워졌습니다.T``E``Ok``T``Err``E``Result``T``E``T``std::fs::File``E``std::io::Error\n보유한 값의 유형만 다른 여러 구조체 또는 열거형 정의가 있는 코드의 상황을 인식하는 경우 대신 제네릭 유형을 사용하여 중복을 방지할 수 있습니다.\n메서드 정의에서\n우리는 구조체와 열거형에 메서드를 구현할 수 있고(5장에서 했던 것처럼) 정의에 제네릭 유형을 사용할 수도 있습니다. Listing 10-9는 Point&lt;T&gt;Listing 10-6에서 정의한 구조체에 x구현된 메서드를 보여줍니다.\n파일 이름: src/main.rs\nstruct Point&lt;T&gt; {\n    x: T,\n    y: T,\n}\n\nimpl&lt;T&gt; Point&lt;T&gt; {\n    fn x(&amp;self) -&gt; &amp;T {\n        &amp;self.x\n    }\n}\n\nfn main() {\n    let p = Point { x: 5, y: 10 };\n\n    println!(`p.x = {}`, p.x());\n}\n\n목록 10-9: 유형 필드 에 대한 참조를 반환하는 구조체 x에 명명된 메서드 구현Point&lt;T&gt;``x``T\n여기에서 필드의 데이터에 대한 참조를 반환하는 xon 이라는 메서드를 정의했습니다.Point&lt;T&gt;``x\n유형에 메서드를 구현하고 있음을 지정하는 데 사용할 수 있도록 T바로 뒤에 선언해야 합니다. 뒤에 일반 유형으로 선언함으로써 Rust는 꺾쇠 괄호 안에 있는 유형이 구체적인 유형이 아닌 일반 유형임을 식별할 수 있습니다. 이 일반 매개변수에 대해 구조체 정의에 선언된 일반 매개변수와 다른 이름을 선택할 수 있지만 동일한 이름을 사용하는 것이 관례입니다. 제네릭 형식을 선언하는 에서 작성된 메서드는 어떤 구체적인 형식이 제네릭 형식을 대체하는지에 관계없이 해당 형식의 모든 인스턴스에서 정의됩니다.impl``T``Point&lt;T&gt;``T``impl``Point``impl\n유형에 대한 메소드를 정의할 때 제네릭 유형에 대한 제약 조건을 지정할 수도 있습니다. 예를 들어 제네릭 유형이 있는 Point&lt;f32&gt;인스턴스가 아닌 인스턴스에서만 메서드를 구현할 수 있습니다. Point&lt;T&gt;Listing 10-10에서 구체적인 type 을 사용합니다 f32. 즉, . 뒤에 어떤 유형도 선언하지 않습니다 impl.\n파일 이름: src/main.rs\nimpl Point&lt;f32&gt; {\n    fn distance_from_origin(&amp;self) -&gt; f32 {\n        (self.x.powi(2) + self.y.powi(2)).sqrt()\n    }\n}\n\nListing 10-10: impl일반 유형 매개변수에 대한 특정 구체적인 유형을 가진 구조체에만 적용되는 블록T\n이 코드는 유형 에 메소드가 Point&lt;f32&gt;있음 을 의미합니다 distance_from_origin. 유형이 아닌 Point&lt;T&gt;다른 인스턴스에는 이 메소드가 정의되지 않습니다. 이 메서드는 포인트가 좌표(0.0, 0.0)의 포인트에서 얼마나 떨어져 있는지 측정하고 부동 소수점 유형에만 사용할 수 있는 수학 연산을 사용합니다.T``f32\n구조체 정의의 일반 유형 매개변수는 동일한 구조체의 메서드 서명에서 사용하는 매개변수와 항상 동일하지 않습니다. 목록 10-11은 예제를 더 명확하게 하기 위해 일반 유형 X1과 Y1구조체 Point및 X2 Y2메서드 서명을 사용합니다. mixup메서드는 ( type ) 의 값 과 전달된 값 ( type ) 을 Point사용하여 새 인스턴스를 만듭니다.x``self Point``X1``y``Point``Y2\n파일 이름: src/main.rs\nstruct Point&lt;X1, Y1&gt; {\n    x: X1,\n    y: Y1,\n}\n\nimpl&lt;X1, Y1&gt; Point&lt;X1, Y1&gt; {\n    fn mixup&lt;X2, Y2&gt;(self, other: Point&lt;X2, Y2&gt;) -&gt; Point&lt;X1, Y2&gt; {\n        Point {\n            x: self.x,\n            y: other.y,\n        }\n    }\n}\n\nfn main() {\n    let p1 = Point { x: 5, y: 10.4 };\n    let p2 = Point { x: `Hello`, y: 'c' };\n\n    let p3 = p1.mixup(p2);\n\n    println!(`p3.x = {}, p3.y = {}`, p3.x, p3.y);\n}\n\n목록 10-11: 구조체의 정의와 다른 제네릭 유형을 사용하는 메서드\n에서 for (값 포함 ) 및 for (값 포함 ) 가 있는 maina를 정의했습니다. 변수 는 for (값 포함 ) 및 for (값 포함 ) 문자열 슬라이스가 있는 구조체 입니다. 인수를 사용하여 호출 하면 for 가 있는 가 제공됩니다. 변수 는 for 를 갖게 됩니다. from 에서 왔기 때문입니다. 매크로 호출이 인쇄됩니다.Point``i32``x``5``f64``y``10.4``p2``Point``x```Hello```char``y``c``mixup``p1``p2``p3``i32``x``x``p1``p3``char``y``y``p2``println!``p3.x = 5, p3.y = c\nimpl`이 예제의 목적은 일부 제네릭 매개 변수가 선언되고 일부는 메서드 정의로 선언되는 상황을 보여 주는 것입니다. 여기에서 일반 매개변수 `X1`및 는 구조체 정의와 함께 이동하기 때문에 `Y1`뒤에 선언됩니다. `impl`일반 매개변수 `X2`및 는 메서드에만 관련되기 때문에 `Y2`뒤에 선언됩니다.`fn mixup\n\n제네릭을 사용한 코드 성능\n제네릭 형식 매개 변수를 사용할 때 런타임 비용이 있는지 궁금할 수 있습니다. 좋은 소식은 제네릭 유형을 사용해도 구체적인 유형을 사용할 때보다 프로그램 실행 속도가 느려지지 않는다는 것입니다.\nRust는 컴파일 타임에 제네릭을 사용하여 코드의 단일형화를 수행함으로써 이를 달성합니다. 단일형화는 컴파일할 때 사용되는 구체적인 유형을 채워 일반 코드를 특정 코드로 바꾸는 프로세스입니다. 이 프로세스에서 컴파일러는 Listing 10-5에서 제네릭 함수를 생성하는 데 사용한 단계와 반대로 수행합니다. 컴파일러는 제네릭 코드가 호출되는 모든 위치를 살펴보고 제네릭 코드가 호출되는 구체적인 유형에 대한 코드를 생성합니다. .\n표준 라이브러리의 일반 열거형을 사용하여 이것이 어떻게 작동하는지 살펴보겠습니다 Option&lt;T&gt;.\nlet integer = Some(5);\nlet float = Some(5.0);\n\nRust는 이 코드를 컴파일할 때 단일형화를 수행합니다. 이 과정에서 컴파일러는 인스턴스에서 사용된 값을 읽고 Option&lt;T&gt;두 가지 종류를 식별합니다 Option&lt;T&gt;. 하나는 이고 i32다른 하나는 입니다 f64. 따라서 의 일반 정의를 및 Option&lt;T&gt;에 특화된 두 가지 정의로 확장하여 일반 정의를 특정 정의로 바꿉니다.i32``f64\n코드의 단일형 버전은 다음과 유사합니다(컴파일러는 설명을 위해 여기에서 사용하는 이름과 다른 이름을 사용함).\n파일 이름: src/main.rs\nenum Option_i32 {\n    Some(i32),\n    None,\n}\n\nenum Option_f64 {\n    Some(f64),\n    None,\n}\n\nfn main() {\n    let integer = Option_i32::Some(5);\n    let float = Option_f64::Some(5.0);\n}\n\n제네릭은 Option&lt;T&gt;컴파일러에서 만든 특정 정의로 대체됩니다. Rust는 제네릭 코드를 각 인스턴스의 유형을 지정하는 코드로 컴파일하기 때문에 제네릭 사용에 대한 런타임 비용을 지불하지 않습니다. 코드가 실행되면 각 정의를 직접 복사한 것처럼 수행됩니다. 단일형화 프로세스는 Rust의 제네릭을 실행 시간에 매우 효율적으로 만듭니다.\n\n특성: 공유 행동 정의\n특성은 특정 유형이 가지고 있고 다른 유형과 공유할 수 있는 기능을 정의합니다. 특성을 사용하여 추상적인 방식으로 공유 동작을 정의할 수 있습니다. 특성 경계를 사용하여 제네릭 유형이 특정 동작이 있는 모든 유형이 될 수 있음을 지정할 수 있습니다.\n\n참고: 특성은 약간의 차이는 있지만 종종 다른 언어에서 인터페이스 라고 하는 기능과 유사합니다.\n\n특성 정의\n유형의 동작은 해당 유형에서 호출할 수 있는 메서드로 구성됩니다. 모든 유형에서 동일한 메서드를 호출할 수 있는 경우 다른 유형은 동일한 동작을 공유합니다. 특성 정의는 어떤 목적을 달성하는 데 필요한 일련의 동작을 정의하기 위해 메서드 서명을 함께 그룹화하는 방법입니다.\n예를 들어 다양한 종류와 양의 텍스트를 포함하는 여러 구조체가 있다고 가정해 보겠습니다. NewsArticle특정 위치에 보관된 뉴스 기사를 포함하는 구조체와 Tweet새 트윗인지 여부를 나타내는 메타데이터와 함께 최대 280자를 포함할 수 있는 구조체가 있습니다. , 리트윗 또는 다른 트윗에 대한 답글.\n또는 인스턴스 aggregator에 저장될 수 있는 데이터의 요약을 표시할 수 있는 이름이 지정된 미디어 수집기 라이브러리 크레이트를 만들고 싶습니다. 이렇게 하려면 각 유형의 요약이 필요하며 인스턴스에서 메서드를 호출하여 해당 요약을 요청합니다. 목록 10-12는 이 동작을 표현하는 공개 특성의 정의를 보여줍니다.NewsArticle``Tweet``summarize``Summary\n파일 이름: src/lib.rs\npub trait Summary {\n    fn summarize(&amp;self) -&gt; String;\n}\n\nListing 10-12: 메서드가 Summary제공하는 동작으로 구성된 트레이트summarize\n여기에서 우리는 키워드를 사용하여 특성을 선언 한 다음 이 경우 trait특성의 이름을 사용합니다. 우리는 또한 몇 가지 예에서 볼 수 있듯이 이 상자에 의존하는 상자가 이 특성을 사용할 수 있도록 Summary특성을 로 선언했습니다. pub중괄호 안에는 이 특성을 구현하는 유형의 동작을 설명하는 메서드 서명을 선언합니다. 이 경우에는 fn summarize(&amp;self) -&gt; String.\n메서드 서명 뒤에 중괄호 안에 구현을 제공하는 대신 세미콜론을 사용합니다. 이 특성을 구현하는 각 유형은 메서드 본문에 대한 고유한 사용자 지정 동작을 제공해야 합니다. 컴파일러는 특성이 있는 모든 유형이 이 서명으로 정의된 Summary메서드를 갖도록 강제합니다.summarize\n특성은 본문에 여러 메서드를 가질 수 있습니다. 메서드 시그니처는 한 줄에 하나씩 나열되고 각 줄은 세미콜론으로 끝납니다.\n유형에 특성 구현\n이제 특성 메서드의 원하는 서명을 정의했으므로 Summary미디어 수집기의 유형에 구현할 수 있습니다. 목록 10-13 은 헤드라인, 작성자 및 위치를 사용하여 의 반환 값을 생성하는 구조체 Summary의 특성 구현을 보여줍니다. 구조체의 경우 트윗 콘텐츠가 이미 280자로 제한되어 있다고 가정하고 트윗의 전체 텍스트가 뒤에 오는 사용자 이름으로 정의합니다.NewsArticle``summarize``Tweet``summarize\n파일 이름: src/lib.rs\npub struct NewsArticle {\n    pub headline: String,\n    pub location: String,\n    pub author: String,\n    pub content: String,\n}\n\nimpl Summary for NewsArticle {\n    fn summarize(&amp;self) -&gt; String {\n        format!(`{}, by {} ({})`, self.headline, self.author, self.location)\n    }\n}\n\npub struct Tweet {\n    pub username: String,\n    pub content: String,\n    pub reply: bool,\n    pub retweet: bool,\n}\n\nimpl Summary for Tweet {\n    fn summarize(&amp;self) -&gt; String {\n        format!(`{}: {}`, self.username, self.content)\n    }\n}\n\nListing 10-13: 및 유형 Summary에 대한 특성 구현NewsArticle``Tweet\n유형에 특성을 구현하는 것은 일반 메서드를 구현하는 것과 유사합니다. 차이점은 뒤에 impl구현하려는 특성 이름을 입력한 다음 for키워드를 사용한 다음 특성을 구현하려는 유형의 이름을 지정한다는 것입니다. 블록 내에서 impl특성 정의가 정의한 메서드 시그니처를 넣습니다. 각 서명 뒤에 세미콜론을 추가하는 대신 중괄호를 사용하고 특성의 메서드가 특정 유형에 대해 갖고 싶은 특정 동작으로 메서드 본문을 채웁니다.\n이제 라이브러리가 및 Summary에 대해 특성을 구현했으므로 크레이트 사용자는 일반 메서드를 호출하는 것과 같은 방식으로 및 의 인스턴스에서 특성 메서드를 호출할 수 있습니다. 유일한 차이점은 사용자가 특성과 유형을 범위로 가져와야 한다는 것입니다. 다음은 바이너리 크레이트가 라이브러리 크레이트를 어떻게 사용할 수 있는지에 대한 예입니다.NewsArticle``Tweet``NewsArticle``Tweet``aggregator\nuse aggregator::{Summary, Tweet};\n\nfn main() {\n    let tweet = Tweet {\n        username: String::from(`horse_ebooks`),\n        content: String::from(\n            `of course, as you probably already know, people`,\n        ),\n        reply: false,\n        retweet: false,\n    };\n\n    println!(`1 new tweet: {}`, tweet.summarize());\n}\n\n이 코드는 1 new tweet: horse_ebooks: of course, as you probably already know, people.\n크레이트 에 의존하는 다른 크레이트 aggregator도 특성을 범위로 가져와 자체 유형에 Summary구현할 수 있습니다. Summary주의해야 할 한 가지 제한 사항은 트레이트 또는 유형 중 적어도 하나가 크레이트에 로컬인 경우에만 유형에 트레이트를 구현할 수 있다는 것입니다. 예를 들어, 유형이 우리 크레이트 에 로컬이기 때문에 크레이트 기능 의 일부로 Display사용자 정의 유형과 같은 표준 라이브러리 특성을 구현할 수 있습니다. 특성이 우리 크레이트에 로컬이기 때문에 우리는 크레이트에서 on을 구현할 수도 있습니다.Tweet``aggregator``Tweet``aggregator``Summary``Vec&lt;T&gt;``aggregator``Summary``aggregator\n그러나 외부 유형에 외부 특성을 구현할 수는 없습니다. 예를 들어, and 가 표준 라이브러리에 정의되어 있고 우리 크레이트에 국한되지 않기 때문에 우리는 크레이트 내에서 Display특성을 구현할 수 없습니다. 이 제한은 coherence 라는 속성의 일부 이며, 특히 부모 유형이 없기 때문에 이름이 지정된 고아 규칙 의 일부입니다. 이 규칙은 다른 사람의 코드가 귀하의 코드를 손상시킬 수 없으며 그 반대의 경우도 마찬가지입니다. 규칙이 없으면 두 개의 크레이트가 동일한 유형에 대해 동일한 특성을 구현할 수 있으며 러스트는 어떤 구현을 사용할지 알 수 없습니다.Vec&lt;T&gt;``aggregator``Display``Vec&lt;T&gt;``aggregator\n기본 구현\n때로는 모든 유형의 모든 메소드에 대한 구현을 요구하는 대신 특성의 일부 또는 모든 메소드에 대한 기본 동작을 갖는 것이 유용합니다. 그런 다음 특정 유형에 특성을 구현하면서 각 메서드의 기본 동작을 유지하거나 재정의할 수 있습니다.\nListing 10-14에서 우리는 Listing 10-12에서 했던 것처럼 메서드 서명만 정의하는 대신 특성의 summarize메서드 에 대한 기본 문자열을 지정합니다.Summary\n파일 이름: src/lib.rs\npub trait Summary {\n    fn summarize(&amp;self) -&gt; String {\n        String::from(`(Read more...)`)\n    }\n}\n\nListing 10-14: 메서드 Summary의 기본 구현으로 트레이트 정의하기summarize\n의 인스턴스를 요약하기 위해 기본 구현을 사용하려면 로 NewsArticle빈 블록을 지정합니다.impl``impl Summary for NewsArticle {}\nsummarize`더 이상 메서드를 직접 정의하지 않지만 기본 구현을 제공하고 특성을 구현하도록 `NewsArticle`지정했습니다. 결과적으로 다음과 같이 의 인스턴스에서 메서드를 계속 호출할 수 있습니다.`NewsArticle``Summary``summarize``NewsArticle\n    let article = NewsArticle {\n        headline: String::from(`Penguins win the Stanley Cup Championship!`),\n        location: String::from(`Pittsburgh, PA, USA`),\n        author: String::from(`Iceburgh`),\n        content: String::from(\n            `The Pittsburgh Penguins once again are the best \\\n             hockey team in the NHL.`,\n        ),\n    };\n\n    println!(`New article available! {}`, article.summarize());\n\n이 코드는 New article available! (Read more...).\nSummary기본 구현을 만들려면 Listing 10-13의 on 구현에 대해 아무것도 변경할 필요가 없습니다 Tweet. 그 이유는 기본 구현을 재정의하는 구문이 기본 구현이 없는 특성 메서드를 구현하는 구문과 동일하기 때문입니다.\n기본 구현은 다른 메서드에 기본 구현이 없더라도 동일한 트레이트에서 다른 메서드를 호출할 수 있습니다. 이러한 방식으로 특성은 많은 유용한 기능을 제공할 수 있으며 구현자는 그 중 일부만 지정하면 됩니다. 예를 들어 구현이 필요한 메서드를 Summary갖도록 특성을 정의한 summarize_author다음 summarize해당 메서드를 호출하는 기본 구현이 있는 메서드를 정의할 수 있습니다 summarize_author.\npub trait Summary {\n    fn summarize_author(&amp;self) -&gt; String;\n\n    fn summarize(&amp;self) -&gt; String {\n        format!(`(Read more from {}...)`, self.summarize_author())\n    }\n}\n\n이 버전의 를 사용하려면 유형에 특성을 구현할 때 Summary정의하기만 하면 됩니다.summarize_author\nimpl Summary for Tweet {\n    fn summarize_author(&amp;self) -&gt; String {\n        format!(`@{}`, self.username)\n    }\n}\n\n를 정의한 후 구조체의 인스턴스를 summarize_author호출할 수 있으며 의 기본 구현은 우리가 제공한 정의를 호출합니다. 우리가 구현했기 때문에 특성 은 더 이상 코드를 작성할 필요 없이 메서드 의 동작을 제공했습니다.summarize``Tweet``summarize``summarize_author``summarize_author``Summary``summarize\n    let tweet = Tweet {\n        username: String::from(`horse_ebooks`),\n        content: String::from(\n            `of course, as you probably already know, people`,\n        ),\n        reply: false,\n        retweet: false,\n    };\n\n    println!(`1 new tweet: {}`, tweet.summarize());\n\n이 코드는 1 new tweet: (Read more from @horse_ebooks...).\n동일한 메서드의 재정의 구현에서 기본 구현을 호출하는 것은 불가능합니다.\n매개변수로서의 특성\n이제 특성을 정의하고 구현하는 방법을 알았으므로 특성을 사용하여 다양한 유형을 허용하는 함수를 정의하는 방법을 탐색할 수 있습니다. 우리는 목록 10-13의 및 유형에서 Summary구현한 특성을 사용하여 특성을 구현하는 유형의 매개변수 에서 메소드를 호출하는 함수를 정의합니다. 이를 위해 다음과 같은 구문을 사용합니다.NewsArticle``Tweet``notify``summarize``item``Summary``impl Trait\npub fn notify(item: &amp;impl Summary) {\n    println!(`Breaking news! {}`, item.summarize());\n}\n\n매개변수 에 대한 구체적인 유형 대신 키워드와 특성 이름을 item지정합니다. impl이 매개변수는 지정된 특성을 구현하는 모든 유형을 허용합니다. 의 본문에서 와 같이 특성 에서 오는 notify모든 메서드를 호출할 수 있습니다. 또는 의 모든 인스턴스를 호출하고 전달할 수 있습니다. a 또는 an 과 같은 다른 유형으로 함수를 호출하는 코드는 해당 유형이 를 구현하지 않기 때문에 컴파일되지 않습니다.item``Summary``summarize``notify``NewsArticle``Tweet``String``i32``Summary\n특성 바인딩 구문\n구문 은 간단한 경우에 작동하지만 실제로는 특성 경계impl Trait 로 알려진 더 긴 형식의 구문 설탕입니다. 다음과 같이 보입니다.\npub fn notify&lt;T: Summary&gt;(item: &amp;T) {\n    println!(`Breaking news! {}`, item.summarize());\n}\n\n이 긴 형식은 이전 섹션의 예와 동일하지만 더 장황합니다. 콜론과 꺾쇠 괄호 안에 제네릭 형식 매개 변수 선언과 함께 특성 범위를 배치합니다.\n구문 impl Trait은 편리하고 단순한 경우에 더 간결한 코드를 작성하는 반면, 더 완전한 특성 바인딩 구문은 다른 경우에 더 복잡함을 표현할 수 있습니다. 예를 들어 Summary. 구문을 사용하면 impl Trait다음과 같습니다.\npub fn notify(item1: &amp;impl Summary, item2: &amp;impl Summary) {\n\nimpl Trait이 함수가 서로 다른 유형을 허용 item1하고 가지도록 하려면 사용하는 것이 적절합니다 item2(두 유형 모두 구현하는 한 Summary). 그러나 두 매개변수가 동일한 유형을 갖도록 하려면 다음과 같이 특성 경계를 사용해야 합니다.\npub fn notify&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) {\n\n및 매개 변수 T의 유형으로 지정된 제네릭 유형은 및 에 대한 인수로 전달된 값의 구체적인 유형이 동일해야 하도록 함수를 제한합니다.item1``item2``item1``item2\n+구문을 사용하여 여러 특성 경계 지정\n하나 이상의 특성 경계를 지정할 수도 있습니다. on notify뿐만 아니라 표시 형식을 사용하고 싶다고 가정해 보겠습니다. 정의 에서 and 를 모두 구현해야 한다고 지정합니다. 다음 구문을 사용하여 그렇게 할 수 있습니다.summarize``item``notify``item``Display``Summary``+\npub fn notify(item: &amp;(impl Summary + Display)) {\n\n구문 +은 제네릭 형식에 대한 특성 범위에서도 유효합니다.\npub fn notify&lt;T: Summary + Display&gt;(item: &amp;T) {\n\n두 개의 특성 경계가 지정되면 의 본문은 format 을 notify호출 summarize하고 사용할 수 있습니다.{}``item\nwhere절로 더 명확한 특성 경계\n너무 많은 특성 범위를 사용하면 단점이 있습니다. 각 제네릭에는 고유한 특성 경계가 있으므로 여러 제네릭 유형 매개변수가 있는 함수는 함수 이름과 해당 매개변수 목록 사이에 많은 특성 경계 정보를 포함할 수 있으므로 함수 서명을 읽기 어렵게 만듭니다. 이러한 이유로 Rust는 where함수 서명 뒤의 절 내부에 특성 범위를 지정하기 위한 대체 구문을 가지고 있습니다. 따라서 다음과 같이 작성하는 대신:\nfn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: &amp;T, u: &amp;U) -&gt; i32 {\n\nwhere다음과 같은 절을 사용할 수 있습니다.\nfn some_function&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32\nwhere\n    T: Display + Clone,\n    U: Clone + Debug,\n{\n\n이 함수의 시그니처는 덜 복잡합니다. 함수 이름, 매개변수 목록 및 반환 유형이 서로 가깝고 많은 특성 범위가 없는 함수와 비슷합니다.\n특성을 구현하는 반환 형식\nimpl Trait다음과 같이 반환 위치의 구문을 사용하여 특성을 구현하는 일부 유형의 값을 반환할 수도 있습니다.\nfn returns_summarizable() -&gt; impl Summary {\n    Tweet {\n        username: String::from(`horse_ebooks`),\n        content: String::from(\n            `of course, as you probably already know, people`,\n        ),\n        reply: false,\n        retweet: false,\n    }\n}\n\nimpl Summary반환 유형에 를 사용하여 함수가 구체적인 유형의 이름을 지정하지 않고 특성을 returns_summarizable구현하는 일부 유형을 반환하도록 지정합니다. Summary이 경우 는 returns_summarizable를 반환 Tweet하지만 이 함수를 호출하는 코드는 이를 알 필요가 없습니다.\n구현하는 특성에 의해서만 반환 유형을 지정하는 기능은 13장에서 다룰 클로저와 반복자의 맥락에서 특히 유용합니다. 클로저와 반복자는 컴파일러만 아는 유형이나 지정하기에 매우 긴 유형을 만듭니다. 구문 impl Trait을 사용하면 함수가 Iterator매우 긴 유형을 작성할 필요 없이 특성을 구현하는 일부 유형을 반환하도록 간결하게 지정할 수 있습니다.\n그러나 impl Trait단일 유형을 반환하는 경우에만 사용할 수 있습니다. 예를 들어 반환 유형이 다음과 같이 지정된 a NewsArticle또는 a를 반환하는 다음 코드는 작동하지 않습니다.Tweet``impl Summary\nfn returns_summarizable(switch: bool) -&gt; impl Summary {\n    if switch {\n        NewsArticle {\n            headline: String::from(\n                `Penguins win the Stanley Cup Championship!`,\n            ),\n            location: String::from(`Pittsburgh, PA, USA`),\n            author: String::from(`Iceburgh`),\n            content: String::from(\n                `The Pittsburgh Penguins once again are the best \\\n                 hockey team in the NHL.`,\n            ),\n        }\n    } else {\n        Tweet {\n            username: String::from(`horse_ebooks`),\n            content: String::from(\n                `of course, as you probably already know, people`,\n            ),\n            reply: false,\n            retweet: false,\n        }\n    }\n}\n\n구문이 컴파일러에서 구현되는 방식에 대한 제한으로 인해 a NewsArticle또는 a를 반환하는 것은 허용되지 않습니다. 17장의 다른 유형의 값을 허용하는 트레이트 개체 사용 섹션에서 이 동작을 사용하여 함수를 작성하는 방법을 다룰 것입니다.Tweet``impl Trait\n특성 경계를 사용하여 메서드를 조건부로 구현\n제네릭 타입 매개변수를 사용 하는 블록에 바인딩된 트레이트를 사용함으로써 impl지정된 트레이트를 구현하는 타입에 대해 조건부로 메서드를 구현할 수 있습니다. 예를 들어 목록 10-15의 유형은 Pair&lt;T&gt;항상 new새로운 인스턴스를 반환하는 함수를 구현합니다 Pair&lt;T&gt;( 블록 유형에 대한 유형 별칭인 5장의 메소드 정의 섹션에서 기억하십시오 . 이 경우에는 입니다.) . 그러나 다음 블록 에서는 내부 유형이 비교를 가능하게 하는 특성 과 인쇄를 가능하게 하는 특성 을 구현하는 경우 에만 메소드를 구현합니다.Self``impl``Pair&lt;T&gt;``impl``Pair&lt;T&gt;``cmp_display``T``PartialOrd``Display\n파일 이름: src/lib.rs\nuse std::fmt::Display;\n\nstruct Pair&lt;T&gt; {\n    x: T,\n    y: T,\n}\n\nimpl&lt;T&gt; Pair&lt;T&gt; {\n    fn new(x: T, y: T) -&gt; Self {\n        Self { x, y }\n    }\n}\n\nimpl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; {\n    fn cmp_display(&amp;self) {\n        if self.x &gt;= self.y {\n            println!(`The largest member is x = {}`, self.x);\n        } else {\n            println!(`The largest member is y = {}`, self.y);\n        }\n    }\n}\n\nListing 10-15: 트레잇 경계에 따라 제네릭 타입에 대한 조건부 구현 메서드\n또한 다른 특성을 구현하는 모든 유형에 대한 특성을 조건부로 구현할 수 있습니다. 트레잇 범위를 만족하는 모든 유형에 대한 트레잇 구현을 블랭킷 구현 이라고 하며 Rust 표준 라이브러리에서 광범위하게 사용됩니다. 예를 들어 표준 라이브러리는 ToString특성을 구현하는 모든 유형에서 Display특성을 구현합니다. impl표준 라이브러리의 블록은 다음 코드와 유사합니다.\nimpl&lt;T: Display&gt; ToString for T {\n    // --snip--\n}\n\n표준 라이브러리에는 이 포괄적인 구현이 있기 때문에 특성을 구현하는 모든 유형에서 특성 to_string에 의해 정의된 메서드를 호출할 수 있습니다. 예를 들어 정수는 다음을 구현하기 때문에 정수를 다음과 같이 해당 값 으로 변환할 수 있습니다.ToString``Display``String``Display\nlet s = 3.to_string();\n\n일괄 구현은 구현자 섹션의 특성에 대한 문서에 나타납니다.\n특성 및 특성 범위를 사용하면 제네릭 형식 매개 변수를 사용하여 중복을 줄이는 코드를 작성할 수 있을 뿐만 아니라 제네릭 형식이 특정 동작을 수행하도록 컴파일러에 지정할 수도 있습니다. 그런 다음 컴파일러는 특성 바인딩 정보를 사용하여 코드와 함께 사용되는 모든 구체적인 유형이 올바른 동작을 제공하는지 확인할 수 있습니다. 동적 형식 언어에서는 메서드를 정의하지 않은 형식에서 메서드를 호출하면 런타임에 오류가 발생합니다. 그러나 Rust는 이러한 오류를 컴파일 시간으로 이동하므로 코드가 실행되기 전에 문제를 수정해야 합니다. 또한 컴파일 타임에 이미 확인했기 때문에 런타임에 동작을 확인하는 코드를 작성할 필요가 없습니다. 이렇게 하면 제네릭의 유연성을 포기하지 않고도 성능이 향상됩니다.\n\n수명으로 참조 유효성 검사\n수명은 우리가 이미 사용하고 있는 또 다른 종류의 제네릭입니다. 타입이 우리가 원하는 행동을 하도록 보장하는 대신, 라이프타임은 참조가 우리가 필요로 하는 한 유효하도록 보장합니다.\n4장의 참조 및 차용 섹션 에서 논의하지 않은 한 가지 세부 사항은 Rust의 모든 참조에는 해당 참조가 유효한 범위인 수명이 있다는 것입니다. 대부분의 경우 수명은 대부분의 경우 유형이 유추되는 것처럼 암시적이고 유추됩니다. 여러 유형이 가능한 경우에만 유형에 주석을 달아야 합니다. 비슷한 방식으로 참조의 수명이 몇 가지 다른 방식으로 관련될 수 있는 경우 수명에 주석을 달아야 합니다. Rust는 런타임에 사용되는 실제 참조가 확실히 유효하도록 일반 수명 매개변수를 사용하여 관계에 주석을 달도록 요구합니다.\n수명에 주석을 다는 것은 대부분의 다른 프로그래밍 언어가 가지고 있는 개념도 아니므로 생소하게 느껴질 것입니다. 이 장에서 라이프타임 전체를 다루지는 않겠지만, 개념에 익숙해질 수 있도록 라이프타임 구문을 만날 수 있는 일반적인 방법에 대해 논의할 것입니다.\n수명이 있는 댕글링 참조 방지\n수명의 주요 목표는 프로그램이 참조하려는 데이터가 아닌 다른 데이터를 참조하게 하는 매달린 참조를 방지하는 것입니다. 외부 범위와 내부 범위가 있는 Listing 10-16의 프로그램을 고려하십시오.\nfn main() {\n    let r;\n\n    {\n        let x = 5;\n        r = &amp;x;\n    }\n\n    println!(`r: {}`, r);\n}\n\n목록 10-16: 값이 범위를 벗어난 참조를 사용하려는 시도\n\n참고: Listings 10-16, 10-17 및 10-23의 예제는 초기 값을 제공하지 않고 변수를 선언하므로 변수 이름은 외부 범위에 존재합니다. 언뜻 보기에 이는 Rust가 null 값을 갖지 않는 것과 충돌하는 것처럼 보일 수 있습니다. 그러나 값을 주기 전에 변수를 사용하려고 하면 Rust가 실제로 null 값을 허용하지 않는다는 것을 보여주는 컴파일 타임 오류가 발생합니다.\n\n외부 범위는 초기값이 없는 명명된 변수를 선언 r하고 내부 범위는 초기값 5로 명명된 변수를 선언합니다 x. 내부 범위 내에서 의 값을 에 대한 r참조로 설정하려고 시도합니다 x. 그런 다음 내부 범위가 종료되고 에 값을 인쇄하려고 시도합니다 r. r이 코드는 사용하려고 시도하기 전에 참조하는 값이 범위를 벗어났기 때문에 컴파일되지 않습니다. 오류 메시지는 다음과 같습니다.\n$ cargo run\n   Compiling chapter10 v0.1.0 (file:///projects/chapter10)\nerror[E0597]: `x` does not live long enough\n --&gt; src/main.rs:6:13\n  |\n6 |         r = &amp;x;\n  |             ^^ borrowed value does not live long enough\n7 |     }\n  |     - `x` dropped here while still borrowed\n8 |\n9 |     println!(`r: {}`, r);\n  |                       - borrow later used here\n\nFor more information about this error, try `rustc --explain E0597`.\nerror: could not compile `chapter10` due to previous error\n\n변수는 x``충분히 오래 살지 않습니다. 그 이유는 x내부 범위가 7행에서 끝날 때 범위를 벗어나기 때문입니다. 그러나 r외부 범위에는 여전히 유효합니다. 그 범위가 더 크기 때문에 우리는 그것이 더 오래 산다고 말합니다. Rust가 이 코드가 작동하도록 허용하면 범위를 벗어날 r때 할당 해제된 메모리를 참조하게 되고 우리가 시도한 모든 작업이 올바르게 작동하지 않을 것입니다. 그렇다면 Rust는 이 코드가 유효하지 않다는 것을 어떻게 판단할까요? 차입 검사기를 사용합니다.x``r\n차용 체커\nRust 컴파일러에는 범위를 비교하여 모든 차용이 유효한지 확인하는 차용 검사기가 있습니다. 목록 10-17은 목록 10-16과 동일한 코드를 보여주지만 변수의 수명을 보여주는 주석이 있습니다.\nfn main() {\n    let r;                // ---------+-- 'a\n                          //          |\n    {                     //          |\n        let x = 5;        // -+-- 'b  |\n        r = &amp;x;           //  |       |\n    }                     // -+       |\n                          //          |\n    println!(`r: {}`, r); //          |\n}                         // ---------+\n\nrListing 10-17: 및 x의 수명에 'a대한 'b주석\nr`여기에서 with 의 수명 과 with `'a`의 수명에 주석을 달았습니다. 보시다시피 내부 블록은 외부 수명 블록보다 훨씬 작습니다. 컴파일 시간에 Rust는 두 수명의 크기를 비교하여 수명이 이지만 수명이 . 다음 보다 짧기 때문에 프로그램이 거부됩니다. 참조 대상이 참조만큼 오래 살지 않습니다.`x``'b``'b``'a``r``'a``'b``'b``'a\n\n목록 10-18은 코드를 수정하여 매달린 참조가 없고 오류 없이 컴파일합니다.\nfn main() {\n    let x = 5;            // ----------+-- 'b\n                          //           |\n    let r = &amp;x;           // --+-- 'a  |\n                          //   |       |\n    println!(`r: {}`, r); //   |       |\n                          // --+       |\n}                         // ----------+\n\nListing 10-18: 데이터가 참조보다 수명이 길기 때문에 유효한 참조\n여기서 x수명은 이며 'b, 이 경우에는 수명이 입니다 'a. 이것은 r참조할 수 있음을 의미합니다 x. Rust는 참조가 유효한 r동안 참조가 항상 유효하다는 것을 알고 있기 때문입니다.x\n이제 참조의 수명이 어디에 있고 Rust가 참조가 항상 유효한지 확인하기 위해 수명을 분석하는 방법을 알았으므로 함수 컨텍스트에서 매개 변수의 일반적인 수명과 반환 값을 살펴보겠습니다.\n함수의 일반 수명\n우리는 두 문자열 조각 중 더 긴 것을 반환하는 함수를 작성할 것입니다. 이 함수는 두 개의 문자열 슬라이스를 가져와 단일 문자열 슬라이스를 반환합니다. 함수 를 구현한 후 longest목록 10-19의 코드는 를 인쇄해야 합니다 The longest string is abcd.\n파일 이름: src/main.rs\nfn main() {\n    let string1 = String::from(`abcd`);\n    let string2 = `xyz`;\n\n    let result = longest(string1.as_str(), string2);\n    println!(`The longest string is {}`, result);\n}\n\n목록 10-19: 두 스트링 슬라이스 중 더 긴 것을 찾는 함수를 main호출하는 함수longest\nlongest우리는 함수가 매개 변수의 소유권을 갖는 것을 원하지 않기 때문에 함수가 문자열이 아닌 참조인 문자열 슬라이스를 취하기를 원한다는 점에 유의하십시오 . 목록 10-19에서 사용하는 매개변수가 우리가 원하는 매개변수인 이유에 대한 자세한 내용은 4장의 매개변수로서의 스트링 슬라이스 섹션을 참조하십시오 .\nListing 10-20과 같이 함수를 구현하려고 하면 longest컴파일되지 않습니다.\n파일 이름: src/main.rs\nfn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {\n    if x.len() &gt; y.len() {\n        x\n    } else {\n        y\n    }\n}\n\n목록 10-20: longest두 문자열 슬라이스 중 더 긴 문자열을 반환하지만 아직 컴파일되지 않은 함수 의 구현\n대신 수명에 대해 말하는 다음 오류가 발생합니다.\n$ cargo run\n   Compiling chapter10 v0.1.0 (file:///projects/chapter10)\nerror[E0106]: missing lifetime specifier\n --&gt; src/main.rs:9:33\n  |\n9 | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {\n  |               ----     ----     ^ expected named lifetime parameter\n  |\n  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`\nhelp: consider introducing a named lifetime parameter\n  |\n9 | fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {\n  |           ++++     ++          ++          ++\n\nFor more information about this error, try `rustc --explain E0106`.\nerror: could not compile `chapter10` due to previous error\nx`도움말 텍스트는 Rust가 반환되는 참조 가 또는 를 참조하는지 여부를 알 수 없기 때문에 반환 유형에 일반 수명 매개변수가 필요함을 나타냅니다 `y`. `if`실제로 이 함수 본문의 블록이 에 대한 참조를 반환 `x`하고 블록이 ! `else`에 대한 참조를 반환하기 때문에 우리도 모릅니다.`y\n\n이 함수를 정의할 때 이 함수에 전달될 구체적인 값을 모르기 때문에 케이스 if또는 else케이스가 실행될지 알 수 없습니다. 우리는 또한 전달될 참조의 구체적인 수명을 모르기 때문에 목록 10-17 및 10-18에서 우리가 반환하는 참조가 항상 유효한지 여부를 결정하기 위해 범위를 볼 수 없습니다. . 차용 검사기는 반환 값의 수명이 어떻게 관련되어 있는지 x모르기 때문에 이것을 결정할 수 없습니다. y이 오류를 수정하기 위해 차용 검사기가 분석을 수행할 수 있도록 참조 간의 관계를 정의하는 일반 수명 매개변수를 추가합니다.\n평생 주석 구문\n평생 주석은 참조가 지속되는 기간을 변경하지 않습니다. 오히려 수명에 영향을 주지 않고 서로에 대한 여러 참조의 수명 관계를 설명합니다. 서명이 일반 유형 매개변수를 지정하면 함수가 모든 유형을 허용할 수 있는 것처럼 함수는 일반 수명 매개변수를 지정하여 모든 수명의 참조를 허용할 수 있습니다.\n수명 주석에는 약간 특이한 구문이 있습니다. 수명 매개변수의 이름은 아포스트로피( ')로 시작해야 하며 일반적으로 모두 소문자이며 일반 유형과 같이 매우 짧습니다. 'a대부분의 사람들은 첫 번째 평생 주석의 이름을 사용합니다. &amp;참조 유형에서 주석을 구분하기 위해 공백을 사용하여 참조 뒤에 수명 매개변수 주석을 배치합니다.\ni32다음은 몇 가지 예입니다: 수명 매개변수가 없는 an에 대한 참조 , i32이라는 수명 매개변수가 있는 an에 대한 참조 'a, 그리고 i32life가 있는 an에 대한 변경 가능한 참조 'a.\n&amp;i32        // a reference\n&amp;'a i32     // a reference with an explicit lifetime\n&amp;'a mut i32 // a mutable reference with an explicit lifetime\n\n하나의 라이프타임 주석 자체는 큰 의미가 없습니다. 왜냐하면 주석은 여러 참조의 일반적인 라이프타임 매개변수가 서로 어떻게 관련되어 있는지 Rust에 알리기 위한 것이기 때문입니다. 수명 주석이 함수 컨텍스트에서 서로 어떻게 관련되는지 살펴보겠습니다 longest.\n함수 서명의 수명 주석\n함수 서명에서 라이프타임 주석을 사용하려면 일반 유형 매개 변수에서 했던 것처럼 함수 이름과 매개변수 목록 사이의 꺾쇠괄호 안에 일반 수명 매개 변수 를 선언해야 합니다.\n서명이 다음 제약 조건을 표현하기를 원합니다. 반환된 참조는 두 매개 변수가 모두 유효한 한 유효합니다. 이것은 매개변수의 수명과 반환 값 간의 관계입니다. 목록 10-21에 표시된 대로 수명에 이름을 지정한 'a다음 각 참조에 추가합니다.\n파일 이름: src/main.rs\nfn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {\n    if x.len() &gt; y.len() {\n        x\n    } else {\n        y\n    }\n}\n\n목록 10-21: longest서명의 모든 참조가 동일한 수명을 가져야 한다고 지정하는 함수 정의'a\nmain이 코드는 목록 10-19의 함수 와 함께 사용할 때 원하는 결과를 컴파일하고 생성해야 합니다.\n함수 시그니처는 이제 러스트에게 어떤 수명 동안 'a함수가 두 개의 매개변수를 취한다고 알려줍니다. 둘 다 최소한 수명만큼 사는 문자열 조각입니다 'a. 함수 서명은 또한 Rust에게 함수에서 반환된 문자열 조각이 적어도 평생만큼은 살아있을 것이라고 알려줍니다 'a. 실제로 이는 함수가 반환하는 참조의 수명이 longest함수 인수가 참조하는 값의 수명 중 더 작은 수명과 동일함을 의미합니다. 이러한 관계는 Rust가 이 코드를 분석할 때 사용하기를 원하는 것입니다.\n이 함수 서명에서 수명 매개변수를 지정할 때 전달되거나 반환된 값의 수명을 변경하지 않는다는 점을 기억하십시오. 오히려 우리는 차용 검사기가 이러한 제약 조건을 준수하지 않는 모든 값을 거부하도록 지정하고 있습니다. 함수 가 얼마나 오래 지속 되는지 longest정확히 알 필요는 없으며 이 서명을 충족하는 일부 범위만 대체할 수 있습니다.x``y``'a\n함수의 수명에 주석을 추가할 때 주석은 함수 본문이 아닌 함수 서명에 포함됩니다. 수명 주석은 서명의 유형과 마찬가지로 함수 계약의 일부가 됩니다. 함수 서명이 수명 계약을 포함한다는 것은 Rust 컴파일러가 수행하는 분석이 더 간단할 수 있음을 의미합니다. 함수에 주석을 달거나 호출하는 방식에 문제가 있는 경우 컴파일러 오류는 코드의 일부와 제약 조건을 더 정확하게 가리킬 수 있습니다. 대신에 Rust 컴파일러가 우리가 의도한 수명 관계에 대해 더 많은 추론을 했다면, 컴파일러는 문제의 원인에서 몇 단계 떨어진 우리 코드의 사용만을 지적할 수 있을 것입니다.\n에 대한 구체적인 참조를 전달할 때 longest대체되는 구체적인 수명은 의 범위 와 겹치는 범위 'a의 일부입니다. 즉, 일반 수명은 및 의 수명 중 더 작은 수명과 동일한 구체적인 수명을 갖게 됩니다. 동일한 수명 매개변수로 반환된 참조에 주석을 달았기 때문에 반환된 참조는 및 의 수명 중 더 작은 수명의 길이에 대해서도 유효합니다.x``y``'a``x``y``'a``x``y\nlongest구체적인 수명이 다른 참조를 전달하여 수명 주석이 함수를 제한하는 방법을 살펴보겠습니다. 목록 10-22는 간단한 예입니다.\n파일 이름: src/main.rs\nfn main() {\n    let string1 = String::from(`long string is long`);\n\n    {\n        let string2 = String::from(`xyz`);\n        let result = longest(string1.as_str(), string2.as_str());\n        println!(`The longest string is {}`, result);\n    }\n}\n\n목록 10-22: 구체적인 수명이 다른 값 longest에 대한 참조와 함께 함수 사용String\n이 예에서 string1is는 외부 범위 끝까지 유효하고 string2내부 범위 끝까지 유효하며 result내부 범위 끝까지 유효한 것을 참조합니다. 이 코드를 실행하면 빌림 검사기가 승인하는 것을 볼 수 있습니다. 컴파일하고 인쇄합니다 The longest string is long string is long.\n다음으로, 참조의 수명이 result두 인수의 더 작은 수명이어야 함을 보여주는 예제를 시도해 봅시다. 내부 범위 외부로 변수 선언을 이동 하지만 범위 내부의 변수 result에 대한 값 할당은 . 그런 다음 내부 범위가 종료된 후 사용하는 를 내부 범위 외부로 이동합니다. 목록 10-23의 코드는 컴파일되지 않습니다.result``string2``println!``result\n파일 이름: src/main.rs\nfn main() {\n    let string1 = String::from(`long string is long`);\n    let result;\n    {\n        let string2 = String::from(`xyz`);\n        result = longest(string1.as_str(), string2.as_str());\n    }\n    println!(`The longest string is {}`, result);\n}\n\n목록 10-23: 범위를 벗어난 result후 사용 시도string2\n이 코드를 컴파일하려고 하면 다음 오류가 발생합니다.\n$ cargo run\n   Compiling chapter10 v0.1.0 (file:///projects/chapter10)\nerror[E0597]: `string2` does not live long enough\n --&gt; src/main.rs:6:44\n  |\n6 |         result = longest(string1.as_str(), string2.as_str());\n  |                                            ^^^^^^^^^^^^^^^^ borrowed value does not live long enough\n7 |     }\n  |     - `string2` dropped here while still borrowed\n8 |     println!(`The longest string is {}`, result);\n  |                                          ------ borrow later used here\n\nFor more information about this error, try `rustc --explain E0597`.\nerror: could not compile `chapter10` due to previous error\n\n이 오류는 for 가 문에 result대해 유효하려면 외부 범위가 끝날 때까지 유효해야 함을 보여줍니다. 러스트는 우리가 동일한 수명 매개변수를 사용하여 함수 매개변수와 반환 값의 수명에 주석을 달았기 때문에 이것을 알고 있습니다.println!``string2``'a\n인간으로서 우리는 이 코드를 볼 수 있고 이것이 string1에 대한 참조를 포함할 것 string2입니다. 가 아직 범위를 벗어나지 않았기 때문에 에 대한 참조는 여전히 명령문에 유효합니다. 그러나 컴파일러는 이 경우 참조가 유효한지 확인할 수 없습니다. 우리는 러스트에게 함수에 의해 반환된 참조의 수명이 전달 된 참조의 수명 중 더 작은 수명과 같다고 말했습니다. 따라서 차용 검사기는 목록 10-23의 코드가 유효하지 않은 참조를 가질 수 있는 것으로 허용하지 않습니다.result``string1``string1``string1``println!``longest\n함수에 전달된 참조의 값과 수명 및 longest반환된 참조가 사용되는 방법을 변경하는 더 많은 실험을 설계해 보십시오. 컴파일하기 전에 실험이 차용 검사기를 통과할지 여부에 대한 가설을 세우십시오. 그런 다음 당신이 옳은지 확인하십시오!\n수명의 관점에서 생각하기\n수명 매개변수를 지정하는 방법은 함수가 수행하는 작업에 따라 다릅니다. 예를 들어 가장 긴 문자열 조각이 아닌 항상 첫 번째 매개변수를 반환하도록 함수의 구현을 변경한 경우 매개변수 longest에 수명을 지정할 필요가 없습니다 y. 다음 코드는 컴파일됩니다.\n파일 이름: src/main.rs\nfn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;str) -&gt; &amp;'a str {\n    x\n}\n'a`매개변수 및 반환 유형에 대해 수명 매개변수를 지정했지만 `x`매개변수에 대해서는 수명 매개변수를 지정하지 않았습니다 `y`. 의 수명은 수명 또는 반환 값 `y`과 관련이 없기 때문입니다.`x\n\n함수에서 참조를 반환할 때 반환 유형에 대한 수명 매개변수는 매개변수 중 하나에 대한 수명 매개변수와 일치해야 합니다. 반환된 참조가 매개 변수 중 하나를 참조 하지 않는 경우 이 함수 내에서 생성된 값을 참조해야 합니다. 그러나 이것은 값이 함수의 끝에서 범위를 벗어나기 때문에 댕글링 참조가 됩니다. longest컴파일되지 않는 함수 의 시도된 구현을 고려하십시오 .\n파일 이름: src/main.rs\nfn longest&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str {\n    let result = String::from(`really long string`);\n    result.as_str()\n}\n\n'a여기 에서 반환 유형에 대해 수명 매개변수를 지정했지만 반환 값 수명이 매개변수의 수명과 전혀 관련이 없기 때문에 이 구현은 컴파일에 실패합니다. 우리가 얻는 오류 메시지는 다음과 같습니다.\n$ cargo run\n   Compiling chapter10 v0.1.0 (file:///projects/chapter10)\nerror[E0515]: cannot return reference to local variable `result`\n  --&gt; src/main.rs:11:5\n   |\n11 |     result.as_str()\n   |     ^^^^^^^^^^^^^^^ returns a reference to data owned by the current function\n\nFor more information about this error, try `rustc --explain E0515`.\nerror: could not compile `chapter10` due to previous error\n\n문제는 result범위를 벗어나 함수가 끝날 때 정리된다는 것입니다 longest. result또한 함수에서 참조를 반환하려고 합니다. 댕글링 참조를 변경하는 수명 매개변수를 지정할 수 있는 방법이 없으며 Rust는 댕글링 참조를 생성하도록 허용하지 않습니다. 이 경우 가장 좋은 해결 방법은 참조가 아닌 소유한 데이터 유형을 반환하여 호출 함수가 값 정리를 담당하도록 하는 것입니다.\n궁극적으로 수명 구문은 다양한 매개 변수의 수명과 함수의 반환 값을 연결하는 것입니다. 일단 연결되면 Rust는 메모리 안전 작업을 허용하고 댕글링 포인터를 생성하거나 메모리 안전을 위반하는 작업을 허용하지 않는 충분한 정보를 갖게 됩니다.\n구조체 정의의 수명 주석\n지금까지 우리가 정의한 모든 구조체는 소유 유형을 보유합니다. 참조를 보유하도록 구조체를 정의할 수 있지만 이 경우 구조체 정의의 모든 참조에 수명 주석을 추가해야 합니다. ImportantExcerpt목록 10-24 에는 스트링 슬라이스를 보유하는 명명된 구조체가 있습니다.\n파일 이름: src/main.rs\nstruct ImportantExcerpt&lt;'a&gt; {\n    part: &amp;'a str,\n}\n\nfn main() {\n    let novel = String::from(`Call me Ishmael. Some years ago...`);\n    let first_sentence = novel.split('.').next().expect(`Could not find a '.'`);\n    let i = ImportantExcerpt {\n        part: first_sentence,\n    };\n}\n\n목록 10-24: 수명 주석이 필요한 참조를 보유하는 구조체\npart이 구조체에는 참조인 문자열 슬라이스를 포함하는 단일 필드가 있습니다. 일반 데이터 유형과 마찬가지로 구조체 이름 뒤의 꺾쇠 괄호 안에 일반 수명 매개변수의 이름을 선언하여 구조체 정의 본문에서 수명 매개변수를 사용할 수 있습니다. 이 주석은 의 ImportantExcerpt인스턴스가 해당 필드에 보유하고 있는 참조보다 오래 지속될 수 없음을 의미합니다 part.\n여기서 함수 는 변수가 소유한 첫 번째 문장에 대한 참조를 보유하는 구조체 main의 인스턴스를 만듭니다. 인스턴스가 생성되기 전에 데이터가 존재합니다. 또한 범위를 벗어날 때까지 범위를 벗어나지 않으므로 인스턴스의 참조가 유효합니다.ImportantExcerpt``String``novel``novel``ImportantExcerpt``novel``ImportantExcerpt``ImportantExcerpt\n평생 제거\n모든 참조에는 수명이 있으며 참조를 사용하는 함수 또는 구조체에 대한 수명 매개 변수를 지정해야 한다는 것을 배웠습니다. 그러나 4장에서 우리는 Listing 4-9에 수명 주석 없이 컴파일된 Listing 10-25에 다시 표시된 함수가 있었습니다.\n파일 이름: src/lib.rs\nfn first_word(s: &amp;str) -&gt; &amp;str {\n    let bytes = s.as_bytes();\n\n    for (i, &amp;item) in bytes.iter().enumerate() {\n        if item == b' ' {\n            return &amp;s[0..i];\n        }\n    }\n\n    &amp;s[..]\n}\n\n목록 10-25: 매개변수와 반환 유형이 참조인 경우에도 수명 주석 없이 컴파일된 목록 4-9에서 정의한 함수\n이 함수가 수명 주석 없이 컴파일되는 이유는 역사적입니다. Rust의 초기 버전(1.0 이전)에서는 모든 참조에 명시적 수명이 필요했기 때문에 이 코드가 컴파일되지 않았을 것입니다. 당시 함수 서명은 다음과 같이 작성되었을 것입니다.\nfn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {\n\n많은 Rust 코드를 작성한 후 Rust 팀은 Rust 프로그래머가 특정 상황에서 동일한 수명 주석을 반복해서 입력하고 있음을 발견했습니다. 이러한 상황은 예측 가능했으며 몇 가지 결정론적 패턴을 따랐습니다. 개발자는 차용 검사기가 이러한 상황에서 수명을 추론할 수 있고 명시적인 주석이 필요하지 않도록 컴파일러 코드에 이러한 패턴을 프로그래밍했습니다.\nRust 역사의 이 부분은 더 결정적인 패턴이 나타나고 컴파일러에 추가될 가능성이 있기 때문에 관련이 있습니다. 앞으로는 더 적은 수명 주석이 필요할 수 있습니다.\nRust의 참조 분석에 프로그래밍된 패턴을 수명 제거 규칙 이라고 합니다. 이것은 프로그래머가 따라야 할 규칙이 아닙니다. 이들은 컴파일러가 고려할 특정 사례의 집합이며, 코드가 이러한 경우에 적합하면 수명을 명시적으로 작성할 필요가 없습니다.\n제거 규칙은 완전한 추론을 제공하지 않습니다. Rust가 결정적으로 규칙을 적용하지만 참조의 수명에 대해 여전히 모호한 경우 컴파일러는 나머지 참조의 수명을 추측하지 않습니다. 추측하는 대신 컴파일러는 수명 주석을 추가하여 해결할 수 있는 오류를 제공합니다.\n함수 또는 메소드 매개변수에 대한 수명을 입력 수명 이라고 하고 반환 값에 대한 수명을 출력 수명 이라고 합니다.\n컴파일러는 명시적인 주석이 없을 때 세 가지 규칙을 사용하여 참조의 수명을 파악합니다. 첫 번째 규칙은 입력 수명에 적용되고 두 번째 및 세 번째 규칙은 출력 수명에 적용됩니다. 컴파일러가 세 가지 규칙의 끝에 도달하고 수명을 파악할 수 없는 참조가 여전히 있는 경우 컴파일러는 오류와 함께 중지됩니다. 이러한 규칙은 블록 fn뿐만 아니라 정의 에도 적용됩니다 impl.\n첫 번째 규칙은 컴파일러가 참조인 각 매개변수에 수명 매개변수를 할당한다는 것입니다. 즉, 하나의 매개변수가 있는 함수는 하나의 라이프타임 매개변수를 얻습니다: fn foo&lt;'a&gt;(x: &amp;'a i32); 두 개의 매개변수가 있는 함수는 두 개의 별도 수명 매개변수를 얻습니다: fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32); 등등.\n두 번째 규칙은 정확히 하나의 입력 수명 매개변수가 있는 경우 해당 수명이 모든 출력 수명 매개변수에 할당된다는 것입니다 fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32.\n세 번째 규칙은 입력 라이프타임 매개변수가 여러 개인 경우 그 중 하나가 메서드이기 &amp;self때문에 모든 출력 라이프타임 매개변수에 &amp;mut self수명이 self할당된다는 것입니다. 이 세 번째 규칙은 더 적은 수의 기호가 필요하기 때문에 메소드를 읽고 쓰기에 훨씬 더 좋습니다.\n우리가 컴파일러라고 가정해 봅시다. first_word목록 10-25에 있는 함수 서명에서 참조의 수명을 파악하기 위해 이러한 규칙을 적용할 것입니다. 서명은 참조와 연결된 수명 없이 시작됩니다.\nfn first_word(s: &amp;str) -&gt; &amp;str {\n\n그런 다음 컴파일러는 각 매개변수가 자체 수명을 갖도록 지정하는 첫 번째 규칙을 적용합니다. 평소와 같이 호출하므로 'a이제 서명은 다음과 같습니다.\nfn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;str {\n\n정확히 하나의 입력 수명이 있기 때문에 두 번째 규칙이 적용됩니다. 두 번째 규칙은 하나의 입력 매개변수의 수명이 출력 수명에 할당되도록 지정하므로 서명은 이제 다음과 같습니다.\nfn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {\n\n이제 이 함수 서명의 모든 참조에는 수명이 있으며 컴파일러는 프로그래머가 이 함수 서명의 수명에 주석을 달 필요 없이 분석을 계속할 수 있습니다.\n또 다른 예를 살펴보겠습니다. 이번에는 longest목록 10-20에서 작업을 시작했을 때 수명 매개변수가 없었던 함수를 사용했습니다.\nfn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {\n\n첫 번째 규칙을 적용해 보겠습니다. 각 매개변수는 고유한 수명을 갖습니다. 이번에는 하나가 아닌 두 개의 매개변수가 있으므로 두 개의 수명이 있습니다.\nfn longest&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;str {\n\n두 개 이상의 입력 수명이 있기 때문에 두 번째 규칙이 적용되지 않는 것을 볼 수 있습니다. 세 번째 규칙도 적용되지 않습니다. 는 longest메서드가 아니라 함수이므로 매개변수 중 어느 것도 self. 세 가지 규칙을 모두 살펴본 후에도 여전히 반환 유형의 수명이 무엇인지 파악하지 못했습니다. 이것이 Listing 10-20의 코드를 컴파일하려고 시도하는 동안 오류가 발생한 이유입니다. 컴파일러는 수명 생략 규칙을 통해 작업했지만 여전히 서명에 있는 참조의 모든 수명을 파악할 수 없었습니다.\n세 번째 규칙은 실제로 메서드 서명에만 적용되기 때문에 세 번째 규칙이 메서드 서명에서 수명에 자주 주석을 달 필요가 없음을 의미하는 이유를 알아보기 위해 해당 컨텍스트에서 수명을 살펴보겠습니다.\n메서드 정의의 수명 주석\n수명이 있는 구조체에 메서드를 구현할 때 목록 10-11에 표시된 제네릭 형식 매개 변수와 동일한 구문을 사용합니다. 수명 매개변수를 선언하고 사용하는 위치는 구조 필드 또는 메서드 매개변수 및 반환 값과 관련되는지 여부에 따라 다릅니다.\n구조체 필드의 수명 이름은 항상 키워드 다음에 선언한 다음 구조체 이름 다음에 사용해야 합니다 impl. 이러한 수명은 구조체 유형의 일부이기 때문입니다.\n블록 내부의 메서드 서명에서 impl참조는 구조체 필드의 참조 수명에 연결되거나 독립적일 수 있습니다. 또한 수명 생략 규칙은 종종 메서드 서명에 수명 주석이 필요하지 않도록 합니다. ImportantExcerpt목록 10-24에서 정의한 구조체 이름을 사용하는 몇 가지 예를 살펴보겠습니다.\nlevel`먼저, 유일한 매개변수가 에 대한 참조 이고 반환 값이 어떤 것에도 참조가 아닌 `self`an 이라는 이름의 메서드를 사용합니다.`i32\nimpl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {\n    fn level(&amp;self) -&gt; i32 {\n        3\n    }\n}\n\n이후의 수명 매개변수 선언 과 유형 이름 이후의 사용이 필요하지만 첫 번째 생략 규칙 때문에 impl참조의 수명에 주석을 달 필요가 없습니다.self\n다음은 세 번째 평생 생략 규칙이 적용되는 예입니다.\nimpl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {\n    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {\n        println!(`Attention please: {}`, announcement);\n        self.part\n    }\n}\n\n두 개의 입력 수명이 있으므로 Rust는 첫 번째 수명 생략 규칙을 적용하고 둘 다 &amp;self자신 announcement의 수명을 제공합니다. 그런 다음 매개변수 중 하나가 이므로 &amp;self반환 유형은 의 수명을 가져오고 &amp;self모든 수명이 고려되었습니다.\n정적 수명\n우리가 논의해야 할 하나의 특별한 수명은 'static영향을 받는 참조가 프로그램의 전체 기간 동안 존재할 수 있음을 나타냅니다. 모든 문자열 리터럴에는 'static다음과 같이 주석을 달 수 있는 수명이 있습니다.\nlet s: &amp;'static str = `I have a static lifetime.`;\n\n이 문자열의 텍스트는 항상 사용 가능한 프로그램의 바이너리에 직접 저장됩니다. 따라서 모든 문자열 리터럴의 수명은 'static.\n'static오류 메시지에서 수명을 사용하라는 제안을 볼 수 있습니다. 그러나 'static참조의 수명으로 지정하기 전에 참조가 실제로 프로그램의 전체 수명 동안 지속되는지 여부와 원하는지 여부를 생각하십시오. 대부분의 경우 수명 을 제안하는 오류 메시지 'static는 댕글링 참조를 만들려고 시도하거나 사용 가능한 수명이 일치하지 않아 발생합니다. 이러한 경우 솔루션은 'static수명을 지정하는 것이 아니라 해당 문제를 수정하는 것입니다.\n일반 유형 매개변수, 특성 경계 및 수명 함께\n제네릭 형식 매개 변수, 특성 범위 및 수명을 모두 하나의 함수로 지정하는 구문을 간단히 살펴보겠습니다!\nuse std::fmt::Display;\n\nfn longest_with_an_announcement&lt;'a, T&gt;(\n    x: &amp;'a str,\n    y: &amp;'a str,\n    ann: T,\n) -&gt; &amp;'a str\nwhere\n    T: Display,\n{\n    println!(`Announcement! {}`, ann);\n    if x.len() &gt; y.len() {\n        x\n    } else {\n        y\n    }\n}\n\n이것은 longest두 문자열 슬라이스 중 더 긴 것을 반환하는 Listing 10-21의 함수입니다. ann그러나 이제 제네릭 형식이라는 이름의 추가 매개변수가 있으며 , 이 매개변수는 절 에서 지정한 대로 특성을 T구현하는 모든 형식으로 채울 수 있습니다. 이 추가 매개변수는 를 사용하여 인쇄될 것이므로 특성 바인딩이 필요합니다. 수명은 제네릭 유형이므로 수명 매개변수 선언 과 제네릭 유형 매개변수는 함수 이름 뒤의 꺾쇠 괄호 안에 있는 동일한 목록에 들어갑니다.Display``where``{}``Display``'a``T\n요약\n이 장에서 많은 내용을 다루었습니다! 이제 일반 유형 매개변수, 특성 및 특성 경계, 일반 수명 매개변수에 대해 알았으므로 다양한 상황에서 작동하는 반복 없이 코드를 작성할 준비가 되었습니다. 일반 유형 매개변수를 사용하면 다른 유형에 코드를 적용할 수 있습니다. 특성 및 특성 범위는 유형이 일반적이더라도 코드에 필요한 동작을 갖도록 합니다. 이 유연한 코드에 매달린 참조가 없도록 수명 주석을 사용하는 방법을 배웠습니다. 그리고 이 모든 분석은 컴파일 시간에 발생하므로 런타임 성능에 영향을 미치지 않습니다!\n믿거나 말거나, 이 장에서 논의한 주제에 대해 더 많은 것을 배울 수 있습니다. 17장에서는 특성을 사용하는 또 다른 방법인 특성 개체에 대해 설명합니다. 매우 고급 시나리오에서만 필요한 수명 주석과 관련된 더 복잡한 시나리오도 있습니다. 그런 경우 Rust Reference 를 읽어야 합니다. 그러나 다음에는 Rust로 테스트를 작성하여 코드가 제대로 작동하는지 확인할 수 있습니다.\n","id":"http://127.0.0.1:1111/rust/chapter4-10/trans/","title":"4-10 translation"},"http://127.0.0.1:1111/rust/to do/chapter4/":{"body":"요약\n\n\n\n\n","id":"http://127.0.0.1:1111/rust/to do/chapter4/","title":"Understanding Ownership"},"http://127.0.0.1:1111/rust/to do/chapter4/1-what-is-ownership/":{"body":"","id":"http://127.0.0.1:1111/rust/to do/chapter4/1-what-is-ownership/","title":"What is Ownership?"},"http://127.0.0.1:1111/rust/to do/chapter4/2-references-and-borrowing/":{"body":"","id":"http://127.0.0.1:1111/rust/to do/chapter4/2-references-and-borrowing/","title":"References and Borrowing"},"http://127.0.0.1:1111/rust/to do/chapter4/3-the-slice-type/":{"body":"","id":"http://127.0.0.1:1111/rust/to do/chapter4/3-the-slice-type/","title":"The Slice Type"},"http://127.0.0.1:1111/rust/to do/chapter5/":{"body":"요약\n\n\n\n\n","id":"http://127.0.0.1:1111/rust/to do/chapter5/","title":"Using Structs to Structure Related Data"},"http://127.0.0.1:1111/rust/to do/chapter5/1-defining-and-instantiating-structs/":{"body":"","id":"http://127.0.0.1:1111/rust/to do/chapter5/1-defining-and-instantiating-structs/","title":"Defining and Instantiating Structs"},"http://127.0.0.1:1111/rust/to do/chapter5/2-an-example-program-using-structs/":{"body":"","id":"http://127.0.0.1:1111/rust/to do/chapter5/2-an-example-program-using-structs/","title":"An Example Program Using Structs"},"http://127.0.0.1:1111/rust/to do/chapter5/3-method-syntax/":{"body":"","id":"http://127.0.0.1:1111/rust/to do/chapter5/3-method-syntax/","title":"Method Syntax"}},"docInfo":{"http://127.0.0.1:1111/":{"body":31,"title":1},"http://127.0.0.1:1111/about/":{"body":12,"title":1},"http://127.0.0.1:1111/docs/":{"body":0,"title":1},"http://127.0.0.1:1111/docs/basic-markdown-syntax/":{"body":1244,"title":3},"http://127.0.0.1:1111/docs/config-options/":{"body":254,"title":2},"http://127.0.0.1:1111/docs/extended-shortcodes/":{"body":1368,"title":2},"http://127.0.0.1:1111/docs/theme-extension/":{"body":96,"title":2},"http://127.0.0.1:1111/docs/welcome-to-deep-thought/":{"body":180,"title":2},"http://127.0.0.1:1111/posts/":{"body":0,"title":1},"http://127.0.0.1:1111/posts/post-1/":{"body":158,"title":1},"http://127.0.0.1:1111/posts/post-2/":{"body":130,"title":5},"http://127.0.0.1:1111/rust/":{"body":151,"title":1},"http://127.0.0.1:1111/rust/chapter1/":{"body":9,"title":2},"http://127.0.0.1:1111/rust/chapter1/1-installation/":{"body":118,"title":1},"http://127.0.0.1:1111/rust/chapter1/2-helloworld/":{"body":210,"title":2},"http://127.0.0.1:1111/rust/chapter1/3-hellocargo/":{"body":364,"title":2},"http://127.0.0.1:1111/rust/chapter11-17/":{"body":32010,"title":2},"http://127.0.0.1:1111/rust/chapter11-17/trans/":{"body":10765,"title":3},"http://127.0.0.1:1111/rust/chapter17-21/":{"body":23202,"title":2},"http://127.0.0.1:1111/rust/chapter17-21/trans/":{"body":6922,"title":3},"http://127.0.0.1:1111/rust/chapter2/":{"body":1272,"title":3},"http://127.0.0.1:1111/rust/chapter22/":{"body":338,"title":0},"http://127.0.0.1:1111/rust/chapter3/":{"body":9,"title":3},"http://127.0.0.1:1111/rust/chapter3/1-variables-and-mutability/":{"body":259,"title":2},"http://127.0.0.1:1111/rust/chapter3/2-data-types/":{"body":466,"title":2},"http://127.0.0.1:1111/rust/chapter3/3-functions/":{"body":435,"title":1},"http://127.0.0.1:1111/rust/chapter3/4-comments/":{"body":41,"title":1},"http://127.0.0.1:1111/rust/chapter3/5-control-flow/":{"body":521,"title":2},"http://127.0.0.1:1111/rust/chapter4-10/":{"body":30620,"title":2},"http://127.0.0.1:1111/rust/chapter4-10/trans/":{"body":8395,"title":3},"http://127.0.0.1:1111/rust/to do/chapter4/":{"body":0,"title":2},"http://127.0.0.1:1111/rust/to do/chapter4/1-what-is-ownership/":{"body":0,"title":1},"http://127.0.0.1:1111/rust/to do/chapter4/2-references-and-borrowing/":{"body":0,"title":2},"http://127.0.0.1:1111/rust/to do/chapter4/3-the-slice-type/":{"body":0,"title":2},"http://127.0.0.1:1111/rust/to do/chapter5/":{"body":0,"title":5},"http://127.0.0.1:1111/rust/to do/chapter5/1-defining-and-instantiating-structs/":{"body":0,"title":3},"http://127.0.0.1:1111/rust/to do/chapter5/2-an-example-program-using-structs/":{"body":0,"title":4},"http://127.0.0.1:1111/rust/to do/chapter5/3-method-syntax/":{"body":0,"title":2}},"length":38},"lang":"English"};